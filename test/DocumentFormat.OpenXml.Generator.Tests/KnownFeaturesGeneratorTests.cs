// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using DocumentFormat.OpenXml.Generator.KnownFeatures;
using Microsoft.CodeAnalysis.Testing;
using System.Threading.Tasks;
using Xunit;

using VerifyCS = DocumentFormat.OpenXml.Generator.Tests.Verifiers.OpenXmlIncrementalSourceGeneratorVerifier<
    DocumentFormat.OpenXml.Generator.KnownFeatures.KnownFeaturesGenerator>;

namespace DocumentFormat.OpenXml.Generator.Tests
{
    public class KnownFeaturesGeneratorTests
    {
        private const string FeatureCollection = @"
namespace DocumentFormat.OpenXml.Features;

public interface IFeatureCollection
{
    T Get<T>();
}";

        private const string Attribute = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace DocumentFormat.OpenXml;

[global::System.Diagnostics.Conditional(""OPENXMLGENERATOR"")]
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
internal sealed class KnownFeatureAttribute : global::System.Attribute
{
    public KnownFeatureAttribute(global::System.Type contract, global::System.Type? service = null)
    {
    }

    public string? Factory { get; set; }
}

[global::System.Diagnostics.Conditional(""OPENXMLGENERATOR"")]
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
internal sealed class DelegatedFeatureAttribute : global::System.Attribute
{
    public DelegatedFeatureAttribute(string name, global::System.Type? container = null)
    {
    }
}

[global::System.Diagnostics.Conditional(""OPENXMLGENERATOR"")]
[global::System.AttributeUsage(global::System.AttributeTargets.Method)]
internal sealed class ThreadSafeAttribute : global::System.Attribute
{
}
";

        [Fact]
        public async Task Empty()
        {
            var test = string.Empty;

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task OnlyOneServiceCanBeRegistered()
        {
            var test = @"using DocumentFormat.OpenXml;

using System.Threading;

namespace Test;

public interface ITest
{
}

public class TestImpl : ITest
{
}

public class TestImpl2 : ITest
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest), typeof(TestImpl))]
    [{|#0:KnownFeature(typeof(ITest), typeof(TestImpl2))|}]
    [ThreadSafe]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private global::Test.ITest? _TestImpl;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest))
        {
            if (_TestImpl is null)
            {
                Interlocked.CompareExchange(ref _TestImpl, new global::Test.TestImpl(), null);
            }

            return (T)_TestImpl;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                    ExpectedDiagnostics =
                    {
                        DiagnosticResult.CompilerError("OOX1001").WithLocation(0),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task DuplicateKnown()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public interface ITest
{
}

public class TestImpl : ITest
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest), typeof(TestImpl))]
    [{|#0:KnownFeature(typeof(ITest), typeof(TestImpl))|}]
    [ThreadSafe]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private global::Test.ITest? _TestImpl;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest))
        {
            if (_TestImpl is null)
            {
                Interlocked.CompareExchange(ref _TestImpl, new global::Test.TestImpl(), null);
            }

            return (T)_TestImpl;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                    ExpectedDiagnostics =
                    {
                        DiagnosticResult.CompilerError("OOX1000").WithLocation(0),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task ConcreteOnly()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public class TestImpl
{
}

public partial class Factory
{
    [KnownFeature(typeof(TestImpl))]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.TestImpl? _TestImpl;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.TestImpl))
        {
            if (_TestImpl is null)
            {
                _TestImpl = new global::Test.TestImpl();
            }

            return (T)(object)_TestImpl;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task ConcreteOnlyThreadSafe()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public class TestImpl
{
}

public partial class Factory
{
    [KnownFeature(typeof(TestImpl))]
    [ThreadSafe]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private global::Test.TestImpl? _TestImpl;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.TestImpl))
        {
            if (_TestImpl is null)
            {
                Interlocked.CompareExchange(ref _TestImpl, new global::Test.TestImpl(), null);
            }

            return (T)(object)_TestImpl;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task SingleGeneratorNestedClass()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public interface ITest
{
}

public class TestImpl : ITest
{
}

public partial class Factory
{
    private partial class Other
    {
        [KnownFeature(typeof(ITest), typeof(TestImpl))]
        [ThreadSafe]
        private partial T Get<T>();
    }
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private partial class Other
    {
        private global::Test.ITest? _TestImpl;

        private partial T? Get<T>()
        {
            if (typeof(T) == typeof(global::Test.ITest))
            {
                if (_TestImpl is null)
                {
                    Interlocked.CompareExchange(ref _TestImpl, new global::Test.TestImpl(), null);
                }

                return (T)_TestImpl;
            }

            return default;
        }
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Other_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task SingleGenerator()
        {
            var test = @"using DocumentFormat.OpenXml;

using System.Threading;

namespace Test;

public interface ITest
{
}

public class TestImpl : ITest
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest), typeof(TestImpl))]
    [ThreadSafe]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private global::Test.ITest? _TestImpl;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest))
        {
            if (_TestImpl is null)
            {
                Interlocked.CompareExchange(ref _TestImpl, new global::Test.TestImpl(), null);
            }

            return (T)_TestImpl;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task SingleGeneratorMultipleServices()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public interface ITest2
{
}

public class TestImpl2 : ITest2
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [KnownFeature(typeof(ITest2), typeof(TestImpl2))]
    [ThreadSafe]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using System.Threading;

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;
    private global::Test.ITest2? _TestImpl2;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                Interlocked.CompareExchange(ref _TestImpl1, new global::Test.TestImpl1(), null);
            }

            return (T)_TestImpl1;
        }

        if (typeof(T) == typeof(global::Test.ITest2))
        {
            if (_TestImpl2 is null)
            {
                Interlocked.CompareExchange(ref _TestImpl2, new global::Test.TestImpl2(), null);
            }

            return (T)_TestImpl2;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task SingleGeneratorMultipleServicesNotThreadSafe()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public interface ITest2
{
}

public class TestImpl2 : ITest2
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [KnownFeature(typeof(ITest2), typeof(TestImpl2))]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;
    private global::Test.ITest2? _TestImpl2;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                _TestImpl1 = new global::Test.TestImpl1();
            }

            return (T)_TestImpl1;
        }

        if (typeof(T) == typeof(global::Test.ITest2))
        {
            if (_TestImpl2 is null)
            {
                _TestImpl2 = new global::Test.TestImpl2();
            }

            return (T)_TestImpl2;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task SingleGeneratorFactoryMethod()
        {
            var test = @"using DocumentFormat.OpenXml;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public interface ITest2
{
}

public class TestImpl2 : ITest2
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [KnownFeature(typeof(ITest2), Factory = nameof(CreateTest2))]
    private partial T Get<T>();

    private ITest2 CreateTest2() => new TestImpl2();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;
    private global::Test.ITest2? _CreateTest2;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                _TestImpl1 = new global::Test.TestImpl1();
            }

            return (T)_TestImpl1;
        }

        if (typeof(T) == typeof(global::Test.ITest2))
        {
            if (_CreateTest2 is null)
            {
                _CreateTest2 = CreateTest2();
            }

            return (T)_CreateTest2;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task DelegatedFeaturesMethod()
        {
            var test = @"using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Features;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public interface ITest2
{
}

public class TestImpl2 : ITest2
{
}

public partial class Factory
{
    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [DelegatedFeature(nameof(OtherFeatures))]
    private partial T Get<T>();

    private ITest2 CreateTest2() => new TestImpl2();

    private IFeatureCollection OtherFeatures() => null;
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                _TestImpl1 = new global::Test.TestImpl1();
            }

            return (T)_TestImpl1;
        }

        if (OtherFeatures() is global::DocumentFormat.OpenXml.Features.IFeatureCollection other1 && other1.Get<T>() is T result1)
        {
            return result1;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task DelegatedFeaturesProperty()
        {
            var test = @"using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Features;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public class DefaultFactory
{
    public static IFeatureCollection Shared { get; }
}

public partial class Factory
{
    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [DelegatedFeature(nameof(DefaultFactory.Shared), typeof(DefaultFactory))]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                _TestImpl1 = new global::Test.TestImpl1();
            }

            return (T)_TestImpl1;
        }

        if (global::Test.DefaultFactory.Shared is global::DocumentFormat.OpenXml.Features.IFeatureCollection other1 && other1.Get<T>() is T result1)
        {
            return result1;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }

        [Fact]
        public async Task DelegatedFeaturesField()
        {
            var test = @"using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Features;

namespace Test;

public interface ITest1
{
}

public class TestImpl1 : ITest1
{
}

public interface ITest2
{
}

public class TestImpl2 : ITest2
{
}

public partial class Factory
{
    private readonly IFeatureCollection _other;

    [KnownFeature(typeof(ITest1), typeof(TestImpl1))]
    [DelegatedFeature(nameof(_other))]
    private partial T Get<T>();
}";
            var created = @"// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

namespace Test;

public partial class Factory
{
    private global::Test.ITest1? _TestImpl1;

    private partial T? Get<T>()
    {
        if (typeof(T) == typeof(global::Test.ITest1))
        {
            if (_TestImpl1 is null)
            {
                _TestImpl1 = new global::Test.TestImpl1();
            }

            return (T)_TestImpl1;
        }

        if (_other is global::DocumentFormat.OpenXml.Features.IFeatureCollection other1 && other1.Get<T>() is T result1)
        {
            return result1;
        }

        return default;
    }
}
";

            await new VerifyCS.Test
            {
                TestState =
                {
                    Sources = { test, FeatureCollection },
                    GeneratedSources =
                    {
                        (typeof(KnownFeaturesGenerator), "KnownFeatureAttribute.cs", Attribute),
                        (typeof(KnownFeaturesGenerator), "Factory_Get.cs", created),
                    },
                },
            }.RunAsync();
        }
    }
}
