// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Drawing;
using DocumentFormat.OpenXml.Drawing.Spreadsheet;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021;
using DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo;
using DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.ExternalCodeService;
using DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.MsForms;
using DocumentFormat.OpenXml.Office2010.Excel;
using DocumentFormat.OpenXml.Office2013.Excel;
using DocumentFormat.OpenXml.Office2013.ExcelAc;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using DocumentFormat.OpenXml.Validation.Semantic;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.Spreadsheet
{
    /// <summary>
    /// <para>Extension.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    public partial class Extension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Extension class.
        /// </summary>
        public Extension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Extension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Extension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Extension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddElement<Extension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Extension>(deep);
    }

    /// <summary>
    /// <para>Calculation Chain Info.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calcChain.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculationCell" /> <c>&lt;x:c></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculationChain : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculationChain class.
        /// </summary>
        public CalculationChain() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculationChain class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculationChain(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculationChain class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculationChain(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculationChain class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculationChain(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calcChain");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculationCell>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculationCell), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculationChain>(deep);

        internal CalculationChain(CalculationChainPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the CalculationChainPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(CalculationChainPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the CalculationChainPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(CalculationChainPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the CalculationChainPart associated with this element.
        /// </summary>
        public CalculationChainPart? CalculationChainPart
        {
            get => OpenXmlPart as CalculationChainPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Comments.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:comments.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Authors" /> <c>&lt;x:authors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CommentList" /> <c>&lt;x:commentList></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Comments : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Comments class.
        /// </summary>
        public Comments() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comments class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Comments(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comments class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Comments(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comments class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Comments(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:comments");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Authors>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CommentList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Authors), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CommentList), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Authors.</para>
        /// <para>Represents the following element tag in the schema: x:authors.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Authors? Authors
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Authors>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>List of Comments.</para>
        /// <para>Represents the following element tag in the schema: x:commentList.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CommentList? CommentList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CommentList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Comments>(deep);

        internal Comments(WorksheetCommentsPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorksheetCommentsPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorksheetCommentsPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorksheetCommentsPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorksheetCommentsPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorksheetCommentsPart associated with this element.
        /// </summary>
        public WorksheetCommentsPart? WorksheetCommentsPart
        {
            get => OpenXmlPart as WorksheetCommentsPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>XML Mapping.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:MapInfo.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Map" /> <c>&lt;x:Map></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Schema" /> <c>&lt;x:Schema></c></description></item>
    /// </list>
    /// </remark>
    public partial class MapInfo : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the MapInfo class.
        /// </summary>
        public MapInfo() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MapInfo class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MapInfo(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MapInfo class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MapInfo(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MapInfo class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MapInfo(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Prefix Mappings for XPath Expressions</para>
        /// <para>Represents the following attribute in the schema: SelectionNamespaces</para>
        /// </summary>
        public StringValue? SelectionNamespaces
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:MapInfo");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Map>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Schema>();
            builder.AddElement<MapInfo>()
                .AddAttribute("SelectionNamespaces", a => a.SelectionNamespaces, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Schema), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Map), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MapInfo>(deep);

        internal MapInfo(CustomXmlMappingsPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the CustomXmlMappingsPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(CustomXmlMappingsPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the CustomXmlMappingsPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(CustomXmlMappingsPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the CustomXmlMappingsPart associated with this element.
        /// </summary>
        public CustomXmlMappingsPart? CustomXmlMappingsPart
        {
            get => OpenXmlPart as CustomXmlMappingsPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Connections.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:connections.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Connection" /> <c>&lt;x:connection></c></description></item>
    /// </list>
    /// </remark>
    public partial class Connections : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Connections class.
        /// </summary>
        public Connections() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connections class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connections(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connections class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connections(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connections class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Connections(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:connections");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Connection>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Connection), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Connections>(deep);

        internal Connections(ConnectionsPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the ConnectionsPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(ConnectionsPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the ConnectionsPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(ConnectionsPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the ConnectionsPart associated with this element.
        /// </summary>
        public ConnectionsPart? ConnectionsPart
        {
            get => OpenXmlPart as ConnectionsPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>PivotCache Definition.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotCacheDefinition.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheFields" /> <c>&lt;x:cacheFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheHierarchies" /> <c>&lt;x:cacheHierarchies></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheSource" /> <c>&lt;x:cacheSource></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedItems" /> <c>&lt;x:calculatedItems></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedMembers" /> <c>&lt;x:calculatedMembers></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Dimensions" /> <c>&lt;x:dimensions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Maps" /> <c>&lt;x:maps></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MeasureGroups" /> <c>&lt;x:measureGroups></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Kpis" /> <c>&lt;x:kpis></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TupleCache" /> <c>&lt;x:tupleCache></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCacheDefinition : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinition class.
        /// </summary>
        public PivotCacheDefinition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCacheDefinition(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>invalid</para>
        /// <para>Represents the following attribute in the schema: invalid</para>
        /// </summary>
        public BooleanValue? Invalid
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>saveData</para>
        /// <para>Represents the following attribute in the schema: saveData</para>
        /// </summary>
        public BooleanValue? SaveData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshOnLoad</para>
        /// <para>Represents the following attribute in the schema: refreshOnLoad</para>
        /// </summary>
        public BooleanValue? RefreshOnLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>optimizeMemory</para>
        /// <para>Represents the following attribute in the schema: optimizeMemory</para>
        /// </summary>
        public BooleanValue? OptimizeMemory
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>enableRefresh</para>
        /// <para>Represents the following attribute in the schema: enableRefresh</para>
        /// </summary>
        public BooleanValue? EnableRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshedBy</para>
        /// <para>Represents the following attribute in the schema: refreshedBy</para>
        /// </summary>
        public StringValue? RefreshedBy
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshedDateIso</para>
        /// <para>Represents the following attribute in the schema: refreshedDateIso</para>
        /// </summary>
        public DateTimeValue? LastRefreshedDateIso
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshedDate</para>
        /// <para>Represents the following attribute in the schema: refreshedDate</para>
        /// </summary>
        public DoubleValue? RefreshedDate
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>backgroundQuery</para>
        /// <para>Represents the following attribute in the schema: backgroundQuery</para>
        /// </summary>
        public BooleanValue? BackgroundQuery
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>missingItemsLimit</para>
        /// <para>Represents the following attribute in the schema: missingItemsLimit</para>
        /// </summary>
        public UInt32Value? MissingItemsLimit
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>createdVersion</para>
        /// <para>Represents the following attribute in the schema: createdVersion</para>
        /// </summary>
        public ByteValue? CreatedVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshedVersion</para>
        /// <para>Represents the following attribute in the schema: refreshedVersion</para>
        /// </summary>
        public ByteValue? RefreshedVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>minRefreshableVersion</para>
        /// <para>Represents the following attribute in the schema: minRefreshableVersion</para>
        /// </summary>
        public ByteValue? MinRefreshableVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>recordCount</para>
        /// <para>Represents the following attribute in the schema: recordCount</para>
        /// </summary>
        public UInt32Value? RecordCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>upgradeOnRefresh</para>
        /// <para>Represents the following attribute in the schema: upgradeOnRefresh</para>
        /// </summary>
        public BooleanValue? UpgradeOnRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>tupleCache</para>
        /// <para>Represents the following attribute in the schema: tupleCache</para>
        /// </summary>
        public BooleanValue? IsTupleCache
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>supportSubquery</para>
        /// <para>Represents the following attribute in the schema: supportSubquery</para>
        /// </summary>
        public BooleanValue? SupportSubquery
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>supportAdvancedDrill</para>
        /// <para>Represents the following attribute in the schema: supportAdvancedDrill</para>
        /// </summary>
        public BooleanValue? SupportAdvancedDrill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotCacheDefinition");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchies>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheSource>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedItems>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedMembers>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Dimensions>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Maps>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MeasureGroups>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Kpis>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TupleCache>();
            builder.AddElement<PivotCacheDefinition>()
                .AddAttribute("r:id", a => a.Id)
                .AddAttribute("invalid", a => a.Invalid)
                .AddAttribute("saveData", a => a.SaveData)
                .AddAttribute("refreshOnLoad", a => a.RefreshOnLoad)
                .AddAttribute("optimizeMemory", a => a.OptimizeMemory)
                .AddAttribute("enableRefresh", a => a.EnableRefresh)
                .AddAttribute("refreshedBy", a => a.RefreshedBy)
                .AddAttribute("refreshedDateIso", a => a.LastRefreshedDateIso)
                .AddAttribute("refreshedDate", a => a.RefreshedDate)
                .AddAttribute("backgroundQuery", a => a.BackgroundQuery)
                .AddAttribute("missingItemsLimit", a => a.MissingItemsLimit)
                .AddAttribute("createdVersion", a => a.CreatedVersion)
                .AddAttribute("refreshedVersion", a => a.RefreshedVersion)
                .AddAttribute("minRefreshableVersion", a => a.MinRefreshableVersion)
                .AddAttribute("recordCount", a => a.RecordCount)
                .AddAttribute("upgradeOnRefresh", a => a.UpgradeOnRefresh)
                .AddAttribute("tupleCache", a => a.IsTupleCache)
                .AddAttribute("supportSubquery", a => a.SupportSubquery)
                .AddAttribute("supportAdvancedDrill", a => a.SupportAdvancedDrill);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheSource), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheFields), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheHierarchies), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Kpis), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TupleCache), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedMembers), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Dimensions), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MeasureGroups), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Maps), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:refreshedBy"), 0, 255));
        }

        /// <summary>
        /// <para>CacheSource.</para>
        /// <para>Represents the following element tag in the schema: x:cacheSource.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CacheSource? CacheSource
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CacheSource>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CacheFields.</para>
        /// <para>Represents the following element tag in the schema: x:cacheFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CacheFields? CacheFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CacheFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CacheHierarchies.</para>
        /// <para>Represents the following element tag in the schema: x:cacheHierarchies.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CacheHierarchies? CacheHierarchies
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchies>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Kpis.</para>
        /// <para>Represents the following element tag in the schema: x:kpis.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Kpis? Kpis
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Kpis>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>TupleCache.</para>
        /// <para>Represents the following element tag in the schema: x:tupleCache.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TupleCache? TupleCache
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TupleCache>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CalculatedItems.</para>
        /// <para>Represents the following element tag in the schema: x:calculatedItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CalculatedItems? CalculatedItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CalculatedItems>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CalculatedMembers.</para>
        /// <para>Represents the following element tag in the schema: x:calculatedMembers.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CalculatedMembers? CalculatedMembers
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CalculatedMembers>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Dimensions.</para>
        /// <para>Represents the following element tag in the schema: x:dimensions.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Dimensions? Dimensions
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Dimensions>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>MeasureGroups.</para>
        /// <para>Represents the following element tag in the schema: x:measureGroups.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MeasureGroups? MeasureGroups
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MeasureGroups>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Maps.</para>
        /// <para>Represents the following element tag in the schema: x:maps.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Maps? Maps
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Maps>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotCacheDefinitionExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList? PivotCacheDefinitionExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCacheDefinition>(deep);

        internal PivotCacheDefinition(PivotTableCacheDefinitionPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the PivotTableCacheDefinitionPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(PivotTableCacheDefinitionPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the PivotTableCacheDefinitionPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(PivotTableCacheDefinitionPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the PivotTableCacheDefinitionPart associated with this element.
        /// </summary>
        public PivotTableCacheDefinitionPart? PivotTableCacheDefinitionPart
        {
            get => OpenXmlPart as PivotTableCacheDefinitionPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>PivotCache Records.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotCacheRecords.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotCacheRecord" /> <c>&lt;x:r></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCacheRecords : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCacheRecords class.
        /// </summary>
        public PivotCacheRecords() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecords class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheRecords(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecords class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheRecords(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecords class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCacheRecords(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>PivotCache Records Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotCacheRecords");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotCacheRecord>();
            builder.AddElement<PivotCacheRecords>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotCacheRecord), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCacheRecords>(deep);

        internal PivotCacheRecords(PivotTableCacheRecordsPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the PivotTableCacheRecordsPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(PivotTableCacheRecordsPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the PivotTableCacheRecordsPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(PivotTableCacheRecordsPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the PivotTableCacheRecordsPart associated with this element.
        /// </summary>
        public PivotTableCacheRecordsPart? PivotTableCacheRecordsPart
        {
            get => OpenXmlPart as PivotTableCacheRecordsPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>PivotTable Definition.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotTableDefinition.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartFormats" /> <c>&lt;x:chartFormats></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnFields" /> <c>&lt;x:colFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchiesUsage" /> <c>&lt;x:colHierarchiesUsage></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnItems" /> <c>&lt;x:colItems></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormats" /> <c>&lt;x:conditionalFormats></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataFields" /> <c>&lt;x:dataFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Formats" /> <c>&lt;x:formats></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Location" /> <c>&lt;x:location></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageFields" /> <c>&lt;x:pageFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFields" /> <c>&lt;x:pivotFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFilters" /> <c>&lt;x:filters></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotHierarchies" /> <c>&lt;x:pivotHierarchies></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle" /> <c>&lt;x:pivotTableStyleInfo></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowFields" /> <c>&lt;x:rowFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowHierarchiesUsage" /> <c>&lt;x:rowHierarchiesUsage></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowItems" /> <c>&lt;x:rowItems></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotTableDefinition : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotTableDefinition class.
        /// </summary>
        public PivotTableDefinition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotTableDefinition(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cacheId</para>
        /// <para>Represents the following attribute in the schema: cacheId</para>
        /// </summary>
        public UInt32Value? CacheId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dataOnRows</para>
        /// <para>Represents the following attribute in the schema: dataOnRows</para>
        /// </summary>
        public BooleanValue? DataOnRows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dataPosition</para>
        /// <para>Represents the following attribute in the schema: dataPosition</para>
        /// </summary>
        public UInt32Value? DataPosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Format Id</para>
        /// <para>Represents the following attribute in the schema: autoFormatId</para>
        /// </summary>
        public UInt32Value? AutoFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Number Formats</para>
        /// <para>Represents the following attribute in the schema: applyNumberFormats</para>
        /// </summary>
        public BooleanValue? ApplyNumberFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Border Formats</para>
        /// <para>Represents the following attribute in the schema: applyBorderFormats</para>
        /// </summary>
        public BooleanValue? ApplyBorderFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Font Formats</para>
        /// <para>Represents the following attribute in the schema: applyFontFormats</para>
        /// </summary>
        public BooleanValue? ApplyFontFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Pattern Formats</para>
        /// <para>Represents the following attribute in the schema: applyPatternFormats</para>
        /// </summary>
        public BooleanValue? ApplyPatternFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Alignment Formats</para>
        /// <para>Represents the following attribute in the schema: applyAlignmentFormats</para>
        /// </summary>
        public BooleanValue? ApplyAlignmentFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Width / Height Formats</para>
        /// <para>Represents the following attribute in the schema: applyWidthHeightFormats</para>
        /// </summary>
        public BooleanValue? ApplyWidthHeightFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dataCaption</para>
        /// <para>Represents the following attribute in the schema: dataCaption</para>
        /// </summary>
        public StringValue? DataCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>grandTotalCaption</para>
        /// <para>Represents the following attribute in the schema: grandTotalCaption</para>
        /// </summary>
        public StringValue? GrandTotalCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>errorCaption</para>
        /// <para>Represents the following attribute in the schema: errorCaption</para>
        /// </summary>
        public StringValue? ErrorCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showError</para>
        /// <para>Represents the following attribute in the schema: showError</para>
        /// </summary>
        public BooleanValue? ShowError
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>missingCaption</para>
        /// <para>Represents the following attribute in the schema: missingCaption</para>
        /// </summary>
        public StringValue? MissingCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showMissing</para>
        /// <para>Represents the following attribute in the schema: showMissing</para>
        /// </summary>
        public BooleanValue? ShowMissing
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pageStyle</para>
        /// <para>Represents the following attribute in the schema: pageStyle</para>
        /// </summary>
        public StringValue? PageStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pivotTableStyle</para>
        /// <para>Represents the following attribute in the schema: pivotTableStyle</para>
        /// </summary>
        public StringValue? PivotTableStyleName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>vacatedStyle</para>
        /// <para>Represents the following attribute in the schema: vacatedStyle</para>
        /// </summary>
        public StringValue? VacatedStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>tag</para>
        /// <para>Represents the following attribute in the schema: tag</para>
        /// </summary>
        public StringValue? Tag
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>updatedVersion</para>
        /// <para>Represents the following attribute in the schema: updatedVersion</para>
        /// </summary>
        public ByteValue? UpdatedVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>minRefreshableVersion</para>
        /// <para>Represents the following attribute in the schema: minRefreshableVersion</para>
        /// </summary>
        public ByteValue? MinRefreshableVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>asteriskTotals</para>
        /// <para>Represents the following attribute in the schema: asteriskTotals</para>
        /// </summary>
        public BooleanValue? AsteriskTotals
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showItems</para>
        /// <para>Represents the following attribute in the schema: showItems</para>
        /// </summary>
        public BooleanValue? ShowItems
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>editData</para>
        /// <para>Represents the following attribute in the schema: editData</para>
        /// </summary>
        public BooleanValue? EditData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disableFieldList</para>
        /// <para>Represents the following attribute in the schema: disableFieldList</para>
        /// </summary>
        public BooleanValue? DisableFieldList
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showCalcMbrs</para>
        /// <para>Represents the following attribute in the schema: showCalcMbrs</para>
        /// </summary>
        public BooleanValue? ShowCalculatedMembers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>visualTotals</para>
        /// <para>Represents the following attribute in the schema: visualTotals</para>
        /// </summary>
        public BooleanValue? VisualTotals
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showMultipleLabel</para>
        /// <para>Represents the following attribute in the schema: showMultipleLabel</para>
        /// </summary>
        public BooleanValue? ShowMultipleLabel
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDataDropDown</para>
        /// <para>Represents the following attribute in the schema: showDataDropDown</para>
        /// </summary>
        public BooleanValue? ShowDataDropDown
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDrill</para>
        /// <para>Represents the following attribute in the schema: showDrill</para>
        /// </summary>
        public BooleanValue? ShowDrill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>printDrill</para>
        /// <para>Represents the following attribute in the schema: printDrill</para>
        /// </summary>
        public BooleanValue? PrintDrill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showMemberPropertyTips</para>
        /// <para>Represents the following attribute in the schema: showMemberPropertyTips</para>
        /// </summary>
        public BooleanValue? ShowMemberPropertyTips
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDataTips</para>
        /// <para>Represents the following attribute in the schema: showDataTips</para>
        /// </summary>
        public BooleanValue? ShowDataTips
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>enableWizard</para>
        /// <para>Represents the following attribute in the schema: enableWizard</para>
        /// </summary>
        public BooleanValue? EnableWizard
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>enableDrill</para>
        /// <para>Represents the following attribute in the schema: enableDrill</para>
        /// </summary>
        public BooleanValue? EnableDrill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>enableFieldProperties</para>
        /// <para>Represents the following attribute in the schema: enableFieldProperties</para>
        /// </summary>
        public BooleanValue? EnableFieldProperties
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>preserveFormatting</para>
        /// <para>Represents the following attribute in the schema: preserveFormatting</para>
        /// </summary>
        public BooleanValue? PreserveFormatting
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>useAutoFormatting</para>
        /// <para>Represents the following attribute in the schema: useAutoFormatting</para>
        /// </summary>
        public BooleanValue? UseAutoFormatting
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pageWrap</para>
        /// <para>Represents the following attribute in the schema: pageWrap</para>
        /// </summary>
        public UInt32Value? PageWrap
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pageOverThenDown</para>
        /// <para>Represents the following attribute in the schema: pageOverThenDown</para>
        /// </summary>
        public BooleanValue? PageOverThenDown
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>subtotalHiddenItems</para>
        /// <para>Represents the following attribute in the schema: subtotalHiddenItems</para>
        /// </summary>
        public BooleanValue? SubtotalHiddenItems
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rowGrandTotals</para>
        /// <para>Represents the following attribute in the schema: rowGrandTotals</para>
        /// </summary>
        public BooleanValue? RowGrandTotals
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>colGrandTotals</para>
        /// <para>Represents the following attribute in the schema: colGrandTotals</para>
        /// </summary>
        public BooleanValue? ColumnGrandTotals
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>fieldPrintTitles</para>
        /// <para>Represents the following attribute in the schema: fieldPrintTitles</para>
        /// </summary>
        public BooleanValue? FieldPrintTitles
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>itemPrintTitles</para>
        /// <para>Represents the following attribute in the schema: itemPrintTitles</para>
        /// </summary>
        public BooleanValue? ItemPrintTitles
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mergeItem</para>
        /// <para>Represents the following attribute in the schema: mergeItem</para>
        /// </summary>
        public BooleanValue? MergeItem
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDropZones</para>
        /// <para>Represents the following attribute in the schema: showDropZones</para>
        /// </summary>
        public BooleanValue? ShowDropZones
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>createdVersion</para>
        /// <para>Represents the following attribute in the schema: createdVersion</para>
        /// </summary>
        public ByteValue? CreatedVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>indent</para>
        /// <para>Represents the following attribute in the schema: indent</para>
        /// </summary>
        public UInt32Value? Indent
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showEmptyRow</para>
        /// <para>Represents the following attribute in the schema: showEmptyRow</para>
        /// </summary>
        public BooleanValue? ShowEmptyRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showEmptyCol</para>
        /// <para>Represents the following attribute in the schema: showEmptyCol</para>
        /// </summary>
        public BooleanValue? ShowEmptyColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showHeaders</para>
        /// <para>Represents the following attribute in the schema: showHeaders</para>
        /// </summary>
        public BooleanValue? ShowHeaders
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>compact</para>
        /// <para>Represents the following attribute in the schema: compact</para>
        /// </summary>
        public BooleanValue? Compact
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>outline</para>
        /// <para>Represents the following attribute in the schema: outline</para>
        /// </summary>
        public BooleanValue? Outline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>outlineData</para>
        /// <para>Represents the following attribute in the schema: outlineData</para>
        /// </summary>
        public BooleanValue? OutlineData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>compactData</para>
        /// <para>Represents the following attribute in the schema: compactData</para>
        /// </summary>
        public BooleanValue? CompactData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>published</para>
        /// <para>Represents the following attribute in the schema: published</para>
        /// </summary>
        public BooleanValue? Published
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>gridDropZones</para>
        /// <para>Represents the following attribute in the schema: gridDropZones</para>
        /// </summary>
        public BooleanValue? GridDropZones
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>immersive</para>
        /// <para>Represents the following attribute in the schema: immersive</para>
        /// </summary>
        public BooleanValue? StopImmersiveUi
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>multipleFieldFilters</para>
        /// <para>Represents the following attribute in the schema: multipleFieldFilters</para>
        /// </summary>
        public BooleanValue? MultipleFieldFilters
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>chartFormat</para>
        /// <para>Represents the following attribute in the schema: chartFormat</para>
        /// </summary>
        public UInt32Value? ChartFormat
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rowHeaderCaption</para>
        /// <para>Represents the following attribute in the schema: rowHeaderCaption</para>
        /// </summary>
        public StringValue? RowHeaderCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>colHeaderCaption</para>
        /// <para>Represents the following attribute in the schema: colHeaderCaption</para>
        /// </summary>
        public StringValue? ColumnHeaderCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>fieldListSortAscending</para>
        /// <para>Represents the following attribute in the schema: fieldListSortAscending</para>
        /// </summary>
        public BooleanValue? FieldListSortAscending
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mdxSubqueries</para>
        /// <para>Represents the following attribute in the schema: mdxSubqueries</para>
        /// </summary>
        public BooleanValue? MdxSubqueries
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>customListSort</para>
        /// <para>Represents the following attribute in the schema: customListSort</para>
        /// </summary>
        public BooleanValue? CustomListSort
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotTableDefinition");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchiesUsage>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnItems>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Formats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Location>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFilters>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotHierarchies>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowHierarchiesUsage>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowItems>();
            builder.AddElement<PivotTableDefinition>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("cacheId", a => a.CacheId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("dataOnRows", a => a.DataOnRows)
                .AddAttribute("dataPosition", a => a.DataPosition)
                .AddAttribute("autoFormatId", a => a.AutoFormatId)
                .AddAttribute("applyNumberFormats", a => a.ApplyNumberFormats)
                .AddAttribute("applyBorderFormats", a => a.ApplyBorderFormats)
                .AddAttribute("applyFontFormats", a => a.ApplyFontFormats)
                .AddAttribute("applyPatternFormats", a => a.ApplyPatternFormats)
                .AddAttribute("applyAlignmentFormats", a => a.ApplyAlignmentFormats)
                .AddAttribute("applyWidthHeightFormats", a => a.ApplyWidthHeightFormats)
                .AddAttribute("dataCaption", a => a.DataCaption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("grandTotalCaption", a => a.GrandTotalCaption)
                .AddAttribute("errorCaption", a => a.ErrorCaption)
                .AddAttribute("showError", a => a.ShowError)
                .AddAttribute("missingCaption", a => a.MissingCaption)
                .AddAttribute("showMissing", a => a.ShowMissing)
                .AddAttribute("pageStyle", a => a.PageStyle)
                .AddAttribute("pivotTableStyle", a => a.PivotTableStyleName)
                .AddAttribute("vacatedStyle", a => a.VacatedStyle)
                .AddAttribute("tag", a => a.Tag)
                .AddAttribute("updatedVersion", a => a.UpdatedVersion)
                .AddAttribute("minRefreshableVersion", a => a.MinRefreshableVersion)
                .AddAttribute("asteriskTotals", a => a.AsteriskTotals)
                .AddAttribute("showItems", a => a.ShowItems)
                .AddAttribute("editData", a => a.EditData)
                .AddAttribute("disableFieldList", a => a.DisableFieldList)
                .AddAttribute("showCalcMbrs", a => a.ShowCalculatedMembers)
                .AddAttribute("visualTotals", a => a.VisualTotals)
                .AddAttribute("showMultipleLabel", a => a.ShowMultipleLabel)
                .AddAttribute("showDataDropDown", a => a.ShowDataDropDown)
                .AddAttribute("showDrill", a => a.ShowDrill)
                .AddAttribute("printDrill", a => a.PrintDrill)
                .AddAttribute("showMemberPropertyTips", a => a.ShowMemberPropertyTips)
                .AddAttribute("showDataTips", a => a.ShowDataTips)
                .AddAttribute("enableWizard", a => a.EnableWizard)
                .AddAttribute("enableDrill", a => a.EnableDrill)
                .AddAttribute("enableFieldProperties", a => a.EnableFieldProperties)
                .AddAttribute("preserveFormatting", a => a.PreserveFormatting)
                .AddAttribute("useAutoFormatting", a => a.UseAutoFormatting)
                .AddAttribute("pageWrap", a => a.PageWrap)
                .AddAttribute("pageOverThenDown", a => a.PageOverThenDown)
                .AddAttribute("subtotalHiddenItems", a => a.SubtotalHiddenItems)
                .AddAttribute("rowGrandTotals", a => a.RowGrandTotals)
                .AddAttribute("colGrandTotals", a => a.ColumnGrandTotals)
                .AddAttribute("fieldPrintTitles", a => a.FieldPrintTitles)
                .AddAttribute("itemPrintTitles", a => a.ItemPrintTitles)
                .AddAttribute("mergeItem", a => a.MergeItem)
                .AddAttribute("showDropZones", a => a.ShowDropZones)
                .AddAttribute("createdVersion", a => a.CreatedVersion)
                .AddAttribute("indent", a => a.Indent)
                .AddAttribute("showEmptyRow", a => a.ShowEmptyRow)
                .AddAttribute("showEmptyCol", a => a.ShowEmptyColumn)
                .AddAttribute("showHeaders", a => a.ShowHeaders)
                .AddAttribute("compact", a => a.Compact)
                .AddAttribute("outline", a => a.Outline)
                .AddAttribute("outlineData", a => a.OutlineData)
                .AddAttribute("compactData", a => a.CompactData)
                .AddAttribute("published", a => a.Published)
                .AddAttribute("gridDropZones", a => a.GridDropZones)
                .AddAttribute("immersive", a => a.StopImmersiveUi)
                .AddAttribute("multipleFieldFilters", a => a.MultipleFieldFilters)
                .AddAttribute("chartFormat", a => a.ChartFormat)
                .AddAttribute("rowHeaderCaption", a => a.RowHeaderCaption)
                .AddAttribute("colHeaderCaption", a => a.ColumnHeaderCaption)
                .AddAttribute("fieldListSortAscending", a => a.FieldListSortAscending)
                .AddAttribute("mdxSubqueries", a => a.MdxSubqueries)
                .AddAttribute("customListSort", a => a.CustomListSort);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Location), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Formats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotHierarchies), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFilters), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowHierarchiesUsage), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchiesUsage), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:autoFormatId"), true, 0, true, 16, true));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:cacheId"), "/WorkbookPart", builder.CreateQName("x:pivotCache"), "x:pivotCache", builder.CreateQName("x:cacheId")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:indent"), true, double.NegativeInfinity, true, 127, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:pageWrap"), true, double.NegativeInfinity, true, 255, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:dataCaption"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName(":grandTotalCaption"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:errorCaption"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:missingCaption"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:pageStyle"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:pivotTableStyle"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:vacatedStyle"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:tag"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Location.</para>
        /// <para>Represents the following element tag in the schema: x:location.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Location? Location
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Location>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotFields.</para>
        /// <para>Represents the following element tag in the schema: x:pivotFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotFields? PivotFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>RowFields.</para>
        /// <para>Represents the following element tag in the schema: x:rowFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RowFields? RowFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RowFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>RowItems.</para>
        /// <para>Represents the following element tag in the schema: x:rowItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RowItems? RowItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RowItems>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ColumnFields.</para>
        /// <para>Represents the following element tag in the schema: x:colFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ColumnFields? ColumnFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ColumnFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ColumnItems.</para>
        /// <para>Represents the following element tag in the schema: x:colItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ColumnItems? ColumnItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ColumnItems>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PageFields.</para>
        /// <para>Represents the following element tag in the schema: x:pageFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageFields? PageFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DataFields.</para>
        /// <para>Represents the following element tag in the schema: x:dataFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DataFields? DataFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DataFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Formats.</para>
        /// <para>Represents the following element tag in the schema: x:formats.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Formats? Formats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Formats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ConditionalFormats.</para>
        /// <para>Represents the following element tag in the schema: x:conditionalFormats.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ConditionalFormats? ConditionalFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ChartFormats.</para>
        /// <para>Represents the following element tag in the schema: x:chartFormats.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartFormats? ChartFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotHierarchies.</para>
        /// <para>Represents the following element tag in the schema: x:pivotHierarchies.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotHierarchies? PivotHierarchies
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotHierarchies>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotTableStyle.</para>
        /// <para>Represents the following element tag in the schema: x:pivotTableStyleInfo.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle? PivotTableStyle
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotTableStyle>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotFilters.</para>
        /// <para>Represents the following element tag in the schema: x:filters.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotFilters? PivotFilters
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotFilters>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>RowHierarchiesUsage.</para>
        /// <para>Represents the following element tag in the schema: x:rowHierarchiesUsage.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RowHierarchiesUsage? RowHierarchiesUsage
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RowHierarchiesUsage>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ColumnHierarchiesUsage.</para>
        /// <para>Represents the following element tag in the schema: x:colHierarchiesUsage.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchiesUsage? ColumnHierarchiesUsage
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchiesUsage>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotTableDefinitionExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList? PivotTableDefinitionExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotTableDefinition>(deep);

        internal PivotTableDefinition(PivotTablePart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the PivotTablePart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(PivotTablePart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the PivotTablePart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(PivotTablePart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the PivotTablePart associated with this element.
        /// </summary>
        public PivotTablePart? PivotTablePart
        {
            get => OpenXmlPart as PivotTablePart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Query Table.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryTable.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableRefresh" /> <c>&lt;x:queryTableRefresh></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTable : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTable class.
        /// </summary>
        public QueryTable() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTable class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTable(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTable class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTable(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTable class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTable(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>headers</para>
        /// <para>Represents the following attribute in the schema: headers</para>
        /// </summary>
        public BooleanValue? Headers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rowNumbers</para>
        /// <para>Represents the following attribute in the schema: rowNumbers</para>
        /// </summary>
        public BooleanValue? RowNumbers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disableRefresh</para>
        /// <para>Represents the following attribute in the schema: disableRefresh</para>
        /// </summary>
        public BooleanValue? DisableRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>backgroundRefresh</para>
        /// <para>Represents the following attribute in the schema: backgroundRefresh</para>
        /// </summary>
        public BooleanValue? BackgroundRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>firstBackgroundRefresh</para>
        /// <para>Represents the following attribute in the schema: firstBackgroundRefresh</para>
        /// </summary>
        public BooleanValue? FirstBackgroundRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshOnLoad</para>
        /// <para>Represents the following attribute in the schema: refreshOnLoad</para>
        /// </summary>
        public BooleanValue? RefreshOnLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>growShrinkType</para>
        /// <para>Represents the following attribute in the schema: growShrinkType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GrowShrinkValues>? GrowShrinkType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.GrowShrinkValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>fillFormulas</para>
        /// <para>Represents the following attribute in the schema: fillFormulas</para>
        /// </summary>
        public BooleanValue? FillFormulas
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>removeDataOnSave</para>
        /// <para>Represents the following attribute in the schema: removeDataOnSave</para>
        /// </summary>
        public BooleanValue? RemoveDataOnSave
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disableEdit</para>
        /// <para>Represents the following attribute in the schema: disableEdit</para>
        /// </summary>
        public BooleanValue? DisableEdit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>preserveFormatting</para>
        /// <para>Represents the following attribute in the schema: preserveFormatting</para>
        /// </summary>
        public BooleanValue? PreserveFormatting
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>adjustColumnWidth</para>
        /// <para>Represents the following attribute in the schema: adjustColumnWidth</para>
        /// </summary>
        public BooleanValue? AdjustColumnWidth
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>intermediate</para>
        /// <para>Represents the following attribute in the schema: intermediate</para>
        /// </summary>
        public BooleanValue? Intermediate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>connectionId</para>
        /// <para>Represents the following attribute in the schema: connectionId</para>
        /// </summary>
        public UInt32Value? ConnectionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Format Id</para>
        /// <para>Represents the following attribute in the schema: autoFormatId</para>
        /// </summary>
        public UInt32Value? AutoFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Number Formats</para>
        /// <para>Represents the following attribute in the schema: applyNumberFormats</para>
        /// </summary>
        public BooleanValue? ApplyNumberFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Border Formats</para>
        /// <para>Represents the following attribute in the schema: applyBorderFormats</para>
        /// </summary>
        public BooleanValue? ApplyBorderFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Font Formats</para>
        /// <para>Represents the following attribute in the schema: applyFontFormats</para>
        /// </summary>
        public BooleanValue? ApplyFontFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Pattern Formats</para>
        /// <para>Represents the following attribute in the schema: applyPatternFormats</para>
        /// </summary>
        public BooleanValue? ApplyPatternFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Alignment Formats</para>
        /// <para>Represents the following attribute in the schema: applyAlignmentFormats</para>
        /// </summary>
        public BooleanValue? ApplyAlignmentFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Width / Height Formats</para>
        /// <para>Represents the following attribute in the schema: applyWidthHeightFormats</para>
        /// </summary>
        public BooleanValue? ApplyWidthHeightFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryTable");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableRefresh>();
            builder.AddElement<QueryTable>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("headers", a => a.Headers)
                .AddAttribute("rowNumbers", a => a.RowNumbers)
                .AddAttribute("disableRefresh", a => a.DisableRefresh)
                .AddAttribute("backgroundRefresh", a => a.BackgroundRefresh)
                .AddAttribute("firstBackgroundRefresh", a => a.FirstBackgroundRefresh)
                .AddAttribute("refreshOnLoad", a => a.RefreshOnLoad)
                .AddAttribute("growShrinkType", a => a.GrowShrinkType)
                .AddAttribute("fillFormulas", a => a.FillFormulas)
                .AddAttribute("removeDataOnSave", a => a.RemoveDataOnSave)
                .AddAttribute("disableEdit", a => a.DisableEdit)
                .AddAttribute("preserveFormatting", a => a.PreserveFormatting)
                .AddAttribute("adjustColumnWidth", a => a.AdjustColumnWidth)
                .AddAttribute("intermediate", a => a.Intermediate)
                .AddAttribute("connectionId", a => a.ConnectionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("autoFormatId", a => a.AutoFormatId)
                .AddAttribute("applyNumberFormats", a => a.ApplyNumberFormats)
                .AddAttribute("applyBorderFormats", a => a.ApplyBorderFormats)
                .AddAttribute("applyFontFormats", a => a.ApplyFontFormats)
                .AddAttribute("applyPatternFormats", a => a.ApplyPatternFormats)
                .AddAttribute("applyAlignmentFormats", a => a.ApplyAlignmentFormats)
                .AddAttribute("applyWidthHeightFormats", a => a.ApplyWidthHeightFormats);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableRefresh), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:backgroundRefresh"), builder.CreateQName("x:firstBackgroundRefresh"), new string[] { "true" }, new string[] { "true" }));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:connectionId"), true, 1, true, double.PositiveInfinity, true));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:connectionId"), "/WorkbookPart/ConnectionsPart", builder.CreateQName("x:connection"), "x:connection", builder.CreateQName("x:id")));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255));
        }

        /// <summary>
        /// <para>QueryTableRefresh.</para>
        /// <para>Represents the following element tag in the schema: x:queryTableRefresh.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.QueryTableRefresh? QueryTableRefresh
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.QueryTableRefresh>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>QueryTableExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.QueryTableExtensionList? QueryTableExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.QueryTableExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTable>(deep);

        internal QueryTable(QueryTablePart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the QueryTablePart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(QueryTablePart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the QueryTablePart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(QueryTablePart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the QueryTablePart associated with this element.
        /// </summary>
        public QueryTablePart? QueryTablePart
        {
            get => OpenXmlPart as QueryTablePart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Shared String Table.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SharedStringItem" /> <c>&lt;x:si></c></description></item>
    /// </list>
    /// </remark>
    public partial class SharedStringTable : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the SharedStringTable class.
        /// </summary>
        public SharedStringTable() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringTable class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedStringTable(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringTable class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedStringTable(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringTable class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SharedStringTable(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>String Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique String Count</para>
        /// <para>Represents the following attribute in the schema: uniqueCount</para>
        /// </summary>
        public UInt32Value? UniqueCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SharedStringItem>();
            builder.AddElement<SharedStringTable>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("uniqueCount", a => a.UniqueCount);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SharedStringItem), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:uniqueCount"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SharedStringTable>(deep);

        internal SharedStringTable(SharedStringTablePart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the SharedStringTablePart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(SharedStringTablePart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the SharedStringTablePart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(SharedStringTablePart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the SharedStringTablePart associated with this element.
        /// </summary>
        public SharedStringTablePart? SharedStringTablePart
        {
            get => OpenXmlPart as SharedStringTablePart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Revision Headers.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:headers.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Header" /> <c>&lt;x:header></c></description></item>
    /// </list>
    /// </remark>
    public partial class Headers : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Headers class.
        /// </summary>
        public Headers() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Headers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Headers(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Headers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Headers(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Headers class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Headers(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Last Revision GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Last GUID</para>
        /// <para>Represents the following attribute in the schema: lastGuid</para>
        /// </summary>
        public StringValue? LastGuid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shared Workbook</para>
        /// <para>Represents the following attribute in the schema: shared</para>
        /// </summary>
        public BooleanValue? Shared
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Disk Revisions</para>
        /// <para>Represents the following attribute in the schema: diskRevisions</para>
        /// </summary>
        public BooleanValue? DiskRevisions
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>History</para>
        /// <para>Represents the following attribute in the schema: history</para>
        /// </summary>
        public BooleanValue? History
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Track Revisions</para>
        /// <para>Represents the following attribute in the schema: trackRevisions</para>
        /// </summary>
        public BooleanValue? TrackRevisions
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Exclusive Mode</para>
        /// <para>Represents the following attribute in the schema: exclusive</para>
        /// </summary>
        public BooleanValue? Exclusive
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: revisionId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Version</para>
        /// <para>Represents the following attribute in the schema: version</para>
        /// </summary>
        public Int32Value? Version
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Keep Change History</para>
        /// <para>Represents the following attribute in the schema: keepChangeHistory</para>
        /// </summary>
        public BooleanValue? KeepChangeHistory
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Protected</para>
        /// <para>Represents the following attribute in the schema: protected</para>
        /// </summary>
        public BooleanValue? Protected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Preserve History</para>
        /// <para>Represents the following attribute in the schema: preserveHistory</para>
        /// </summary>
        public UInt32Value? PreserveHistory
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:headers");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Header>();
            builder.AddElement<Headers>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("lastGuid", a => a.LastGuid, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("shared", a => a.Shared)
                .AddAttribute("diskRevisions", a => a.DiskRevisions)
                .AddAttribute("history", a => a.History)
                .AddAttribute("trackRevisions", a => a.TrackRevisions)
                .AddAttribute("exclusive", a => a.Exclusive)
                .AddAttribute("revisionId", a => a.RevisionId)
                .AddAttribute("version", a => a.Version)
                .AddAttribute("keepChangeHistory", a => a.KeepChangeHistory)
                .AddAttribute("protected", a => a.Protected)
                .AddAttribute("preserveHistory", a => a.PreserveHistory);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Header), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:version"), true, 1, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:preserveHistory"), true, 0, true, 32768, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:revisionId"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:guid"), false, new string[] { "00000000-0000-0000-0000-000000000000" }));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Headers>(deep);

        internal Headers(WorkbookRevisionHeaderPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorkbookRevisionHeaderPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorkbookRevisionHeaderPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorkbookRevisionHeaderPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorkbookRevisionHeaderPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorkbookRevisionHeaderPart associated with this element.
        /// </summary>
        public WorkbookRevisionHeaderPart? WorkbookRevisionHeaderPart
        {
            get => OpenXmlPart as WorkbookRevisionHeaderPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Revisions.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:revisions.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionAutoFormat" /> <c>&lt;x:raf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange" /> <c>&lt;x:rcc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionComment" /> <c>&lt;x:rcmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionConflict" /> <c>&lt;x:rcft></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionCustomView" /> <c>&lt;x:rcv></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionDefinedName" /> <c>&lt;x:rdn></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionFormat" /> <c>&lt;x:rfmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionInsertSheet" /> <c>&lt;x:ris></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionMove" /> <c>&lt;x:rm></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionQueryTable" /> <c>&lt;x:rqt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionRowColumn" /> <c>&lt;x:rrc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionSheetName" /> <c>&lt;x:rsnm></c></description></item>
    /// </list>
    /// </remark>
    public partial class Revisions : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Revisions class.
        /// </summary>
        public Revisions() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Revisions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Revisions(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Revisions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Revisions(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Revisions class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Revisions(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:revisions");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionAutoFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionComment>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionConflict>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionCustomView>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionDefinedName>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionInsertSheet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionMove>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionQueryTable>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionRowColumn>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionSheetName>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionRowColumn), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionMove), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionCustomView), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionSheetName), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionInsertSheet), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionFormat), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionAutoFormat), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionDefinedName), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionComment), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionQueryTable), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionConflict), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Revisions>(deep);

        internal Revisions(WorkbookRevisionLogPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorkbookRevisionLogPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorkbookRevisionLogPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorkbookRevisionLogPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorkbookRevisionLogPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorkbookRevisionLogPart associated with this element.
        /// </summary>
        public WorkbookRevisionLogPart? WorkbookRevisionLogPart
        {
            get => OpenXmlPart as WorkbookRevisionLogPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>User List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:users.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.UserInfo" /> <c>&lt;x:userInfo></c></description></item>
    /// </list>
    /// </remark>
    public partial class Users : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Users class.
        /// </summary>
        public Users() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Users class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Users(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Users class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Users(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Users class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Users(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Active User Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:users");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.UserInfo>();
            builder.AddElement<Users>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.UserInfo), 0, 256)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 256, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Users>(deep);

        internal Users(WorkbookUserDataPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorkbookUserDataPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorkbookUserDataPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorkbookUserDataPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorkbookUserDataPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorkbookUserDataPart associated with this element.
        /// </summary>
        public WorkbookUserDataPart? WorkbookUserDataPart
        {
            get => OpenXmlPart as WorkbookUserDataPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Worksheet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:worksheet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.AutoFilter" /> <c>&lt;x:autoFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellWatches" /> <c>&lt;x:cellWatches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Columns" /> <c>&lt;x:cols></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatting" /> <c>&lt;x:conditionalFormatting></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Controls" /> <c>&lt;x:controls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomProperties" /> <c>&lt;x:customProperties></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews" /> <c>&lt;x:customSheetViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataConsolidate" /> <c>&lt;x:dataConsolidate></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataValidations" /> <c>&lt;x:dataValidations></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Drawing" /> <c>&lt;x:drawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter" /> <c>&lt;x:drawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HeaderFooter" /> <c>&lt;x:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Hyperlinks" /> <c>&lt;x:hyperlinks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.IgnoredErrors" /> <c>&lt;x:ignoredErrors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing" /> <c>&lt;x:legacyDrawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter" /> <c>&lt;x:legacyDrawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MergeCells" /> <c>&lt;x:mergeCells></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleObjects" /> <c>&lt;x:oleObjects></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowBreaks" /> <c>&lt;x:rowBreaks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks" /> <c>&lt;x:colBreaks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageMargins" /> <c>&lt;x:pageMargins></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageSetup" /> <c>&lt;x:pageSetup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties" /> <c>&lt;x:phoneticPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PrintOptions" /> <c>&lt;x:printOptions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ProtectedRanges" /> <c>&lt;x:protectedRanges></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Scenarios" /> <c>&lt;x:scenarios></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Picture" /> <c>&lt;x:picture></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetCalculationProperties" /> <c>&lt;x:sheetCalcPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetData" /> <c>&lt;x:sheetData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetDimension" /> <c>&lt;x:dimension></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties" /> <c>&lt;x:sheetFormatPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetProperties" /> <c>&lt;x:sheetPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetProtection" /> <c>&lt;x:sheetProtection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetViews" /> <c>&lt;x:sheetViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortState" /> <c>&lt;x:sortState></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableParts" /> <c>&lt;x:tableParts></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishItems" /> <c>&lt;x:webPublishItems></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorksheetExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Worksheet : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Worksheet class.
        /// </summary>
        public Worksheet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Worksheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Worksheet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Worksheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Worksheet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Worksheet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Worksheet(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:worksheet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellWatches>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Columns>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatting>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Controls>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataConsolidate>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataValidations>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Drawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Hyperlinks>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.IgnoredErrors>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MergeCells>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleObjects>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowBreaks>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageSetup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PrintOptions>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ProtectedRanges>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Scenarios>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Picture>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetCalculationProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetData>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetDimension>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetProtection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableParts>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishItems>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorksheetExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetDimension), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Columns), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetData), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetCalculationProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetProtection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ProtectedRanges), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Scenarios), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.AutoFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortState), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataConsolidate), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MergeCells), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatting), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataValidations), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Hyperlinks), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PrintOptions), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageMargins), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageSetup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowBreaks), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellWatches), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.IgnoredErrors), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Drawing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Picture), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleObjects), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Controls), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableParts), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorksheetExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>SheetProperties.</para>
        /// <para>Represents the following element tag in the schema: x:sheetPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetProperties? SheetProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>SheetDimension.</para>
        /// <para>Represents the following element tag in the schema: x:dimension.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetDimension? SheetDimension
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetDimension>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>SheetViews.</para>
        /// <para>Represents the following element tag in the schema: x:sheetViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetViews? SheetViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>SheetFormatProperties.</para>
        /// <para>Represents the following element tag in the schema: x:sheetFormatPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties? SheetFormatProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Worksheet>(deep);

        internal Worksheet(WorksheetPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorksheetPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorksheetPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorksheetPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorksheetPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorksheetPart associated with this element.
        /// </summary>
        public WorksheetPart? WorksheetPart
        {
            get => OpenXmlPart as WorksheetPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Chart Sheet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:chartsheet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetProperties" /> <c>&lt;x:sheetPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetProtection" /> <c>&lt;x:sheetProtection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetViews" /> <c>&lt;x:sheetViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup" /> <c>&lt;x:pageSetup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetViews" /> <c>&lt;x:customSheetViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Drawing" /> <c>&lt;x:drawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter" /> <c>&lt;x:drawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HeaderFooter" /> <c>&lt;x:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing" /> <c>&lt;x:legacyDrawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter" /> <c>&lt;x:legacyDrawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageMargins" /> <c>&lt;x:pageMargins></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Picture" /> <c>&lt;x:picture></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishItems" /> <c>&lt;x:webPublishItems></c></description></item>
    /// </list>
    /// </remark>
    public partial class Chartsheet : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Chartsheet class.
        /// </summary>
        public Chartsheet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chartsheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Chartsheet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chartsheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Chartsheet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chartsheet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Chartsheet(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:chartsheet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetProtection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Drawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Picture>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishItems>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetViews), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetProtection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageMargins), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Drawing), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Picture), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Chart Sheet Properties.</para>
        /// <para>Represents the following element tag in the schema: x:sheetPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartSheetProperties? ChartSheetProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartSheetProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Chart Sheet Views.</para>
        /// <para>Represents the following element tag in the schema: x:sheetViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartSheetViews? ChartSheetViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartSheetViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Chart Sheet Protection.</para>
        /// <para>Represents the following element tag in the schema: x:sheetProtection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartSheetProtection? ChartSheetProtection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartSheetProtection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Custom Chart Sheet Views.</para>
        /// <para>Represents the following element tag in the schema: x:customSheetViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetViews? CustomChartsheetViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PageMargins.</para>
        /// <para>Represents the following element tag in the schema: x:pageMargins.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageMargins? PageMargins
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ChartSheetPageSetup.</para>
        /// <para>Represents the following element tag in the schema: x:pageSetup.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup? ChartSheetPageSetup
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>HeaderFooter.</para>
        /// <para>Represents the following element tag in the schema: x:headerFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.HeaderFooter? HeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Drawing.</para>
        /// <para>Represents the following element tag in the schema: x:drawing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Drawing? Drawing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Drawing>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>LegacyDrawing.</para>
        /// <para>Represents the following element tag in the schema: x:legacyDrawing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing? LegacyDrawing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Legacy Drawing Reference in  Header Footer.</para>
        /// <para>Represents the following element tag in the schema: x:legacyDrawingHF.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter? LegacyDrawingHeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DrawingHeaderFooter.</para>
        /// <para>Represents the following element tag in the schema: x:drawingHF.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter? DrawingHeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Picture.</para>
        /// <para>Represents the following element tag in the schema: x:picture.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Picture? Picture
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Picture>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>WebPublishItems.</para>
        /// <para>Represents the following element tag in the schema: x:webPublishItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WebPublishItems? WebPublishItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WebPublishItems>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Chartsheet>(deep);

        internal Chartsheet(ChartsheetPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the ChartsheetPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(ChartsheetPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the ChartsheetPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(ChartsheetPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the ChartsheetPart associated with this element.
        /// </summary>
        public ChartsheetPart? ChartsheetPart
        {
            get => OpenXmlPart as ChartsheetPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Dialog Sheet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dialogsheet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Controls" /> <c>&lt;x:controls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews" /> <c>&lt;x:customSheetViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Drawing" /> <c>&lt;x:drawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter" /> <c>&lt;x:drawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HeaderFooter" /> <c>&lt;x:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing" /> <c>&lt;x:legacyDrawing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter" /> <c>&lt;x:legacyDrawingHF></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleObjects" /> <c>&lt;x:oleObjects></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageMargins" /> <c>&lt;x:pageMargins></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageSetup" /> <c>&lt;x:pageSetup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PrintOptions" /> <c>&lt;x:printOptions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties" /> <c>&lt;x:sheetFormatPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetProperties" /> <c>&lt;x:sheetPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetProtection" /> <c>&lt;x:sheetProtection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetViews" /> <c>&lt;x:sheetViews></c></description></item>
    /// </list>
    /// </remark>
    public partial class DialogSheet : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the DialogSheet class.
        /// </summary>
        public DialogSheet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DialogSheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DialogSheet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DialogSheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DialogSheet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DialogSheet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DialogSheet(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dialogsheet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Controls>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Drawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleObjects>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageSetup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PrintOptions>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetProtection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetViews>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetProtection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PrintOptions), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageMargins), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageSetup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Drawing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleObjects), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Controls), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Sheet Properties.</para>
        /// <para>Represents the following element tag in the schema: x:sheetPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetProperties? SheetProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Dialog Sheet Views.</para>
        /// <para>Represents the following element tag in the schema: x:sheetViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetViews? SheetViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Dialog Sheet Format Properties.</para>
        /// <para>Represents the following element tag in the schema: x:sheetFormatPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties? SheetFormatProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetFormatProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sheet Protection.</para>
        /// <para>Represents the following element tag in the schema: x:sheetProtection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetProtection? SheetProtection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetProtection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Custom Sheet Views.</para>
        /// <para>Represents the following element tag in the schema: x:customSheetViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews? CustomSheetViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CustomSheetViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Print Options.</para>
        /// <para>Represents the following element tag in the schema: x:printOptions.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PrintOptions? PrintOptions
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PrintOptions>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Page Margins.</para>
        /// <para>Represents the following element tag in the schema: x:pageMargins.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageMargins? PageMargins
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Page Setup Settings.</para>
        /// <para>Represents the following element tag in the schema: x:pageSetup.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageSetup? PageSetup
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageSetup>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Header and Footer Settings.</para>
        /// <para>Represents the following element tag in the schema: x:headerFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.HeaderFooter? HeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Drawing.</para>
        /// <para>Represents the following element tag in the schema: x:drawing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Drawing? Drawing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Drawing>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Legacy Drawing.</para>
        /// <para>Represents the following element tag in the schema: x:legacyDrawing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing? LegacyDrawing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawing>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Legacy Drawing Header Footer.</para>
        /// <para>Represents the following element tag in the schema: x:legacyDrawingHF.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter? LegacyDrawingHeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.LegacyDrawingHeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DrawingHeaderFooter.</para>
        /// <para>Represents the following element tag in the schema: x:drawingHF.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter? DrawingHeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DrawingHeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>OleObjects.</para>
        /// <para>Represents the following element tag in the schema: x:oleObjects.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OleObjects? OleObjects
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OleObjects>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Controls.</para>
        /// <para>Represents the following element tag in the schema: x:controls.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Controls? Controls
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Controls>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DialogSheet>(deep);

        internal DialogSheet(DialogsheetPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the DialogsheetPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(DialogsheetPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the DialogsheetPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(DialogsheetPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the DialogsheetPart associated with this element.
        /// </summary>
        public DialogsheetPart? DialogsheetPart
        {
            get => OpenXmlPart as DialogsheetPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:metadata.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FutureMetadata" /> <c>&lt;x:futureMetadata></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MdxMetadata" /> <c>&lt;x:mdxMetadata></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellMetadata" /> <c>&lt;x:cellMetadata></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ValueMetadata" /> <c>&lt;x:valueMetadata></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataStrings" /> <c>&lt;x:metadataStrings></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataTypes" /> <c>&lt;x:metadataTypes></c></description></item>
    /// </list>
    /// </remark>
    public partial class Metadata : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Metadata class.
        /// </summary>
        public Metadata() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Metadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Metadata(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Metadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Metadata(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Metadata class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Metadata(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:metadata");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FutureMetadata>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MdxMetadata>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellMetadata>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ValueMetadata>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MetadataStrings>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MetadataTypes>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataTypes), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataStrings), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MdxMetadata), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FutureMetadata), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellMetadata), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ValueMetadata), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Metadata Types Collection.</para>
        /// <para>Represents the following element tag in the schema: x:metadataTypes.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MetadataTypes? MetadataTypes
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MetadataTypes>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Metadata String Store.</para>
        /// <para>Represents the following element tag in the schema: x:metadataStrings.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MetadataStrings? MetadataStrings
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MetadataStrings>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>MDX Metadata Information.</para>
        /// <para>Represents the following element tag in the schema: x:mdxMetadata.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MdxMetadata? MdxMetadata
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MdxMetadata>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Metadata>(deep);

        internal Metadata(CellMetadataPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the CellMetadataPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(CellMetadataPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the CellMetadataPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(CellMetadataPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the CellMetadataPart associated with this element.
        /// </summary>
        public CellMetadataPart? CellMetadataPart
        {
            get => OpenXmlPart as CellMetadataPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Single Cells.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:singleXmlCells.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SingleXmlCell" /> <c>&lt;x:singleXmlCell></c></description></item>
    /// </list>
    /// </remark>
    public partial class SingleXmlCells : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the SingleXmlCells class.
        /// </summary>
        public SingleXmlCells() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCells class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SingleXmlCells(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCells class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SingleXmlCells(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCells class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SingleXmlCells(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:singleXmlCells");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SingleXmlCell>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SingleXmlCell), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SingleXmlCells>(deep);

        internal SingleXmlCells(SingleCellTablePart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the SingleCellTablePart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(SingleCellTablePart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the SingleCellTablePart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(SingleCellTablePart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the SingleCellTablePart associated with this element.
        /// </summary>
        public SingleCellTablePart? SingleCellTablePart
        {
            get => OpenXmlPart as SingleCellTablePart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Style Sheet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:styleSheet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Borders" /> <c>&lt;x:borders></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellStyles" /> <c>&lt;x:cellStyles></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellStyleFormats" /> <c>&lt;x:cellStyleXfs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormats" /> <c>&lt;x:cellXfs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Colors" /> <c>&lt;x:colors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DifferentialFormats" /> <c>&lt;x:dxfs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fills" /> <c>&lt;x:fills></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fonts" /> <c>&lt;x:fonts></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormats" /> <c>&lt;x:numFmts></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StylesheetExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableStyles" /> <c>&lt;x:tableStyles></c></description></item>
    /// </list>
    /// </remark>
    public partial class Stylesheet : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Stylesheet class.
        /// </summary>
        public Stylesheet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Stylesheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Stylesheet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Stylesheet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Stylesheet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Stylesheet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Stylesheet(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:styleSheet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Borders>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellStyles>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellStyleFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Colors>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DifferentialFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Fills>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Fonts>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberingFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StylesheetExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableStyles>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberingFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fonts), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fills), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Borders), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellStyleFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellStyles), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DifferentialFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableStyles), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Colors), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StylesheetExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>NumberingFormats.</para>
        /// <para>Represents the following element tag in the schema: x:numFmts.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.NumberingFormats? NumberingFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.NumberingFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Fonts.</para>
        /// <para>Represents the following element tag in the schema: x:fonts.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Fonts? Fonts
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Fonts>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Fills.</para>
        /// <para>Represents the following element tag in the schema: x:fills.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Fills? Fills
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Fills>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Borders.</para>
        /// <para>Represents the following element tag in the schema: x:borders.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Borders? Borders
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Borders>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CellStyleFormats.</para>
        /// <para>Represents the following element tag in the schema: x:cellStyleXfs.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellStyleFormats? CellStyleFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellStyleFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CellFormats.</para>
        /// <para>Represents the following element tag in the schema: x:cellXfs.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellFormats? CellFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CellStyles.</para>
        /// <para>Represents the following element tag in the schema: x:cellStyles.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellStyles? CellStyles
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellStyles>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DifferentialFormats.</para>
        /// <para>Represents the following element tag in the schema: x:dxfs.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DifferentialFormats? DifferentialFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DifferentialFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>TableStyles.</para>
        /// <para>Represents the following element tag in the schema: x:tableStyles.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TableStyles? TableStyles
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TableStyles>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Colors.</para>
        /// <para>Represents the following element tag in the schema: x:colors.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Colors? Colors
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Colors>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>StylesheetExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.StylesheetExtensionList? StylesheetExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.StylesheetExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Stylesheet>(deep);

        internal Stylesheet(WorkbookStylesPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorkbookStylesPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorkbookStylesPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorkbookStylesPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorkbookStylesPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorkbookStylesPart associated with this element.
        /// </summary>
        public WorkbookStylesPart? WorkbookStylesPart
        {
            get => OpenXmlPart as WorkbookStylesPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>External Reference.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:externalLink.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DdeLink" /> <c>&lt;x:ddeLink></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalBook" /> <c>&lt;x:externalBook></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleLink" /> <c>&lt;x:oleLink></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalLink : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalLink class.
        /// </summary>
        public ExternalLink() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalLink(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalLink(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalLink class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalLink(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:externalLink");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DdeLink>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalBook>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleLink>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                {
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalBook), 1, 1),
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DdeLink), 1, 1),
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleLink), 1, 1)
                },
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalLink>(deep);

        internal ExternalLink(ExternalWorkbookPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the ExternalWorkbookPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(ExternalWorkbookPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the ExternalWorkbookPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(ExternalWorkbookPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the ExternalWorkbookPart associated with this element.
        /// </summary>
        public ExternalWorkbookPart? ExternalWorkbookPart
        {
            get => OpenXmlPart as ExternalWorkbookPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Table.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:table.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.AutoFilter" /> <c>&lt;x:autoFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortState" /> <c>&lt;x:sortState></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableColumns" /> <c>&lt;x:tableColumns></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableStyleInfo" /> <c>&lt;x:tableStyleInfo></c></description></item>
    /// </list>
    /// </remark>
    public partial class Table : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Table class.
        /// </summary>
        public Table() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Table class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Table(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Table class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Table(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Table class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Table(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Name</para>
        /// <para>Represents the following attribute in the schema: displayName</para>
        /// </summary>
        public StringValue? DisplayName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Comment</para>
        /// <para>Represents the following attribute in the schema: comment</para>
        /// </summary>
        public StringValue? Comment
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Type</para>
        /// <para>Represents the following attribute in the schema: tableType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableValues>? TableType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Count</para>
        /// <para>Represents the following attribute in the schema: headerRowCount</para>
        /// </summary>
        public UInt32Value? HeaderRowCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Row Showing</para>
        /// <para>Represents the following attribute in the schema: insertRow</para>
        /// </summary>
        public BooleanValue? InsertRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Row Shift</para>
        /// <para>Represents the following attribute in the schema: insertRowShift</para>
        /// </summary>
        public BooleanValue? InsertRowShift
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Count</para>
        /// <para>Represents the following attribute in the schema: totalsRowCount</para>
        /// </summary>
        public UInt32Value? TotalsRowCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Shown</para>
        /// <para>Represents the following attribute in the schema: totalsRowShown</para>
        /// </summary>
        public BooleanValue? TotalsRowShown
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Published</para>
        /// <para>Represents the following attribute in the schema: published</para>
        /// </summary>
        public BooleanValue? Published
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Format Id</para>
        /// <para>Represents the following attribute in the schema: headerRowDxfId</para>
        /// </summary>
        public UInt32Value? HeaderRowFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Area Format Id</para>
        /// <para>Represents the following attribute in the schema: dataDxfId</para>
        /// </summary>
        public UInt32Value? DataFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Format Id</para>
        /// <para>Represents the following attribute in the schema: totalsRowDxfId</para>
        /// </summary>
        public UInt32Value? TotalsRowFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Border Format Id</para>
        /// <para>Represents the following attribute in the schema: headerRowBorderDxfId</para>
        /// </summary>
        public UInt32Value? HeaderRowBorderFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Border Format Id</para>
        /// <para>Represents the following attribute in the schema: tableBorderDxfId</para>
        /// </summary>
        public UInt32Value? BorderFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Border Format Id</para>
        /// <para>Represents the following attribute in the schema: totalsRowBorderDxfId</para>
        /// </summary>
        public UInt32Value? TotalsRowBorderFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Style</para>
        /// <para>Represents the following attribute in the schema: headerRowCellStyle</para>
        /// </summary>
        public StringValue? HeaderRowCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Style Name</para>
        /// <para>Represents the following attribute in the schema: dataCellStyle</para>
        /// </summary>
        public StringValue? DataCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Style</para>
        /// <para>Represents the following attribute in the schema: totalsRowCellStyle</para>
        /// </summary>
        public StringValue? TotalsRowCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Connection ID</para>
        /// <para>Represents the following attribute in the schema: connectionId</para>
        /// </summary>
        public UInt32Value? ConnectionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:table");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableColumns>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableStyleInfo>();
            builder.AddElement<Table>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name)
                .AddAttribute("displayName", a => a.DisplayName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("comment", a => a.Comment)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("tableType", a => a.TableType)
                .AddAttribute("headerRowCount", a => a.HeaderRowCount)
                .AddAttribute("insertRow", a => a.InsertRow)
                .AddAttribute("insertRowShift", a => a.InsertRowShift)
                .AddAttribute("totalsRowCount", a => a.TotalsRowCount)
                .AddAttribute("totalsRowShown", a => a.TotalsRowShown)
                .AddAttribute("published", a => a.Published)
                .AddAttribute("headerRowDxfId", a => a.HeaderRowFormatId)
                .AddAttribute("dataDxfId", a => a.DataFormatId)
                .AddAttribute("totalsRowDxfId", a => a.TotalsRowFormatId)
                .AddAttribute("headerRowBorderDxfId", a => a.HeaderRowBorderFormatId)
                .AddAttribute("tableBorderDxfId", a => a.BorderFormatId)
                .AddAttribute("totalsRowBorderDxfId", a => a.TotalsRowBorderFormatId)
                .AddAttribute("headerRowCellStyle", a => a.HeaderRowCellStyle)
                .AddAttribute("dataCellStyle", a => a.DataCellStyle)
                .AddAttribute("totalsRowCellStyle", a => a.TotalsRowCellStyle)
                .AddAttribute("connectionId", a => a.ConnectionId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.AutoFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortState), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableColumns), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableStyleInfo), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dataDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:headerRowBorderDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:headerRowDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:tableBorderDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:totalsRowBorderDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:totalsRowDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:connectionId"), "/WorkbookPart/ConnectionsPart", builder.CreateQName("x:connection"), "x:connection", builder.CreateQName("x:id")));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:id"), false, new string[] { "0", "" }));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, 4294967294, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:comment"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:dataCellStyle"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:headerRowCellStyle"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:totalsRowCellStyle"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:connectionId"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Table AutoFilter.</para>
        /// <para>Represents the following element tag in the schema: x:autoFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.AutoFilter? AutoFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sort State.</para>
        /// <para>Represents the following element tag in the schema: x:sortState.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SortState? SortState
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Table Columns.</para>
        /// <para>Represents the following element tag in the schema: x:tableColumns.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TableColumns? TableColumns
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TableColumns>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Table Style.</para>
        /// <para>Represents the following element tag in the schema: x:tableStyleInfo.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TableStyleInfo? TableStyleInfo
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TableStyleInfo>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TableExtensionList? TableExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TableExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Table>(deep);

        internal Table(TableDefinitionPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the TableDefinitionPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(TableDefinitionPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the TableDefinitionPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(TableDefinitionPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the TableDefinitionPart associated with this element.
        /// </summary>
        public TableDefinitionPart? TableDefinitionPart
        {
            get => OpenXmlPart as TableDefinitionPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Volatile Dependency Types.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:volTypes.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.VolatileType" /> <c>&lt;x:volType></c></description></item>
    /// </list>
    /// </remark>
    public partial class VolatileTypes : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the VolatileTypes class.
        /// </summary>
        public VolatileTypes() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VolatileTypes(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VolatileTypes(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileTypes class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VolatileTypes(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:volTypes");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.VolatileType>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.VolatileType), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VolatileTypes>(deep);

        internal VolatileTypes(VolatileDependenciesPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the VolatileDependenciesPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(VolatileDependenciesPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the VolatileDependenciesPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(VolatileDependenciesPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the VolatileDependenciesPart associated with this element.
        /// </summary>
        public VolatileDependenciesPart? VolatileDependenciesPart
        {
            get => OpenXmlPart as VolatileDependenciesPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Workbook.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:workbook.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BookViews" /> <c>&lt;x:bookViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculationProperties" /> <c>&lt;x:calcPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookViews" /> <c>&lt;x:customWorkbookViews></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DefinedNames" /> <c>&lt;x:definedNames></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalReferences" /> <c>&lt;x:externalReferences></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FileRecoveryProperties" /> <c>&lt;x:fileRecoveryPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FileSharing" /> <c>&lt;x:fileSharing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FileVersion" /> <c>&lt;x:fileVersion></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FunctionGroups" /> <c>&lt;x:functionGroups></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleSize" /> <c>&lt;x:oleSize></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotCaches" /> <c>&lt;x:pivotCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Sheets" /> <c>&lt;x:sheets></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishing" /> <c>&lt;x:webPublishing></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishObjects" /> <c>&lt;x:webPublishObjects></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorkbookExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorkbookProperties" /> <c>&lt;x:workbookPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorkbookProtection" /> <c>&lt;x:workbookProtection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath" /> <c>&lt;x15ac:absPath></c></description></item>
    /// </list>
    /// </remark>
    public partial class Workbook : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Workbook class.
        /// </summary>
        public Workbook() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Workbook class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Workbook(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Workbook class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Workbook(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Workbook class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Workbook(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>conformance</para>
        /// <para>Represents the following attribute in the schema: conformance</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConformanceClass>? Conformance
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConformanceClass>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:workbook");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BookViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculationProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookViews>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DefinedNames>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalReferences>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FileRecoveryProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FileSharing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FileVersion>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FunctionGroups>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleSize>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Sheets>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishing>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishObjects>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorkbookExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorkbookProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorkbookProtection>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath>();
            builder.AddElement<Workbook>()
                .AddAttribute("conformance", a => a.Conformance);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FileVersion), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FileSharing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorkbookProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath), 0, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorkbookProtection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BookViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Sheets), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FunctionGroups), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalReferences), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DefinedNames), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculationProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleSize), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookViews), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotCaches), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishing), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FileRecoveryProperties), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishObjects), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorkbookExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>FileVersion.</para>
        /// <para>Represents the following element tag in the schema: x:fileVersion.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FileVersion? FileVersion
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FileVersion>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>FileSharing.</para>
        /// <para>Represents the following element tag in the schema: x:fileSharing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FileSharing? FileSharing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FileSharing>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>WorkbookProperties.</para>
        /// <para>Represents the following element tag in the schema: x:workbookPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WorkbookProperties? WorkbookProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WorkbookProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>AbsolutePath, this property is only available in Office 2013 and later..</para>
        /// <para>Represents the following element tag in the schema: x15ac:absPath.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x15ac = http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac
        /// </remark>
        public DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath? AbsolutePath
        {
            get => GetElement<DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>WorkbookProtection.</para>
        /// <para>Represents the following element tag in the schema: x:workbookProtection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WorkbookProtection? WorkbookProtection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WorkbookProtection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>BookViews.</para>
        /// <para>Represents the following element tag in the schema: x:bookViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.BookViews? BookViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.BookViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sheets.</para>
        /// <para>Represents the following element tag in the schema: x:sheets.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Sheets? Sheets
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Sheets>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>FunctionGroups.</para>
        /// <para>Represents the following element tag in the schema: x:functionGroups.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FunctionGroups? FunctionGroups
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FunctionGroups>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExternalReferences.</para>
        /// <para>Represents the following element tag in the schema: x:externalReferences.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExternalReferences? ExternalReferences
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExternalReferences>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DefinedNames.</para>
        /// <para>Represents the following element tag in the schema: x:definedNames.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DefinedNames? DefinedNames
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DefinedNames>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CalculationProperties.</para>
        /// <para>Represents the following element tag in the schema: x:calcPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CalculationProperties? CalculationProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CalculationProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>OleSize.</para>
        /// <para>Represents the following element tag in the schema: x:oleSize.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OleSize? OleSize
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OleSize>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CustomWorkbookViews.</para>
        /// <para>Represents the following element tag in the schema: x:customWorkbookViews.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookViews? CustomWorkbookViews
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookViews>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotCaches.</para>
        /// <para>Represents the following element tag in the schema: x:pivotCaches.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotCaches? PivotCaches
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotCaches>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>WebPublishing.</para>
        /// <para>Represents the following element tag in the schema: x:webPublishing.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WebPublishing? WebPublishing
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WebPublishing>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Workbook>(deep);

        internal Workbook(WorkbookPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the WorkbookPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(WorkbookPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the WorkbookPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(WorkbookPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the WorkbookPart associated with this element.
        /// </summary>
        public WorkbookPart? WorkbookPart
        {
            get => OpenXmlPart as WorkbookPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>AutoFilter Column.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:filterColumn.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColorFilter" /> <c>&lt;x:colorFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomFilters" /> <c>&lt;x:customFilters></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DynamicFilter" /> <c>&lt;x:dynamicFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Filters" /> <c>&lt;x:filters></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.IconFilter" /> <c>&lt;x:iconFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Top10" /> <c>&lt;x:top10></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.CustomFilters" /> <c>&lt;x14:customFilters></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.IconFilter" /> <c>&lt;x14:iconFilter></c></description></item>
    /// </list>
    /// </remark>
    public partial class FilterColumn : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FilterColumn class.
        /// </summary>
        public FilterColumn() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FilterColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FilterColumn(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FilterColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FilterColumn(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FilterColumn class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FilterColumn(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Filter Column Data</para>
        /// <para>Represents the following attribute in the schema: colId</para>
        /// </summary>
        public UInt32Value? ColumnId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden AutoFilter Button</para>
        /// <para>Represents the following attribute in the schema: hiddenButton</para>
        /// </summary>
        public BooleanValue? HiddenButton
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Filter Button</para>
        /// <para>Represents the following attribute in the schema: showButton</para>
        /// </summary>
        public BooleanValue? ShowButton
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:filterColumn");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColorFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomFilters>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DynamicFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Filters>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.IconFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Top10>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.CustomFilters>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.IconFilter>();
            builder.AddElement<FilterColumn>()
                .AddAttribute("colId", a => a.ColumnId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("hiddenButton", a => a.HiddenButton)
                .AddAttribute("showButton", a => a.ShowButton);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Filters), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Top10), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.CustomFilters), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomFilters), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DynamicFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColorFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.IconFilter), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.IconFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Filter Criteria.</para>
        /// <para>Represents the following element tag in the schema: x:filters.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Filters? Filters
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Filters>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Top 10.</para>
        /// <para>Represents the following element tag in the schema: x:top10.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Top10? Top10
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Top10>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CustomFilters14, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x14:customFilters.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x14 = http://schemas.microsoft.com/office/spreadsheetml/2009/9/main
        /// </remark>
        public DocumentFormat.OpenXml.Office2010.Excel.CustomFilters? CustomFilters14
        {
            get => GetElement<DocumentFormat.OpenXml.Office2010.Excel.CustomFilters>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Custom Filters.</para>
        /// <para>Represents the following element tag in the schema: x:customFilters.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CustomFilters? CustomFilters
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CustomFilters>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Dynamic Filter.</para>
        /// <para>Represents the following element tag in the schema: x:dynamicFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DynamicFilter? DynamicFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DynamicFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Color Filter Criteria.</para>
        /// <para>Represents the following element tag in the schema: x:colorFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ColorFilter? ColorFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ColorFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>IconFilter14, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x14:iconFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x14 = http://schemas.microsoft.com/office/spreadsheetml/2009/9/main
        /// </remark>
        public DocumentFormat.OpenXml.Office2010.Excel.IconFilter? IconFilter14
        {
            get => GetElement<DocumentFormat.OpenXml.Office2010.Excel.IconFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Icon Filter.</para>
        /// <para>Represents the following element tag in the schema: x:iconFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.IconFilter? IconFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.IconFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FilterColumn>(deep);
    }

    /// <summary>
    /// <para>Sort State for Auto Filter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sortState.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortCondition" /> <c>&lt;x:sortCondition></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SortCondition" /> <c>&lt;x14:sortCondition></c></description></item>
    /// </list>
    /// </remark>
    public partial class SortState : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SortState class.
        /// </summary>
        public SortState() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortState class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SortState(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortState class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SortState(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortState class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SortState(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Sort by Columns</para>
        /// <para>Represents the following attribute in the schema: columnSort</para>
        /// </summary>
        public BooleanValue? ColumnSort
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Case Sensitive</para>
        /// <para>Represents the following attribute in the schema: caseSensitive</para>
        /// </summary>
        public BooleanValue? CaseSensitive
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sort Method</para>
        /// <para>Represents the following attribute in the schema: sortMethod</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortMethodValues>? SortMethod
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortMethodValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sort Range</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sortState");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortCondition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SortCondition>();
            builder.AddElement<SortState>()
                .AddAttribute("columnSort", a => a.ColumnSort)
                .AddAttribute("caseSensitive", a => a.CaseSensitive)
                .AddAttribute("sortMethod", a => a.SortMethod)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                {
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SortCondition), 0, 64, version: FileFormatVersions.Office2010),
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortCondition), 0, 64)
                },
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SortState>(deep);
    }

    /// <summary>
    /// <para>Defines the ExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Extension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExtensionList class.
        /// </summary>
        public ExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Extension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Extension), 0, 0)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExtensionList>(deep);
    }

    /// <summary>
    /// <para>Custom Filter Criteria.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customFilter.</para>
    /// </summary>
    public partial class CustomFilter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomFilter class.
        /// </summary>
        public CustomFilter() : base()
        {
        }

        /// <summary>
        /// <para>Filter Comparison Operator</para>
        /// <para>Represents the following attribute in the schema: operator</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FilterOperatorValues>? Operator
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FilterOperatorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top or Bottom Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customFilter");
            builder.AddElement<CustomFilter>()
                .AddAttribute("operator", a => a.Operator)
                .AddAttribute("val", a => a.Val);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomFilter>(deep);
    }

    /// <summary>
    /// <para>Cell.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:c.</para>
    /// </summary>
    public partial class CalculationCell : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculationCell class.
        /// </summary>
        public CalculationCell() : base()
        {
        }

        /// <summary>
        /// <para>Cell Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public Int32Value? SheetId
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Child Chain</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public BooleanValue? InChildChain
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Dependency Level</para>
        /// <para>Represents the following attribute in the schema: l</para>
        /// </summary>
        public BooleanValue? NewLevel
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Thread</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public BooleanValue? NewThread
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Array</para>
        /// <para>Represents the following attribute in the schema: a</para>
        /// </summary>
        public BooleanValue? Array
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:c");
            builder.AddElement<CalculationCell>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("i", a => a.SheetId)
                .AddAttribute("s", a => a.InChildChain)
                .AddAttribute("l", a => a.NewLevel)
                .AddAttribute("t", a => a.NewThread)
                .AddAttribute("a", a => a.Array);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:cm"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:cm"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:cellMetadata"), builder.CreateQName("x:bk"), "x:bk", 1));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:vm"), true, double.NegativeInfinity, true, 2147483648, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:vm"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:valueMetadata"), builder.CreateQName("x:bk"), "x:bk", 1));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:s"), true, 0, true, 65490, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:s"), "/WorkbookPart/WorkbookStylesPart", builder.CreateQName("x:cellXfs"), builder.CreateQName("x:xf"), "x:xf", 0));
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:l"), builder.CreateQName("x:s")));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:i"), "/WorkbookPart", builder.CreateQName("x:sheet"), "x:sheet", builder.CreateQName("x:sheetId")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:i"), true, 1, true, 65534, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculationCell>(deep);
    }

    /// <summary>
    /// <para>Authors.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:authors.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Author" /> <c>&lt;x:author></c></description></item>
    /// </list>
    /// </remark>
    public partial class Authors : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Authors class.
        /// </summary>
        public Authors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Authors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Authors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Authors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Authors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Authors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Authors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:authors");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Author>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Author), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Authors>(deep);
    }

    /// <summary>
    /// <para>List of Comments.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:commentList.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Comment" /> <c>&lt;x:comment></c></description></item>
    /// </list>
    /// </remark>
    public partial class CommentList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CommentList class.
        /// </summary>
        public CommentList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CommentList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:commentList");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Comment>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Comment), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CommentList>(deep);
    }

    /// <summary>
    /// <para>Comment.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:comment.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CommentProperties" /> <c>&lt;x:commentPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CommentText" /> <c>&lt;x:text></c></description></item>
    /// </list>
    /// </remark>
    public partial class Comment : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Comment class.
        /// </summary>
        public Comment() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comment class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Comment(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comment class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Comment(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Comment class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Comment(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Cell Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Author Id</para>
        /// <para>Represents the following attribute in the schema: authorId</para>
        /// </summary>
        public UInt32Value? AuthorId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique Identifier for Comment</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>shapeId, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: shapeId</para>
        /// </summary>
        public UInt32Value? ShapeId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:comment");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CommentProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CommentText>();
            builder.AddElement<Comment>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("authorId", a => a.AuthorId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("shapeId", a => a.ShapeId, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CommentText), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CommentProperties), 0, 1, version: FileFormatVersions.Office2010)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:authorId"), ".", null, builder.CreateQName("x:author"), "x:author", 0));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:guid"), false, null));
        }

        /// <summary>
        /// <para>Comment Text.</para>
        /// <para>Represents the following element tag in the schema: x:text.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CommentText? CommentText
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CommentText>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CommentProperties, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x:commentPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CommentProperties? CommentProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CommentProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Comment>(deep);
    }

    /// <summary>
    /// <para>Author.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:author.</para>
    /// </summary>
    public partial class Author : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Author class.
        /// </summary>
        public Author() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Author class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Author(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:author");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Author>(deep);
    }

    /// <summary>
    /// <para>Text.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:t.</para>
    /// </summary>
    public partial class Text : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Text class.
        /// </summary>
        public Text() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Text class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Text(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:t");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:si"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:si"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:c"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fi"), true, double.NegativeInfinity, true, 58, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Text>(deep);
    }

    /// <summary>
    /// <para>Cell Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:v.</para>
    /// </summary>
    public partial class CellValue : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the CellValue class.
        /// </summary>
        public CellValue() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellValue class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public CellValue(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:v");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellValue>(deep);
    }

    /// <summary>
    /// <para>Formula.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:formula.</para>
    /// </summary>
    public partial class Formula : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Formula class.
        /// </summary>
        public Formula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Formula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:formula");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Formula>(deep);
    }

    /// <summary>
    /// <para>Old Formula.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oldFormula.</para>
    /// </summary>
    public partial class OldFormula : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the OldFormula class.
        /// </summary>
        public OldFormula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldFormula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public OldFormula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oldFormula");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OldFormula>(deep);
    }

    /// <summary>
    /// <para>Odd Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oddHeader.</para>
    /// </summary>
    public partial class OddHeader : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the OddHeader class.
        /// </summary>
        public OddHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OddHeader class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public OddHeader(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oddHeader");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OddHeader>(deep);
    }

    /// <summary>
    /// <para>Odd Page Footer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oddFooter.</para>
    /// </summary>
    public partial class OddFooter : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the OddFooter class.
        /// </summary>
        public OddFooter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OddFooter class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public OddFooter(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oddFooter");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OddFooter>(deep);
    }

    /// <summary>
    /// <para>Even Page Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:evenHeader.</para>
    /// </summary>
    public partial class EvenHeader : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the EvenHeader class.
        /// </summary>
        public EvenHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EvenHeader class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public EvenHeader(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:evenHeader");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EvenHeader>(deep);
    }

    /// <summary>
    /// <para>Even Page Footer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:evenFooter.</para>
    /// </summary>
    public partial class EvenFooter : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the EvenFooter class.
        /// </summary>
        public EvenFooter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EvenFooter class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public EvenFooter(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:evenFooter");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EvenFooter>(deep);
    }

    /// <summary>
    /// <para>First Page Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:firstHeader.</para>
    /// </summary>
    public partial class FirstHeader : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the FirstHeader class.
        /// </summary>
        public FirstHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FirstHeader class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public FirstHeader(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:firstHeader");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FirstHeader>(deep);
    }

    /// <summary>
    /// <para>First Page Footer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:firstFooter.</para>
    /// </summary>
    public partial class FirstFooter : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the FirstFooter class.
        /// </summary>
        public FirstFooter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FirstFooter class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public FirstFooter(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:firstFooter");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FirstFooter>(deep);
    }

    /// <summary>
    /// <para>DDE Link Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:val.</para>
    /// </summary>
    public partial class DdeLinkValue : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the DdeLinkValue class.
        /// </summary>
        public DdeLinkValue() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeLinkValue class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public DdeLinkValue(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:val");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DdeLinkValue>(deep);
    }

    /// <summary>
    /// <para>Strings in Subtopic.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:stp.</para>
    /// </summary>
    public partial class Subtopic : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Subtopic class.
        /// </summary>
        public Subtopic() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Subtopic class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Subtopic(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:stp");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Subtopic>(deep);
    }

    /// <summary>
    /// <para>Defines the Formula1 Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:formula1.</para>
    /// </summary>
    public partial class Formula1 : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Formula1 class.
        /// </summary>
        public Formula1() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formula1 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Formula1(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:formula1");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Formula1>(deep);
    }

    /// <summary>
    /// <para>Defines the Formula2 Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:formula2.</para>
    /// </summary>
    public partial class Formula2 : XstringType
    {
        /// <summary>
        /// Initializes a new instance of the Formula2 class.
        /// </summary>
        public Formula2() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formula2 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Formula2(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:formula2");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Formula2>(deep);
    }

    /// <summary>
    /// <para>Defines the XstringType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class XstringType : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the XstringType class.
        /// </summary>
        protected XstringType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the XstringType class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        protected XstringType(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>Content Contains Significant Whitespace</para>
        /// <para>Represents the following attribute in the schema: xml:space</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>? Space
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<XstringType>()
                .AddAttribute("xml:space", a => a.Space);
        }
    }

    /// <summary>
    /// <para>XML Schema.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:Schema.</para>
    /// </summary>
    public partial class Schema : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Schema class.
        /// </summary>
        public Schema() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Schema class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Schema(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Schema class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Schema(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Schema class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Schema(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Schema ID</para>
        /// <para>Represents the following attribute in the schema: ID</para>
        /// </summary>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Schema Reference</para>
        /// <para>Represents the following attribute in the schema: SchemaRef</para>
        /// </summary>
        public StringValue? SchemaReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Schema Root Namespace</para>
        /// <para>Represents the following attribute in the schema: Namespace</para>
        /// </summary>
        public StringValue? Namespace
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:Schema");
            builder.AddElement<Schema>()
                .AddAttribute("ID", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("SchemaRef", a => a.SchemaReference)
                .AddAttribute("Namespace", a => a.Namespace);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new AnyParticle(0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:ID"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:ID"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:SchemaRef"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:Namespace"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Schema>(deep);
    }

    /// <summary>
    /// <para>XML Mapping Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:Map.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataBinding" /> <c>&lt;x:DataBinding></c></description></item>
    /// </list>
    /// </remark>
    public partial class Map : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Map class.
        /// </summary>
        public Map() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Map class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Map(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Map class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Map(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Map class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Map(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>XML Mapping ID</para>
        /// <para>Represents the following attribute in the schema: ID</para>
        /// </summary>
        public UInt32Value? ID
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>XML Mapping Name</para>
        /// <para>Represents the following attribute in the schema: Name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Root Element Name</para>
        /// <para>Represents the following attribute in the schema: RootElement</para>
        /// </summary>
        public StringValue? RootElement
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Schema Name</para>
        /// <para>Represents the following attribute in the schema: SchemaID</para>
        /// </summary>
        public StringValue? SchemaId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Validation Errors</para>
        /// <para>Represents the following attribute in the schema: ShowImportExportValidationErrors</para>
        /// </summary>
        public BooleanValue? ShowImportExportErrors
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>AutoFit Table on Refresh</para>
        /// <para>Represents the following attribute in the schema: AutoFit</para>
        /// </summary>
        public BooleanValue? AutoFit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Append Data to Table</para>
        /// <para>Represents the following attribute in the schema: Append</para>
        /// </summary>
        public BooleanValue? AppendData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Preserve AutoFilter State</para>
        /// <para>Represents the following attribute in the schema: PreserveSortAFLayout</para>
        /// </summary>
        public BooleanValue? PreserveAutoFilterState
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Preserve Cell Formatting</para>
        /// <para>Represents the following attribute in the schema: PreserveFormat</para>
        /// </summary>
        public BooleanValue? PreserveFormat
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:Map");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataBinding>();
            builder.AddElement<Map>()
                .AddAttribute("ID", a => a.ID, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("Name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("RootElement", a => a.RootElement, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("SchemaID", a => a.SchemaId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ShowImportExportValidationErrors", a => a.ShowImportExportErrors, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("AutoFit", a => a.AutoFit, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("Append", a => a.AppendData, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("PreserveSortAFLayout", a => a.PreserveAutoFilterState, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("PreserveFormat", a => a.PreserveFormat, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataBinding), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:SchemaID"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:Name"), 0, 65535));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:RootElement"), 0, 65535));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:ID"), true, 1, true, 2147483647, true));
        }

        /// <summary>
        /// <para>XML Mapping.</para>
        /// <para>Represents the following element tag in the schema: x:DataBinding.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DataBinding? DataBinding
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DataBinding>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Map>(deep);
    }

    /// <summary>
    /// <para>XML Mapping.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:DataBinding.</para>
    /// </summary>
    public partial class DataBinding : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataBinding class.
        /// </summary>
        public DataBinding() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBinding class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataBinding(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBinding class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataBinding(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBinding class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataBinding(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>DataBindingName</para>
        /// <para>Represents the following attribute in the schema: DataBindingName</para>
        /// </summary>
        public StringValue? DataBindingName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>FileBinding</para>
        /// <para>Represents the following attribute in the schema: FileBinding</para>
        /// </summary>
        public BooleanValue? FileBinding
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>ConnectionID</para>
        /// <para>Represents the following attribute in the schema: ConnectionID</para>
        /// </summary>
        public UInt32Value? ConnectionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>FileBindingName</para>
        /// <para>Represents the following attribute in the schema: FileBindingName</para>
        /// </summary>
        public StringValue? FileBindingName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>DataBindingLoadMode</para>
        /// <para>Represents the following attribute in the schema: DataBindingLoadMode</para>
        /// </summary>
        public UInt32Value? DataBindingLoadMode
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:DataBinding");
            builder.AddElement<DataBinding>()
                .AddAttribute("DataBindingName", a => a.DataBindingName)
                .AddAttribute("FileBinding", a => a.FileBinding)
                .AddAttribute("ConnectionID", a => a.ConnectionId)
                .AddAttribute("FileBindingName", a => a.FileBindingName)
                .AddAttribute("DataBindingLoadMode", a => a.DataBindingLoadMode, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new AnyParticle(0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:DataBindingName"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:FileBindingName"), true, null));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:DataBindingLoadMode"), true, 0, true, 4, true));
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:ConnectionID"), builder.CreateQName("x:FileBinding"), "false"));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:ConnectionID"), builder.CreateQName("x:FileBinding") , "true"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:DataBindingName"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:FileBindingName"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:ConnectionID"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:FileBindingName"), builder.CreateQName("x:FileBinding"), "false") { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataBinding>(deep);
    }

    /// <summary>
    /// <para>Connection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:connection.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConnectionExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DatabaseProperties" /> <c>&lt;x:dbPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OlapProperties" /> <c>&lt;x:olapPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Parameters" /> <c>&lt;x:parameters></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TextProperties" /> <c>&lt;x:textPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebQueryProperties" /> <c>&lt;x:webPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class Connection : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Connection class.
        /// </summary>
        public Connection() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connection(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connection(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Connection(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sourceFile</para>
        /// <para>Represents the following attribute in the schema: sourceFile</para>
        /// </summary>
        public StringValue? SourceFile
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>odcFile</para>
        /// <para>Represents the following attribute in the schema: odcFile</para>
        /// </summary>
        public StringValue? ConnectionFile
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>keepAlive</para>
        /// <para>Represents the following attribute in the schema: keepAlive</para>
        /// </summary>
        public BooleanValue? KeepAlive
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>interval</para>
        /// <para>Represents the following attribute in the schema: interval</para>
        /// </summary>
        public UInt32Value? Interval
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>description</para>
        /// <para>Represents the following attribute in the schema: description</para>
        /// </summary>
        public StringValue? Description
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public UInt32Value? Type
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>reconnectionMethod</para>
        /// <para>Represents the following attribute in the schema: reconnectionMethod</para>
        /// </summary>
        public UInt32Value? ReconnectionMethod
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshedVersion</para>
        /// <para>Represents the following attribute in the schema: refreshedVersion</para>
        /// </summary>
        public ByteValue? RefreshedVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>minRefreshableVersion</para>
        /// <para>Represents the following attribute in the schema: minRefreshableVersion</para>
        /// </summary>
        public ByteValue? MinRefreshableVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>savePassword</para>
        /// <para>Represents the following attribute in the schema: savePassword</para>
        /// </summary>
        public BooleanValue? SavePassword
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>new</para>
        /// <para>Represents the following attribute in the schema: new</para>
        /// </summary>
        public BooleanValue? New
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>deleted</para>
        /// <para>Represents the following attribute in the schema: deleted</para>
        /// </summary>
        public BooleanValue? Deleted
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>onlyUseConnectionFile</para>
        /// <para>Represents the following attribute in the schema: onlyUseConnectionFile</para>
        /// </summary>
        public BooleanValue? OnlyUseConnectionFile
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>background</para>
        /// <para>Represents the following attribute in the schema: background</para>
        /// </summary>
        public BooleanValue? Background
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>refreshOnLoad</para>
        /// <para>Represents the following attribute in the schema: refreshOnLoad</para>
        /// </summary>
        public BooleanValue? RefreshOnLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>saveData</para>
        /// <para>Represents the following attribute in the schema: saveData</para>
        /// </summary>
        public BooleanValue? SaveData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>credentials</para>
        /// <para>Represents the following attribute in the schema: credentials</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CredentialsMethodValues>? Credentials
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CredentialsMethodValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>singleSignOnId</para>
        /// <para>Represents the following attribute in the schema: singleSignOnId</para>
        /// </summary>
        public StringValue? SingleSignOnId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:connection");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConnectionExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DatabaseProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OlapProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Parameters>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TextProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebQueryProperties>();
            builder.AddElement<Connection>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceFile", a => a.SourceFile)
                .AddAttribute("odcFile", a => a.ConnectionFile)
                .AddAttribute("keepAlive", a => a.KeepAlive)
                .AddAttribute("interval", a => a.Interval)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("description", a => a.Description)
                .AddAttribute("type", a => a.Type)
                .AddAttribute("reconnectionMethod", a => a.ReconnectionMethod)
                .AddAttribute("refreshedVersion", a => a.RefreshedVersion, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minRefreshableVersion", a => a.MinRefreshableVersion)
                .AddAttribute("savePassword", a => a.SavePassword)
                .AddAttribute("new", a => a.New)
                .AddAttribute("deleted", a => a.Deleted)
                .AddAttribute("onlyUseConnectionFile", a => a.OnlyUseConnectionFile)
                .AddAttribute("background", a => a.Background)
                .AddAttribute("refreshOnLoad", a => a.RefreshOnLoad)
                .AddAttribute("saveData", a => a.SaveData)
                .AddAttribute("credentials", a => a.Credentials)
                .AddAttribute("singleSignOnId", a => a.SingleSignOnId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DatabaseProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OlapProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebQueryProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TextProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Parameters), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConnectionExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, null));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:type"), true, 1, true, 8, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, null));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:interval"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:description"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:singleSignOnId"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:odcFile"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sourceFile"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>DatabaseProperties.</para>
        /// <para>Represents the following element tag in the schema: x:dbPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DatabaseProperties? DatabaseProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DatabaseProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>OlapProperties.</para>
        /// <para>Represents the following element tag in the schema: x:olapPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OlapProperties? OlapProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OlapProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>WebQueryProperties.</para>
        /// <para>Represents the following element tag in the schema: x:webPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WebQueryProperties? WebQueryProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WebQueryProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>TextProperties.</para>
        /// <para>Represents the following element tag in the schema: x:textPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TextProperties? TextProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TextProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Parameters.</para>
        /// <para>Represents the following element tag in the schema: x:parameters.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Parameters? Parameters
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Parameters>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ConnectionExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ConnectionExtensionList? ConnectionExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ConnectionExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Connection>(deep);
    }

    /// <summary>
    /// <para>Tables.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tables.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldItem" /> <c>&lt;x:x></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MissingTable" /> <c>&lt;x:m></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CharacterValue" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class Tables : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Tables class.
        /// </summary>
        public Tables() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tables class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Tables(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tables class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Tables(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tables class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Tables(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Count of Tables</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tables");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MissingTable>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CharacterValue>();
            builder.AddElement<Tables>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MissingTable), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CharacterValue), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldItem), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Tables>(deep);
    }

    /// <summary>
    /// <para>Parameter Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:parameter.</para>
    /// </summary>
    public partial class Parameter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Parameter class.
        /// </summary>
        public Parameter() : base()
        {
        }

        /// <summary>
        /// <para>Parameter Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>SQL Data Type</para>
        /// <para>Represents the following attribute in the schema: sqlType</para>
        /// </summary>
        public Int32Value? SqlType
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parameter Type</para>
        /// <para>Represents the following attribute in the schema: parameterType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ParameterValues>? ParameterType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ParameterValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Refresh on Change</para>
        /// <para>Represents the following attribute in the schema: refreshOnChange</para>
        /// </summary>
        public BooleanValue? RefreshOnChange
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parameter Prompt String</para>
        /// <para>Represents the following attribute in the schema: prompt</para>
        /// </summary>
        public StringValue? Prompt
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Boolean</para>
        /// <para>Represents the following attribute in the schema: boolean</para>
        /// </summary>
        public BooleanValue? Boolean
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Double</para>
        /// <para>Represents the following attribute in the schema: double</para>
        /// </summary>
        public DoubleValue? Double
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Integer</para>
        /// <para>Represents the following attribute in the schema: integer</para>
        /// </summary>
        public Int32Value? Integer
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>String</para>
        /// <para>Represents the following attribute in the schema: string</para>
        /// </summary>
        public StringValue? String
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Reference</para>
        /// <para>Represents the following attribute in the schema: cell</para>
        /// </summary>
        public StringValue? Cell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:parameter");
            builder.AddElement<Parameter>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("sqlType", a => a.SqlType)
                .AddAttribute("parameterType", a => a.ParameterType)
                .AddAttribute("refreshOnChange", a => a.RefreshOnChange)
                .AddAttribute("prompt", a => a.Prompt)
                .AddAttribute("boolean", a => a.Boolean)
                .AddAttribute("double", a => a.Double)
                .AddAttribute("integer", a => a.Integer)
                .AddAttribute("string", a => a.String)
                .AddAttribute("cell", a => a.Cell);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:sqlType"), true, new string[] { "-22", "-20", "-11", "-10", "-9", "-8", "-7", "-6", "-5", "-4", "-3", "-2", "-1", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113" }));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:string"), 0, 255));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:cell"), builder.CreateQName("x:parameterType") , "cell"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:prompt"), 0, 65535));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Parameter>(deep);
    }

    /// <summary>
    /// <para>No Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:m.</para>
    /// </summary>
    public partial class MissingTable : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MissingTable class.
        /// </summary>
        public MissingTable() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:m");
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MissingTable>(deep);
    }

    /// <summary>
    /// <para>Character Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:s.</para>
    /// </summary>
    public partial class CharacterValue : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CharacterValue class.
        /// </summary>
        public CharacterValue() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:s");
            builder.AddElement<CharacterValue>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CharacterValue>(deep);
    }

    /// <summary>
    /// <para>Index.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:x.</para>
    /// </summary>
    public partial class FieldItem : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FieldItem class.
        /// </summary>
        public FieldItem() : base()
        {
        }

        /// <summary>
        /// <para>Shared Items Index</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public UInt32Value? Val
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:x");
            builder.AddElement<FieldItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FieldItem>(deep);
    }

    /// <summary>
    /// <para>Text Import Field Settings.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:textField.</para>
    /// </summary>
    public partial class TextField : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the TextField class.
        /// </summary>
        public TextField() : base()
        {
        }

        /// <summary>
        /// <para>Field Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ExternalConnectionValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ExternalConnectionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Position</para>
        /// <para>Represents the following attribute in the schema: position</para>
        /// </summary>
        public UInt32Value? Position
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:textField");
            builder.AddElement<TextField>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("position", a => a.Position);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:position"), true, 0, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextField>(deep);
    }

    /// <summary>
    /// <para>PivotCache Field.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cacheField.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldGroup" /> <c>&lt;x:fieldGroup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SharedItems" /> <c>&lt;x:sharedItems></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertiesMap" /> <c>&lt;x:mpMap></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheField : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheField class.
        /// </summary>
        public CacheField() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheField(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheField(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheField class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheField(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>caption</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>propertyName</para>
        /// <para>Represents the following attribute in the schema: propertyName</para>
        /// </summary>
        public StringValue? PropertyName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>serverField</para>
        /// <para>Represents the following attribute in the schema: serverField</para>
        /// </summary>
        public BooleanValue? ServerField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>uniqueList</para>
        /// <para>Represents the following attribute in the schema: uniqueList</para>
        /// </summary>
        public BooleanValue? UniqueList
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>numFmtId</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>formula</para>
        /// <para>Represents the following attribute in the schema: formula</para>
        /// </summary>
        public StringValue? Formula
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sqlType</para>
        /// <para>Represents the following attribute in the schema: sqlType</para>
        /// </summary>
        public Int32Value? SqlType
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hierarchy</para>
        /// <para>Represents the following attribute in the schema: hierarchy</para>
        /// </summary>
        public Int32Value? Hierarchy
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>level</para>
        /// <para>Represents the following attribute in the schema: level</para>
        /// </summary>
        public UInt32Value? Level
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>databaseField</para>
        /// <para>Represents the following attribute in the schema: databaseField</para>
        /// </summary>
        public BooleanValue? DatabaseField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mappingCount</para>
        /// <para>Represents the following attribute in the schema: mappingCount</para>
        /// </summary>
        public UInt32Value? MappingCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>memberPropertyField</para>
        /// <para>Represents the following attribute in the schema: memberPropertyField</para>
        /// </summary>
        public BooleanValue? MemberPropertyField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cacheField");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldGroup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SharedItems>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertiesMap>();
            builder.AddElement<CacheField>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption)
                .AddAttribute("propertyName", a => a.PropertyName)
                .AddAttribute("serverField", a => a.ServerField)
                .AddAttribute("uniqueList", a => a.UniqueList)
                .AddAttribute("numFmtId", a => a.NumberFormatId)
                .AddAttribute("formula", a => a.Formula)
                .AddAttribute("sqlType", a => a.SqlType)
                .AddAttribute("hierarchy", a => a.Hierarchy)
                .AddAttribute("level", a => a.Level)
                .AddAttribute("databaseField", a => a.DatabaseField)
                .AddAttribute("mappingCount", a => a.MappingCount)
                .AddAttribute("memberPropertyField", a => a.MemberPropertyField);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SharedItems), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldGroup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertiesMap), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, null));
        }

        /// <summary>
        /// <para>SharedItems.</para>
        /// <para>Represents the following element tag in the schema: x:sharedItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SharedItems? SharedItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SharedItems>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>FieldGroup.</para>
        /// <para>Represents the following element tag in the schema: x:fieldGroup.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FieldGroup? FieldGroup
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FieldGroup>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheField>(deep);
    }

    /// <summary>
    /// <para>Page Item Values.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pages.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Page" /> <c>&lt;x:page></c></description></item>
    /// </list>
    /// </remark>
    public partial class Pages : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Pages class.
        /// </summary>
        public Pages() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Pages class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Pages(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Pages class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Pages(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Pages class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Pages(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Page Item String Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pages");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Page>();
            builder.AddElement<Pages>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Page), 1, 4)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Pages>(deep);
    }

    /// <summary>
    /// <para>Range Sets.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rangeSets.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RangeSet" /> <c>&lt;x:rangeSet></c></description></item>
    /// </list>
    /// </remark>
    public partial class RangeSets : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RangeSets class.
        /// </summary>
        public RangeSets() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RangeSets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RangeSets(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RangeSets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RangeSets(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RangeSets class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RangeSets(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Reference and Page Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rangeSets");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RangeSet>();
            builder.AddElement<RangeSets>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RangeSet), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RangeSets>(deep);
    }

    /// <summary>
    /// <para>Page Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:page.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageItem" /> <c>&lt;x:pageItem></c></description></item>
    /// </list>
    /// </remark>
    public partial class Page : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Page class.
        /// </summary>
        public Page() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Page class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Page(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Page class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Page(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Page class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Page(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Page Item String Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:page");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageItem>();
            builder.AddElement<Page>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageItem), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Page>(deep);
    }

    /// <summary>
    /// <para>Page Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageItem.</para>
    /// </summary>
    public partial class PageItem : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PageItem class.
        /// </summary>
        public PageItem() : base()
        {
        }

        /// <summary>
        /// <para>Page Item Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageItem");
            builder.AddElement<PageItem>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageItem>(deep);
    }

    /// <summary>
    /// <para>Range Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rangeSet.</para>
    /// </summary>
    public partial class RangeSet : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RangeSet class.
        /// </summary>
        public RangeSet() : base()
        {
        }

        /// <summary>
        /// <para>Field Item Index Page 1</para>
        /// <para>Represents the following attribute in the schema: i1</para>
        /// </summary>
        public UInt32Value? FieldItemIndexPage1
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Item Index Page 2</para>
        /// <para>Represents the following attribute in the schema: i2</para>
        /// </summary>
        public UInt32Value? FieldItemIndexPage2
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Item index Page 3</para>
        /// <para>Represents the following attribute in the schema: i3</para>
        /// </summary>
        public UInt32Value? FieldItemIndexPage3
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Item Index Page 4</para>
        /// <para>Represents the following attribute in the schema: i4</para>
        /// </summary>
        public UInt32Value? FieldItemIndexPage4
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Named Range</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Name</para>
        /// <para>Represents the following attribute in the schema: sheet</para>
        /// </summary>
        public StringValue? Sheet
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rangeSet");
            builder.AddElement<RangeSet>()
                .AddAttribute("i1", a => a.FieldItemIndexPage1)
                .AddAttribute("i2", a => a.FieldItemIndexPage2)
                .AddAttribute("i3", a => a.FieldItemIndexPage3)
                .AddAttribute("i4", a => a.FieldItemIndexPage4)
                .AddAttribute("ref", a => a.Reference)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("sheet", a => a.Sheet)
                .AddAttribute("r:id", a => a.Id);
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:name"), builder.CreateQName("x:ref")));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sheet"), 1, 31));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RangeSet>(deep);
    }

    /// <summary>
    /// <para>No Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:m.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class MissingItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MissingItem class.
        /// </summary>
        public MissingItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MissingItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MissingItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MissingItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MissingItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MissingItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MissingItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Index</para>
        /// <para>Represents the following attribute in the schema: in</para>
        /// </summary>
        public UInt32Value? FormatIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>background Color</para>
        /// <para>Represents the following attribute in the schema: bc</para>
        /// </summary>
        public HexBinaryValue? BackgroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Foreground Color</para>
        /// <para>Represents the following attribute in the schema: fc</para>
        /// </summary>
        public HexBinaryValue? ForegroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Italic</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public BooleanValue? Italic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Underline</para>
        /// <para>Represents the following attribute in the schema: un</para>
        /// </summary>
        public BooleanValue? Underline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Strikethrough</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public BooleanValue? Strikethrough
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bold</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public BooleanValue? Bold
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:m");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<MissingItem>()
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount)
                .AddAttribute("in", a => a.FormatIndex)
                .AddAttribute("bc", a => a.BackgroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("fc", a => a.ForegroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("i", a => a.Italic)
                .AddAttribute("un", a => a.Underline)
                .AddAttribute("st", a => a.Strikethrough)
                .AddAttribute("b", a => a.Bold);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MissingItem>(deep);
    }

    /// <summary>
    /// <para>Numeric.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:n.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class NumberItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the NumberItem class.
        /// </summary>
        public NumberItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumberItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumberItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NumberItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Index</para>
        /// <para>Represents the following attribute in the schema: in</para>
        /// </summary>
        public UInt32Value? FormatIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Background Color</para>
        /// <para>Represents the following attribute in the schema: bc</para>
        /// </summary>
        public HexBinaryValue? BackgroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Foreground Color</para>
        /// <para>Represents the following attribute in the schema: fc</para>
        /// </summary>
        public HexBinaryValue? ForegroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Italic</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public BooleanValue? Italic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Underline</para>
        /// <para>Represents the following attribute in the schema: un</para>
        /// </summary>
        public BooleanValue? Underline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Strikethrough</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public BooleanValue? Strikethrough
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bold</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public BooleanValue? Bold
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:n");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<NumberItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount)
                .AddAttribute("in", a => a.FormatIndex)
                .AddAttribute("bc", a => a.BackgroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("fc", a => a.ForegroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("i", a => a.Italic)
                .AddAttribute("un", a => a.Underline)
                .AddAttribute("st", a => a.Strikethrough)
                .AddAttribute("b", a => a.Bold);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:x"), true, 0, true, double.PositiveInfinity, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:x"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:v"), false, new string[] { "INF", "-INF", "NaN" }) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumberItem>(deep);
    }

    /// <summary>
    /// <para>Boolean.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:b.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class BooleanItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the BooleanItem class.
        /// </summary>
        public BooleanItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BooleanItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BooleanItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BooleanItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BooleanItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BooleanItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public BooleanItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public BooleanValue? Val
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:b");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<BooleanItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BooleanItem>(deep);
    }

    /// <summary>
    /// <para>Error Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:e.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class ErrorItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ErrorItem class.
        /// </summary>
        public ErrorItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ErrorItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ErrorItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ErrorItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ErrorItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ErrorItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ErrorItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Index</para>
        /// <para>Represents the following attribute in the schema: in</para>
        /// </summary>
        public UInt32Value? FormatIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>background Color</para>
        /// <para>Represents the following attribute in the schema: bc</para>
        /// </summary>
        public HexBinaryValue? BackgroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Foreground Color</para>
        /// <para>Represents the following attribute in the schema: fc</para>
        /// </summary>
        public HexBinaryValue? ForegroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Italic</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public BooleanValue? Italic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Underline</para>
        /// <para>Represents the following attribute in the schema: un</para>
        /// </summary>
        public BooleanValue? Underline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Strikethrough</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public BooleanValue? Strikethrough
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bold</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public BooleanValue? Bold
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:e");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<ErrorItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount)
                .AddAttribute("in", a => a.FormatIndex)
                .AddAttribute("bc", a => a.BackgroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("fc", a => a.ForegroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("i", a => a.Italic)
                .AddAttribute("un", a => a.Underline)
                .AddAttribute("st", a => a.Strikethrough)
                .AddAttribute("b", a => a.Bold);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Tuples.</para>
        /// <para>Represents the following element tag in the schema: x:tpls.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Tuples? Tuples
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ErrorItem>(deep);
    }

    /// <summary>
    /// <para>Character Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:s.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class StringItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StringItem class.
        /// </summary>
        public StringItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StringItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Index</para>
        /// <para>Represents the following attribute in the schema: in</para>
        /// </summary>
        public UInt32Value? FormatIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Background Color</para>
        /// <para>Represents the following attribute in the schema: bc</para>
        /// </summary>
        public HexBinaryValue? BackgroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Foreground Color</para>
        /// <para>Represents the following attribute in the schema: fc</para>
        /// </summary>
        public HexBinaryValue? ForegroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Italic</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public BooleanValue? Italic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Underline</para>
        /// <para>Represents the following attribute in the schema: un</para>
        /// </summary>
        public BooleanValue? Underline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Strikethrough</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public BooleanValue? Strikethrough
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bold</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public BooleanValue? Bold
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:s");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<StringItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount)
                .AddAttribute("in", a => a.FormatIndex)
                .AddAttribute("bc", a => a.BackgroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("fc", a => a.ForegroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("i", a => a.Italic)
                .AddAttribute("un", a => a.Underline)
                .AddAttribute("st", a => a.Strikethrough)
                .AddAttribute("b", a => a.Bold);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StringItem>(deep);
    }

    /// <summary>
    /// <para>Date Time.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:d.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class DateTimeItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DateTimeItem class.
        /// </summary>
        public DateTimeItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DateTimeItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DateTimeItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DateTimeItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DateTimeItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DateTimeItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DateTimeItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public DateTimeValue? Val
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unused Item</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Unused
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item Value</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Caption</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Member Property Count</para>
        /// <para>Represents the following attribute in the schema: cp</para>
        /// </summary>
        public UInt32Value? PropertyCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:d");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<DateTimeItem>()
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("u", a => a.Unused)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("c", a => a.Caption)
                .AddAttribute("cp", a => a.PropertyCount);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DateTimeItem>(deep);
    }

    /// <summary>
    /// <para>Tuples.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tpls.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuple" /> <c>&lt;x:tpl></c></description></item>
    /// </list>
    /// </remark>
    public partial class Tuples : TuplesType
    {
        /// <summary>
        /// Initializes a new instance of the Tuples class.
        /// </summary>
        public Tuples() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tuples class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Tuples(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tuples class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Tuples(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Tuples class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Tuples(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tpls");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuple), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Tuples>(deep);
    }

    /// <summary>
    /// <para>Sort By Tuple.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sortByTuple.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuple" /> <c>&lt;x:tpl></c></description></item>
    /// </list>
    /// </remark>
    public partial class SortByTuple : TuplesType
    {
        /// <summary>
        /// Initializes a new instance of the SortByTuple class.
        /// </summary>
        public SortByTuple() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortByTuple class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SortByTuple(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortByTuple class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SortByTuple(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SortByTuple class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SortByTuple(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sortByTuple");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuple), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SortByTuple>(deep);
    }

    /// <summary>
    /// <para>Defines the TuplesType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuple" /> <c>&lt;x:tpl></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class TuplesType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TuplesType class.
        /// </summary>
        protected TuplesType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TuplesType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected TuplesType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TuplesType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected TuplesType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TuplesType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected TuplesType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Member Name Count</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public UInt32Value? MemberNameCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuple>();
            builder.AddElement<TuplesType>()
                .AddAttribute("c", a => a.MemberNameCount);
        }
    }

    /// <summary>
    /// <para>Member Property Indexes.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:x.</para>
    /// </summary>
    public partial class MemberPropertyIndex : XType
    {
        /// <summary>
        /// Initializes a new instance of the MemberPropertyIndex class.
        /// </summary>
        public MemberPropertyIndex() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:x");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MemberPropertyIndex>(deep);
    }

    /// <summary>
    /// <para>Defines the MemberPropertiesMap Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mpMap.</para>
    /// </summary>
    public partial class MemberPropertiesMap : XType
    {
        /// <summary>
        /// Initializes a new instance of the MemberPropertiesMap class.
        /// </summary>
        public MemberPropertiesMap() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mpMap");
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:v"), ".", null, builder.CreateQName("x:cacheField"), "x:cacheField", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MemberPropertiesMap>(deep);
    }

    /// <summary>
    /// <para>Defines the XType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class XType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the XType class.
        /// </summary>
        protected XType() : base()
        {
        }

        /// <summary>
        /// <para>Shared Items Index</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<XType>()
                .AddAttribute("v", a => a.Val);
        }
    }

    /// <summary>
    /// <para>PivotCache Record.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:r.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BooleanItem" /> <c>&lt;x:b></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DateTimeItem" /> <c>&lt;x:d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ErrorItem" /> <c>&lt;x:e></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldItem" /> <c>&lt;x:x></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MissingItem" /> <c>&lt;x:m></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberItem" /> <c>&lt;x:n></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StringItem" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCacheRecord : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCacheRecord class.
        /// </summary>
        public PivotCacheRecord() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecord class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheRecord(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecord class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheRecord(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheRecord class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCacheRecord(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:r");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BooleanItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DateTimeItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ErrorItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MissingItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StringItem>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MissingItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BooleanItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ErrorItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StringItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DateTimeItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldItem), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCacheRecord>(deep);
    }

    /// <summary>
    /// <para>OLAP KPI.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:kpi.</para>
    /// </summary>
    public partial class Kpi : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Kpi class.
        /// </summary>
        public Kpi() : base()
        {
        }

        /// <summary>
        /// <para>KPI Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Display Name</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Display Folder</para>
        /// <para>Represents the following attribute in the schema: displayFolder</para>
        /// </summary>
        public StringValue? DisplayFolder
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Measure Group Name</para>
        /// <para>Represents the following attribute in the schema: measureGroup</para>
        /// </summary>
        public StringValue? MeasureGroup
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parent KPI</para>
        /// <para>Represents the following attribute in the schema: parent</para>
        /// </summary>
        public StringValue? ParentKpi
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Value Unique Name</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public StringValue? Value
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Goal Unique Name</para>
        /// <para>Represents the following attribute in the schema: goal</para>
        /// </summary>
        public StringValue? Goal
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Status Unique Name</para>
        /// <para>Represents the following attribute in the schema: status</para>
        /// </summary>
        public StringValue? Status
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Trend Unique Name</para>
        /// <para>Represents the following attribute in the schema: trend</para>
        /// </summary>
        public StringValue? Trend
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Weight Unique Name</para>
        /// <para>Represents the following attribute in the schema: weight</para>
        /// </summary>
        public StringValue? Weight
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:kpi");
            builder.AddElement<Kpi>()
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("displayFolder", a => a.DisplayFolder)
                .AddAttribute("measureGroup", a => a.MeasureGroup)
                .AddAttribute("parent", a => a.ParentKpi)
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("goal", a => a.Goal)
                .AddAttribute("status", a => a.Status)
                .AddAttribute("trend", a => a.Trend)
                .AddAttribute("weight", a => a.Weight);
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:goal"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:status"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:trend"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:value"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:weight"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:caption"), 1, 32767) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:displayFolder"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:measureGroup"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:parent"), 0, 32767) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Kpi>(deep);
    }

    /// <summary>
    /// <para>PivotCache Field Id.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fieldUsage.</para>
    /// </summary>
    public partial class FieldUsage : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FieldUsage class.
        /// </summary>
        public FieldUsage() : base()
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: x</para>
        /// </summary>
        public Int32Value? Index
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fieldUsage");
            builder.AddElement<FieldUsage>()
                .AddAttribute("x", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:x"), ".", null, builder.CreateQName("x:cacheField"), "x:cacheField", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:x"), true, -1, true, double.PositiveInfinity, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FieldUsage>(deep);
    }

    /// <summary>
    /// <para>OLAP Grouping Levels.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groupLevel.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Groups" /> <c>&lt;x:groups></c></description></item>
    /// </list>
    /// </remark>
    public partial class GroupLevel : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GroupLevel class.
        /// </summary>
        public GroupLevel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupLevel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupLevel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GroupLevel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Grouping Level Display Name</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User-Defined Group Level</para>
        /// <para>Represents the following attribute in the schema: user</para>
        /// </summary>
        public BooleanValue? User
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Roll Up</para>
        /// <para>Represents the following attribute in the schema: customRollUp</para>
        /// </summary>
        public BooleanValue? CustomRollUp
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groupLevel");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Groups>();
            builder.AddElement<GroupLevel>()
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("user", a => a.User)
                .AddAttribute("customRollUp", a => a.CustomRollUp);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Groups), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
        }

        /// <summary>
        /// <para>OLAP Level Groups.</para>
        /// <para>Represents the following element tag in the schema: x:groups.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Groups? Groups
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Groups>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GroupLevel>(deep);
    }

    /// <summary>
    /// <para>OLAP Level Groups.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groups.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Group" /> <c>&lt;x:group></c></description></item>
    /// </list>
    /// </remark>
    public partial class Groups : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Groups class.
        /// </summary>
        public Groups() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Groups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Groups(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Groups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Groups(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Groups class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Groups(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Level Group Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groups");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Group>();
            builder.AddElement<Groups>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Group), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Groups>(deep);
    }

    /// <summary>
    /// <para>OLAP Group.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:group.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GroupMembers" /> <c>&lt;x:groupMembers></c></description></item>
    /// </list>
    /// </remark>
    public partial class Group : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Group class.
        /// </summary>
        public Group() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Group class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Group(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Group class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Group(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Group class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Group(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Group Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique Group Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Group Caption</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parent Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueParent</para>
        /// </summary>
        public StringValue? UniqueParent
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Group Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public Int32Value? Id
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:group");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GroupMembers>();
            builder.AddElement<Group>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uniqueParent", a => a.UniqueParent)
                .AddAttribute("id", a => a.Id);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GroupMembers), 1, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, builder.CreateQName("x:groups")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, double.PositiveInfinity, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueParent"), 0, 65535));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
        }

        /// <summary>
        /// <para>OLAP Group Members.</para>
        /// <para>Represents the following element tag in the schema: x:groupMembers.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.GroupMembers? GroupMembers
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.GroupMembers>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Group>(deep);
    }

    /// <summary>
    /// <para>OLAP Group Members.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groupMembers.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GroupMember" /> <c>&lt;x:groupMember></c></description></item>
    /// </list>
    /// </remark>
    public partial class GroupMembers : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GroupMembers class.
        /// </summary>
        public GroupMembers() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupMembers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupMembers(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupMembers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupMembers(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupMembers class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GroupMembers(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Group Member Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groupMembers");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GroupMember>();
            builder.AddElement<GroupMembers>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GroupMember), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GroupMembers>(deep);
    }

    /// <summary>
    /// <para>OLAP Group Member.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groupMember.</para>
    /// </summary>
    public partial class GroupMember : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the GroupMember class.
        /// </summary>
        public GroupMember() : base()
        {
        }

        /// <summary>
        /// <para>Group Member Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Group</para>
        /// <para>Represents the following attribute in the schema: group</para>
        /// </summary>
        public BooleanValue? Group
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groupMember");
            builder.AddElement<GroupMember>()
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("group", a => a.Group);
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueName"), 1, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GroupMember>(deep);
    }

    /// <summary>
    /// <para>Entries.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:entries.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ErrorItem" /> <c>&lt;x:e></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MissingItem" /> <c>&lt;x:m></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberItem" /> <c>&lt;x:n></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StringItem" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class Entries : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Entries class.
        /// </summary>
        public Entries() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Entries class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Entries(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Entries class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Entries(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Entries class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Entries(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Tuple Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:entries");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ErrorItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MissingItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StringItem>();
            builder.AddElement<Entries>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MissingItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ErrorItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StringItem), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Entries>(deep);
    }

    /// <summary>
    /// <para>Sets.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sets.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TupleSet" /> <c>&lt;x:set></c></description></item>
    /// </list>
    /// </remark>
    public partial class Sets : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Sets class.
        /// </summary>
        public Sets() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Sets(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Sets(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sets class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Sets(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Tuple Set Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sets");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TupleSet>();
            builder.AddElement<Sets>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TupleSet), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Sets>(deep);
    }

    /// <summary>
    /// <para>OLAP Query Cache.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryCache.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Query" /> <c>&lt;x:query></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryCache : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryCache class.
        /// </summary>
        public QueryCache() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryCache(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryCache(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryCache class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryCache(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Cached Query Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryCache");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Query>();
            builder.AddElement<QueryCache>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Query), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryCache>(deep);
    }

    /// <summary>
    /// <para>Server Formats.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:serverFormats.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ServerFormat" /> <c>&lt;x:serverFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class ServerFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ServerFormats class.
        /// </summary>
        public ServerFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ServerFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ServerFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ServerFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ServerFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ServerFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ServerFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:serverFormats");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ServerFormat>();
            builder.AddElement<ServerFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ServerFormat), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ServerFormats>(deep);
    }

    /// <summary>
    /// <para>Server Format.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:serverFormat.</para>
    /// </summary>
    public partial class ServerFormat : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ServerFormat class.
        /// </summary>
        public ServerFormat() : base()
        {
        }

        /// <summary>
        /// <para>Culture</para>
        /// <para>Represents the following attribute in the schema: culture</para>
        /// </summary>
        public StringValue? Culture
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format</para>
        /// <para>Represents the following attribute in the schema: format</para>
        /// </summary>
        public StringValue? Format
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:serverFormat");
            builder.AddElement<ServerFormat>()
                .AddAttribute("culture", a => a.Culture)
                .AddAttribute("format", a => a.Format);
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:culture"), builder.CreateQName("x:format")));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:culture"), 0, 31));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:format"), 0, 65535));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ServerFormat>(deep);
    }

    /// <summary>
    /// <para>Tuple.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tpl.</para>
    /// </summary>
    public partial class Tuple : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Tuple class.
        /// </summary>
        public Tuple() : base()
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: fld</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hierarchy Index</para>
        /// <para>Represents the following attribute in the schema: hier</para>
        /// </summary>
        public UInt32Value? Hierarchy
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Index</para>
        /// <para>Represents the following attribute in the schema: item</para>
        /// </summary>
        public UInt32Value? Item
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tpl");
            builder.AddElement<Tuple>()
                .AddAttribute("fld", a => a.Field)
                .AddAttribute("hier", a => a.Hierarchy)
                .AddAttribute("item", a => a.Item, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fld"), ".", null, builder.CreateQName("x:cacheField"), "x:cacheField", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:hier"), ".", null, builder.CreateQName("x:cacheHierarchy"), "x:cacheHierarchy", 0));
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:fld"), builder.CreateQName("x:hier")) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Tuple>(deep);
    }

    /// <summary>
    /// <para>OLAP Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:set.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortByTuple" /> <c>&lt;x:sortByTuple></c></description></item>
    /// </list>
    /// </remark>
    public partial class TupleSet : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TupleSet class.
        /// </summary>
        public TupleSet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TupleSet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TupleSet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleSet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TupleSet(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Number of Tuples</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Rank Requested</para>
        /// <para>Represents the following attribute in the schema: maxRank</para>
        /// </summary>
        public Int32Value? MaxRank
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>MDX Set Definition</para>
        /// <para>Represents the following attribute in the schema: setDefinition</para>
        /// </summary>
        public StringValue? SetDefinition
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Set Sort Order</para>
        /// <para>Represents the following attribute in the schema: sortType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortValues>? SortType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Query Failed</para>
        /// <para>Represents the following attribute in the schema: queryFailed</para>
        /// </summary>
        public BooleanValue? QueryFailed
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:set");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortByTuple>();
            builder.AddElement<TupleSet>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("maxRank", a => a.MaxRank, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("setDefinition", a => a.SetDefinition, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sortType", a => a.SortType)
                .AddAttribute("queryFailed", a => a.QueryFailed);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortByTuple), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:setDefinition"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:maxRank"), true, 0, true, 1048576, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TupleSet>(deep);
    }

    /// <summary>
    /// <para>Query.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:query.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tuples" /> <c>&lt;x:tpls></c></description></item>
    /// </list>
    /// </remark>
    public partial class Query : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Query class.
        /// </summary>
        public Query() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Query class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Query(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Query class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Query(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Query class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Query(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>MDX Query String</para>
        /// <para>Represents the following attribute in the schema: mdx</para>
        /// </summary>
        public StringValue? Mdx
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:query");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            builder.AddElement<Query>()
                .AddAttribute("mdx", a => a.Mdx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tuples), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:mdx"), 0, 65535));
        }

        /// <summary>
        /// <para>Tuples.</para>
        /// <para>Represents the following element tag in the schema: x:tpls.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Tuples? Tuples
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Tuples>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Query>(deep);
    }

    /// <summary>
    /// <para>Calculated Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calculatedItem.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedItem class.
        /// </summary>
        public CalculatedItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: field</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Item Formula</para>
        /// <para>Represents the following attribute in the schema: formula</para>
        /// </summary>
        public StringValue? Formula
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calculatedItem");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.AddElement<CalculatedItem>()
                .AddAttribute("field", a => a.Field)
                .AddAttribute("formula", a => a.Formula);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Calculated Item Location.</para>
        /// <para>Represents the following element tag in the schema: x:pivotArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotArea? PivotArea
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedItem>(deep);
    }

    /// <summary>
    /// <para>Calculated Item Location.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotArea.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotAreaReferences" /> <c>&lt;x:references></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotArea : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotArea class.
        /// </summary>
        public PivotArea() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotArea class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotArea(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotArea class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotArea(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotArea class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotArea(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: field</para>
        /// </summary>
        public Int32Value? Field
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Rule Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotAreaValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotAreaValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Only</para>
        /// <para>Represents the following attribute in the schema: dataOnly</para>
        /// </summary>
        public BooleanValue? DataOnly
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Labels Only</para>
        /// <para>Represents the following attribute in the schema: labelOnly</para>
        /// </summary>
        public BooleanValue? LabelOnly
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Row Grand Total</para>
        /// <para>Represents the following attribute in the schema: grandRow</para>
        /// </summary>
        public BooleanValue? GrandRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Column Grand Total</para>
        /// <para>Represents the following attribute in the schema: grandCol</para>
        /// </summary>
        public BooleanValue? GrandColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cache Index</para>
        /// <para>Represents the following attribute in the schema: cacheIndex</para>
        /// </summary>
        public BooleanValue? CacheIndex
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline</para>
        /// <para>Represents the following attribute in the schema: outline</para>
        /// </summary>
        public BooleanValue? Outline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Offset Reference</para>
        /// <para>Represents the following attribute in the schema: offset</para>
        /// </summary>
        public StringValue? Offset
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Collapsed Levels Are Subtotals</para>
        /// <para>Represents the following attribute in the schema: collapsedLevelsAreSubtotals</para>
        /// </summary>
        public BooleanValue? CollapsedLevelsAreSubtotals
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>? Axis
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Position</para>
        /// <para>Represents the following attribute in the schema: fieldPosition</para>
        /// </summary>
        public UInt32Value? FieldPosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotArea");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotAreaReferences>();
            builder.AddElement<PivotArea>()
                .AddAttribute("field", a => a.Field)
                .AddAttribute("type", a => a.Type)
                .AddAttribute("dataOnly", a => a.DataOnly)
                .AddAttribute("labelOnly", a => a.LabelOnly)
                .AddAttribute("grandRow", a => a.GrandRow)
                .AddAttribute("grandCol", a => a.GrandColumn)
                .AddAttribute("cacheIndex", a => a.CacheIndex)
                .AddAttribute("outline", a => a.Outline)
                .AddAttribute("offset", a => a.Offset)
                .AddAttribute("collapsedLevelsAreSubtotals", a => a.CollapsedLevelsAreSubtotals)
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("fieldPosition", a => a.FieldPosition);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotAreaReferences), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fieldPosition"), true, 0, true, 255, true));
        }

        /// <summary>
        /// <para>References.</para>
        /// <para>Represents the following element tag in the schema: x:references.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotAreaReferences? PivotAreaReferences
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotAreaReferences>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotArea>(deep);
    }

    /// <summary>
    /// <para>Calculated Member.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calculatedMember.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedMember : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedMember class.
        /// </summary>
        public CalculatedMember() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMember class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMember(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMember class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMember(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMember class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedMember(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mdx</para>
        /// <para>Represents the following attribute in the schema: mdx</para>
        /// </summary>
        public StringValue? Mdx
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>memberName</para>
        /// <para>Represents the following attribute in the schema: memberName</para>
        /// </summary>
        public StringValue? MemberName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hierarchy</para>
        /// <para>Represents the following attribute in the schema: hierarchy</para>
        /// </summary>
        public StringValue? Hierarchy
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>parent</para>
        /// <para>Represents the following attribute in the schema: parent</para>
        /// </summary>
        public StringValue? ParentName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>solveOrder</para>
        /// <para>Represents the following attribute in the schema: solveOrder</para>
        /// </summary>
        public Int32Value? SolveOrder
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>set</para>
        /// <para>Represents the following attribute in the schema: set</para>
        /// </summary>
        public BooleanValue? Set
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calculatedMember");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtensionList>();
            builder.AddElement<CalculatedMember>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("mdx", a => a.Mdx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("memberName", a => a.MemberName)
                .AddAttribute("hierarchy", a => a.Hierarchy)
                .AddAttribute("parent", a => a.ParentName)
                .AddAttribute("solveOrder", a => a.SolveOrder)
                .AddAttribute("set", a => a.Set);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 0, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 63999));
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:hierarchy"), builder.CreateQName("x:set"), "1"));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:hierarchy"), builder.CreateQName("x:set") , "0"));
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:parent"), builder.CreateQName("x:set"), "1"));
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:memberName"), builder.CreateQName("x:set"), "1"));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:memberName"), builder.CreateQName("x:set") , "0"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:memberName"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:hierarchy"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:parent"), 1, 65535) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>CalculatedMemberExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtensionList? CalculatedMemberExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedMember>(deep);
    }

    /// <summary>
    /// <para>PivotTable Field.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotField.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.AutoSortScope" /> <c>&lt;x:autoSortScope></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Items" /> <c>&lt;x:items></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotField : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotField class.
        /// </summary>
        public PivotField() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotField(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotField(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotField class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotField(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>? Axis
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Field</para>
        /// <para>Represents the following attribute in the schema: dataField</para>
        /// </summary>
        public BooleanValue? DataField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Subtotal Caption</para>
        /// <para>Represents the following attribute in the schema: subtotalCaption</para>
        /// </summary>
        public StringValue? SubtotalCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show PivotField Header Drop Downs</para>
        /// <para>Represents the following attribute in the schema: showDropDowns</para>
        /// </summary>
        public BooleanValue? ShowDropDowns
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Level</para>
        /// <para>Represents the following attribute in the schema: hiddenLevel</para>
        /// </summary>
        public BooleanValue? HiddenLevel
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique Member Property</para>
        /// <para>Represents the following attribute in the schema: uniqueMemberProperty</para>
        /// </summary>
        public StringValue? UniqueMemberProperty
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Compact</para>
        /// <para>Represents the following attribute in the schema: compact</para>
        /// </summary>
        public BooleanValue? Compact
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>All Items Expanded</para>
        /// <para>Represents the following attribute in the schema: allDrilled</para>
        /// </summary>
        public BooleanValue? AllDrilled
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Format Id</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline Items</para>
        /// <para>Represents the following attribute in the schema: outline</para>
        /// </summary>
        public BooleanValue? Outline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Subtotals At Top</para>
        /// <para>Represents the following attribute in the schema: subtotalTop</para>
        /// </summary>
        public BooleanValue? SubtotalTop
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag To Row</para>
        /// <para>Represents the following attribute in the schema: dragToRow</para>
        /// </summary>
        public BooleanValue? DragToRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag To Column</para>
        /// <para>Represents the following attribute in the schema: dragToCol</para>
        /// </summary>
        public BooleanValue? DragToColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Multiple Field Filters</para>
        /// <para>Represents the following attribute in the schema: multipleItemSelectionAllowed</para>
        /// </summary>
        public BooleanValue? MultipleItemSelectionAllowed
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag Field to Page</para>
        /// <para>Represents the following attribute in the schema: dragToPage</para>
        /// </summary>
        public BooleanValue? DragToPage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Can Drag to Data</para>
        /// <para>Represents the following attribute in the schema: dragToData</para>
        /// </summary>
        public BooleanValue? DragToData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag Off</para>
        /// <para>Represents the following attribute in the schema: dragOff</para>
        /// </summary>
        public BooleanValue? DragOff
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show All Items</para>
        /// <para>Represents the following attribute in the schema: showAll</para>
        /// </summary>
        public BooleanValue? ShowAll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Blank Row</para>
        /// <para>Represents the following attribute in the schema: insertBlankRow</para>
        /// </summary>
        public BooleanValue? InsertBlankRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server-based Page Field</para>
        /// <para>Represents the following attribute in the schema: serverField</para>
        /// </summary>
        public BooleanValue? ServerField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Item Page Break</para>
        /// <para>Represents the following attribute in the schema: insertPageBreak</para>
        /// </summary>
        public BooleanValue? InsertPageBreak
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Show</para>
        /// <para>Represents the following attribute in the schema: autoShow</para>
        /// </summary>
        public BooleanValue? AutoShow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Auto Show</para>
        /// <para>Represents the following attribute in the schema: topAutoShow</para>
        /// </summary>
        public BooleanValue? TopAutoShow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide New Items</para>
        /// <para>Represents the following attribute in the schema: hideNewItems</para>
        /// </summary>
        public BooleanValue? HideNewItems
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Measure Filter</para>
        /// <para>Represents the following attribute in the schema: measureFilter</para>
        /// </summary>
        public BooleanValue? MeasureFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Inclusive Manual Filter</para>
        /// <para>Represents the following attribute in the schema: includeNewItemsInFilter</para>
        /// </summary>
        public BooleanValue? IncludeNewItemsInFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Items Per Page Count</para>
        /// <para>Represents the following attribute in the schema: itemPageCount</para>
        /// </summary>
        public UInt32Value? ItemPageCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Sort Type</para>
        /// <para>Represents the following attribute in the schema: sortType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FieldSortValues>? SortType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FieldSortValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Source Sort</para>
        /// <para>Represents the following attribute in the schema: dataSourceSort</para>
        /// </summary>
        public BooleanValue? DataSourceSort
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Sort</para>
        /// <para>Represents the following attribute in the schema: nonAutoSortDefault</para>
        /// </summary>
        public BooleanValue? NonAutoSortDefault
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Show Rank By</para>
        /// <para>Represents the following attribute in the schema: rankBy</para>
        /// </summary>
        public UInt32Value? RankBy
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Default Subtotal</para>
        /// <para>Represents the following attribute in the schema: defaultSubtotal</para>
        /// </summary>
        public BooleanValue? DefaultSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sum Subtotal</para>
        /// <para>Represents the following attribute in the schema: sumSubtotal</para>
        /// </summary>
        public BooleanValue? SumSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>CountA</para>
        /// <para>Represents the following attribute in the schema: countASubtotal</para>
        /// </summary>
        public BooleanValue? CountASubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Average</para>
        /// <para>Represents the following attribute in the schema: avgSubtotal</para>
        /// </summary>
        public BooleanValue? AverageSubTotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Max Subtotal</para>
        /// <para>Represents the following attribute in the schema: maxSubtotal</para>
        /// </summary>
        public BooleanValue? MaxSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Min Subtotal</para>
        /// <para>Represents the following attribute in the schema: minSubtotal</para>
        /// </summary>
        public BooleanValue? MinSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Product Subtotal</para>
        /// <para>Represents the following attribute in the schema: productSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyProductInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: countSubtotal</para>
        /// </summary>
        public BooleanValue? CountSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>StdDev Subtotal</para>
        /// <para>Represents the following attribute in the schema: stdDevSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyStandardDeviationInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>StdDevP Subtotal</para>
        /// <para>Represents the following attribute in the schema: stdDevPSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyStandardDeviationPInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Variance Subtotal</para>
        /// <para>Represents the following attribute in the schema: varSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyVarianceInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>VarP Subtotal</para>
        /// <para>Represents the following attribute in the schema: varPSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyVariancePInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Member Property in Cell</para>
        /// <para>Represents the following attribute in the schema: showPropCell</para>
        /// </summary>
        public BooleanValue? ShowPropCell
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Member Property ToolTip</para>
        /// <para>Represents the following attribute in the schema: showPropTip</para>
        /// </summary>
        public BooleanValue? ShowPropertyTooltip
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show As Caption</para>
        /// <para>Represents the following attribute in the schema: showPropAsCaption</para>
        /// </summary>
        public BooleanValue? ShowPropAsCaption
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drill State</para>
        /// <para>Represents the following attribute in the schema: defaultAttributeDrillState</para>
        /// </summary>
        public BooleanValue? DefaultAttributeDrillState
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotField");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.AutoSortScope>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Items>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtensionList>();
            builder.AddElement<PivotField>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("dataField", a => a.DataField)
                .AddAttribute("subtotalCaption", a => a.SubtotalCaption)
                .AddAttribute("showDropDowns", a => a.ShowDropDowns)
                .AddAttribute("hiddenLevel", a => a.HiddenLevel)
                .AddAttribute("uniqueMemberProperty", a => a.UniqueMemberProperty)
                .AddAttribute("compact", a => a.Compact)
                .AddAttribute("allDrilled", a => a.AllDrilled)
                .AddAttribute("numFmtId", a => a.NumberFormatId)
                .AddAttribute("outline", a => a.Outline)
                .AddAttribute("subtotalTop", a => a.SubtotalTop)
                .AddAttribute("dragToRow", a => a.DragToRow)
                .AddAttribute("dragToCol", a => a.DragToColumn)
                .AddAttribute("multipleItemSelectionAllowed", a => a.MultipleItemSelectionAllowed)
                .AddAttribute("dragToPage", a => a.DragToPage)
                .AddAttribute("dragToData", a => a.DragToData)
                .AddAttribute("dragOff", a => a.DragOff)
                .AddAttribute("showAll", a => a.ShowAll)
                .AddAttribute("insertBlankRow", a => a.InsertBlankRow)
                .AddAttribute("serverField", a => a.ServerField)
                .AddAttribute("insertPageBreak", a => a.InsertPageBreak)
                .AddAttribute("autoShow", a => a.AutoShow)
                .AddAttribute("topAutoShow", a => a.TopAutoShow)
                .AddAttribute("hideNewItems", a => a.HideNewItems)
                .AddAttribute("measureFilter", a => a.MeasureFilter)
                .AddAttribute("includeNewItemsInFilter", a => a.IncludeNewItemsInFilter)
                .AddAttribute("itemPageCount", a => a.ItemPageCount)
                .AddAttribute("sortType", a => a.SortType)
                .AddAttribute("dataSourceSort", a => a.DataSourceSort)
                .AddAttribute("nonAutoSortDefault", a => a.NonAutoSortDefault)
                .AddAttribute("rankBy", a => a.RankBy)
                .AddAttribute("defaultSubtotal", a => a.DefaultSubtotal)
                .AddAttribute("sumSubtotal", a => a.SumSubtotal)
                .AddAttribute("countASubtotal", a => a.CountASubtotal)
                .AddAttribute("avgSubtotal", a => a.AverageSubTotal)
                .AddAttribute("maxSubtotal", a => a.MaxSubtotal)
                .AddAttribute("minSubtotal", a => a.MinSubtotal)
                .AddAttribute("productSubtotal", a => a.ApplyProductInSubtotal)
                .AddAttribute("countSubtotal", a => a.CountSubtotal)
                .AddAttribute("stdDevSubtotal", a => a.ApplyStandardDeviationInSubtotal)
                .AddAttribute("stdDevPSubtotal", a => a.ApplyStandardDeviationPInSubtotal)
                .AddAttribute("varSubtotal", a => a.ApplyVarianceInSubtotal)
                .AddAttribute("varPSubtotal", a => a.ApplyVariancePInSubtotal)
                .AddAttribute("showPropCell", a => a.ShowPropCell)
                .AddAttribute("showPropTip", a => a.ShowPropertyTooltip)
                .AddAttribute("showPropAsCaption", a => a.ShowPropAsCaption)
                .AddAttribute("defaultAttributeDrillState", a => a.DefaultAttributeDrillState);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Items), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.AutoSortScope), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:axis"), false, new string[] { "axisValues" }));
        }

        /// <summary>
        /// <para>Field Items.</para>
        /// <para>Represents the following element tag in the schema: x:items.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Items? Items
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Items>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>AutoSort Scope.</para>
        /// <para>Represents the following element tag in the schema: x:autoSortScope.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.AutoSortScope? AutoSortScope
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.AutoSortScope>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtensionList? PivotFieldExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotField>(deep);
    }

    /// <summary>
    /// <para>PivotTable Field Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:item.</para>
    /// </summary>
    public partial class Item : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Item class.
        /// </summary>
        public Item() : base()
        {
        }

        /// <summary>
        /// <para>Item User Caption</para>
        /// <para>Represents the following attribute in the schema: n</para>
        /// </summary>
        public StringValue? ItemName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>? ItemType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden</para>
        /// <para>Represents the following attribute in the schema: h</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Character</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public BooleanValue? HasStringVlue
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Details</para>
        /// <para>Represents the following attribute in the schema: sd</para>
        /// </summary>
        public BooleanValue? HideDetails
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Member</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public BooleanValue? Calculated
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Missing</para>
        /// <para>Represents the following attribute in the schema: m</para>
        /// </summary>
        public BooleanValue? Missing
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Child Items</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public BooleanValue? ChildItems
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Index</para>
        /// <para>Represents the following attribute in the schema: x</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Expanded</para>
        /// <para>Represents the following attribute in the schema: d</para>
        /// </summary>
        public BooleanValue? Expanded
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drill Across Attributes</para>
        /// <para>Represents the following attribute in the schema: e</para>
        /// </summary>
        public BooleanValue? DrillAcrossAttributes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:item");
            builder.AddElement<Item>()
                .AddAttribute("n", a => a.ItemName)
                .AddAttribute("t", a => a.ItemType)
                .AddAttribute("h", a => a.Hidden)
                .AddAttribute("s", a => a.HasStringVlue)
                .AddAttribute("sd", a => a.HideDetails)
                .AddAttribute("f", a => a.Calculated)
                .AddAttribute("m", a => a.Missing)
                .AddAttribute("c", a => a.ChildItems)
                .AddAttribute("x", a => a.Index)
                .AddAttribute("d", a => a.Expanded)
                .AddAttribute("e", a => a.DrillAcrossAttributes);
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:n"), true, builder.CreateQName("x:pivotField")));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:t"), false, new string[] { "blank", "grand" }));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:x"), builder.CreateQName("x:t") , "data") { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Item>(deep);
    }

    /// <summary>
    /// <para>Data Field Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataField.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataFieldExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataField : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataField class.
        /// </summary>
        public DataField() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataField(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataField(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataField class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataField(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>fld</para>
        /// <para>Represents the following attribute in the schema: fld</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>subtotal</para>
        /// <para>Represents the following attribute in the schema: subtotal</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>? Subtotal
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDataAs</para>
        /// <para>Represents the following attribute in the schema: showDataAs</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ShowDataAsValues>? ShowDataAs
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ShowDataAsValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>baseField</para>
        /// <para>Represents the following attribute in the schema: baseField</para>
        /// </summary>
        public Int32Value? BaseField
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>baseItem</para>
        /// <para>Represents the following attribute in the schema: baseItem</para>
        /// </summary>
        public UInt32Value? BaseItem
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>numFmtId</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataField");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataFieldExtensionList>();
            builder.AddElement<DataField>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("fld", a => a.Field, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("subtotal", a => a.Subtotal)
                .AddAttribute("showDataAs", a => a.ShowDataAs)
                .AddAttribute("baseField", a => a.BaseField)
                .AddAttribute("baseItem", a => a.BaseItem)
                .AddAttribute("numFmtId", a => a.NumberFormatId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataFieldExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fld"), ".", null, builder.CreateQName("x:pivotField"), "x:pivotField", 0));
        }

        /// <summary>
        /// <para>DataFieldExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DataFieldExtensionList? DataFieldExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DataFieldExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataField>(deep);
    }

    /// <summary>
    /// <para>Row Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:i.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class RowItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RowItem class.
        /// </summary>
        public RowItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RowItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Item Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>? ItemType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Repeated Items Count</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public UInt32Value? RepeatedItemCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Field Index</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:i");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex>();
            builder.AddElement<RowItem>()
                .AddAttribute("t", a => a.ItemType)
                .AddAttribute("r", a => a.RepeatedItemCount)
                .AddAttribute("i", a => a.Index);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberPropertyIndex), 0, 0)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:i"), ".", null, builder.CreateQName("x:dataField"), "x:dataField", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowItem>(deep);
    }

    /// <summary>
    /// <para>Row Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:field.</para>
    /// </summary>
    public partial class Field : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Field class.
        /// </summary>
        public Field() : base()
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: x</para>
        /// </summary>
        public Int32Value? Index
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:field");
            builder.AddElement<Field>()
                .AddAttribute("x", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:x"), true, builder.CreateQName("x:colFields")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Field>(deep);
    }

    /// <summary>
    /// <para>PivotTable Format.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:format.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class Format : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Format class.
        /// </summary>
        public Format() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Format class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Format(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Format class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Format(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Format class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Format(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Format Action</para>
        /// <para>Represents the following attribute in the schema: action</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormatActionValues>? Action
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormatActionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Id</para>
        /// <para>Represents the following attribute in the schema: dxfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:format");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.AddElement<Format>()
                .AddAttribute("action", a => a.Action)
                .AddAttribute("dxfId", a => a.FormatId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
        }

        /// <summary>
        /// <para>Pivot Table Location.</para>
        /// <para>Represents the following element tag in the schema: x:pivotArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotArea? PivotArea
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Format>(deep);
    }

    /// <summary>
    /// <para>Conditional Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:conditionalFormat.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotAreas" /> <c>&lt;x:pivotAreas></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormat : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormat class.
        /// </summary>
        public ConditionalFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormat(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Conditional Formatting Scope</para>
        /// <para>Represents the following attribute in the schema: scope</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ScopeValues>? Scope
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ScopeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Conditional Formatting Rule Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RuleValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.RuleValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Priority</para>
        /// <para>Represents the following attribute in the schema: priority</para>
        /// </summary>
        public UInt32Value? Priority
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:conditionalFormat");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotAreas>();
            builder.AddElement<ConditionalFormat>()
                .AddAttribute("scope", a => a.Scope)
                .AddAttribute("type", a => a.Type)
                .AddAttribute("priority", a => a.Priority, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotAreas), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:type"), builder.CreateQName("x:scope"), new string[] { "none", "all" }, new string[] { "data", "selection" }));
        }

        /// <summary>
        /// <para>Pivot Areas.</para>
        /// <para>Represents the following element tag in the schema: x:pivotAreas.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotAreas? PivotAreas
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotAreas>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormat>(deep);
    }

    /// <summary>
    /// <para>Pivot Areas.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotAreas.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotAreas : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotAreas class.
        /// </summary>
        public PivotAreas() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreas class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreas(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreas class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreas(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreas class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotAreas(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Pivot Area Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotAreas");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.AddElement<PivotAreas>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotAreas>(deep);
    }

    /// <summary>
    /// <para>PivotChart Format.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:chartFormat.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChartFormat : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartFormat class.
        /// </summary>
        public ChartFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartFormat(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Chart Index</para>
        /// <para>Represents the following attribute in the schema: chart</para>
        /// </summary>
        public UInt32Value? Chart
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Pivot Format Id</para>
        /// <para>Represents the following attribute in the schema: format</para>
        /// </summary>
        public UInt32Value? Format
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Series Format</para>
        /// <para>Represents the following attribute in the schema: series</para>
        /// </summary>
        public BooleanValue? Series
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:chartFormat");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.AddElement<ChartFormat>()
                .AddAttribute("chart", a => a.Chart, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("format", a => a.Format, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("series", a => a.Series);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 1, 1)
            };
        }

        /// <summary>
        /// <para>Pivot Table Location Rule.</para>
        /// <para>Represents the following element tag in the schema: x:pivotArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotArea? PivotArea
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartFormat>(deep);
    }

    /// <summary>
    /// <para>OLAP Hierarchy.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotHierarchy.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberProperties" /> <c>&lt;x:mps></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Members" /> <c>&lt;x:members></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotHierarchy : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotHierarchy class.
        /// </summary>
        public PivotHierarchy() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchy class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchy(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchy class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchy(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchy class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotHierarchy(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Outline New Levels</para>
        /// <para>Represents the following attribute in the schema: outline</para>
        /// </summary>
        public BooleanValue? Outline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Multiple Field Filters</para>
        /// <para>Represents the following attribute in the schema: multipleItemSelectionAllowed</para>
        /// </summary>
        public BooleanValue? MultipleItemSelectionAllowed
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Levels Subtotals At Top</para>
        /// <para>Represents the following attribute in the schema: subtotalTop</para>
        /// </summary>
        public BooleanValue? SubtotalTop
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show In Field List</para>
        /// <para>Represents the following attribute in the schema: showInFieldList</para>
        /// </summary>
        public BooleanValue? ShowInFieldList
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag To Row</para>
        /// <para>Represents the following attribute in the schema: dragToRow</para>
        /// </summary>
        public BooleanValue? DragToRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag To Column</para>
        /// <para>Represents the following attribute in the schema: dragToCol</para>
        /// </summary>
        public BooleanValue? DragToColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag to Page</para>
        /// <para>Represents the following attribute in the schema: dragToPage</para>
        /// </summary>
        public BooleanValue? DragToPage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag To Data</para>
        /// <para>Represents the following attribute in the schema: dragToData</para>
        /// </summary>
        public BooleanValue? DragToData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drag Off</para>
        /// <para>Represents the following attribute in the schema: dragOff</para>
        /// </summary>
        public BooleanValue? DragOff
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Inclusive Manual Filter</para>
        /// <para>Represents the following attribute in the schema: includeNewItemsInFilter</para>
        /// </summary>
        public BooleanValue? IncludeNewItemsInFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hierarchy Caption</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotHierarchy");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Members>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtensionList>();
            builder.AddElement<PivotHierarchy>()
                .AddAttribute("outline", a => a.Outline)
                .AddAttribute("multipleItemSelectionAllowed", a => a.MultipleItemSelectionAllowed)
                .AddAttribute("subtotalTop", a => a.SubtotalTop)
                .AddAttribute("showInFieldList", a => a.ShowInFieldList)
                .AddAttribute("dragToRow", a => a.DragToRow)
                .AddAttribute("dragToCol", a => a.DragToColumn)
                .AddAttribute("dragToPage", a => a.DragToPage)
                .AddAttribute("dragToData", a => a.DragToData)
                .AddAttribute("dragOff", a => a.DragOff)
                .AddAttribute("includeNewItemsInFilter", a => a.IncludeNewItemsInFilter)
                .AddAttribute("caption", a => a.Caption);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Members), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:caption"), 0, 65535));
        }

        /// <summary>
        /// <para>OLAP Member Properties.</para>
        /// <para>Represents the following element tag in the schema: x:mps.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MemberProperties? MemberProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MemberProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotHierarchy>(deep);
    }

    /// <summary>
    /// <para>Row OLAP Hierarchies.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rowHierarchyUsage.</para>
    /// </summary>
    public partial class RowHierarchyUsage : HierarchyUsageType
    {
        /// <summary>
        /// Initializes a new instance of the RowHierarchyUsage class.
        /// </summary>
        public RowHierarchyUsage() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rowHierarchyUsage");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowHierarchyUsage>(deep);
    }

    /// <summary>
    /// <para>Column OLAP Hierarchies.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colHierarchyUsage.</para>
    /// </summary>
    public partial class ColumnHierarchyUsage : HierarchyUsageType
    {
        /// <summary>
        /// Initializes a new instance of the ColumnHierarchyUsage class.
        /// </summary>
        public ColumnHierarchyUsage() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colHierarchyUsage");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColumnHierarchyUsage>(deep);
    }

    /// <summary>
    /// <para>Defines the HierarchyUsageType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class HierarchyUsageType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the HierarchyUsageType class.
        /// </summary>
        protected HierarchyUsageType() : base()
        {
        }

        /// <summary>
        /// <para>Hierarchy Usage</para>
        /// <para>Represents the following attribute in the schema: hierarchyUsage</para>
        /// </summary>
        public Int32Value? Value
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<HierarchyUsageType>()
                .AddAttribute("hierarchyUsage", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }
    }

    /// <summary>
    /// <para>OLAP Member Property.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mp.</para>
    /// </summary>
    public partial class MemberProperty : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MemberProperty class.
        /// </summary>
        public MemberProperty() : base()
        {
        }

        /// <summary>
        /// <para>OLAP Member Property Unique Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Cell</para>
        /// <para>Represents the following attribute in the schema: showCell</para>
        /// </summary>
        public BooleanValue? ShowCell
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Tooltip</para>
        /// <para>Represents the following attribute in the schema: showTip</para>
        /// </summary>
        public BooleanValue? ShowTip
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show As Caption</para>
        /// <para>Represents the following attribute in the schema: showAsCaption</para>
        /// </summary>
        public BooleanValue? ShowAsCaption
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Name Length</para>
        /// <para>Represents the following attribute in the schema: nameLen</para>
        /// </summary>
        public UInt32Value? NameLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Property Name Character Index</para>
        /// <para>Represents the following attribute in the schema: pPos</para>
        /// </summary>
        public UInt32Value? PropertyNamePosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Property Name Length</para>
        /// <para>Represents the following attribute in the schema: pLen</para>
        /// </summary>
        public UInt32Value? PropertyNameLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Level Index</para>
        /// <para>Represents the following attribute in the schema: level</para>
        /// </summary>
        public UInt32Value? Level
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: field</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mp");
            builder.AddElement<MemberProperty>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("showCell", a => a.ShowCell)
                .AddAttribute("showTip", a => a.ShowTip)
                .AddAttribute("showAsCaption", a => a.ShowAsCaption)
                .AddAttribute("nameLen", a => a.NameLength)
                .AddAttribute("pPos", a => a.PropertyNamePosition)
                .AddAttribute("pLen", a => a.PropertyNameLength)
                .AddAttribute("level", a => a.Level)
                .AddAttribute("field", a => a.Field, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:field"), "PivotTableCacheDefinitionPart", null, builder.CreateQName("x:cacheField"), "x:cacheField", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MemberProperty>(deep);
    }

    /// <summary>
    /// <para>Member.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:member.</para>
    /// </summary>
    public partial class Member : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Member class.
        /// </summary>
        public Member() : base()
        {
        }

        /// <summary>
        /// <para>Hidden Item Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:member");
            builder.AddElement<Member>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Member>(deep);
    }

    /// <summary>
    /// <para>OLAP Dimension.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dimension.</para>
    /// </summary>
    public partial class Dimension : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Dimension class.
        /// </summary>
        public Dimension() : base()
        {
        }

        /// <summary>
        /// <para>Measure</para>
        /// <para>Represents the following attribute in the schema: measure</para>
        /// </summary>
        public BooleanValue? Measure
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dimension Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dimension Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dimension Display Name</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dimension");
            builder.AddElement<Dimension>()
                .AddAttribute("measure", a => a.Measure)
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:caption"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueName"), 1, 32767) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Dimension>(deep);
    }

    /// <summary>
    /// <para>OLAP Measure Group.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:measureGroup.</para>
    /// </summary>
    public partial class MeasureGroup : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MeasureGroup class.
        /// </summary>
        public MeasureGroup() : base()
        {
        }

        /// <summary>
        /// <para>Measure Group Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Measure Group Display Name</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:measureGroup");
            builder.AddElement<MeasureGroup>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:caption"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MeasureGroup>(deep);
    }

    /// <summary>
    /// <para>OLAP Measure Group.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:map.</para>
    /// </summary>
    public partial class MeasureDimensionMap : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MeasureDimensionMap class.
        /// </summary>
        public MeasureDimensionMap() : base()
        {
        }

        /// <summary>
        /// <para>Measure Group Id</para>
        /// <para>Represents the following attribute in the schema: measureGroup</para>
        /// </summary>
        public UInt32Value? MeasureGroup
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dimension Id</para>
        /// <para>Represents the following attribute in the schema: dimension</para>
        /// </summary>
        public UInt32Value? Dimension
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:map");
            builder.AddElement<MeasureDimensionMap>()
                .AddAttribute("measureGroup", a => a.MeasureGroup, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("dimension", a => a.Dimension, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MeasureDimensionMap>(deep);
    }

    /// <summary>
    /// <para>PivotTable Advanced Filter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:filter.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.AutoFilter" /> <c>&lt;x:autoFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFilter : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFilter class.
        /// </summary>
        public PivotFilter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilter(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilter(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilter class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFilter(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>fld</para>
        /// <para>Represents the following attribute in the schema: fld</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mpFld</para>
        /// <para>Represents the following attribute in the schema: mpFld</para>
        /// </summary>
        public UInt32Value? MemberPropertyFieldId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotFilterValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotFilterValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>evalOrder</para>
        /// <para>Represents the following attribute in the schema: evalOrder</para>
        /// </summary>
        public Int32Value? EvaluationOrder
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>iMeasureHier</para>
        /// <para>Represents the following attribute in the schema: iMeasureHier</para>
        /// </summary>
        public UInt32Value? MeasureHierarchy
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>iMeasureFld</para>
        /// <para>Represents the following attribute in the schema: iMeasureFld</para>
        /// </summary>
        public UInt32Value? MeasureField
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>description</para>
        /// <para>Represents the following attribute in the schema: description</para>
        /// </summary>
        public StringValue? Description
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>stringValue1</para>
        /// <para>Represents the following attribute in the schema: stringValue1</para>
        /// </summary>
        public StringValue? StringValue1
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>stringValue2</para>
        /// <para>Represents the following attribute in the schema: stringValue2</para>
        /// </summary>
        public StringValue? StringValue2
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:filter");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtensionList>();
            builder.AddElement<PivotFilter>()
                .AddAttribute("fld", a => a.Field, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("mpFld", a => a.MemberPropertyFieldId)
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("evalOrder", a => a.EvaluationOrder)
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("iMeasureHier", a => a.MeasureHierarchy)
                .AddAttribute("iMeasureFld", a => a.MeasureField)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("description", a => a.Description)
                .AddAttribute("stringValue1", a => a.StringValue1)
                .AddAttribute("stringValue2", a => a.StringValue2);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.AutoFilter), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fld"), ".", null, builder.CreateQName("x:pivotField"), "x:pivotField", 0));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), false, null));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:iMeasureFld"), ".", null, builder.CreateQName("x:pivotField"), "x:pivotField", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:iMeasureHier"), ".", null, builder.CreateQName("x:pivotHierarchy"), "x:pivotHierarchy", 0));
        }

        /// <summary>
        /// <para>AutoFilter.</para>
        /// <para>Represents the following element tag in the schema: x:autoFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.AutoFilter? AutoFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PivotFilterExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtensionList? PivotFilterExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFilter>(deep);
    }

    /// <summary>
    /// <para>PivotCache Hierarchy.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cacheHierarchy.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldsUsage" /> <c>&lt;x:fieldsUsage></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GroupLevels" /> <c>&lt;x:groupLevels></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheHierarchy : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheHierarchy class.
        /// </summary>
        public CacheHierarchy() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchy class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchy(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchy class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchy(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchy class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheHierarchy(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>uniqueName</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>caption</para>
        /// <para>Represents the following attribute in the schema: caption</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>measure</para>
        /// <para>Represents the following attribute in the schema: measure</para>
        /// </summary>
        public BooleanValue? Measure
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>set</para>
        /// <para>Represents the following attribute in the schema: set</para>
        /// </summary>
        public BooleanValue? Set
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>parentSet</para>
        /// <para>Represents the following attribute in the schema: parentSet</para>
        /// </summary>
        public UInt32Value? ParentSet
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>iconSet</para>
        /// <para>Represents the following attribute in the schema: iconSet</para>
        /// </summary>
        public Int32Value? IconSet
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>attribute</para>
        /// <para>Represents the following attribute in the schema: attribute</para>
        /// </summary>
        public BooleanValue? Attribute
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>time</para>
        /// <para>Represents the following attribute in the schema: time</para>
        /// </summary>
        public BooleanValue? Time
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>keyAttribute</para>
        /// <para>Represents the following attribute in the schema: keyAttribute</para>
        /// </summary>
        public BooleanValue? KeyAttribute
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>defaultMemberUniqueName</para>
        /// <para>Represents the following attribute in the schema: defaultMemberUniqueName</para>
        /// </summary>
        public StringValue? DefaultMemberUniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>allUniqueName</para>
        /// <para>Represents the following attribute in the schema: allUniqueName</para>
        /// </summary>
        public StringValue? AllUniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>allCaption</para>
        /// <para>Represents the following attribute in the schema: allCaption</para>
        /// </summary>
        public StringValue? AllCaption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dimensionUniqueName</para>
        /// <para>Represents the following attribute in the schema: dimensionUniqueName</para>
        /// </summary>
        public StringValue? DimensionUniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>displayFolder</para>
        /// <para>Represents the following attribute in the schema: displayFolder</para>
        /// </summary>
        public StringValue? DisplayFolder
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>measureGroup</para>
        /// <para>Represents the following attribute in the schema: measureGroup</para>
        /// </summary>
        public StringValue? MeasureGroup
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>measures</para>
        /// <para>Represents the following attribute in the schema: measures</para>
        /// </summary>
        public BooleanValue? Measures
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>oneField</para>
        /// <para>Represents the following attribute in the schema: oneField</para>
        /// </summary>
        public BooleanValue? OneField
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>memberValueDatatype</para>
        /// <para>Represents the following attribute in the schema: memberValueDatatype</para>
        /// </summary>
        public UInt16Value? MemberValueDatatype
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>unbalanced</para>
        /// <para>Represents the following attribute in the schema: unbalanced</para>
        /// </summary>
        public BooleanValue? Unbalanced
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>unbalancedGroup</para>
        /// <para>Represents the following attribute in the schema: unbalancedGroup</para>
        /// </summary>
        public BooleanValue? UnbalancedGroup
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hidden</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cacheHierarchy");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldsUsage>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GroupLevels>();
            builder.AddElement<CacheHierarchy>()
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("caption", a => a.Caption)
                .AddAttribute("measure", a => a.Measure)
                .AddAttribute("set", a => a.Set)
                .AddAttribute("parentSet", a => a.ParentSet)
                .AddAttribute("iconSet", a => a.IconSet)
                .AddAttribute("attribute", a => a.Attribute)
                .AddAttribute("time", a => a.Time)
                .AddAttribute("keyAttribute", a => a.KeyAttribute)
                .AddAttribute("defaultMemberUniqueName", a => a.DefaultMemberUniqueName)
                .AddAttribute("allUniqueName", a => a.AllUniqueName)
                .AddAttribute("allCaption", a => a.AllCaption)
                .AddAttribute("dimensionUniqueName", a => a.DimensionUniqueName)
                .AddAttribute("displayFolder", a => a.DisplayFolder)
                .AddAttribute("measureGroup", a => a.MeasureGroup)
                .AddAttribute("measures", a => a.Measures)
                .AddAttribute("count", a => a.Count, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("oneField", a => a.OneField)
                .AddAttribute("memberValueDatatype", a => a.MemberValueDatatype)
                .AddAttribute("unbalanced", a => a.Unbalanced)
                .AddAttribute("unbalancedGroup", a => a.UnbalancedGroup)
                .AddAttribute("hidden", a => a.Hidden);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldsUsage), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GroupLevels), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:allUniqueName"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:defaultMemberUniqueName"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:displayFolder"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:measureGroup"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:iconSet"), true, 0, true, 11, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>FieldsUsage.</para>
        /// <para>Represents the following element tag in the schema: x:fieldsUsage.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FieldsUsage? FieldsUsage
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FieldsUsage>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>GroupLevels.</para>
        /// <para>Represents the following element tag in the schema: x:groupLevels.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.GroupLevels? GroupLevels
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.GroupLevels>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CacheHierarchyExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtensionList? CacheHierarchyExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheHierarchy>(deep);
    }

    /// <summary>
    /// <para>Range Grouping Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rangePr.</para>
    /// </summary>
    public partial class RangeProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RangeProperties class.
        /// </summary>
        public RangeProperties() : base()
        {
        }

        /// <summary>
        /// <para>Source Data Set Beginning Range</para>
        /// <para>Represents the following attribute in the schema: autoStart</para>
        /// </summary>
        public BooleanValue? AutoStart
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Data Ending Range</para>
        /// <para>Represents the following attribute in the schema: autoEnd</para>
        /// </summary>
        public BooleanValue? AutoEnd
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Group By</para>
        /// <para>Represents the following attribute in the schema: groupBy</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GroupByValues>? GroupBy
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.GroupByValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Numeric Grouping Start Value</para>
        /// <para>Represents the following attribute in the schema: startNum</para>
        /// </summary>
        public DoubleValue? StartNumber
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Numeric Grouping End Value</para>
        /// <para>Represents the following attribute in the schema: endNum</para>
        /// </summary>
        public DoubleValue? EndNum
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Date Grouping Start Value</para>
        /// <para>Represents the following attribute in the schema: startDate</para>
        /// </summary>
        public DateTimeValue? StartDate
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Date Grouping End Value</para>
        /// <para>Represents the following attribute in the schema: endDate</para>
        /// </summary>
        public DateTimeValue? EndDate
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Grouping Interval</para>
        /// <para>Represents the following attribute in the schema: groupInterval</para>
        /// </summary>
        public DoubleValue? GroupInterval
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rangePr");
            builder.AddElement<RangeProperties>()
                .AddAttribute("autoStart", a => a.AutoStart)
                .AddAttribute("autoEnd", a => a.AutoEnd)
                .AddAttribute("groupBy", a => a.GroupBy)
                .AddAttribute("startNum", a => a.StartNumber)
                .AddAttribute("endNum", a => a.EndNum)
                .AddAttribute("startDate", a => a.StartDate)
                .AddAttribute("endDate", a => a.EndDate)
                .AddAttribute("groupInterval", a => a.GroupInterval);
            builder.AddConstraint(new AttributeValueLessEqualToAnother(builder.CreateQName("x:startNum"), builder.CreateQName("x:endNum"), false));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RangeProperties>(deep);
    }

    /// <summary>
    /// <para>Discrete Grouping Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:discretePr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldItem" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiscreteProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DiscreteProperties class.
        /// </summary>
        public DiscreteProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiscreteProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiscreteProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiscreteProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiscreteProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiscreteProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiscreteProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Mapping Index Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:discretePr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldItem>();
            builder.AddElement<DiscreteProperties>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldItem), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiscreteProperties>(deep);
    }

    /// <summary>
    /// <para>OLAP Group Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groupItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BooleanItem" /> <c>&lt;x:b></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DateTimeItem" /> <c>&lt;x:d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ErrorItem" /> <c>&lt;x:e></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MissingItem" /> <c>&lt;x:m></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberItem" /> <c>&lt;x:n></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StringItem" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class GroupItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GroupItems class.
        /// </summary>
        public GroupItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GroupItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Items Created Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groupItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BooleanItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DateTimeItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ErrorItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MissingItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StringItem>();
            builder.AddElement<GroupItems>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MissingItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BooleanItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ErrorItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StringItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DateTimeItem), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GroupItems>(deep);
    }

    /// <summary>
    /// <para>Page Field.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageField.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class PageField : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PageField class.
        /// </summary>
        public PageField() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PageField(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PageField(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageField class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PageField(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field</para>
        /// <para>Represents the following attribute in the schema: fld</para>
        /// </summary>
        public Int32Value? Field
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Index</para>
        /// <para>Represents the following attribute in the schema: item</para>
        /// </summary>
        public UInt32Value? Item
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLAP Hierarchy Index</para>
        /// <para>Represents the following attribute in the schema: hier</para>
        /// </summary>
        public Int32Value? Hierarchy
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hierarchy Unique Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hierarchy Display Name</para>
        /// <para>Represents the following attribute in the schema: cap</para>
        /// </summary>
        public StringValue? Caption
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageField");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<PageField>()
                .AddAttribute("fld", a => a.Field, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("item", a => a.Item)
                .AddAttribute("hier", a => a.Hierarchy)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("cap", a => a.Caption);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 0, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fld"), "PivotTableCacheDefinitionPart", null, builder.CreateQName("x:cacheField"), "x:cacheField", 0));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, null));
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageField>(deep);
    }

    /// <summary>
    /// <para>References.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:references.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotAreaReference" /> <c>&lt;x:reference></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotAreaReferences : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotAreaReferences class.
        /// </summary>
        public PivotAreaReferences() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreaReferences(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreaReferences(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReferences class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotAreaReferences(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Pivot Filter Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:references");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotAreaReference>();
            builder.AddElement<PivotAreaReferences>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotAreaReference), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotAreaReferences>(deep);
    }

    /// <summary>
    /// <para>Reference.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:reference.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldItem" /> <c>&lt;x:x></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotAreaReference : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotAreaReference class.
        /// </summary>
        public PivotAreaReference() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReference class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreaReference(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReference class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotAreaReference(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotAreaReference class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotAreaReference(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Index</para>
        /// <para>Represents the following attribute in the schema: field</para>
        /// </summary>
        public UInt32Value? Field
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Item Index Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Selected</para>
        /// <para>Represents the following attribute in the schema: selected</para>
        /// </summary>
        public BooleanValue? Selected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Positional Reference</para>
        /// <para>Represents the following attribute in the schema: byPosition</para>
        /// </summary>
        public BooleanValue? ByPosition
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relative Reference</para>
        /// <para>Represents the following attribute in the schema: relative</para>
        /// </summary>
        public BooleanValue? Relative
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Default Filter</para>
        /// <para>Represents the following attribute in the schema: defaultSubtotal</para>
        /// </summary>
        public BooleanValue? DefaultSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Sum Filter</para>
        /// <para>Represents the following attribute in the schema: sumSubtotal</para>
        /// </summary>
        public BooleanValue? SumSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include CountA Filter</para>
        /// <para>Represents the following attribute in the schema: countASubtotal</para>
        /// </summary>
        public BooleanValue? CountASubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Average Filter</para>
        /// <para>Represents the following attribute in the schema: avgSubtotal</para>
        /// </summary>
        public BooleanValue? AverageSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Maximum Filter</para>
        /// <para>Represents the following attribute in the schema: maxSubtotal</para>
        /// </summary>
        public BooleanValue? MaxSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Minimum Filter</para>
        /// <para>Represents the following attribute in the schema: minSubtotal</para>
        /// </summary>
        public BooleanValue? MinSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Product Filter</para>
        /// <para>Represents the following attribute in the schema: productSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyProductInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Count Subtotal</para>
        /// <para>Represents the following attribute in the schema: countSubtotal</para>
        /// </summary>
        public BooleanValue? CountSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include StdDev Filter</para>
        /// <para>Represents the following attribute in the schema: stdDevSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyStandardDeviationInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include StdDevP Filter</para>
        /// <para>Represents the following attribute in the schema: stdDevPSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyStandardDeviationPInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Var Filter</para>
        /// <para>Represents the following attribute in the schema: varSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyVarianceInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include VarP Filter</para>
        /// <para>Represents the following attribute in the schema: varPSubtotal</para>
        /// </summary>
        public BooleanValue? ApplyVariancePInSubtotal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:reference");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldItem>();
            builder.AddElement<PivotAreaReference>()
                .AddAttribute("field", a => a.Field)
                .AddAttribute("count", a => a.Count)
                .AddAttribute("selected", a => a.Selected)
                .AddAttribute("byPosition", a => a.ByPosition)
                .AddAttribute("relative", a => a.Relative)
                .AddAttribute("defaultSubtotal", a => a.DefaultSubtotal)
                .AddAttribute("sumSubtotal", a => a.SumSubtotal)
                .AddAttribute("countASubtotal", a => a.CountASubtotal)
                .AddAttribute("avgSubtotal", a => a.AverageSubtotal)
                .AddAttribute("maxSubtotal", a => a.MaxSubtotal)
                .AddAttribute("minSubtotal", a => a.MinSubtotal)
                .AddAttribute("productSubtotal", a => a.ApplyProductInSubtotal)
                .AddAttribute("countSubtotal", a => a.CountSubtotal)
                .AddAttribute("stdDevSubtotal", a => a.ApplyStandardDeviationInSubtotal)
                .AddAttribute("stdDevPSubtotal", a => a.ApplyStandardDeviationPInSubtotal)
                .AddAttribute("varSubtotal", a => a.ApplyVarianceInSubtotal)
                .AddAttribute("varPSubtotal", a => a.ApplyVariancePInSubtotal);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldItem), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotAreaReference>(deep);
    }

    /// <summary>
    /// <para>Query table fields.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryTableFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableField" /> <c>&lt;x:queryTableField></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableFields class.
        /// </summary>
        public QueryTableFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Column Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryTableFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableField>();
            builder.AddElement<QueryTableFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableField), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableFields>(deep);
    }

    /// <summary>
    /// <para>Deleted Fields.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryTableDeletedFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DeletedField" /> <c>&lt;x:deletedField></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableDeletedFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableDeletedFields class.
        /// </summary>
        public QueryTableDeletedFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableDeletedFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableDeletedFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableDeletedFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableDeletedFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableDeletedFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableDeletedFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Deleted Fields Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryTableDeletedFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DeletedField>();
            builder.AddElement<QueryTableDeletedFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DeletedField), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableDeletedFields>(deep);
    }

    /// <summary>
    /// <para>Deleted Field.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:deletedField.</para>
    /// </summary>
    public partial class DeletedField : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DeletedField class.
        /// </summary>
        public DeletedField() : base()
        {
        }

        /// <summary>
        /// <para>Deleted Fields Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:deletedField");
            builder.AddElement<DeletedField>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DeletedField>(deep);
    }

    /// <summary>
    /// <para>QueryTable Field.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryTableField.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableField : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableField class.
        /// </summary>
        public QueryTableField() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableField(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableField class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableField(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableField class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableField(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Bound Column</para>
        /// <para>Represents the following attribute in the schema: dataBound</para>
        /// </summary>
        public BooleanValue? DataBound
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Row Numbers</para>
        /// <para>Represents the following attribute in the schema: rowNumbers</para>
        /// </summary>
        public BooleanValue? RowNumbers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fill This Formula On Refresh</para>
        /// <para>Represents the following attribute in the schema: fillFormulas</para>
        /// </summary>
        public BooleanValue? FillFormulas
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Clipped Column</para>
        /// <para>Represents the following attribute in the schema: clipped</para>
        /// </summary>
        public BooleanValue? Clipped
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Column Id</para>
        /// <para>Represents the following attribute in the schema: tableColumnId</para>
        /// </summary>
        public UInt32Value? TableColumnId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryTableField");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<QueryTableField>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name)
                .AddAttribute("dataBound", a => a.DataBound)
                .AddAttribute("rowNumbers", a => a.RowNumbers)
                .AddAttribute("fillFormulas", a => a.FillFormulas)
                .AddAttribute("clipped", a => a.Clipped)
                .AddAttribute("tableColumnId", a => a.TableColumnId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 0, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:dataBound"), builder.CreateQName("x:clipped"), new string[] { "true" }, new string[] { "true" }));
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:dataBound"), builder.CreateQName("x:fillFormulas"), new string[] { "false" }, new string[] { "true" }));
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:dataBound"), builder.CreateQName("x:rowNumbers"), new string[] { "true" }, new string[] { "true" }));
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableField>(deep);
    }

    /// <summary>
    /// <para>String Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:si.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties" /> <c>&lt;x:phoneticPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticRun" /> <c>&lt;x:rPh></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Run" /> <c>&lt;x:r></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class SharedStringItem : RstType
    {
        /// <summary>
        /// Initializes a new instance of the SharedStringItem class.
        /// </summary>
        public SharedStringItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedStringItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedStringItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedStringItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SharedStringItem(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:si");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Text), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Run), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticRun), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SharedStringItem>(deep);
    }

    /// <summary>
    /// <para>Rich Text Inline.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:is.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties" /> <c>&lt;x:phoneticPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticRun" /> <c>&lt;x:rPh></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Run" /> <c>&lt;x:r></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class InlineString : RstType
    {
        /// <summary>
        /// Initializes a new instance of the InlineString class.
        /// </summary>
        public InlineString() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the InlineString class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public InlineString(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the InlineString class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public InlineString(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the InlineString class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public InlineString(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:is");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Text), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Run), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticRun), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<InlineString>(deep);
    }

    /// <summary>
    /// <para>Comment Text.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:text.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties" /> <c>&lt;x:phoneticPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticRun" /> <c>&lt;x:rPh></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Run" /> <c>&lt;x:r></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class CommentText : RstType
    {
        /// <summary>
        /// Initializes a new instance of the CommentText class.
        /// </summary>
        public CommentText() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentText class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentText(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentText class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentText(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentText class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CommentText(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:text");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Text), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Run), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticRun), 0, 32767),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CommentText>(deep);
    }

    /// <summary>
    /// <para>Defines the RstType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties" /> <c>&lt;x:phoneticPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PhoneticRun" /> <c>&lt;x:rPh></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Run" /> <c>&lt;x:r></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class RstType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RstType class.
        /// </summary>
        protected RstType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RstType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected RstType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RstType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected RstType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RstType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected RstType(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PhoneticProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PhoneticRun>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Run>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Text>();
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: x:t.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Text? Text
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Text>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>Bold.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:b.</para>
    /// </summary>
    public partial class Bold : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Bold class.
        /// </summary>
        public Bold() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:b");
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Bold>(deep);
    }

    /// <summary>
    /// <para>Italic.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:i.</para>
    /// </summary>
    public partial class Italic : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Italic class.
        /// </summary>
        public Italic() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:i");
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:i"), ".", null, builder.CreateQName("x:dataField"), "x:dataField", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Italic>(deep);
    }

    /// <summary>
    /// <para>Strike Through.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:strike.</para>
    /// </summary>
    public partial class Strike : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Strike class.
        /// </summary>
        public Strike() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:strike");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Strike>(deep);
    }

    /// <summary>
    /// <para>Condense.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:condense.</para>
    /// </summary>
    public partial class Condense : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Condense class.
        /// </summary>
        public Condense() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:condense");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Condense>(deep);
    }

    /// <summary>
    /// <para>Extend.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extend.</para>
    /// </summary>
    public partial class Extend : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Extend class.
        /// </summary>
        public Extend() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extend");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Extend>(deep);
    }

    /// <summary>
    /// <para>Outline.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:outline.</para>
    /// </summary>
    public partial class Outline : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Outline class.
        /// </summary>
        public Outline() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:outline");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Outline>(deep);
    }

    /// <summary>
    /// <para>Shadow.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:shadow.</para>
    /// </summary>
    public partial class Shadow : BooleanPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the Shadow class.
        /// </summary>
        public Shadow() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:shadow");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Shadow>(deep);
    }

    /// <summary>
    /// <para>Defines the BooleanPropertyType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class BooleanPropertyType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the BooleanPropertyType class.
        /// </summary>
        protected BooleanPropertyType() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public BooleanValue? Val
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<BooleanPropertyType>()
                .AddAttribute("val", a => a.Val);
        }
    }

    /// <summary>
    /// <para>Underline.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:u.</para>
    /// </summary>
    public partial class Underline : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Underline class.
        /// </summary>
        public Underline() : base()
        {
        }

        /// <summary>
        /// <para>Underline Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.UnderlineValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.UnderlineValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:u");
            builder.AddElement<Underline>()
                .AddAttribute("val", a => a.Val);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Underline>(deep);
    }

    /// <summary>
    /// <para>Vertical Alignment.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:vertAlign.</para>
    /// </summary>
    public partial class VerticalTextAlignment : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the VerticalTextAlignment class.
        /// </summary>
        public VerticalTextAlignment() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentRunValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentRunValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:vertAlign");
            builder.AddElement<VerticalTextAlignment>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VerticalTextAlignment>(deep);
    }

    /// <summary>
    /// <para>Font Size.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sz.</para>
    /// </summary>
    public partial class FontSize : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FontSize class.
        /// </summary>
        public FontSize() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sz");
            builder.AddElement<FontSize>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, 1, true, 409.55, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontSize>(deep);
    }

    /// <summary>
    /// <para>Text Color.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:color.</para>
    /// </summary>
    public partial class Color : ColorType
    {
        /// <summary>
        /// Initializes a new instance of the Color class.
        /// </summary>
        public Color() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:color");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tint"), true, -1, true, 1, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:indexed"), true, double.NegativeInfinity, true, 255, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:theme"), true, 0, true, 255, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Color>(deep);
    }

    /// <summary>
    /// <para>Sheet Tab Color.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tabColor.</para>
    /// </summary>
    public partial class TabColor : ColorType
    {
        /// <summary>
        /// Initializes a new instance of the TabColor class.
        /// </summary>
        public TabColor() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tabColor");
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:auto"), builder.CreateQName("x:indexed"), builder.CreateQName("x:rgb"), builder.CreateQName("x:theme")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tint"), true, -1, true, 1, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TabColor>(deep);
    }

    /// <summary>
    /// <para>Foreground Color.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fgColor.</para>
    /// </summary>
    public partial class ForegroundColor : ColorType
    {
        /// <summary>
        /// Initializes a new instance of the ForegroundColor class.
        /// </summary>
        public ForegroundColor() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fgColor");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tint"), true, -1, true, 1, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ForegroundColor>(deep);
    }

    /// <summary>
    /// <para>Background Color.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:bgColor.</para>
    /// </summary>
    public partial class BackgroundColor : ColorType
    {
        /// <summary>
        /// Initializes a new instance of the BackgroundColor class.
        /// </summary>
        public BackgroundColor() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:bgColor");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tint"), true, -1, true, 1, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BackgroundColor>(deep);
    }

    /// <summary>
    /// <para>Defines the ColorType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class ColorType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorType class.
        /// </summary>
        protected ColorType() : base()
        {
        }

        /// <summary>
        /// <para>Automatic</para>
        /// <para>Represents the following attribute in the schema: auto</para>
        /// </summary>
        public BooleanValue? Auto
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Index</para>
        /// <para>Represents the following attribute in the schema: indexed</para>
        /// </summary>
        public UInt32Value? Indexed
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Alpha Red Green Blue Color Value</para>
        /// <para>Represents the following attribute in the schema: rgb</para>
        /// </summary>
        public HexBinaryValue? Rgb
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Theme Color</para>
        /// <para>Represents the following attribute in the schema: theme</para>
        /// </summary>
        public UInt32Value? Theme
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Tint</para>
        /// <para>Represents the following attribute in the schema: tint</para>
        /// </summary>
        public DoubleValue? Tint
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<ColorType>()
                .AddAttribute("auto", a => a.Auto)
                .AddAttribute("indexed", a => a.Indexed)
                .AddAttribute("rgb", a => a.Rgb, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("theme", a => a.Theme)
                .AddAttribute("tint", a => a.Tint);
        }
    }

    /// <summary>
    /// <para>Font.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rFont.</para>
    /// </summary>
    public partial class RunFont : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RunFont class.
        /// </summary>
        public RunFont() : base()
        {
        }

        /// <summary>
        /// <para>String Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rFont");
            builder.AddElement<RunFont>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:val"), 0, 31));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RunFont>(deep);
    }

    /// <summary>
    /// <para>Font Family.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:family.</para>
    /// </summary>
    public partial class FontFamily : InternationalPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the FontFamily class.
        /// </summary>
        public FontFamily() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:family");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, 0, true, 5, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontFamily>(deep);
    }

    /// <summary>
    /// <para>Character Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:charset.</para>
    /// </summary>
    public partial class RunPropertyCharSet : InternationalPropertyType
    {
        /// <summary>
        /// Initializes a new instance of the RunPropertyCharSet class.
        /// </summary>
        public RunPropertyCharSet() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:charset");
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, 0, true, 255, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RunPropertyCharSet>(deep);
    }

    /// <summary>
    /// <para>Defines the InternationalPropertyType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class InternationalPropertyType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the InternationalPropertyType class.
        /// </summary>
        protected InternationalPropertyType() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<InternationalPropertyType>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }
    }

    /// <summary>
    /// <para>Font Scheme.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:scheme.</para>
    /// </summary>
    public partial class FontScheme : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FontScheme class.
        /// </summary>
        public FontScheme() : base()
        {
        }

        /// <summary>
        /// <para>Font Scheme</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FontSchemeValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FontSchemeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:scheme");
            builder.AddElement<FontScheme>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontScheme>(deep);
    }

    /// <summary>
    /// <para>Run Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Bold" /> <c>&lt;x:b></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Italic" /> <c>&lt;x:i></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Strike" /> <c>&lt;x:strike></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Condense" /> <c>&lt;x:condense></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Extend" /> <c>&lt;x:extend></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Outline" /> <c>&lt;x:outline></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Shadow" /> <c>&lt;x:shadow></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RunFont" /> <c>&lt;x:rFont></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontScheme" /> <c>&lt;x:scheme></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontSize" /> <c>&lt;x:sz></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontFamily" /> <c>&lt;x:family></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RunPropertyCharSet" /> <c>&lt;x:charset></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Underline" /> <c>&lt;x:u></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment" /> <c>&lt;x:vertAlign></c></description></item>
    /// </list>
    /// </remark>
    public partial class RunProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RunProperties class.
        /// </summary>
        public RunProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RunProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RunProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RunProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RunProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RunProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RunProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Bold>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Italic>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Strike>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Condense>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Extend>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Outline>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Shadow>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RunFont>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontScheme>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontSize>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontFamily>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RunPropertyCharSet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Underline>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Bold), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Italic), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Strike), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Condense), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Extend), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Outline), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Shadow), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Underline), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontSize), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RunFont), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontFamily), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RunPropertyCharSet), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontScheme), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RunProperties>(deep);
    }

    /// <summary>
    /// <para>Rich Text Run.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:r.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RunProperties" /> <c>&lt;x:rPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class Run : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Run class.
        /// </summary>
        public Run() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Run class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Run(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Run class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Run(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Run class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Run(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:r");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RunProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Text>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RunProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Text), 1, 1)
            };
        }

        /// <summary>
        /// <para>Run Properties.</para>
        /// <para>Represents the following element tag in the schema: x:rPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RunProperties? RunProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RunProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: x:t.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Text? Text
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Text>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Run>(deep);
    }

    /// <summary>
    /// <para>Phonetic Run.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rPh.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Text" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class PhoneticRun : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PhoneticRun class.
        /// </summary>
        public PhoneticRun() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PhoneticRun class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PhoneticRun(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PhoneticRun class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PhoneticRun(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PhoneticRun class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PhoneticRun(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Base Text Start Index</para>
        /// <para>Represents the following attribute in the schema: sb</para>
        /// </summary>
        public UInt32Value? BaseTextStartIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Base Text End Index</para>
        /// <para>Represents the following attribute in the schema: eb</para>
        /// </summary>
        public UInt32Value? EndingBaseIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rPh");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Text>();
            builder.AddElement<PhoneticRun>()
                .AddAttribute("sb", a => a.BaseTextStartIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("eb", a => a.EndingBaseIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Text), 1, 1)
            };
            builder.AddConstraint(new AttributeValueLessEqualToAnother(builder.CreateQName("x:sb"), builder.CreateQName("x:eb"), false));
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: x:t.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Text? Text
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Text>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PhoneticRun>(deep);
    }

    /// <summary>
    /// <para>Phonetic Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:phoneticPr.</para>
    /// </summary>
    public partial class PhoneticProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PhoneticProperties class.
        /// </summary>
        public PhoneticProperties() : base()
        {
        }

        /// <summary>
        /// <para>Font Id</para>
        /// <para>Represents the following attribute in the schema: fontId</para>
        /// </summary>
        public UInt32Value? FontId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Character Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Alignment</para>
        /// <para>Represents the following attribute in the schema: alignment</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticAlignmentValues>? Alignment
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticAlignmentValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:phoneticPr");
            builder.AddElement<PhoneticProperties>()
                .AddAttribute("fontId", a => a.FontId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("type", a => a.Type)
                .AddAttribute("alignment", a => a.Alignment);
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fontId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:font"), "x:font", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PhoneticProperties>(deep);
    }

    /// <summary>
    /// <para>Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:header.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ReviewedList" /> <c>&lt;x:reviewedList></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetIdMap" /> <c>&lt;x:sheetIdMap></c></description></item>
    /// </list>
    /// </remark>
    public partial class Header : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Header class.
        /// </summary>
        public Header() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Header class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Header(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Header class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Header(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Header class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Header(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Date Time</para>
        /// <para>Represents the following attribute in the schema: dateTime</para>
        /// </summary>
        public DateTimeValue? DateTime
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Last Sheet Id</para>
        /// <para>Represents the following attribute in the schema: maxSheetId</para>
        /// </summary>
        public UInt32Value? MaxSheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Name</para>
        /// <para>Represents the following attribute in the schema: userName</para>
        /// </summary>
        public StringValue? UserName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship ID</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Revision Id</para>
        /// <para>Represents the following attribute in the schema: minRId</para>
        /// </summary>
        public UInt32Value? MinRevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Max Revision Id</para>
        /// <para>Represents the following attribute in the schema: maxRId</para>
        /// </summary>
        public UInt32Value? MaxRevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:header");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ReviewedList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetIdMap>();
            builder.AddElement<Header>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("dateTime", a => a.DateTime, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("maxSheetId", a => a.MaxSheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("userName", a => a.UserName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minRId", a => a.MinRevisionId)
                .AddAttribute("maxRId", a => a.MaxRevisionId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetIdMap), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ReviewedList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:maxSheetId"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:userName"), 1, 54) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:minRId"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Sheet Id Map.</para>
        /// <para>Represents the following element tag in the schema: x:sheetIdMap.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetIdMap? SheetIdMap
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetIdMap>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Reviewed List.</para>
        /// <para>Represents the following element tag in the schema: x:reviewedList.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ReviewedList? ReviewedList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ReviewedList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Header>(deep);
    }

    /// <summary>
    /// <para>Revision Row Column Insert Delete.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rrc.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange" /> <c>&lt;x:rcc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionFormat" /> <c>&lt;x:rfmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Undo" /> <c>&lt;x:undo></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionRowColumn : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionRowColumn class.
        /// </summary>
        public RevisionRowColumn() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionRowColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionRowColumn(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionRowColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionRowColumn(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionRowColumn class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionRowColumn(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>End Of List</para>
        /// <para>Represents the following attribute in the schema: eol</para>
        /// </summary>
        public BooleanValue? EndOfList
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Action</para>
        /// <para>Represents the following attribute in the schema: action</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RowColumnActionValues>? Action
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.RowColumnActionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Edge Deleted</para>
        /// <para>Represents the following attribute in the schema: edge</para>
        /// </summary>
        public BooleanValue? Edge
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rrc");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Undo>();
            builder.AddElement<RevisionRowColumn>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("eol", a => a.EndOfList)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("action", a => a.Action, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("edge", a => a.Edge);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Undo), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionFormat), 0, 0)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sId"), 0, 32767));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionRowColumn>(deep);
    }

    /// <summary>
    /// <para>Revision Cell Move.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rm.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange" /> <c>&lt;x:rcc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RevisionFormat" /> <c>&lt;x:rfmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Undo" /> <c>&lt;x:undo></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionMove : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionMove class.
        /// </summary>
        public RevisionMove() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionMove class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionMove(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionMove class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionMove(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionMove class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionMove(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source</para>
        /// <para>Represents the following attribute in the schema: source</para>
        /// </summary>
        public StringValue? Source
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination</para>
        /// <para>Represents the following attribute in the schema: destination</para>
        /// </summary>
        public StringValue? Destination
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sourceSheetId</para>
        /// </summary>
        public UInt32Value? SourceSheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rm");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RevisionFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Undo>();
            builder.AddElement<RevisionMove>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("source", a => a.Source, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("destination", a => a.Destination, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceSheetId", a => a.SourceSheetId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Undo), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionCellChange), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RevisionFormat), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, double.NegativeInfinity, true, 32767, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sourceSheetId"), true, double.NegativeInfinity, true, 32767, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionMove>(deep);
    }

    /// <summary>
    /// <para>Revision Custom View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rcv.</para>
    /// </summary>
    public partial class RevisionCustomView : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionCustomView class.
        /// </summary>
        public RevisionCustomView() : base()
        {
        }

        /// <summary>
        /// <para>GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Action</para>
        /// <para>Represents the following attribute in the schema: action</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>? Action
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rcv");
            builder.AddElement<RevisionCustomView>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("action", a => a.Action, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionCustomView>(deep);
    }

    /// <summary>
    /// <para>Revision Sheet Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rsnm.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionSheetName : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionSheetName class.
        /// </summary>
        public RevisionSheetName() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionSheetName class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionSheetName(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionSheetName class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionSheetName(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionSheetName class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionSheetName(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Sheet Name</para>
        /// <para>Represents the following attribute in the schema: oldName</para>
        /// </summary>
        public StringValue? OldName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Sheet Name</para>
        /// <para>Represents the following attribute in the schema: newName</para>
        /// </summary>
        public StringValue? NewName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rsnm");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<RevisionSheetName>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("oldName", a => a.OldName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("newName", a => a.NewName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sheetId"), 0, 32767));
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionSheetName>(deep);
    }

    /// <summary>
    /// <para>Revision Insert Sheet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ris.</para>
    /// </summary>
    public partial class RevisionInsertSheet : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionInsertSheet class.
        /// </summary>
        public RevisionInsertSheet() : base()
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Position</para>
        /// <para>Represents the following attribute in the schema: sheetPosition</para>
        /// </summary>
        public UInt32Value? SheetPosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ris");
            builder.AddElement<RevisionInsertSheet>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sheetPosition", a => a.SheetPosition, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetPosition"), true, double.NegativeInfinity, true, 65533, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionInsertSheet>(deep);
    }

    /// <summary>
    /// <para>Revision Cell Change.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rcc.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OldCell" /> <c>&lt;x:oc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OldDifferentialFormat" /> <c>&lt;x:odxf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NewDifferentialFormat" /> <c>&lt;x:ndxf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NewCell" /> <c>&lt;x:nc></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionCellChange : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionCellChange class.
        /// </summary>
        public RevisionCellChange() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionCellChange class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionCellChange(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionCellChange class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionCellChange(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionCellChange class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionCellChange(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Formatting</para>
        /// <para>Represents the following attribute in the schema: odxf</para>
        /// </summary>
        public BooleanValue? OldFormatting
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Row Column Formatting Change</para>
        /// <para>Represents the following attribute in the schema: xfDxf</para>
        /// </summary>
        public BooleanValue? RowColumnFormattingAffected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style Revision</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public BooleanValue? StyleRevision
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Formatting</para>
        /// <para>Represents the following attribute in the schema: dxf</para>
        /// </summary>
        public BooleanValue? Format
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Format Id</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Quote Prefix</para>
        /// <para>Represents the following attribute in the schema: quotePrefix</para>
        /// </summary>
        public BooleanValue? QuotePrefix
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Quote Prefix</para>
        /// <para>Represents the following attribute in the schema: oldQuotePrefix</para>
        /// </summary>
        public BooleanValue? OldQuotePrefix
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Phonetic Text</para>
        /// <para>Represents the following attribute in the schema: ph</para>
        /// </summary>
        public BooleanValue? HasPhoneticText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Phonetic Text</para>
        /// <para>Represents the following attribute in the schema: oldPh</para>
        /// </summary>
        public BooleanValue? OldPhoneticText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>End of List  Formula Update</para>
        /// <para>Represents the following attribute in the schema: endOfListFormulaUpdate</para>
        /// </summary>
        public BooleanValue? EndOfListFormulaUpdate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rcc");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OldCell>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OldDifferentialFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NewDifferentialFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NewCell>();
            builder.AddElement<RevisionCellChange>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("odxf", a => a.OldFormatting)
                .AddAttribute("xfDxf", a => a.RowColumnFormattingAffected)
                .AddAttribute("s", a => a.StyleRevision)
                .AddAttribute("dxf", a => a.Format)
                .AddAttribute("numFmtId", a => a.NumberFormatId)
                .AddAttribute("quotePrefix", a => a.QuotePrefix)
                .AddAttribute("oldQuotePrefix", a => a.OldQuotePrefix)
                .AddAttribute("ph", a => a.HasPhoneticText)
                .AddAttribute("oldPh", a => a.OldPhoneticText)
                .AddAttribute("endOfListFormulaUpdate", a => a.EndOfListFormulaUpdate);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OldCell), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NewCell), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OldDifferentialFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NewDifferentialFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sId"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Old Cell Data.</para>
        /// <para>Represents the following element tag in the schema: x:oc.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OldCell? OldCell
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OldCell>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>New Cell Data.</para>
        /// <para>Represents the following element tag in the schema: x:nc.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.NewCell? NewCell
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.NewCell>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Old Formatting Information.</para>
        /// <para>Represents the following element tag in the schema: x:odxf.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OldDifferentialFormat? OldDifferentialFormat
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OldDifferentialFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>New Formatting Information.</para>
        /// <para>Represents the following element tag in the schema: x:ndxf.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.NewDifferentialFormat? NewDifferentialFormat
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.NewDifferentialFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionCellChange>(deep);
    }

    /// <summary>
    /// <para>Revision Format.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rfmt.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat" /> <c>&lt;x:dxf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionFormat : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionFormat class.
        /// </summary>
        public RevisionFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionFormat(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Row or Column Formatting Change</para>
        /// <para>Represents the following attribute in the schema: xfDxf</para>
        /// </summary>
        public BooleanValue? RowOrColumnAffected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public BooleanValue? StyleAffected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sequence Of References</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Start index</para>
        /// <para>Represents the following attribute in the schema: start</para>
        /// </summary>
        public UInt32Value? Start
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Length</para>
        /// <para>Represents the following attribute in the schema: length</para>
        /// </summary>
        public UInt32Value? Length
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rfmt");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<RevisionFormat>()
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("xfDxf", a => a.RowOrColumnAffected)
                .AddAttribute("s", a => a.StyleAffected)
                .AddAttribute("sqref", a => a.SequenceOfReferences, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("start", a => a.Start)
                .AddAttribute("length", a => a.Length);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 32767, true));
        }

        /// <summary>
        /// <para>Formatting.</para>
        /// <para>Represents the following element tag in the schema: x:dxf.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat? DifferentialFormat
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionFormat>(deep);
    }

    /// <summary>
    /// <para>Revision AutoFormat.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:raf.</para>
    /// </summary>
    public partial class RevisionAutoFormat : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionAutoFormat class.
        /// </summary>
        public RevisionAutoFormat() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Format Id</para>
        /// <para>Represents the following attribute in the schema: autoFormatId</para>
        /// </summary>
        public UInt32Value? AutoFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Number Formats</para>
        /// <para>Represents the following attribute in the schema: applyNumberFormats</para>
        /// </summary>
        public BooleanValue? ApplyNumberFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Border Formats</para>
        /// <para>Represents the following attribute in the schema: applyBorderFormats</para>
        /// </summary>
        public BooleanValue? ApplyBorderFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Font Formats</para>
        /// <para>Represents the following attribute in the schema: applyFontFormats</para>
        /// </summary>
        public BooleanValue? ApplyFontFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Pattern Formats</para>
        /// <para>Represents the following attribute in the schema: applyPatternFormats</para>
        /// </summary>
        public BooleanValue? ApplyPatternFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Alignment Formats</para>
        /// <para>Represents the following attribute in the schema: applyAlignmentFormats</para>
        /// </summary>
        public BooleanValue? ApplyAlignmentFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Width / Height Formats</para>
        /// <para>Represents the following attribute in the schema: applyWidthHeightFormats</para>
        /// </summary>
        public BooleanValue? ApplyWidthHeightFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:raf");
            builder.AddElement<RevisionAutoFormat>()
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("autoFormatId", a => a.AutoFormatId)
                .AddAttribute("applyNumberFormats", a => a.ApplyNumberFormats)
                .AddAttribute("applyBorderFormats", a => a.ApplyBorderFormats)
                .AddAttribute("applyFontFormats", a => a.ApplyFontFormats)
                .AddAttribute("applyPatternFormats", a => a.ApplyPatternFormats)
                .AddAttribute("applyAlignmentFormats", a => a.ApplyAlignmentFormats)
                .AddAttribute("applyWidthHeightFormats", a => a.ApplyWidthHeightFormats)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:autoFormatId"), true, 0, true, 16, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionAutoFormat>(deep);
    }

    /// <summary>
    /// <para>Revision Defined Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rdn.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Formula" /> <c>&lt;x:formula></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OldFormula" /> <c>&lt;x:oldFormula></c></description></item>
    /// </list>
    /// </remark>
    public partial class RevisionDefinedName : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionDefinedName class.
        /// </summary>
        public RevisionDefinedName() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionDefinedName class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionDefinedName(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionDefinedName class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RevisionDefinedName(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RevisionDefinedName class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RevisionDefinedName(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Local Name Sheet Id</para>
        /// <para>Represents the following attribute in the schema: localSheetId</para>
        /// </summary>
        public UInt32Value? LocalSheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom View</para>
        /// <para>Represents the following attribute in the schema: customView</para>
        /// </summary>
        public BooleanValue? CustomView
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Function</para>
        /// <para>Represents the following attribute in the schema: function</para>
        /// </summary>
        public BooleanValue? Function
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Function</para>
        /// <para>Represents the following attribute in the schema: oldFunction</para>
        /// </summary>
        public BooleanValue? OldFunction
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Function Group Id</para>
        /// <para>Represents the following attribute in the schema: functionGroupId</para>
        /// </summary>
        public ByteValue? FunctionGroupId
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Function Group Id</para>
        /// <para>Represents the following attribute in the schema: oldFunctionGroupId</para>
        /// </summary>
        public ByteValue? OldFunctionGroupId
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shortcut Key</para>
        /// <para>Represents the following attribute in the schema: shortcutKey</para>
        /// </summary>
        public ByteValue? ShortcutKey
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Short Cut Key</para>
        /// <para>Represents the following attribute in the schema: oldShortcutKey</para>
        /// </summary>
        public ByteValue? OldShortcutKey
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Named Range Hidden</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Hidden</para>
        /// <para>Represents the following attribute in the schema: oldHidden</para>
        /// </summary>
        public BooleanValue? OldHidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Custom Menu</para>
        /// <para>Represents the following attribute in the schema: customMenu</para>
        /// </summary>
        public StringValue? CustomMenu
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Custom Menu Text</para>
        /// <para>Represents the following attribute in the schema: oldCustomMenu</para>
        /// </summary>
        public StringValue? OldCustomMenu
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description</para>
        /// <para>Represents the following attribute in the schema: description</para>
        /// </summary>
        public StringValue? Description
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Description</para>
        /// <para>Represents the following attribute in the schema: oldDescription</para>
        /// </summary>
        public StringValue? OldDescription
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Help Topic</para>
        /// <para>Represents the following attribute in the schema: help</para>
        /// </summary>
        public StringValue? Help
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Help Topic</para>
        /// <para>Represents the following attribute in the schema: oldHelp</para>
        /// </summary>
        public StringValue? OldHelp
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Status Bar</para>
        /// <para>Represents the following attribute in the schema: statusBar</para>
        /// </summary>
        public StringValue? StatusBar
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Status Bar</para>
        /// <para>Represents the following attribute in the schema: oldStatusBar</para>
        /// </summary>
        public StringValue? OldStatusBar
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Name Comment</para>
        /// <para>Represents the following attribute in the schema: comment</para>
        /// </summary>
        public StringValue? Comment
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Name Comment</para>
        /// <para>Represents the following attribute in the schema: oldComment</para>
        /// </summary>
        public StringValue? OldComment
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rdn");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Formula>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OldFormula>();
            builder.AddElement<RevisionDefinedName>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("localSheetId", a => a.LocalSheetId)
                .AddAttribute("customView", a => a.CustomView)
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("function", a => a.Function)
                .AddAttribute("oldFunction", a => a.OldFunction)
                .AddAttribute("functionGroupId", a => a.FunctionGroupId)
                .AddAttribute("oldFunctionGroupId", a => a.OldFunctionGroupId)
                .AddAttribute("shortcutKey", a => a.ShortcutKey)
                .AddAttribute("oldShortcutKey", a => a.OldShortcutKey)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("oldHidden", a => a.OldHidden)
                .AddAttribute("customMenu", a => a.CustomMenu)
                .AddAttribute("oldCustomMenu", a => a.OldCustomMenu)
                .AddAttribute("description", a => a.Description)
                .AddAttribute("oldDescription", a => a.OldDescription)
                .AddAttribute("help", a => a.Help)
                .AddAttribute("oldHelp", a => a.OldHelp)
                .AddAttribute("statusBar", a => a.StatusBar)
                .AddAttribute("oldStatusBar", a => a.OldStatusBar)
                .AddAttribute("comment", a => a.Comment)
                .AddAttribute("oldComment", a => a.OldComment);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Formula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OldFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:functionGroupId"), true, 1, true, 14, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:localSheetId"), true, double.NegativeInfinity, true, 32767, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:customMenu"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:oldCustomMenu"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:description"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:oldDescription"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:help"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:oldHelp"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:statusBar"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:oldStatusBar"), 0, 32767));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:revisions")));
            builder.AddConstraint(new AttributeValuePatternConstraint(builder.CreateQName("x:name"), @"[a-zA-Z_\\][a-zA-Z0-9_.]*"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:comment"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:oldComment"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:rId"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Formula.</para>
        /// <para>Represents the following element tag in the schema: x:formula.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Formula? Formula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Formula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Old Formula.</para>
        /// <para>Represents the following element tag in the schema: x:oldFormula.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OldFormula? OldFormula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OldFormula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionDefinedName>(deep);
    }

    /// <summary>
    /// <para>Revision Cell Comment.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rcmt.</para>
    /// </summary>
    public partial class RevisionComment : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionComment class.
        /// </summary>
        public RevisionComment() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell</para>
        /// <para>Represents the following attribute in the schema: cell</para>
        /// </summary>
        public StringValue? Cell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Action</para>
        /// <para>Represents the following attribute in the schema: action</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>? Action
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Always Show Comment</para>
        /// <para>Represents the following attribute in the schema: alwaysShow</para>
        /// </summary>
        public BooleanValue? AlwaysShow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Old Comment</para>
        /// <para>Represents the following attribute in the schema: old</para>
        /// </summary>
        public BooleanValue? Old
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Comment In Hidden Row</para>
        /// <para>Represents the following attribute in the schema: hiddenRow</para>
        /// </summary>
        public BooleanValue? HiddenRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Column</para>
        /// <para>Represents the following attribute in the schema: hiddenColumn</para>
        /// </summary>
        public BooleanValue? HiddenColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Author</para>
        /// <para>Represents the following attribute in the schema: author</para>
        /// </summary>
        public StringValue? Author
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Original Comment Length</para>
        /// <para>Represents the following attribute in the schema: oldLength</para>
        /// </summary>
        public UInt32Value? OldLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>New Comment Length</para>
        /// <para>Represents the following attribute in the schema: newLength</para>
        /// </summary>
        public UInt32Value? NewLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rcmt");
            builder.AddElement<RevisionComment>()
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("cell", a => a.Cell, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("action", a => a.Action)
                .AddAttribute("alwaysShow", a => a.AlwaysShow)
                .AddAttribute("old", a => a.Old)
                .AddAttribute("hiddenRow", a => a.HiddenRow)
                .AddAttribute("hiddenColumn", a => a.HiddenColumn)
                .AddAttribute("author", a => a.Author, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("oldLength", a => a.OldLength)
                .AddAttribute("newLength", a => a.NewLength);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:author"), 1, 52));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionComment>(deep);
    }

    /// <summary>
    /// <para>Revision Query Table.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rqt.</para>
    /// </summary>
    public partial class RevisionQueryTable : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionQueryTable class.
        /// </summary>
        public RevisionQueryTable() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>QueryTable Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Id</para>
        /// <para>Represents the following attribute in the schema: fieldId</para>
        /// </summary>
        public UInt32Value? FieldId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rqt");
            builder.AddElement<RevisionQueryTable>()
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("fieldId", a => a.FieldId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionQueryTable>(deep);
    }

    /// <summary>
    /// <para>Revision Merge Conflict.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rcft.</para>
    /// </summary>
    public partial class RevisionConflict : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RevisionConflict class.
        /// </summary>
        public RevisionConflict() : base()
        {
        }

        /// <summary>
        /// <para>Revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision From Rejection</para>
        /// <para>Represents the following attribute in the schema: ua</para>
        /// </summary>
        public BooleanValue? Ua
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Undo Rejected</para>
        /// <para>Represents the following attribute in the schema: ra</para>
        /// </summary>
        public BooleanValue? Ra
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rcft");
            builder.AddElement<RevisionConflict>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ua", a => a.Ua)
                .AddAttribute("ra", a => a.Ra)
                .AddAttribute("sheetId", a => a.SheetId);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 32767, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RevisionConflict>(deep);
    }

    /// <summary>
    /// <para>Sheet Id Map.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetIdMap.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetId" /> <c>&lt;x:sheetId></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetIdMap : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetIdMap class.
        /// </summary>
        public SheetIdMap() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetIdMap class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetIdMap(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetIdMap class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetIdMap(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetIdMap class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetIdMap(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Sheet Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetIdMap");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetId>();
            builder.AddElement<SheetIdMap>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetId), 1, 65535)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetIdMap>(deep);
    }

    /// <summary>
    /// <para>Reviewed List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:reviewedList.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Reviewed" /> <c>&lt;x:reviewed></c></description></item>
    /// </list>
    /// </remark>
    public partial class ReviewedList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ReviewedList class.
        /// </summary>
        public ReviewedList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ReviewedList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ReviewedList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ReviewedList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ReviewedList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ReviewedList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ReviewedList(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Reviewed Revisions Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:reviewedList");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Reviewed>();
            builder.AddElement<ReviewedList>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Reviewed), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ReviewedList>(deep);
    }

    /// <summary>
    /// <para>Reviewed.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:reviewed.</para>
    /// </summary>
    public partial class Reviewed : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Reviewed class.
        /// </summary>
        public Reviewed() : base()
        {
        }

        /// <summary>
        /// <para>revision Id</para>
        /// <para>Represents the following attribute in the schema: rId</para>
        /// </summary>
        public UInt32Value? RevisionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:reviewed");
            builder.AddElement<Reviewed>()
                .AddAttribute("rId", a => a.RevisionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:rId"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Reviewed>(deep);
    }

    /// <summary>
    /// <para>Undo.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:undo.</para>
    /// </summary>
    public partial class Undo : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Undo class.
        /// </summary>
        public Undo() : base()
        {
        }

        /// <summary>
        /// <para>Index</para>
        /// <para>Represents the following attribute in the schema: index</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Expression</para>
        /// <para>Represents the following attribute in the schema: exp</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormulaExpressionValues>? Expression
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormulaExpressionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference 3D</para>
        /// <para>Represents the following attribute in the schema: ref3D</para>
        /// </summary>
        public BooleanValue? Reference3D
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Array Entered</para>
        /// <para>Represents the following attribute in the schema: array</para>
        /// </summary>
        public BooleanValue? Array
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value Needed</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public BooleanValue? Val
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Defined Name Formula</para>
        /// <para>Represents the following attribute in the schema: nf</para>
        /// </summary>
        public BooleanValue? DefinedNameFormula
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cross Sheet Move</para>
        /// <para>Represents the following attribute in the schema: cs</para>
        /// </summary>
        public BooleanValue? CrossSheetMove
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Range</para>
        /// <para>Represents the following attribute in the schema: dr</para>
        /// </summary>
        public StringValue? DeletedRange
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Defined Name</para>
        /// <para>Represents the following attribute in the schema: dn</para>
        /// </summary>
        public StringValue? DefinedName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:undo");
            builder.AddElement<Undo>()
                .AddAttribute("index", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("exp", a => a.Expression, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ref3D", a => a.Reference3D)
                .AddAttribute("array", a => a.Array)
                .AddAttribute("v", a => a.Val)
                .AddAttribute("nf", a => a.DefinedNameFormula)
                .AddAttribute("cs", a => a.CrossSheetMove)
                .AddAttribute("dr", a => a.DeletedRange, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("dn", a => a.DefinedName)
                .AddAttribute("r", a => a.CellReference)
                .AddAttribute("sId", a => a.SheetId);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sId"), true, double.NegativeInfinity, true, 32767, true));
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:ref3D"), builder.CreateQName("x:nf"), new string[] { "false" }, new string[] { "true" }));
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:dn"), builder.CreateQName("x:r")));
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:dn"), builder.CreateQName("x:sId")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Undo>(deep);
    }

    /// <summary>
    /// <para>Old Cell Data.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oc.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormula" /> <c>&lt;x:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.InlineString" /> <c>&lt;x:is></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellValue" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public partial class OldCell : CellType
    {
        /// <summary>
        /// Initializes a new instance of the OldCell class.
        /// </summary>
        public OldCell() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OldCell(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OldCell(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldCell class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OldCell(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oc");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellValue), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.InlineString), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:cm"), "/WorkbookPart/CellMetadataPart", null, builder.CreateQName("x:cellMetadata"), "x:cellMetadata", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:s"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:cellStyle"), "x:cellStyle", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:vm"), "/WorkbookPart/CellMetadataPart", null, builder.CreateQName("x:valueMetadata"), "x:valueMetadata", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OldCell>(deep);
    }

    /// <summary>
    /// <para>Cell.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:c.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormula" /> <c>&lt;x:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.InlineString" /> <c>&lt;x:is></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellValue" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public partial class Cell : CellType
    {
        /// <summary>
        /// Initializes a new instance of the Cell class.
        /// </summary>
        public Cell() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Cell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Cell(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Cell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Cell(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Cell class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Cell(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:c");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellValue), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.InlineString), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:cm"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:cm"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:cellMetadata"), builder.CreateQName("x:bk"), "x:bk", 1));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:vm"), true, double.NegativeInfinity, true, 2147483648, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:vm"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:valueMetadata"), builder.CreateQName("x:bk"), "x:bk", 1));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:s"), true, 0, true, 65490, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:s"), "/WorkbookPart/WorkbookStylesPart", builder.CreateQName("x:cellXfs"), builder.CreateQName("x:xf"), "x:xf", 0));
            builder.AddConstraint(new AttributeMutualExclusive(builder.CreateQName("x:l"), builder.CreateQName("x:s")));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:i"), "/WorkbookPart", builder.CreateQName("x:sheet"), "x:sheet", builder.CreateQName("x:sheetId")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:i"), true, 1, true, 65534, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Cell>(deep);
    }

    /// <summary>
    /// <para>Defines the CellType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormula" /> <c>&lt;x:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.InlineString" /> <c>&lt;x:is></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellValue" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class CellType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellType class.
        /// </summary>
        protected CellType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected CellType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected CellType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected CellType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style Index</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public UInt32Value? StyleIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Data Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>? DataType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Metadata Index</para>
        /// <para>Represents the following attribute in the schema: cm</para>
        /// </summary>
        public UInt32Value? CellMetaIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value Metadata Index</para>
        /// <para>Represents the following attribute in the schema: vm</para>
        /// </summary>
        public UInt32Value? ValueMetaIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Phonetic</para>
        /// <para>Represents the following attribute in the schema: ph</para>
        /// </summary>
        public BooleanValue? ShowPhonetic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.InlineString>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellValue>();
            builder.AddElement<CellType>()
                .AddAttribute("r", a => a.CellReference)
                .AddAttribute("s", a => a.StyleIndex)
                .AddAttribute("t", a => a.DataType)
                .AddAttribute("cm", a => a.CellMetaIndex)
                .AddAttribute("vm", a => a.ValueMetaIndex)
                .AddAttribute("ph", a => a.ShowPhonetic);
        }

        /// <summary>
        /// <para>Formula.</para>
        /// <para>Represents the following element tag in the schema: x:f.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellFormula? CellFormula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellFormula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Cell Value.</para>
        /// <para>Represents the following element tag in the schema: x:v.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellValue? CellValue
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellValue>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Rich Text Inline.</para>
        /// <para>Represents the following element tag in the schema: x:is.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.InlineString? InlineString
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.InlineString>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>New Cell Data.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:nc.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormula" /> <c>&lt;x:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.InlineString" /> <c>&lt;x:is></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellValue" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public partial class NewCell : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the NewCell class.
        /// </summary>
        public NewCell() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NewCell(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NewCell(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewCell class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NewCell(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style Index</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public UInt32Value? StyleIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Data Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>? DataType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Metadata Index</para>
        /// <para>Represents the following attribute in the schema: cm</para>
        /// </summary>
        public UInt32Value? CellMetaIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value Metadata Index</para>
        /// <para>Represents the following attribute in the schema: vm</para>
        /// </summary>
        public UInt32Value? ValueMetaIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Phonetic</para>
        /// <para>Represents the following attribute in the schema: ph</para>
        /// </summary>
        public BooleanValue? ShowPhonetic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:nc");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.InlineString>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellValue>();
            builder.AddElement<NewCell>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("s", a => a.StyleIndex)
                .AddAttribute("t", a => a.DataType)
                .AddAttribute("cm", a => a.CellMetaIndex)
                .AddAttribute("vm", a => a.ValueMetaIndex)
                .AddAttribute("ph", a => a.ShowPhonetic);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellValue), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.InlineString), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:cm"), true, new string[] { "0" }) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:vm"), true, new string[] { "0" }) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:s"), true, new string[] { "0" }) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Formula.</para>
        /// <para>Represents the following element tag in the schema: x:f.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellFormula? CellFormula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellFormula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Cell Value.</para>
        /// <para>Represents the following element tag in the schema: x:v.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CellValue? CellValue
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CellValue>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Rich Text Inline.</para>
        /// <para>Represents the following element tag in the schema: x:is.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.InlineString? InlineString
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.InlineString>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NewCell>(deep);
    }

    /// <summary>
    /// <para>Old Formatting Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:odxf.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Border" /> <c>&lt;x:border></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Alignment" /> <c>&lt;x:alignment></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Protection" /> <c>&lt;x:protection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fill" /> <c>&lt;x:fill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Font" /> <c>&lt;x:font></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormat" /> <c>&lt;x:numFmt></c></description></item>
    /// </list>
    /// </remark>
    public partial class OldDifferentialFormat : DifferentialFormatType
    {
        /// <summary>
        /// Initializes a new instance of the OldDifferentialFormat class.
        /// </summary>
        public OldDifferentialFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldDifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OldDifferentialFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldDifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OldDifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OldDifferentialFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OldDifferentialFormat(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:odxf");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Font), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberingFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fill), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Alignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Border), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Protection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OldDifferentialFormat>(deep);
    }

    /// <summary>
    /// <para>New Formatting Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ndxf.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Border" /> <c>&lt;x:border></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Alignment" /> <c>&lt;x:alignment></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Protection" /> <c>&lt;x:protection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fill" /> <c>&lt;x:fill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Font" /> <c>&lt;x:font></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormat" /> <c>&lt;x:numFmt></c></description></item>
    /// </list>
    /// </remark>
    public partial class NewDifferentialFormat : DifferentialFormatType
    {
        /// <summary>
        /// Initializes a new instance of the NewDifferentialFormat class.
        /// </summary>
        public NewDifferentialFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewDifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NewDifferentialFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewDifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NewDifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NewDifferentialFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NewDifferentialFormat(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ndxf");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Font), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberingFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fill), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Alignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Border), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Protection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NewDifferentialFormat>(deep);
    }

    /// <summary>
    /// <para>Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dxf.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Border" /> <c>&lt;x:border></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Alignment" /> <c>&lt;x:alignment></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Protection" /> <c>&lt;x:protection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fill" /> <c>&lt;x:fill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Font" /> <c>&lt;x:font></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormat" /> <c>&lt;x:numFmt></c></description></item>
    /// </list>
    /// </remark>
    public partial class DifferentialFormat : DifferentialFormatType
    {
        /// <summary>
        /// Initializes a new instance of the DifferentialFormat class.
        /// </summary>
        public DifferentialFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DifferentialFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DifferentialFormat(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dxf");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Font), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberingFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fill), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Alignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Border), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Protection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DifferentialFormat>(deep);
    }

    /// <summary>
    /// <para>Defines the DifferentialFormatType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Border" /> <c>&lt;x:border></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Alignment" /> <c>&lt;x:alignment></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Protection" /> <c>&lt;x:protection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fill" /> <c>&lt;x:fill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Font" /> <c>&lt;x:font></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormat" /> <c>&lt;x:numFmt></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class DifferentialFormatType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DifferentialFormatType class.
        /// </summary>
        protected DifferentialFormatType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormatType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected DifferentialFormatType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormatType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected DifferentialFormatType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormatType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected DifferentialFormatType(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Border>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Alignment>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Protection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Fill>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Font>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberingFormat>();
        }

        /// <summary>
        /// <para>Font Properties.</para>
        /// <para>Represents the following element tag in the schema: x:font.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Font? Font
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Font>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Number Format.</para>
        /// <para>Represents the following element tag in the schema: x:numFmt.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.NumberingFormat? NumberingFormat
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.NumberingFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Fill.</para>
        /// <para>Represents the following element tag in the schema: x:fill.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Fill? Fill
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Fill>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Alignment.</para>
        /// <para>Represents the following element tag in the schema: x:alignment.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Alignment? Alignment
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Alignment>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Border Properties.</para>
        /// <para>Represents the following element tag in the schema: x:border.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Border? Border
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Border>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Protection Properties.</para>
        /// <para>Represents the following element tag in the schema: x:protection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Protection? Protection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Protection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>Sheet Id.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetId.</para>
    /// </summary>
    public partial class SheetId : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetId class.
        /// </summary>
        public SheetId() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public UInt32Value? Val
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetId");
            builder.AddElement<SheetId>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, double.NegativeInfinity, true, 65535, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetId>(deep);
    }

    /// <summary>
    /// <para>Formula.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:f.</para>
    /// </summary>
    public partial class CellFormula : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the CellFormula class.
        /// </summary>
        public CellFormula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public CellFormula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>Formula Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellFormulaValues>? FormulaType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellFormulaValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Always Calculate Array</para>
        /// <para>Represents the following attribute in the schema: aca</para>
        /// </summary>
        public BooleanValue? AlwaysCalculateArray
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Range of Cells</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Table 2-D</para>
        /// <para>Represents the following attribute in the schema: dt2D</para>
        /// </summary>
        public BooleanValue? DataTable2D
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Table Row</para>
        /// <para>Represents the following attribute in the schema: dtr</para>
        /// </summary>
        public BooleanValue? DataTableRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Input 1 Deleted</para>
        /// <para>Represents the following attribute in the schema: del1</para>
        /// </summary>
        public BooleanValue? Input1Deleted
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Input 2 Deleted</para>
        /// <para>Represents the following attribute in the schema: del2</para>
        /// </summary>
        public BooleanValue? Input2Deleted
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Table Cell 1</para>
        /// <para>Represents the following attribute in the schema: r1</para>
        /// </summary>
        public StringValue? R1
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Input Cell 2</para>
        /// <para>Represents the following attribute in the schema: r2</para>
        /// </summary>
        public StringValue? R2
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculate Cell</para>
        /// <para>Represents the following attribute in the schema: ca</para>
        /// </summary>
        public BooleanValue? CalculateCell
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shared Group Index</para>
        /// <para>Represents the following attribute in the schema: si</para>
        /// </summary>
        public UInt32Value? SharedIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Assigns Value to Name</para>
        /// <para>Represents the following attribute in the schema: bx</para>
        /// </summary>
        public BooleanValue? Bx
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Content Contains Significant Whitespace</para>
        /// <para>Represents the following attribute in the schema: xml:space</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>? Space
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:f");
            builder.AddElement<CellFormula>()
                .AddAttribute("t", a => a.FormulaType)
                .AddAttribute("aca", a => a.AlwaysCalculateArray)
                .AddAttribute("ref", a => a.Reference)
                .AddAttribute("dt2D", a => a.DataTable2D)
                .AddAttribute("dtr", a => a.DataTableRow)
                .AddAttribute("del1", a => a.Input1Deleted)
                .AddAttribute("del2", a => a.Input2Deleted)
                .AddAttribute("r1", a => a.R1)
                .AddAttribute("r2", a => a.R2)
                .AddAttribute("ca", a => a.CalculateCell)
                .AddAttribute("si", a => a.SharedIndex)
                .AddAttribute("bx", a => a.Bx)
                .AddAttribute("xml:space", a => a.Space);
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:bx"), true, new string[] { "false" }));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:si"), builder.CreateQName("x:t") , "shared"));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellFormula>(deep);
    }

    /// <summary>
    /// <para>User Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:userInfo.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class UserInfo : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the UserInfo class.
        /// </summary>
        public UserInfo() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserInfo class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public UserInfo(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserInfo class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public UserInfo(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserInfo class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public UserInfo(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>User Revisions GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public Int32Value? Id
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Date Time</para>
        /// <para>Represents the following attribute in the schema: dateTime</para>
        /// </summary>
        public DateTimeValue? DateTime
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:userInfo");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<UserInfo>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("dateTime", a => a.DateTime, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<UserInfo>(deep);
    }

    /// <summary>
    /// <para>Row.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:row.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Cell" /> <c>&lt;x:c></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Row : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Row class.
        /// </summary>
        public Row() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Row class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Row(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Row class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Row(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Row class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Row(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Row Index</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public UInt32Value? RowIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Spans</para>
        /// <para>Represents the following attribute in the schema: spans</para>
        /// </summary>
        public ListValue<StringValue>? Spans
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style Index</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public UInt32Value? StyleIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Format</para>
        /// <para>Represents the following attribute in the schema: customFormat</para>
        /// </summary>
        public BooleanValue? CustomFormat
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Row Height</para>
        /// <para>Represents the following attribute in the schema: ht</para>
        /// </summary>
        public DoubleValue? Height
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Height</para>
        /// <para>Represents the following attribute in the schema: customHeight</para>
        /// </summary>
        public BooleanValue? CustomHeight
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline Level</para>
        /// <para>Represents the following attribute in the schema: outlineLevel</para>
        /// </summary>
        public ByteValue? OutlineLevel
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Collapsed</para>
        /// <para>Represents the following attribute in the schema: collapsed</para>
        /// </summary>
        public BooleanValue? Collapsed
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Thick Top Border</para>
        /// <para>Represents the following attribute in the schema: thickTop</para>
        /// </summary>
        public BooleanValue? ThickTop
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Thick Bottom</para>
        /// <para>Represents the following attribute in the schema: thickBot</para>
        /// </summary>
        public BooleanValue? ThickBot
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Phonetic</para>
        /// <para>Represents the following attribute in the schema: ph</para>
        /// </summary>
        public BooleanValue? ShowPhonetic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dyDescent, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: x14ac:dyDescent</para>
        /// </summary>
        /// <remark>
        /// xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
        /// </remark>
        public DoubleValue? DyDescent
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:row");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Cell>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<Row>()
                .AddAttribute("r", a => a.RowIndex)
                .AddAttribute("spans", a => a.Spans)
                .AddAttribute("s", a => a.StyleIndex)
                .AddAttribute("customFormat", a => a.CustomFormat)
                .AddAttribute("ht", a => a.Height)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("customHeight", a => a.CustomHeight)
                .AddAttribute("outlineLevel", a => a.OutlineLevel)
                .AddAttribute("collapsed", a => a.Collapsed)
                .AddAttribute("thickTop", a => a.ThickTop)
                .AddAttribute("thickBot", a => a.ThickBot)
                .AddAttribute("ph", a => a.ShowPhonetic)
                .AddAttribute("x14ac:dyDescent", a => a.DyDescent, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Cell), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:r"), true, 1, true, 1048576, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:outlineLevel"), true, 0, true, 7, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:s"), true, 0, true, 65490, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:r"), true, double.NegativeInfinity, true, 1048576, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Row>(deep);
    }

    /// <summary>
    /// <para>Column Width and Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:col.</para>
    /// </summary>
    public partial class Column : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Column class.
        /// </summary>
        public Column() : base()
        {
        }

        /// <summary>
        /// <para>Minimum Column</para>
        /// <para>Represents the following attribute in the schema: min</para>
        /// </summary>
        public UInt32Value? Min
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Column</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public UInt32Value? Max
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Column Width</para>
        /// <para>Represents the following attribute in the schema: width</para>
        /// </summary>
        public DoubleValue? Width
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style</para>
        /// <para>Represents the following attribute in the schema: style</para>
        /// </summary>
        public UInt32Value? Style
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Columns</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Best Fit Column Width</para>
        /// <para>Represents the following attribute in the schema: bestFit</para>
        /// </summary>
        public BooleanValue? BestFit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Width</para>
        /// <para>Represents the following attribute in the schema: customWidth</para>
        /// </summary>
        public BooleanValue? CustomWidth
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Phonetic Information</para>
        /// <para>Represents the following attribute in the schema: phonetic</para>
        /// </summary>
        public BooleanValue? Phonetic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline Level</para>
        /// <para>Represents the following attribute in the schema: outlineLevel</para>
        /// </summary>
        public ByteValue? OutlineLevel
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Collapsed</para>
        /// <para>Represents the following attribute in the schema: collapsed</para>
        /// </summary>
        public BooleanValue? Collapsed
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:col");
            builder.AddElement<Column>()
                .AddAttribute("min", a => a.Min, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("max", a => a.Max, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("width", a => a.Width)
                .AddAttribute("style", a => a.Style)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("bestFit", a => a.BestFit)
                .AddAttribute("customWidth", a => a.CustomWidth)
                .AddAttribute("phonetic", a => a.Phonetic)
                .AddAttribute("outlineLevel", a => a.OutlineLevel)
                .AddAttribute("collapsed", a => a.Collapsed);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:outlineLevel"), true, 0, true, 7, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:min"), true, 1, true, 16384, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:max"), true, 1, true, 16384, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:width"), true, 0, true, 255, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:style"), true, 0, true, 65429, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:style"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:xf"), "x:xf", 0));
            builder.AddConstraint(new AttributeValueLessEqualToAnother(builder.CreateQName("x:min"), builder.CreateQName("x:max"), true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Column>(deep);
    }

    /// <summary>
    /// <para>Outline Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:outlinePr.</para>
    /// </summary>
    public partial class OutlineProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the OutlineProperties class.
        /// </summary>
        public OutlineProperties() : base()
        {
        }

        /// <summary>
        /// <para>Apply Styles in Outline</para>
        /// <para>Represents the following attribute in the schema: applyStyles</para>
        /// </summary>
        public BooleanValue? ApplyStyles
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Summary Below</para>
        /// <para>Represents the following attribute in the schema: summaryBelow</para>
        /// </summary>
        public BooleanValue? SummaryBelow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Summary Right</para>
        /// <para>Represents the following attribute in the schema: summaryRight</para>
        /// </summary>
        public BooleanValue? SummaryRight
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Outline Symbols</para>
        /// <para>Represents the following attribute in the schema: showOutlineSymbols</para>
        /// </summary>
        public BooleanValue? ShowOutlineSymbols
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:outlinePr");
            builder.AddElement<OutlineProperties>()
                .AddAttribute("applyStyles", a => a.ApplyStyles)
                .AddAttribute("summaryBelow", a => a.SummaryBelow)
                .AddAttribute("summaryRight", a => a.SummaryRight)
                .AddAttribute("showOutlineSymbols", a => a.ShowOutlineSymbols);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OutlineProperties>(deep);
    }

    /// <summary>
    /// <para>Page Setup Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageSetUpPr.</para>
    /// </summary>
    public partial class PageSetupProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PageSetupProperties class.
        /// </summary>
        public PageSetupProperties() : base()
        {
        }

        /// <summary>
        /// <para>Show Auto Page Breaks</para>
        /// <para>Represents the following attribute in the schema: autoPageBreaks</para>
        /// </summary>
        public BooleanValue? AutoPageBreaks
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fit To Page</para>
        /// <para>Represents the following attribute in the schema: fitToPage</para>
        /// </summary>
        public BooleanValue? FitToPage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageSetUpPr");
            builder.AddElement<PageSetupProperties>()
                .AddAttribute("autoPageBreaks", a => a.AutoPageBreaks)
                .AddAttribute("fitToPage", a => a.FitToPage);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageSetupProperties>(deep);
    }

    /// <summary>
    /// <para>View Pane.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pane.</para>
    /// </summary>
    public partial class Pane : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Pane class.
        /// </summary>
        public Pane() : base()
        {
        }

        /// <summary>
        /// <para>Horizontal Split Position</para>
        /// <para>Represents the following attribute in the schema: xSplit</para>
        /// </summary>
        public DoubleValue? HorizontalSplit
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical Split Position</para>
        /// <para>Represents the following attribute in the schema: ySplit</para>
        /// </summary>
        public DoubleValue? VerticalSplit
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Visible Cell</para>
        /// <para>Represents the following attribute in the schema: topLeftCell</para>
        /// </summary>
        public StringValue? TopLeftCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Pane</para>
        /// <para>Represents the following attribute in the schema: activePane</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>? ActivePane
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Split State</para>
        /// <para>Represents the following attribute in the schema: state</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneStateValues>? State
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneStateValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pane");
            builder.AddElement<Pane>()
                .AddAttribute("xSplit", a => a.HorizontalSplit)
                .AddAttribute("ySplit", a => a.VerticalSplit)
                .AddAttribute("topLeftCell", a => a.TopLeftCell)
                .AddAttribute("activePane", a => a.ActivePane)
                .AddAttribute("state", a => a.State);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Pane>(deep);
    }

    /// <summary>
    /// <para>Selection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:selection.</para>
    /// </summary>
    public partial class Selection : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Selection class.
        /// </summary>
        public Selection() : base()
        {
        }

        /// <summary>
        /// <para>Pane</para>
        /// <para>Represents the following attribute in the schema: pane</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>? Pane
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Cell Location</para>
        /// <para>Represents the following attribute in the schema: activeCell</para>
        /// </summary>
        public StringValue? ActiveCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Cell Index</para>
        /// <para>Represents the following attribute in the schema: activeCellId</para>
        /// </summary>
        public UInt32Value? ActiveCellId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sequence of References</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:selection");
            builder.AddElement<Selection>()
                .AddAttribute("pane", a => a.Pane)
                .AddAttribute("activeCell", a => a.ActiveCell)
                .AddAttribute("activeCellId", a => a.ActiveCellId)
                .AddAttribute("sqref", a => a.SequenceOfReferences);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:activeCell"), true, double.NegativeInfinity, true, 8191, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Selection>(deep);
    }

    /// <summary>
    /// <para>PivotTable Selection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotSelection.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotSelection : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotSelection class.
        /// </summary>
        public PivotSelection() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotSelection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotSelection(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotSelection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotSelection(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotSelection class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotSelection(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Pane</para>
        /// <para>Represents the following attribute in the schema: pane</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>? Pane
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Header</para>
        /// <para>Represents the following attribute in the schema: showHeader</para>
        /// </summary>
        public BooleanValue? ShowHeader
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Label</para>
        /// <para>Represents the following attribute in the schema: label</para>
        /// </summary>
        public BooleanValue? Label
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Selection</para>
        /// <para>Represents the following attribute in the schema: data</para>
        /// </summary>
        public BooleanValue? Data
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Extendable</para>
        /// <para>Represents the following attribute in the schema: extendable</para>
        /// </summary>
        public BooleanValue? Extendable
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Selection Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>? Axis
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dimension</para>
        /// <para>Represents the following attribute in the schema: dimension</para>
        /// </summary>
        public UInt32Value? Dimension
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Start</para>
        /// <para>Represents the following attribute in the schema: start</para>
        /// </summary>
        public UInt32Value? Start
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum</para>
        /// <para>Represents the following attribute in the schema: min</para>
        /// </summary>
        public UInt32Value? Min
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public UInt32Value? Max
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Row</para>
        /// <para>Represents the following attribute in the schema: activeRow</para>
        /// </summary>
        public UInt32Value? ActiveRow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Column</para>
        /// <para>Represents the following attribute in the schema: activeCol</para>
        /// </summary>
        public UInt32Value? ActiveColumn
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Previous Row</para>
        /// <para>Represents the following attribute in the schema: previousRow</para>
        /// </summary>
        public UInt32Value? PreviousRow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Previous Column Selection</para>
        /// <para>Represents the following attribute in the schema: previousCol</para>
        /// </summary>
        public UInt32Value? PreviousColumn
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Click Count</para>
        /// <para>Represents the following attribute in the schema: click</para>
        /// </summary>
        public UInt32Value? Click
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotSelection");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.AddElement<PivotSelection>()
                .AddAttribute("pane", a => a.Pane)
                .AddAttribute("showHeader", a => a.ShowHeader)
                .AddAttribute("label", a => a.Label)
                .AddAttribute("data", a => a.Data)
                .AddAttribute("extendable", a => a.Extendable)
                .AddAttribute("count", a => a.Count)
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("dimension", a => a.Dimension)
                .AddAttribute("start", a => a.Start)
                .AddAttribute("min", a => a.Min)
                .AddAttribute("max", a => a.Max)
                .AddAttribute("activeRow", a => a.ActiveRow)
                .AddAttribute("activeCol", a => a.ActiveColumn)
                .AddAttribute("previousRow", a => a.PreviousRow)
                .AddAttribute("previousCol", a => a.PreviousColumn)
                .AddAttribute("click", a => a.Click)
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 1, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:axis"), false, new string[] { "axisValues" }));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:previousCol"), true, double.NegativeInfinity, true, 16383, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:previousRow"), true, double.NegativeInfinity, true, 1048575, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Pivot Area.</para>
        /// <para>Represents the following element tag in the schema: x:pivotArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotArea? PivotArea
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotSelection>(deep);
    }

    /// <summary>
    /// <para>Break.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:brk.</para>
    /// </summary>
    public partial class Break : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Break class.
        /// </summary>
        public Break() : base()
        {
        }

        /// <summary>
        /// <para>Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum</para>
        /// <para>Represents the following attribute in the schema: min</para>
        /// </summary>
        public UInt32Value? Min
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public UInt32Value? Max
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Manual Page Break</para>
        /// <para>Represents the following attribute in the schema: man</para>
        /// </summary>
        public BooleanValue? ManualPageBreak
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Pivot-Created Page Break</para>
        /// <para>Represents the following attribute in the schema: pt</para>
        /// </summary>
        public BooleanValue? PivotTablePageBreak
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:brk");
            builder.AddElement<Break>()
                .AddAttribute("id", a => a.Id)
                .AddAttribute("min", a => a.Min)
                .AddAttribute("max", a => a.Max)
                .AddAttribute("man", a => a.ManualPageBreak)
                .AddAttribute("pt", a => a.PivotTablePageBreak);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:min"), true, double.NegativeInfinity, true, 1048576, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, 1048576, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:max"), true, 1, true, 1048576, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Break>(deep);
    }

    /// <summary>
    /// <para>Data Consolidation Reference.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataRef.</para>
    /// </summary>
    public partial class DataReference : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DataReference class.
        /// </summary>
        public DataReference() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Named Range</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Name</para>
        /// <para>Represents the following attribute in the schema: sheet</para>
        /// </summary>
        public StringValue? Sheet
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataRef");
            builder.AddElement<DataReference>()
                .AddAttribute("ref", a => a.Reference)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("sheet", a => a.Sheet)
                .AddAttribute("r:id", a => a.Id);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataReference>(deep);
    }

    /// <summary>
    /// <para>Horizontal Page Breaks.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rowBreaks.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Break" /> <c>&lt;x:brk></c></description></item>
    /// </list>
    /// </remark>
    public partial class RowBreaks : PageBreakType
    {
        /// <summary>
        /// Initializes a new instance of the RowBreaks class.
        /// </summary>
        public RowBreaks() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowBreaks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowBreaks(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowBreaks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowBreaks(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowBreaks class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RowBreaks(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rowBreaks");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Break), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 1022, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:manualBreakCount"), true, double.NegativeInfinity, true, 1022, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowBreaks>(deep);
    }

    /// <summary>
    /// <para>Vertical Page Breaks.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colBreaks.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Break" /> <c>&lt;x:brk></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColumnBreaks : PageBreakType
    {
        /// <summary>
        /// Initializes a new instance of the ColumnBreaks class.
        /// </summary>
        public ColumnBreaks() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnBreaks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnBreaks(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnBreaks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnBreaks(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnBreaks class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColumnBreaks(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colBreaks");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Break), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 1023, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:manualBreakCount"), true, double.NegativeInfinity, true, 1023, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColumnBreaks>(deep);
    }

    /// <summary>
    /// <para>Defines the PageBreakType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Break" /> <c>&lt;x:brk></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class PageBreakType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PageBreakType class.
        /// </summary>
        protected PageBreakType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageBreakType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected PageBreakType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageBreakType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected PageBreakType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageBreakType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected PageBreakType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Page Break Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Manual Break Count</para>
        /// <para>Represents the following attribute in the schema: manualBreakCount</para>
        /// </summary>
        public UInt32Value? ManualBreakCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Break>();
            builder.AddElement<PageBreakType>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("manualBreakCount", a => a.ManualBreakCount);
        }
    }

    /// <summary>
    /// <para>Page Margins.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageMargins.</para>
    /// </summary>
    public partial class PageMargins : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PageMargins class.
        /// </summary>
        public PageMargins() : base()
        {
        }

        /// <summary>
        /// <para>Left Page Margin</para>
        /// <para>Represents the following attribute in the schema: left</para>
        /// </summary>
        public DoubleValue? Left
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Right Page Margin</para>
        /// <para>Represents the following attribute in the schema: right</para>
        /// </summary>
        public DoubleValue? Right
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Page Margin</para>
        /// <para>Represents the following attribute in the schema: top</para>
        /// </summary>
        public DoubleValue? Top
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bottom Page Margin</para>
        /// <para>Represents the following attribute in the schema: bottom</para>
        /// </summary>
        public DoubleValue? Bottom
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Page Margin</para>
        /// <para>Represents the following attribute in the schema: header</para>
        /// </summary>
        public DoubleValue? Header
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Footer Page Margin</para>
        /// <para>Represents the following attribute in the schema: footer</para>
        /// </summary>
        public DoubleValue? Footer
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageMargins");
            builder.AddElement<PageMargins>()
                .AddAttribute("left", a => a.Left, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("right", a => a.Right, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("top", a => a.Top, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("bottom", a => a.Bottom, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("header", a => a.Header, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("footer", a => a.Footer, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:left"), true, 0, true, 49, false));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:right"), true, 0, true, 49, false));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:top"), true, 0, true, 49, false));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:bottom"), true, 0, true, 49, false));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:header"), true, 0, true, 49, false));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:footer"), true, 0, true, 49, false));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageMargins>(deep);
    }

    /// <summary>
    /// <para>Print Options.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:printOptions.</para>
    /// </summary>
    public partial class PrintOptions : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PrintOptions class.
        /// </summary>
        public PrintOptions() : base()
        {
        }

        /// <summary>
        /// <para>Horizontal Centered</para>
        /// <para>Represents the following attribute in the schema: horizontalCentered</para>
        /// </summary>
        public BooleanValue? HorizontalCentered
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical Centered</para>
        /// <para>Represents the following attribute in the schema: verticalCentered</para>
        /// </summary>
        public BooleanValue? VerticalCentered
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Headings</para>
        /// <para>Represents the following attribute in the schema: headings</para>
        /// </summary>
        public BooleanValue? Headings
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Grid Lines</para>
        /// <para>Represents the following attribute in the schema: gridLines</para>
        /// </summary>
        public BooleanValue? GridLines
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Grid Lines Set</para>
        /// <para>Represents the following attribute in the schema: gridLinesSet</para>
        /// </summary>
        public BooleanValue? GridLinesSet
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:printOptions");
            builder.AddElement<PrintOptions>()
                .AddAttribute("horizontalCentered", a => a.HorizontalCentered)
                .AddAttribute("verticalCentered", a => a.VerticalCentered)
                .AddAttribute("headings", a => a.Headings)
                .AddAttribute("gridLines", a => a.GridLines)
                .AddAttribute("gridLinesSet", a => a.GridLinesSet);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PrintOptions>(deep);
    }

    /// <summary>
    /// <para>Page Setup Settings.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageSetup.</para>
    /// </summary>
    public partial class PageSetup : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PageSetup class.
        /// </summary>
        public PageSetup() : base()
        {
        }

        /// <summary>
        /// <para>Paper Size</para>
        /// <para>Represents the following attribute in the schema: paperSize</para>
        /// </summary>
        public UInt32Value? PaperSize
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Scale</para>
        /// <para>Represents the following attribute in the schema: scale</para>
        /// </summary>
        public UInt32Value? Scale
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>First Page Number</para>
        /// <para>Represents the following attribute in the schema: firstPageNumber</para>
        /// </summary>
        public UInt32Value? FirstPageNumber
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fit To Width</para>
        /// <para>Represents the following attribute in the schema: fitToWidth</para>
        /// </summary>
        public UInt32Value? FitToWidth
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fit To Height</para>
        /// <para>Represents the following attribute in the schema: fitToHeight</para>
        /// </summary>
        public UInt32Value? FitToHeight
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Page Order</para>
        /// <para>Represents the following attribute in the schema: pageOrder</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PageOrderValues>? PageOrder
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PageOrderValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Orientation</para>
        /// <para>Represents the following attribute in the schema: orientation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>? Orientation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use Printer Defaults</para>
        /// <para>Represents the following attribute in the schema: usePrinterDefaults</para>
        /// </summary>
        public BooleanValue? UsePrinterDefaults
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Black And White</para>
        /// <para>Represents the following attribute in the schema: blackAndWhite</para>
        /// </summary>
        public BooleanValue? BlackAndWhite
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Draft</para>
        /// <para>Represents the following attribute in the schema: draft</para>
        /// </summary>
        public BooleanValue? Draft
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Cell Comments</para>
        /// <para>Represents the following attribute in the schema: cellComments</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellCommentsValues>? CellComments
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellCommentsValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use First Page Number</para>
        /// <para>Represents the following attribute in the schema: useFirstPageNumber</para>
        /// </summary>
        public BooleanValue? UseFirstPageNumber
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Error Handling</para>
        /// <para>Represents the following attribute in the schema: errors</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PrintErrorValues>? Errors
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PrintErrorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Horizontal DPI</para>
        /// <para>Represents the following attribute in the schema: horizontalDpi</para>
        /// </summary>
        public UInt32Value? HorizontalDpi
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical DPI</para>
        /// <para>Represents the following attribute in the schema: verticalDpi</para>
        /// </summary>
        public UInt32Value? VerticalDpi
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Of Copies</para>
        /// <para>Represents the following attribute in the schema: copies</para>
        /// </summary>
        public UInt32Value? Copies
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageSetup");
            builder.AddElement<PageSetup>()
                .AddAttribute("paperSize", a => a.PaperSize)
                .AddAttribute("scale", a => a.Scale)
                .AddAttribute("firstPageNumber", a => a.FirstPageNumber)
                .AddAttribute("fitToWidth", a => a.FitToWidth)
                .AddAttribute("fitToHeight", a => a.FitToHeight)
                .AddAttribute("pageOrder", a => a.PageOrder)
                .AddAttribute("orientation", a => a.Orientation)
                .AddAttribute("usePrinterDefaults", a => a.UsePrinterDefaults)
                .AddAttribute("blackAndWhite", a => a.BlackAndWhite)
                .AddAttribute("draft", a => a.Draft)
                .AddAttribute("cellComments", a => a.CellComments)
                .AddAttribute("useFirstPageNumber", a => a.UseFirstPageNumber)
                .AddAttribute("errors", a => a.Errors)
                .AddAttribute("horizontalDpi", a => a.HorizontalDpi)
                .AddAttribute("verticalDpi", a => a.VerticalDpi)
                .AddAttribute("copies", a => a.Copies)
                .AddAttribute("r:id", a => a.Id);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fitToWidth"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fitToHeight"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:copies"), true, 1, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:horizontalDpi"), true, 1, true, double.PositiveInfinity, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:verticalDpi"), true, 1, true, double.PositiveInfinity, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageSetup>(deep);
    }

    /// <summary>
    /// <para>Header Footer Settings.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:headerFooter.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OddHeader" /> <c>&lt;x:oddHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OddFooter" /> <c>&lt;x:oddFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.EvenHeader" /> <c>&lt;x:evenHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.EvenFooter" /> <c>&lt;x:evenFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FirstHeader" /> <c>&lt;x:firstHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FirstFooter" /> <c>&lt;x:firstFooter></c></description></item>
    /// </list>
    /// </remark>
    public partial class HeaderFooter : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the HeaderFooter class.
        /// </summary>
        public HeaderFooter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HeaderFooter(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HeaderFooter(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public HeaderFooter(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Different Odd Even Header Footer</para>
        /// <para>Represents the following attribute in the schema: differentOddEven</para>
        /// </summary>
        public BooleanValue? DifferentOddEven
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Different First Page</para>
        /// <para>Represents the following attribute in the schema: differentFirst</para>
        /// </summary>
        public BooleanValue? DifferentFirst
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Scale Header and Footer With Document</para>
        /// <para>Represents the following attribute in the schema: scaleWithDoc</para>
        /// </summary>
        public BooleanValue? ScaleWithDoc
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Align Margins</para>
        /// <para>Represents the following attribute in the schema: alignWithMargins</para>
        /// </summary>
        public BooleanValue? AlignWithMargins
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:headerFooter");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OddHeader>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OddFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.EvenHeader>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.EvenFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FirstHeader>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FirstFooter>();
            builder.AddElement<HeaderFooter>()
                .AddAttribute("differentOddEven", a => a.DifferentOddEven)
                .AddAttribute("differentFirst", a => a.DifferentFirst)
                .AddAttribute("scaleWithDoc", a => a.ScaleWithDoc)
                .AddAttribute("alignWithMargins", a => a.AlignWithMargins);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OddHeader), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OddFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.EvenHeader), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.EvenFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FirstHeader), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FirstFooter), 0, 1)
            };
        }

        /// <summary>
        /// <para>Odd Header.</para>
        /// <para>Represents the following element tag in the schema: x:oddHeader.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OddHeader? OddHeader
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OddHeader>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Odd Page Footer.</para>
        /// <para>Represents the following element tag in the schema: x:oddFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OddFooter? OddFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OddFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Even Page Header.</para>
        /// <para>Represents the following element tag in the schema: x:evenHeader.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.EvenHeader? EvenHeader
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.EvenHeader>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Even Page Footer.</para>
        /// <para>Represents the following element tag in the schema: x:evenFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.EvenFooter? EvenFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.EvenFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>First Page Header.</para>
        /// <para>Represents the following element tag in the schema: x:firstHeader.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FirstHeader? FirstHeader
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FirstHeader>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>First Page Footer.</para>
        /// <para>Represents the following element tag in the schema: x:firstFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FirstFooter? FirstFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FirstFooter>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<HeaderFooter>(deep);
    }

    /// <summary>
    /// <para>AutoFilter Settings.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:autoFilter.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FilterColumn" /> <c>&lt;x:filterColumn></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortState" /> <c>&lt;x:sortState></c></description></item>
    /// </list>
    /// </remark>
    public partial class AutoFilter : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the AutoFilter class.
        /// </summary>
        public AutoFilter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoFilter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AutoFilter(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoFilter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AutoFilter(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoFilter class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AutoFilter(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Cell or Range Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:autoFilter");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FilterColumn>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            builder.AddElement<AutoFilter>()
                .AddAttribute("ref", a => a.Reference);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FilterColumn), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortState), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AutoFilter>(deep);
    }

    /// <summary>
    /// <para>Conditional Formatting Rule.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cfRule.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColorScale" /> <c>&lt;x:colorScale></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataBar" /> <c>&lt;x:dataBar></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.IconSet" /> <c>&lt;x:iconSet></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Formula" /> <c>&lt;x:formula></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormattingRule : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRule class.
        /// </summary>
        public ConditionalFormattingRule() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRule class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRule(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRule class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRule(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRule class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormattingRule(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Differential Formatting Id</para>
        /// <para>Represents the following attribute in the schema: dxfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Priority</para>
        /// <para>Represents the following attribute in the schema: priority</para>
        /// </summary>
        public Int32Value? Priority
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Stop If True</para>
        /// <para>Represents the following attribute in the schema: stopIfTrue</para>
        /// </summary>
        public BooleanValue? StopIfTrue
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Above Or Below Average</para>
        /// <para>Represents the following attribute in the schema: aboveAverage</para>
        /// </summary>
        public BooleanValue? AboveAverage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top 10 Percent</para>
        /// <para>Represents the following attribute in the schema: percent</para>
        /// </summary>
        public BooleanValue? Percent
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bottom N</para>
        /// <para>Represents the following attribute in the schema: bottom</para>
        /// </summary>
        public BooleanValue? Bottom
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Operator</para>
        /// <para>Represents the following attribute in the schema: operator</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingOperatorValues>? Operator
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingOperatorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Text</para>
        /// <para>Represents the following attribute in the schema: text</para>
        /// </summary>
        public StringValue? Text
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Time Period</para>
        /// <para>Represents the following attribute in the schema: timePeriod</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TimePeriodValues>? TimePeriod
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TimePeriodValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Rank</para>
        /// <para>Represents the following attribute in the schema: rank</para>
        /// </summary>
        public UInt32Value? Rank
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>StdDev</para>
        /// <para>Represents the following attribute in the schema: stdDev</para>
        /// </summary>
        public Int32Value? StdDev
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Equal Average</para>
        /// <para>Represents the following attribute in the schema: equalAverage</para>
        /// </summary>
        public BooleanValue? EqualAverage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cfRule");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColorScale>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataBar>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.IconSet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Formula>();
            builder.AddElement<ConditionalFormattingRule>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("dxfId", a => a.FormatId)
                .AddAttribute("priority", a => a.Priority, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("stopIfTrue", a => a.StopIfTrue)
                .AddAttribute("aboveAverage", a => a.AboveAverage)
                .AddAttribute("percent", a => a.Percent)
                .AddAttribute("bottom", a => a.Bottom)
                .AddAttribute("operator", a => a.Operator)
                .AddAttribute("text", a => a.Text)
                .AddAttribute("timePeriod", a => a.TimePeriod)
                .AddAttribute("rank", a => a.Rank)
                .AddAttribute("stdDev", a => a.StdDev)
                .AddAttribute("equalAverage", a => a.EqualAverage);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Formula), 0, 3),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColorScale), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataBar), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.IconSet), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:operator"), builder.CreateQName("x:type") , "cells"));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:timePeriod"), builder.CreateQName("x:type") , "timePeriod"));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormattingRule>(deep);
    }

    /// <summary>
    /// <para>Hyperlink.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:hyperlink.</para>
    /// </summary>
    public partial class Hyperlink : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Hyperlink class.
        /// </summary>
        public Hyperlink() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Location</para>
        /// <para>Represents the following attribute in the schema: location</para>
        /// </summary>
        public StringValue? Location
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Tool Tip</para>
        /// <para>Represents the following attribute in the schema: tooltip</para>
        /// </summary>
        public StringValue? Tooltip
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Display String</para>
        /// <para>Represents the following attribute in the schema: display</para>
        /// </summary>
        public StringValue? Display
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:hyperlink");
            builder.AddElement<Hyperlink>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id)
                .AddAttribute("location", a => a.Location)
                .AddAttribute("tooltip", a => a.Tooltip)
                .AddAttribute("display", a => a.Display);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:location"), 0, 2084));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:display"), 0, 2084));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:tooltip"), 0, 255));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Hyperlink>(deep);
    }

    /// <summary>
    /// <para>Conditional Format Value Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cfvo.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormatValueObject : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormatValueObject class.
        /// </summary>
        public ConditionalFormatValueObject() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatValueObject class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormatValueObject(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatValueObject class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormatValueObject(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatValueObject class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormatValueObject(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObjectValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObjectValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Greater Than Or Equal</para>
        /// <para>Represents the following attribute in the schema: gte</para>
        /// </summary>
        public BooleanValue? GreaterThanOrEqual
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cfvo");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<ConditionalFormatValueObject>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("val", a => a.Val)
                .AddAttribute("gte", a => a.GreaterThanOrEqual);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormatValueObject>(deep);
    }

    /// <summary>
    /// <para>Scenario.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:scenario.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.InputCells" /> <c>&lt;x:inputCells></c></description></item>
    /// </list>
    /// </remark>
    public partial class Scenario : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Scenario class.
        /// </summary>
        public Scenario() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenario class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scenario(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenario class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scenario(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenario class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Scenario(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Scenario Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Scenario Locked</para>
        /// <para>Represents the following attribute in the schema: locked</para>
        /// </summary>
        public BooleanValue? Locked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Scenario</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Changing Cell Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Name</para>
        /// <para>Represents the following attribute in the schema: user</para>
        /// </summary>
        public StringValue? User
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Scenario Comment</para>
        /// <para>Represents the following attribute in the schema: comment</para>
        /// </summary>
        public StringValue? Comment
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:scenario");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.InputCells>();
            builder.AddElement<Scenario>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("locked", a => a.Locked)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("count", a => a.Count)
                .AddAttribute("user", a => a.User)
                .AddAttribute("comment", a => a.Comment);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.InputCells), 1, 32)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:worksheet")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, 1, true, 32, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:user"), 1, 54) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:comment"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Scenario>(deep);
    }

    /// <summary>
    /// <para>Protected Range.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:protectedRange.</para>
    /// </summary>
    public partial class ProtectedRange : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ProtectedRange class.
        /// </summary>
        public ProtectedRange() : base()
        {
        }

        /// <summary>
        /// <para>password</para>
        /// <para>Represents the following attribute in the schema: password</para>
        /// </summary>
        public HexBinaryValue? Password
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>algorithmName</para>
        /// <para>Represents the following attribute in the schema: algorithmName</para>
        /// </summary>
        public StringValue? AlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hashValue</para>
        /// <para>Represents the following attribute in the schema: hashValue</para>
        /// </summary>
        public Base64BinaryValue? HashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>saltValue</para>
        /// <para>Represents the following attribute in the schema: saltValue</para>
        /// </summary>
        public Base64BinaryValue? SaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>spinCount</para>
        /// <para>Represents the following attribute in the schema: spinCount</para>
        /// </summary>
        public UInt32Value? SpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sqref</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>securityDescriptor</para>
        /// <para>Represents the following attribute in the schema: securityDescriptor</para>
        /// </summary>
        public StringValue? SecurityDescriptor
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:protectedRange");
            builder.AddElement<ProtectedRange>()
                .AddAttribute("password", a => a.Password, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("algorithmName", a => a.AlgorithmName)
                .AddAttribute("hashValue", a => a.HashValue)
                .AddAttribute("saltValue", a => a.SaltValue)
                .AddAttribute("spinCount", a => a.SpinCount)
                .AddAttribute("sqref", a => a.SequenceOfReferences, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("securityDescriptor", a => a.SecurityDescriptor);
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:protectedRanges")));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Word });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sqref"), true, 1, true, double.PositiveInfinity, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ProtectedRange>(deep);
    }

    /// <summary>
    /// <para>Cell Watch Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellWatch.</para>
    /// </summary>
    public partial class CellWatch : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CellWatch class.
        /// </summary>
        public CellWatch() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellWatch");
            builder.AddElement<CellWatch>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:r"), true, builder.CreateQName("x:cellWatches")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellWatch>(deep);
    }

    /// <summary>
    /// <para>Chart Sheet Page Setup.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageSetup.</para>
    /// </summary>
    public partial class ChartSheetPageSetup : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartSheetPageSetup class.
        /// </summary>
        public ChartSheetPageSetup() : base()
        {
        }

        /// <summary>
        /// <para>Paper Size</para>
        /// <para>Represents the following attribute in the schema: paperSize</para>
        /// </summary>
        public UInt32Value? PaperSize
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>First Page Number</para>
        /// <para>Represents the following attribute in the schema: firstPageNumber</para>
        /// </summary>
        public UInt32Value? FirstPageNumber
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Orientation</para>
        /// <para>Represents the following attribute in the schema: orientation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>? Orientation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use Printer Defaults</para>
        /// <para>Represents the following attribute in the schema: usePrinterDefaults</para>
        /// </summary>
        public BooleanValue? UsePrinterDefaults
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Black And White</para>
        /// <para>Represents the following attribute in the schema: blackAndWhite</para>
        /// </summary>
        public BooleanValue? BlackAndWhite
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Draft</para>
        /// <para>Represents the following attribute in the schema: draft</para>
        /// </summary>
        public BooleanValue? Draft
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use First Page Number</para>
        /// <para>Represents the following attribute in the schema: useFirstPageNumber</para>
        /// </summary>
        public BooleanValue? UseFirstPageNumber
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Horizontal DPI</para>
        /// <para>Represents the following attribute in the schema: horizontalDpi</para>
        /// </summary>
        public UInt32Value? HorizontalDpi
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical DPI</para>
        /// <para>Represents the following attribute in the schema: verticalDpi</para>
        /// </summary>
        public UInt32Value? VerticalDpi
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Of Copies</para>
        /// <para>Represents the following attribute in the schema: copies</para>
        /// </summary>
        public UInt32Value? Copies
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageSetup");
            builder.AddElement<ChartSheetPageSetup>()
                .AddAttribute("paperSize", a => a.PaperSize)
                .AddAttribute("firstPageNumber", a => a.FirstPageNumber)
                .AddAttribute("orientation", a => a.Orientation)
                .AddAttribute("usePrinterDefaults", a => a.UsePrinterDefaults)
                .AddAttribute("blackAndWhite", a => a.BlackAndWhite)
                .AddAttribute("draft", a => a.Draft)
                .AddAttribute("useFirstPageNumber", a => a.UseFirstPageNumber)
                .AddAttribute("horizontalDpi", a => a.HorizontalDpi)
                .AddAttribute("verticalDpi", a => a.VerticalDpi)
                .AddAttribute("copies", a => a.Copies)
                .AddAttribute("r:id", a => a.Id);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fitToWidth"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fitToHeight"), true, double.NegativeInfinity, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:copies"), true, 1, true, 32767, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:horizontalDpi"), true, 1, true, double.PositiveInfinity, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:verticalDpi"), true, 1, true, double.PositiveInfinity, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSheetPageSetup>(deep);
    }

    /// <summary>
    /// <para>Custom Property.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customPr.</para>
    /// </summary>
    public partial class CustomProperty : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomProperty class.
        /// </summary>
        public CustomProperty() : base()
        {
        }

        /// <summary>
        /// <para>Custom Property Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customPr");
            builder.AddElement<CustomProperty>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), false, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomProperty>(deep);
    }

    /// <summary>
    /// <para>Web Publishing Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPublishItem.</para>
    /// </summary>
    public partial class WebPublishItem : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WebPublishItem class.
        /// </summary>
        public WebPublishItem() : base()
        {
        }

        /// <summary>
        /// <para>Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination Bookmark</para>
        /// <para>Represents the following attribute in the schema: divId</para>
        /// </summary>
        public StringValue? DivId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Web Source Type</para>
        /// <para>Represents the following attribute in the schema: sourceType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.WebSourceValues>? SourceType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.WebSourceValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Id</para>
        /// <para>Represents the following attribute in the schema: sourceRef</para>
        /// </summary>
        public StringValue? SourceRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Object Name</para>
        /// <para>Represents the following attribute in the schema: sourceObject</para>
        /// </summary>
        public StringValue? SourceObject
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination File Name</para>
        /// <para>Represents the following attribute in the schema: destinationFile</para>
        /// </summary>
        public StringValue? DestinationFile
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Title</para>
        /// <para>Represents the following attribute in the schema: title</para>
        /// </summary>
        public StringValue? Title
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Automatically Publish</para>
        /// <para>Represents the following attribute in the schema: autoRepublish</para>
        /// </summary>
        public BooleanValue? AutoRepublish
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPublishItem");
            builder.AddElement<WebPublishItem>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("divId", a => a.DivId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceType", a => a.SourceType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceRef", a => a.SourceRef)
                .AddAttribute("sourceObject", a => a.SourceObject)
                .AddAttribute("destinationFile", a => a.DestinationFile, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("title", a => a.Title)
                .AddAttribute("autoRepublish", a => a.AutoRepublish);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:title"), 0, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:destinationFile"), 1, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:divId"), 1, 255));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, 2147483647, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, null));
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:sourceRef"), builder.CreateQName("x:sourceType") , "range"));
            builder.AddConstraint(new AttributeAbsentConditionToNonValue(builder.CreateQName("x:sourceRef"), builder.CreateQName("x:sourceType"), "range"));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebPublishItem>(deep);
    }

    /// <summary>
    /// <para>Table Part.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tablePart.</para>
    /// </summary>
    public partial class TablePart : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the TablePart class.
        /// </summary>
        public TablePart() : base()
        {
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tablePart");
            builder.AddElement<TablePart>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TablePart>(deep);
    }

    /// <summary>
    /// <para>Chart Sheet View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChartSheetView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartSheetView class.
        /// </summary>
        public ChartSheetView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartSheetView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Sheet Tab Selected</para>
        /// <para>Represents the following attribute in the schema: tabSelected</para>
        /// </summary>
        public BooleanValue? TabSelected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Window Zoom Scale</para>
        /// <para>Represents the following attribute in the schema: zoomScale</para>
        /// </summary>
        public UInt32Value? ZoomScale
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Workbook View Id</para>
        /// <para>Represents the following attribute in the schema: workbookViewId</para>
        /// </summary>
        public UInt32Value? WorkbookViewId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom To Fit</para>
        /// <para>Represents the following attribute in the schema: zoomToFit</para>
        /// </summary>
        public BooleanValue? ZoomToFit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<ChartSheetView>()
                .AddAttribute("tabSelected", a => a.TabSelected)
                .AddAttribute("zoomScale", a => a.ZoomScale)
                .AddAttribute("workbookViewId", a => a.WorkbookViewId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("zoomToFit", a => a.ZoomToFit);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:colorId"), true, double.NegativeInfinity, true, 64, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScale"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScaleNormal"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScalePageLayoutView"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScaleSheetLayoutView"), true, 10, true, 400, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:workbookViewId"), "/WorkbookPart", null, builder.CreateQName("x:workbookView"), "x:workbookView", 0));
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSheetView>(deep);
    }

    /// <summary>
    /// <para>Custom Chart Sheet View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customSheetView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup" /> <c>&lt;x:pageSetup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HeaderFooter" /> <c>&lt;x:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageMargins" /> <c>&lt;x:pageMargins></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomChartsheetView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomChartsheetView class.
        /// </summary>
        public CustomChartsheetView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomChartsheetView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomChartsheetView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomChartsheetView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Scale</para>
        /// <para>Represents the following attribute in the schema: scale</para>
        /// </summary>
        public UInt32Value? Scale
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Visible State</para>
        /// <para>Represents the following attribute in the schema: state</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>? State
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom To Fit</para>
        /// <para>Represents the following attribute in the schema: zoomToFit</para>
        /// </summary>
        public BooleanValue? ZoomToFit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customSheetView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            builder.AddElement<CustomChartsheetView>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("scale", a => a.Scale)
                .AddAttribute("state", a => a.State)
                .AddAttribute("zoomToFit", a => a.ZoomToFit);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageMargins), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HeaderFooter), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:scale"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:colorId"), true, double.NegativeInfinity, true, 64, true));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:guid"), false, new string[] { "00000000-0000-0000-0000-000000000000" }));
        }

        /// <summary>
        /// <para>PageMargins.</para>
        /// <para>Represents the following element tag in the schema: x:pageMargins.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageMargins? PageMargins
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Chart Sheet Page Setup.</para>
        /// <para>Represents the following element tag in the schema: x:pageSetup.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup? ChartSheetPageSetup
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ChartSheetPageSetup>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>HeaderFooter.</para>
        /// <para>Represents the following element tag in the schema: x:headerFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.HeaderFooter? HeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomChartsheetView>(deep);
    }

    /// <summary>
    /// <para>Input Cells.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:inputCells.</para>
    /// </summary>
    public partial class InputCells : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the InputCells class.
        /// </summary>
        public InputCells() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Deleted</para>
        /// <para>Represents the following attribute in the schema: deleted</para>
        /// </summary>
        public BooleanValue? Deleted
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Undone</para>
        /// <para>Represents the following attribute in the schema: undone</para>
        /// </summary>
        public BooleanValue? Undone
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Format Id</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:inputCells");
            builder.AddElement<InputCells>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("deleted", a => a.Deleted)
                .AddAttribute("undone", a => a.Undone)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("numFmtId", a => a.NumberFormatId);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:val"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<InputCells>(deep);
    }

    /// <summary>
    /// <para>Embedded Control.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:control.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ControlProperties" /> <c>&lt;x:controlPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class Control : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Control class.
        /// </summary>
        public Control() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Control class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Control(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Control class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Control(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Control class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Control(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Shape Id</para>
        /// <para>Represents the following attribute in the schema: shapeId</para>
        /// </summary>
        public UInt32Value? ShapeId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Control Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:control");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ControlProperties>();
            builder.AddElement<Control>()
                .AddAttribute("shapeId", a => a.ShapeId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ControlProperties), 0, 1, version: FileFormatVersions.Office2010)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:shapeId"), true, 1, true, 67098623, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, null) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 32) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>ControlProperties, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x:controlPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ControlProperties? ControlProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ControlProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Control>(deep);
    }

    /// <summary>
    /// <para>Ignored Error.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ignoredError.</para>
    /// </summary>
    public partial class IgnoredError : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the IgnoredError class.
        /// </summary>
        public IgnoredError() : base()
        {
        }

        /// <summary>
        /// <para>Sequence of References</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Evaluation Error</para>
        /// <para>Represents the following attribute in the schema: evalError</para>
        /// </summary>
        public BooleanValue? EvalError
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Two Digit Text Year</para>
        /// <para>Represents the following attribute in the schema: twoDigitTextYear</para>
        /// </summary>
        public BooleanValue? TwoDigitTextYear
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Stored As Text</para>
        /// <para>Represents the following attribute in the schema: numberStoredAsText</para>
        /// </summary>
        public BooleanValue? NumberStoredAsText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Formula</para>
        /// <para>Represents the following attribute in the schema: formula</para>
        /// </summary>
        public BooleanValue? Formula
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Formula Range</para>
        /// <para>Represents the following attribute in the schema: formulaRange</para>
        /// </summary>
        public BooleanValue? FormulaRange
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unlocked Formula</para>
        /// <para>Represents the following attribute in the schema: unlockedFormula</para>
        /// </summary>
        public BooleanValue? UnlockedFormula
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Empty Cell Reference</para>
        /// <para>Represents the following attribute in the schema: emptyCellReference</para>
        /// </summary>
        public BooleanValue? EmptyCellReference
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>List Data Validation</para>
        /// <para>Represents the following attribute in the schema: listDataValidation</para>
        /// </summary>
        public BooleanValue? ListDataValidation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculated Column</para>
        /// <para>Represents the following attribute in the schema: calculatedColumn</para>
        /// </summary>
        public BooleanValue? CalculatedColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ignoredError");
            builder.AddElement<IgnoredError>()
                .AddAttribute("sqref", a => a.SequenceOfReferences, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("evalError", a => a.EvalError)
                .AddAttribute("twoDigitTextYear", a => a.TwoDigitTextYear)
                .AddAttribute("numberStoredAsText", a => a.NumberStoredAsText)
                .AddAttribute("formula", a => a.Formula)
                .AddAttribute("formulaRange", a => a.FormulaRange)
                .AddAttribute("unlockedFormula", a => a.UnlockedFormula)
                .AddAttribute("emptyCellReference", a => a.EmptyCellReference)
                .AddAttribute("listDataValidation", a => a.ListDataValidation)
                .AddAttribute("calculatedColumn", a => a.CalculatedColumn);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sqref"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IgnoredError>(deep);
    }

    /// <summary>
    /// <para>Merged Cell.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mergeCell.</para>
    /// </summary>
    public partial class MergeCell : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MergeCell class.
        /// </summary>
        public MergeCell() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mergeCell");
            builder.AddElement<MergeCell>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MergeCell>(deep);
    }

    /// <summary>
    /// <para>Data Validation.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataValidation.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Formula1" /> <c>&lt;x:formula1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Formula2" /> <c>&lt;x:formula2></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.ExcelAc.List" /> <c>&lt;x12ac:list></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataValidation : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataValidation class.
        /// </summary>
        public DataValidation() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataValidation(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataValidation(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidation class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataValidation(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>errorStyle</para>
        /// <para>Represents the following attribute in the schema: errorStyle</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationErrorStyleValues>? ErrorStyle
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationErrorStyleValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>imeMode</para>
        /// <para>Represents the following attribute in the schema: imeMode</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationImeModeValues>? ImeMode
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationImeModeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>operator</para>
        /// <para>Represents the following attribute in the schema: operator</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationOperatorValues>? Operator
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationOperatorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>allowBlank</para>
        /// <para>Represents the following attribute in the schema: allowBlank</para>
        /// </summary>
        public BooleanValue? AllowBlank
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showDropDown</para>
        /// <para>Represents the following attribute in the schema: showDropDown</para>
        /// </summary>
        public BooleanValue? ShowDropDown
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showInputMessage</para>
        /// <para>Represents the following attribute in the schema: showInputMessage</para>
        /// </summary>
        public BooleanValue? ShowInputMessage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>showErrorMessage</para>
        /// <para>Represents the following attribute in the schema: showErrorMessage</para>
        /// </summary>
        public BooleanValue? ShowErrorMessage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>errorTitle</para>
        /// <para>Represents the following attribute in the schema: errorTitle</para>
        /// </summary>
        public StringValue? ErrorTitle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>error</para>
        /// <para>Represents the following attribute in the schema: error</para>
        /// </summary>
        public StringValue? Error
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>promptTitle</para>
        /// <para>Represents the following attribute in the schema: promptTitle</para>
        /// </summary>
        public StringValue? PromptTitle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>prompt</para>
        /// <para>Represents the following attribute in the schema: prompt</para>
        /// </summary>
        public StringValue? Prompt
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sqref</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataValidation");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Formula1>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Formula2>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.ExcelAc.List>();
            builder.AddElement<DataValidation>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("errorStyle", a => a.ErrorStyle)
                .AddAttribute("imeMode", a => a.ImeMode)
                .AddAttribute("operator", a => a.Operator)
                .AddAttribute("allowBlank", a => a.AllowBlank)
                .AddAttribute("showDropDown", a => a.ShowDropDown)
                .AddAttribute("showInputMessage", a => a.ShowInputMessage)
                .AddAttribute("showErrorMessage", a => a.ShowErrorMessage)
                .AddAttribute("errorTitle", a => a.ErrorTitle)
                .AddAttribute("error", a => a.Error)
                .AddAttribute("promptTitle", a => a.PromptTitle)
                .AddAttribute("prompt", a => a.Prompt)
                .AddAttribute("sqref", a => a.SequenceOfReferences, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.ExcelAc.List), 0, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Formula1), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Formula2), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sqref"), true, 1, true, 32767, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:errorTitle"), 0, 32));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:promptTitle"), 0, 32));
        }

        /// <summary>
        /// <para>List, this property is only available in Office 2013 and later..</para>
        /// <para>Represents the following element tag in the schema: x12ac:list.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x12ac = http://schemas.microsoft.com/office/spreadsheetml/2011/1/ac
        /// </remark>
        public DocumentFormat.OpenXml.Office2010.ExcelAc.List? List
        {
            get => GetElement<DocumentFormat.OpenXml.Office2010.ExcelAc.List>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Formula1.</para>
        /// <para>Represents the following element tag in the schema: x:formula1.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Formula1? Formula1
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Formula1>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Formula2.</para>
        /// <para>Represents the following element tag in the schema: x:formula2.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Formula2? Formula2
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Formula2>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataValidation>(deep);
    }

    /// <summary>
    /// <para>Worksheet View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Pane" /> <c>&lt;x:pane></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotSelection" /> <c>&lt;x:pivotSelection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Selection" /> <c>&lt;x:selection></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetView class.
        /// </summary>
        public SheetView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Window Protection</para>
        /// <para>Represents the following attribute in the schema: windowProtection</para>
        /// </summary>
        public BooleanValue? WindowProtection
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Formulas</para>
        /// <para>Represents the following attribute in the schema: showFormulas</para>
        /// </summary>
        public BooleanValue? ShowFormulas
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Grid Lines</para>
        /// <para>Represents the following attribute in the schema: showGridLines</para>
        /// </summary>
        public BooleanValue? ShowGridLines
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Headers</para>
        /// <para>Represents the following attribute in the schema: showRowColHeaders</para>
        /// </summary>
        public BooleanValue? ShowRowColHeaders
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Zero Values</para>
        /// <para>Represents the following attribute in the schema: showZeros</para>
        /// </summary>
        public BooleanValue? ShowZeros
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Right To Left</para>
        /// <para>Represents the following attribute in the schema: rightToLeft</para>
        /// </summary>
        public BooleanValue? RightToLeft
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Tab Selected</para>
        /// <para>Represents the following attribute in the schema: tabSelected</para>
        /// </summary>
        public BooleanValue? TabSelected
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Ruler</para>
        /// <para>Represents the following attribute in the schema: showRuler</para>
        /// </summary>
        public BooleanValue? ShowRuler
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Outline Symbols</para>
        /// <para>Represents the following attribute in the schema: showOutlineSymbols</para>
        /// </summary>
        public BooleanValue? ShowOutlineSymbols
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Grid Color</para>
        /// <para>Represents the following attribute in the schema: defaultGridColor</para>
        /// </summary>
        public BooleanValue? DefaultGridColor
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show White Space</para>
        /// <para>Represents the following attribute in the schema: showWhiteSpace</para>
        /// </summary>
        public BooleanValue? ShowWhiteSpace
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>View Type</para>
        /// <para>Represents the following attribute in the schema: view</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>? View
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Visible Cell</para>
        /// <para>Represents the following attribute in the schema: topLeftCell</para>
        /// </summary>
        public StringValue? TopLeftCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Color Id</para>
        /// <para>Represents the following attribute in the schema: colorId</para>
        /// </summary>
        public UInt32Value? ColorId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom Scale</para>
        /// <para>Represents the following attribute in the schema: zoomScale</para>
        /// </summary>
        public UInt32Value? ZoomScale
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom Scale Normal View</para>
        /// <para>Represents the following attribute in the schema: zoomScaleNormal</para>
        /// </summary>
        public UInt32Value? ZoomScaleNormal
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom Scale Page Break Preview</para>
        /// <para>Represents the following attribute in the schema: zoomScaleSheetLayoutView</para>
        /// </summary>
        public UInt32Value? ZoomScaleSheetLayoutView
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Zoom Scale Page Layout View</para>
        /// <para>Represents the following attribute in the schema: zoomScalePageLayoutView</para>
        /// </summary>
        public UInt32Value? ZoomScalePageLayoutView
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Workbook View Index</para>
        /// <para>Represents the following attribute in the schema: workbookViewId</para>
        /// </summary>
        public UInt32Value? WorkbookViewId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Pane>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotSelection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Selection>();
            builder.AddElement<SheetView>()
                .AddAttribute("windowProtection", a => a.WindowProtection)
                .AddAttribute("showFormulas", a => a.ShowFormulas)
                .AddAttribute("showGridLines", a => a.ShowGridLines)
                .AddAttribute("showRowColHeaders", a => a.ShowRowColHeaders)
                .AddAttribute("showZeros", a => a.ShowZeros)
                .AddAttribute("rightToLeft", a => a.RightToLeft)
                .AddAttribute("tabSelected", a => a.TabSelected)
                .AddAttribute("showRuler", a => a.ShowRuler)
                .AddAttribute("showOutlineSymbols", a => a.ShowOutlineSymbols)
                .AddAttribute("defaultGridColor", a => a.DefaultGridColor)
                .AddAttribute("showWhiteSpace", a => a.ShowWhiteSpace)
                .AddAttribute("view", a => a.View)
                .AddAttribute("topLeftCell", a => a.TopLeftCell)
                .AddAttribute("colorId", a => a.ColorId)
                .AddAttribute("zoomScale", a => a.ZoomScale)
                .AddAttribute("zoomScaleNormal", a => a.ZoomScaleNormal)
                .AddAttribute("zoomScaleSheetLayoutView", a => a.ZoomScaleSheetLayoutView)
                .AddAttribute("zoomScalePageLayoutView", a => a.ZoomScalePageLayoutView)
                .AddAttribute("workbookViewId", a => a.WorkbookViewId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Pane), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Selection), 0, 4),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotSelection), 0, 4),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:colorId"), true, double.NegativeInfinity, true, 64, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScale"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScaleNormal"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScalePageLayoutView"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:zoomScaleSheetLayoutView"), true, 10, true, 400, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:workbookViewId"), "/WorkbookPart", null, builder.CreateQName("x:workbookView"), "x:workbookView", 0));
        }

        /// <summary>
        /// <para>View Pane.</para>
        /// <para>Represents the following element tag in the schema: x:pane.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Pane? Pane
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Pane>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetView>(deep);
    }

    /// <summary>
    /// <para>Custom Sheet View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customSheetView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.AutoFilter" /> <c>&lt;x:autoFilter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HeaderFooter" /> <c>&lt;x:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowBreaks" /> <c>&lt;x:rowBreaks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks" /> <c>&lt;x:colBreaks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageMargins" /> <c>&lt;x:pageMargins></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageSetup" /> <c>&lt;x:pageSetup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Pane" /> <c>&lt;x:pane></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PrintOptions" /> <c>&lt;x:printOptions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Selection" /> <c>&lt;x:selection></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomSheetView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomSheetView class.
        /// </summary>
        public CustomSheetView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomSheetView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomSheetView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomSheetView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Scale</para>
        /// <para>Represents the following attribute in the schema: scale</para>
        /// </summary>
        public UInt32Value? Scale
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Color Id</para>
        /// <para>Represents the following attribute in the schema: colorId</para>
        /// </summary>
        public UInt32Value? ColorId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Page Breaks</para>
        /// <para>Represents the following attribute in the schema: showPageBreaks</para>
        /// </summary>
        public BooleanValue? ShowPageBreaks
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Formulas</para>
        /// <para>Represents the following attribute in the schema: showFormulas</para>
        /// </summary>
        public BooleanValue? ShowFormulas
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Grid Lines</para>
        /// <para>Represents the following attribute in the schema: showGridLines</para>
        /// </summary>
        public BooleanValue? ShowGridLines
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Headers</para>
        /// <para>Represents the following attribute in the schema: showRowCol</para>
        /// </summary>
        public BooleanValue? ShowRowColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Outline Symbols</para>
        /// <para>Represents the following attribute in the schema: outlineSymbols</para>
        /// </summary>
        public BooleanValue? OutlineSymbols
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Zero Values</para>
        /// <para>Represents the following attribute in the schema: zeroValues</para>
        /// </summary>
        public BooleanValue? ZeroValues
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fit To Page</para>
        /// <para>Represents the following attribute in the schema: fitToPage</para>
        /// </summary>
        public BooleanValue? FitToPage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Print Area Defined</para>
        /// <para>Represents the following attribute in the schema: printArea</para>
        /// </summary>
        public BooleanValue? PrintArea
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filtered List</para>
        /// <para>Represents the following attribute in the schema: filter</para>
        /// </summary>
        public BooleanValue? Filter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show AutoFitler Drop Down Controls</para>
        /// <para>Represents the following attribute in the schema: showAutoFilter</para>
        /// </summary>
        public BooleanValue? ShowAutoFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Rows</para>
        /// <para>Represents the following attribute in the schema: hiddenRows</para>
        /// </summary>
        public BooleanValue? HiddenRows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Columns</para>
        /// <para>Represents the following attribute in the schema: hiddenColumns</para>
        /// </summary>
        public BooleanValue? HiddenColumns
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Visible State</para>
        /// <para>Represents the following attribute in the schema: state</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>? State
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter</para>
        /// <para>Represents the following attribute in the schema: filterUnique</para>
        /// </summary>
        public BooleanValue? FilterUnique
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>View Type</para>
        /// <para>Represents the following attribute in the schema: view</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>? View
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Ruler</para>
        /// <para>Represents the following attribute in the schema: showRuler</para>
        /// </summary>
        public BooleanValue? ShowRuler
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Visible Cell</para>
        /// <para>Represents the following attribute in the schema: topLeftCell</para>
        /// </summary>
        public StringValue? TopLeftCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customSheetView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowBreaks>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageSetup>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Pane>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PrintOptions>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Selection>();
            builder.AddElement<CustomSheetView>()
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("scale", a => a.Scale)
                .AddAttribute("colorId", a => a.ColorId)
                .AddAttribute("showPageBreaks", a => a.ShowPageBreaks)
                .AddAttribute("showFormulas", a => a.ShowFormulas)
                .AddAttribute("showGridLines", a => a.ShowGridLines)
                .AddAttribute("showRowCol", a => a.ShowRowColumn)
                .AddAttribute("outlineSymbols", a => a.OutlineSymbols)
                .AddAttribute("zeroValues", a => a.ZeroValues)
                .AddAttribute("fitToPage", a => a.FitToPage)
                .AddAttribute("printArea", a => a.PrintArea)
                .AddAttribute("filter", a => a.Filter)
                .AddAttribute("showAutoFilter", a => a.ShowAutoFilter)
                .AddAttribute("hiddenRows", a => a.HiddenRows)
                .AddAttribute("hiddenColumns", a => a.HiddenColumns)
                .AddAttribute("state", a => a.State)
                .AddAttribute("filterUnique", a => a.FilterUnique)
                .AddAttribute("view", a => a.View)
                .AddAttribute("showRuler", a => a.ShowRuler)
                .AddAttribute("topLeftCell", a => a.TopLeftCell);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Pane), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Selection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowBreaks), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageMargins), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PrintOptions), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageSetup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HeaderFooter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.AutoFilter), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:scale"), true, 10, true, 400, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:colorId"), true, double.NegativeInfinity, true, 64, true));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:guid"), false, new string[] { "00000000-0000-0000-0000-000000000000" }));
        }

        /// <summary>
        /// <para>Pane Split Information.</para>
        /// <para>Represents the following element tag in the schema: x:pane.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Pane? Pane
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Pane>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Selection.</para>
        /// <para>Represents the following element tag in the schema: x:selection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Selection? Selection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Selection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Horizontal Page Breaks.</para>
        /// <para>Represents the following element tag in the schema: x:rowBreaks.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RowBreaks? RowBreaks
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RowBreaks>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Vertical Page Breaks.</para>
        /// <para>Represents the following element tag in the schema: x:colBreaks.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks? ColumnBreaks
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ColumnBreaks>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Page Margins.</para>
        /// <para>Represents the following element tag in the schema: x:pageMargins.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageMargins? PageMargins
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageMargins>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Print Options.</para>
        /// <para>Represents the following element tag in the schema: x:printOptions.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PrintOptions? PrintOptions
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PrintOptions>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Page Setup Settings.</para>
        /// <para>Represents the following element tag in the schema: x:pageSetup.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageSetup? PageSetup
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageSetup>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Header Footer Settings.</para>
        /// <para>Represents the following element tag in the schema: x:headerFooter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.HeaderFooter? HeaderFooter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.HeaderFooter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>AutoFilter Settings.</para>
        /// <para>Represents the following element tag in the schema: x:autoFilter.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.AutoFilter? AutoFilter
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.AutoFilter>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomSheetView>(deep);
    }

    /// <summary>
    /// <para>OLE Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleObject.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.EmbeddedObjectProperties" /> <c>&lt;x:objectPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class OleObject : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the OleObject class.
        /// </summary>
        public OleObject() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObject class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleObject(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObject class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleObject(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObject class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OleObject(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>OLE ProgId</para>
        /// <para>Represents the following attribute in the schema: progId</para>
        /// </summary>
        public StringValue? ProgId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data or View Aspect</para>
        /// <para>Represents the following attribute in the schema: dvAspect</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataViewAspectValues>? DataOrViewAspect
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataViewAspectValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLE Link Moniker</para>
        /// <para>Represents the following attribute in the schema: link</para>
        /// </summary>
        public StringValue? Link
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLE Update</para>
        /// <para>Represents the following attribute in the schema: oleUpdate</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OleUpdateValues>? OleUpdate
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.OleUpdateValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Load</para>
        /// <para>Represents the following attribute in the schema: autoLoad</para>
        /// </summary>
        public BooleanValue? AutoLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shape Id</para>
        /// <para>Represents the following attribute in the schema: shapeId</para>
        /// </summary>
        public UInt32Value? ShapeId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleObject");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.EmbeddedObjectProperties>();
            builder.AddElement<OleObject>()
                .AddAttribute("progId", a => a.ProgId)
                .AddAttribute("dvAspect", a => a.DataOrViewAspect)
                .AddAttribute("link", a => a.Link)
                .AddAttribute("oleUpdate", a => a.OleUpdate)
                .AddAttribute("autoLoad", a => a.AutoLoad)
                .AddAttribute("shapeId", a => a.ShapeId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.EmbeddedObjectProperties), 0, 1, version: FileFormatVersions.Office2010)
            };
            builder.AddConstraint(new AttributeValuePatternConstraint(builder.CreateQName("x:progId"), @"[^\d].*"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:progId"), 0, 39));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:shapeId"), true, 1, true, 67098623, true));
        }

        /// <summary>
        /// <para>EmbeddedObjectProperties, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x:objectPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.EmbeddedObjectProperties? EmbeddedObjectProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.EmbeddedObjectProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleObject>(deep);
    }

    /// <summary>
    /// <para>Metadata Types Collection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:metadataTypes.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataType" /> <c>&lt;x:metadataType></c></description></item>
    /// </list>
    /// </remark>
    public partial class MetadataTypes : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataTypes class.
        /// </summary>
        public MetadataTypes() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataTypes(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataTypes(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataTypes class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MetadataTypes(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Metadata Type Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:metadataTypes");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MetadataType>();
            builder.AddElement<MetadataTypes>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataType), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MetadataTypes>(deep);
    }

    /// <summary>
    /// <para>Metadata String Store.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:metadataStrings.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CharacterValue" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class MetadataStrings : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataStrings class.
        /// </summary>
        public MetadataStrings() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataStrings class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataStrings(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataStrings class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataStrings(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataStrings class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MetadataStrings(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>MDX Metadata String Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:metadataStrings");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CharacterValue>();
            builder.AddElement<MetadataStrings>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CharacterValue), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MetadataStrings>(deep);
    }

    /// <summary>
    /// <para>MDX Metadata Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mdxMetadata.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Mdx" /> <c>&lt;x:mdx></c></description></item>
    /// </list>
    /// </remark>
    public partial class MdxMetadata : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MdxMetadata class.
        /// </summary>
        public MdxMetadata() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxMetadata(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxMetadata(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxMetadata class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MdxMetadata(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>MDX Metadata Record Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mdxMetadata");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Mdx>();
            builder.AddElement<MdxMetadata>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Mdx), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MdxMetadata>(deep);
    }

    /// <summary>
    /// <para>Future Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:futureMetadata.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FutureMetadataBlock" /> <c>&lt;x:bk></c></description></item>
    /// </list>
    /// </remark>
    public partial class FutureMetadata : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FutureMetadata class.
        /// </summary>
        public FutureMetadata() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FutureMetadata(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FutureMetadata(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadata class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FutureMetadata(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Metadata Type Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Future Metadata Block Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:futureMetadata");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FutureMetadataBlock>();
            builder.AddElement<FutureMetadata>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FutureMetadataBlock), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:metadata")));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:name"), false, new string[] { "XLMDX" }));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 65535));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FutureMetadata>(deep);
    }

    /// <summary>
    /// <para>Cell Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellMetadata.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataBlock" /> <c>&lt;x:bk></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellMetadata : MetadataBlocksType
    {
        /// <summary>
        /// Initializes a new instance of the CellMetadata class.
        /// </summary>
        public CellMetadata() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellMetadata(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellMetadata(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellMetadata class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellMetadata(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellMetadata");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataBlock), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellMetadata>(deep);
    }

    /// <summary>
    /// <para>Value Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:valueMetadata.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataBlock" /> <c>&lt;x:bk></c></description></item>
    /// </list>
    /// </remark>
    public partial class ValueMetadata : MetadataBlocksType
    {
        /// <summary>
        /// Initializes a new instance of the ValueMetadata class.
        /// </summary>
        public ValueMetadata() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueMetadata(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueMetadata class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueMetadata(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueMetadata class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ValueMetadata(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:valueMetadata");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataBlock), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ValueMetadata>(deep);
    }

    /// <summary>
    /// <para>Defines the MetadataBlocksType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataBlock" /> <c>&lt;x:bk></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class MetadataBlocksType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataBlocksType class.
        /// </summary>
        protected MetadataBlocksType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlocksType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected MetadataBlocksType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlocksType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected MetadataBlocksType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlocksType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected MetadataBlocksType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Metadata Block Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MetadataBlock>();
            builder.AddElement<MetadataBlocksType>()
                .AddAttribute("count", a => a.Count);
        }
    }

    /// <summary>
    /// <para>Metadata Type Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:metadataType.</para>
    /// </summary>
    public partial class MetadataType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataType class.
        /// </summary>
        public MetadataType() : base()
        {
        }

        /// <summary>
        /// <para>Metadata Type Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Supported Version</para>
        /// <para>Represents the following attribute in the schema: minSupportedVersion</para>
        /// </summary>
        public UInt32Value? MinSupportedVersion
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Ghost Row</para>
        /// <para>Represents the following attribute in the schema: ghostRow</para>
        /// </summary>
        public BooleanValue? GhostRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Ghost Column</para>
        /// <para>Represents the following attribute in the schema: ghostCol</para>
        /// </summary>
        public BooleanValue? GhostColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Edit</para>
        /// <para>Represents the following attribute in the schema: edit</para>
        /// </summary>
        public BooleanValue? Edit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Cell Value Delete</para>
        /// <para>Represents the following attribute in the schema: delete</para>
        /// </summary>
        public BooleanValue? Delete
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Copy</para>
        /// <para>Represents the following attribute in the schema: copy</para>
        /// </summary>
        public BooleanValue? Copy
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste All</para>
        /// <para>Represents the following attribute in the schema: pasteAll</para>
        /// </summary>
        public BooleanValue? PasteAll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Formulas</para>
        /// <para>Represents the following attribute in the schema: pasteFormulas</para>
        /// </summary>
        public BooleanValue? PasteFormulas
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Special Values</para>
        /// <para>Represents the following attribute in the schema: pasteValues</para>
        /// </summary>
        public BooleanValue? PasteValues
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Formats</para>
        /// <para>Represents the following attribute in the schema: pasteFormats</para>
        /// </summary>
        public BooleanValue? PasteFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Comments</para>
        /// <para>Represents the following attribute in the schema: pasteComments</para>
        /// </summary>
        public BooleanValue? PasteComments
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Data Validation</para>
        /// <para>Represents the following attribute in the schema: pasteDataValidation</para>
        /// </summary>
        public BooleanValue? PasteDataValidation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Borders</para>
        /// <para>Represents the following attribute in the schema: pasteBorders</para>
        /// </summary>
        public BooleanValue? PasteBorders
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Column Widths</para>
        /// <para>Represents the following attribute in the schema: pasteColWidths</para>
        /// </summary>
        public BooleanValue? PasteColWidths
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Paste Number Formats</para>
        /// <para>Represents the following attribute in the schema: pasteNumberFormats</para>
        /// </summary>
        public BooleanValue? PasteNumberFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Merge</para>
        /// <para>Represents the following attribute in the schema: merge</para>
        /// </summary>
        public BooleanValue? Merge
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Meatadata Split First</para>
        /// <para>Represents the following attribute in the schema: splitFirst</para>
        /// </summary>
        public BooleanValue? SplitFirst
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Split All</para>
        /// <para>Represents the following attribute in the schema: splitAll</para>
        /// </summary>
        public BooleanValue? SplitAll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Insert Delete</para>
        /// <para>Represents the following attribute in the schema: rowColShift</para>
        /// </summary>
        public BooleanValue? RowColumnShift
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Clear All</para>
        /// <para>Represents the following attribute in the schema: clearAll</para>
        /// </summary>
        public BooleanValue? ClearAll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Clear Formats</para>
        /// <para>Represents the following attribute in the schema: clearFormats</para>
        /// </summary>
        public BooleanValue? ClearFormats
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Clear Contents</para>
        /// <para>Represents the following attribute in the schema: clearContents</para>
        /// </summary>
        public BooleanValue? ClearContents
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Clear Comments</para>
        /// <para>Represents the following attribute in the schema: clearComments</para>
        /// </summary>
        public BooleanValue? ClearComments
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Formula Assignment</para>
        /// <para>Represents the following attribute in the schema: assign</para>
        /// </summary>
        public BooleanValue? Assign
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Coercion</para>
        /// <para>Represents the following attribute in the schema: coerce</para>
        /// </summary>
        public BooleanValue? Coerce
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Adjust Metadata</para>
        /// <para>Represents the following attribute in the schema: adjust</para>
        /// </summary>
        public BooleanValue? Adjust
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cell Metadata</para>
        /// <para>Represents the following attribute in the schema: cellMeta</para>
        /// </summary>
        public BooleanValue? CellMeta
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:metadataType");
            builder.AddElement<MetadataType>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minSupportedVersion", a => a.MinSupportedVersion, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ghostRow", a => a.GhostRow)
                .AddAttribute("ghostCol", a => a.GhostColumn)
                .AddAttribute("edit", a => a.Edit)
                .AddAttribute("delete", a => a.Delete)
                .AddAttribute("copy", a => a.Copy)
                .AddAttribute("pasteAll", a => a.PasteAll)
                .AddAttribute("pasteFormulas", a => a.PasteFormulas)
                .AddAttribute("pasteValues", a => a.PasteValues)
                .AddAttribute("pasteFormats", a => a.PasteFormats)
                .AddAttribute("pasteComments", a => a.PasteComments)
                .AddAttribute("pasteDataValidation", a => a.PasteDataValidation)
                .AddAttribute("pasteBorders", a => a.PasteBorders)
                .AddAttribute("pasteColWidths", a => a.PasteColWidths)
                .AddAttribute("pasteNumberFormats", a => a.PasteNumberFormats)
                .AddAttribute("merge", a => a.Merge)
                .AddAttribute("splitFirst", a => a.SplitFirst)
                .AddAttribute("splitAll", a => a.SplitAll)
                .AddAttribute("rowColShift", a => a.RowColumnShift)
                .AddAttribute("clearAll", a => a.ClearAll)
                .AddAttribute("clearFormats", a => a.ClearFormats)
                .AddAttribute("clearContents", a => a.ClearContents)
                .AddAttribute("clearComments", a => a.ClearComments)
                .AddAttribute("assign", a => a.Assign)
                .AddAttribute("coerce", a => a.Coerce)
                .AddAttribute("adjust", a => a.Adjust)
                .AddAttribute("cellMeta", a => a.CellMeta);
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:metadataTypes")));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 65535));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MetadataType>(deep);
    }

    /// <summary>
    /// <para>Metadata Block.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:bk.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MetadataRecord" /> <c>&lt;x:rc></c></description></item>
    /// </list>
    /// </remark>
    public partial class MetadataBlock : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataBlock class.
        /// </summary>
        public MetadataBlock() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlock class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataBlock(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlock class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MetadataBlock(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MetadataBlock class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MetadataBlock(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:bk");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MetadataRecord>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MetadataRecord), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MetadataBlock>(deep);
    }

    /// <summary>
    /// <para>Metadata Record.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rc.</para>
    /// </summary>
    public partial class MetadataRecord : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MetadataRecord class.
        /// </summary>
        public MetadataRecord() : base()
        {
        }

        /// <summary>
        /// <para>Metadata Record Type Index</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public UInt32Value? TypeIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Metadata Record Value Index</para>
        /// <para>Represents the following attribute in the schema: v</para>
        /// </summary>
        public UInt32Value? Val
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rc");
            builder.AddElement<MetadataRecord>()
                .AddAttribute("t", a => a.TypeIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("v", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:t"), ".", null, builder.CreateQName("x:metadataType"), "x:metadataType", 1));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:t"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MetadataRecord>(deep);
    }

    /// <summary>
    /// <para>Future Metadata Block.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:bk.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class FutureMetadataBlock : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FutureMetadataBlock class.
        /// </summary>
        public FutureMetadataBlock() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadataBlock class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FutureMetadataBlock(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadataBlock class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FutureMetadataBlock(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FutureMetadataBlock class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FutureMetadataBlock(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:bk");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Future Feature Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FutureMetadataBlock>(deep);
    }

    /// <summary>
    /// <para>MDX Metadata Record.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mdx.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MdxKpi" /> <c>&lt;x:k></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MdxMemberProp" /> <c>&lt;x:p></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MdxSet" /> <c>&lt;x:ms></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MdxTuple" /> <c>&lt;x:t></c></description></item>
    /// </list>
    /// </remark>
    public partial class Mdx : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Mdx class.
        /// </summary>
        public Mdx() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mdx class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Mdx(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mdx class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Mdx(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mdx class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Mdx(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Connection Name Index</para>
        /// <para>Represents the following attribute in the schema: n</para>
        /// </summary>
        public UInt32Value? NameIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cube Function Tag</para>
        /// <para>Represents the following attribute in the schema: f</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxFunctionValues>? CubeFunction
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxFunctionValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mdx");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MdxKpi>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MdxMemberProp>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MdxSet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MdxTuple>();
            builder.AddElement<Mdx>()
                .AddAttribute("n", a => a.NameIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("f", a => a.CubeFunction, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MdxTuple), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MdxSet), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MdxMemberProp), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MdxKpi), 1, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:n"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:n"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <summary>
        /// <para>Tuple MDX Metadata.</para>
        /// <para>Represents the following element tag in the schema: x:t.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MdxTuple? MdxTuple
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MdxTuple>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Set MDX Metadata.</para>
        /// <para>Represents the following element tag in the schema: x:ms.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MdxSet? MdxSet
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MdxSet>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Member Property MDX Metadata.</para>
        /// <para>Represents the following element tag in the schema: x:p.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MdxMemberProp? MdxMemberProp
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MdxMemberProp>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>KPI MDX Metadata.</para>
        /// <para>Represents the following element tag in the schema: x:k.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MdxKpi? MdxKpi
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MdxKpi>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Mdx>(deep);
    }

    /// <summary>
    /// <para>Tuple MDX Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:t.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NameIndex" /> <c>&lt;x:n></c></description></item>
    /// </list>
    /// </remark>
    public partial class MdxTuple : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MdxTuple class.
        /// </summary>
        public MdxTuple() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxTuple class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxTuple(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxTuple class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxTuple(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxTuple class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MdxTuple(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Member Index Count</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public UInt32Value? MemberIndexCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Culture Currency</para>
        /// <para>Represents the following attribute in the schema: ct</para>
        /// </summary>
        public StringValue? CultureCurrency
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting String Index</para>
        /// <para>Represents the following attribute in the schema: si</para>
        /// </summary>
        public UInt32Value? FormattingStringIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Built-In Number Format Index</para>
        /// <para>Represents the following attribute in the schema: fi</para>
        /// </summary>
        public UInt32Value? FormatIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Background Color</para>
        /// <para>Represents the following attribute in the schema: bc</para>
        /// </summary>
        public HexBinaryValue? BackgroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Foreground Color</para>
        /// <para>Represents the following attribute in the schema: fc</para>
        /// </summary>
        public HexBinaryValue? ForegroundColor
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Italic Font</para>
        /// <para>Represents the following attribute in the schema: i</para>
        /// </summary>
        public BooleanValue? Italic
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Underline Font</para>
        /// <para>Represents the following attribute in the schema: u</para>
        /// </summary>
        public BooleanValue? Underline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Strikethrough Font</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public BooleanValue? Strikethrough
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Server Formatting Bold Font</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public BooleanValue? Bold
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:t");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NameIndex>();
            builder.AddElement<MdxTuple>()
                .AddAttribute("c", a => a.MemberIndexCount)
                .AddAttribute("ct", a => a.CultureCurrency)
                .AddAttribute("si", a => a.FormattingStringIndex)
                .AddAttribute("fi", a => a.FormatIndex)
                .AddAttribute("bc", a => a.BackgroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("fc", a => a.ForegroundColor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                })
                .AddAttribute("i", a => a.Italic)
                .AddAttribute("u", a => a.Underline)
                .AddAttribute("st", a => a.Strikethrough)
                .AddAttribute("b", a => a.Bold);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NameIndex), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:si"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:si"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:c"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:fi"), true, double.NegativeInfinity, true, 58, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MdxTuple>(deep);
    }

    /// <summary>
    /// <para>Set MDX Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ms.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NameIndex" /> <c>&lt;x:n></c></description></item>
    /// </list>
    /// </remark>
    public partial class MdxSet : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MdxSet class.
        /// </summary>
        public MdxSet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxSet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MdxSet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MdxSet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MdxSet(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Set Definition Index</para>
        /// <para>Represents the following attribute in the schema: ns</para>
        /// </summary>
        public UInt32Value? SetDefinitionIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sort By Member Index Count</para>
        /// <para>Represents the following attribute in the schema: c</para>
        /// </summary>
        public UInt32Value? MemberIndexCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Set Sort Order</para>
        /// <para>Represents the following attribute in the schema: o</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxSetOrderValues>? SortingOrder
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxSetOrderValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ms");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NameIndex>();
            builder.AddElement<MdxSet>()
                .AddAttribute("ns", a => a.SetDefinitionIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("c", a => a.MemberIndexCount)
                .AddAttribute("o", a => a.SortingOrder);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NameIndex), 0, 0)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:ns"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:ns"), true, 0, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:c"), true, 0, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MdxSet>(deep);
    }

    /// <summary>
    /// <para>Member Property MDX Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:p.</para>
    /// </summary>
    public partial class MdxMemberProp : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MdxMemberProp class.
        /// </summary>
        public MdxMemberProp() : base()
        {
        }

        /// <summary>
        /// <para>Member Unique Name Index</para>
        /// <para>Represents the following attribute in the schema: n</para>
        /// </summary>
        public UInt32Value? NameIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Property Name Index</para>
        /// <para>Represents the following attribute in the schema: np</para>
        /// </summary>
        public UInt32Value? PropertyNameIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:p");
            builder.AddElement<MdxMemberProp>()
                .AddAttribute("n", a => a.NameIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("np", a => a.PropertyNameIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:n"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:n"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:np"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:np"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MdxMemberProp>(deep);
    }

    /// <summary>
    /// <para>KPI MDX Metadata.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:k.</para>
    /// </summary>
    public partial class MdxKpi : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MdxKpi class.
        /// </summary>
        public MdxKpi() : base()
        {
        }

        /// <summary>
        /// <para>Member Unique Name Index</para>
        /// <para>Represents the following attribute in the schema: n</para>
        /// </summary>
        public UInt32Value? NameIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Index</para>
        /// <para>Represents the following attribute in the schema: np</para>
        /// </summary>
        public UInt32Value? KpiIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>KPI Property</para>
        /// <para>Represents the following attribute in the schema: p</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxKPIPropertyValues>? KpiProperty
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxKPIPropertyValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:k");
            builder.AddElement<MdxKpi>()
                .AddAttribute("n", a => a.NameIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("np", a => a.KpiIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("p", a => a.KpiProperty, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:n"), ".", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:n"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:np"), "/WorkbookPart/CellMetadataPart", builder.CreateQName("x:metadataStrings"), builder.CreateQName("x:s"), "x:s", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:np"), true, double.NegativeInfinity, true, 2147483647, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MdxKpi>(deep);
    }

    /// <summary>
    /// <para>Member Unique Name Index.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:n.</para>
    /// </summary>
    public partial class NameIndex : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the NameIndex class.
        /// </summary>
        public NameIndex() : base()
        {
        }

        /// <summary>
        /// <para>Index Value</para>
        /// <para>Represents the following attribute in the schema: x</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>String is a Set</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public BooleanValue? IsASet
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:n");
            builder.AddElement<NameIndex>()
                .AddAttribute("x", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("s", a => a.IsASet);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:x"), true, 0, true, double.PositiveInfinity, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:x"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:in"), ".", null, builder.CreateQName("x:serverFormat"), "x:serverFormat", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:c"), 0, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:v"), false, new string[] { "INF", "-INF", "NaN" }) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NameIndex>(deep);
    }

    /// <summary>
    /// <para>Table Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:singleXmlCell.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.XmlCellProperties" /> <c>&lt;x:xmlCellPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class SingleXmlCell : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SingleXmlCell class.
        /// </summary>
        public SingleXmlCell() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SingleXmlCell(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SingleXmlCell(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SingleXmlCell class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SingleXmlCell(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Connection ID</para>
        /// <para>Represents the following attribute in the schema: connectionId</para>
        /// </summary>
        public UInt32Value? ConnectionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:singleXmlCell");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.XmlCellProperties>();
            builder.AddElement<SingleXmlCell>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("connectionId", a => a.ConnectionId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.XmlCellProperties), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, 4294967294, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:connectionId"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, null));
        }

        /// <summary>
        /// <para>Cell Properties.</para>
        /// <para>Represents the following element tag in the schema: x:xmlCellPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.XmlCellProperties? XmlCellProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.XmlCellProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SingleXmlCell>(deep);
    }

    /// <summary>
    /// <para>Cell Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:xmlCellPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.XmlProperties" /> <c>&lt;x:xmlPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class XmlCellProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the XmlCellProperties class.
        /// </summary>
        public XmlCellProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlCellProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlCellProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlCellProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlCellProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlCellProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public XmlCellProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Field Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique Table Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:xmlCellPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.XmlProperties>();
            builder.AddElement<XmlCellProperties>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uniqueName", a => a.UniqueName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.XmlProperties), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:id"), true, new string[] { "1" }));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueName"), 1, 255) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Column XML Properties.</para>
        /// <para>Represents the following element tag in the schema: x:xmlPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.XmlProperties? XmlProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.XmlProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<XmlCellProperties>(deep);
    }

    /// <summary>
    /// <para>Column XML Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:xmlPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class XmlProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the XmlProperties class.
        /// </summary>
        public XmlProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public XmlProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>XML Map Id</para>
        /// <para>Represents the following attribute in the schema: mapId</para>
        /// </summary>
        public UInt32Value? MapId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>XPath</para>
        /// <para>Represents the following attribute in the schema: xpath</para>
        /// </summary>
        public StringValue? XPath
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>XML Data Type</para>
        /// <para>Represents the following attribute in the schema: xmlDataType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>? XmlDataType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:xmlPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<XmlProperties>()
                .AddAttribute("mapId", a => a.MapId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("xpath", a => a.XPath, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("xmlDataType", a => a.XmlDataType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:xpath"), 0, 32000));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:mapId"), true, 1, true, 2147483647, true));
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<XmlProperties>(deep);
    }

    /// <summary>
    /// <para>Pattern.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:patternFill.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ForegroundColor" /> <c>&lt;x:fgColor></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BackgroundColor" /> <c>&lt;x:bgColor></c></description></item>
    /// </list>
    /// </remark>
    public partial class PatternFill : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PatternFill class.
        /// </summary>
        public PatternFill() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PatternFill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PatternFill(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PatternFill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PatternFill(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PatternFill class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PatternFill(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Pattern Type</para>
        /// <para>Represents the following attribute in the schema: patternType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PatternValues>? PatternType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.PatternValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:patternFill");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ForegroundColor>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BackgroundColor>();
            builder.AddElement<PatternFill>()
                .AddAttribute("patternType", a => a.PatternType);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ForegroundColor), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BackgroundColor), 0, 1)
            };
        }

        /// <summary>
        /// <para>Foreground Color.</para>
        /// <para>Represents the following element tag in the schema: x:fgColor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ForegroundColor? ForegroundColor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ForegroundColor>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Background Color.</para>
        /// <para>Represents the following element tag in the schema: x:bgColor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.BackgroundColor? BackgroundColor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.BackgroundColor>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PatternFill>(deep);
    }

    /// <summary>
    /// <para>Gradient.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:gradientFill.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GradientStop" /> <c>&lt;x:stop></c></description></item>
    /// </list>
    /// </remark>
    public partial class GradientFill : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GradientFill class.
        /// </summary>
        public GradientFill() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientFill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GradientFill(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientFill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GradientFill(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientFill class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GradientFill(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Gradient Fill Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GradientValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.GradientValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Linear Gradient Degree</para>
        /// <para>Represents the following attribute in the schema: degree</para>
        /// </summary>
        public DoubleValue? Degree
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Left Convergence</para>
        /// <para>Represents the following attribute in the schema: left</para>
        /// </summary>
        public DoubleValue? Left
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Right Convergence</para>
        /// <para>Represents the following attribute in the schema: right</para>
        /// </summary>
        public DoubleValue? Right
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Gradient Convergence</para>
        /// <para>Represents the following attribute in the schema: top</para>
        /// </summary>
        public DoubleValue? Top
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Bottom Convergence</para>
        /// <para>Represents the following attribute in the schema: bottom</para>
        /// </summary>
        public DoubleValue? Bottom
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:gradientFill");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GradientStop>();
            builder.AddElement<GradientFill>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("degree", a => a.Degree)
                .AddAttribute("left", a => a.Left)
                .AddAttribute("right", a => a.Right)
                .AddAttribute("top", a => a.Top)
                .AddAttribute("bottom", a => a.Bottom);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GradientStop), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:top"), true, 0, true, 1, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:bottom"), true, 0, true, 1, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:left"), true, 0, true, 1, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:right"), true, 0, true, 1, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:degree"), true, -1.7E+308, true, 1.7E+308, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GradientFill>(deep);
    }

    /// <summary>
    /// <para>Gradient Stop.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:stop.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class GradientStop : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GradientStop class.
        /// </summary>
        public GradientStop() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientStop class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GradientStop(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientStop class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GradientStop(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GradientStop class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GradientStop(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Gradient Stop Position</para>
        /// <para>Represents the following attribute in the schema: position</para>
        /// </summary>
        public DoubleValue? Position
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:stop");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.AddElement<GradientStop>()
                .AddAttribute("position", a => a.Position, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 1, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:position"), true, 0, true, 1, true));
        }

        /// <summary>
        /// <para>Color.</para>
        /// <para>Represents the following element tag in the schema: x:color.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Color? Color
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Color>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GradientStop>(deep);
    }

    /// <summary>
    /// <para>Number Formats.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:numFmt.</para>
    /// </summary>
    public partial class NumberingFormat : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the NumberingFormat class.
        /// </summary>
        public NumberingFormat() : base()
        {
        }

        /// <summary>
        /// <para>Number Format Id</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Number Format Code</para>
        /// <para>Represents the following attribute in the schema: formatCode</para>
        /// </summary>
        public StringValue? FormatCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:numFmt");
            builder.AddElement<NumberingFormat>()
                .AddAttribute("numFmtId", a => a.NumberFormatId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("formatCode", a => a.FormatCode, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:formatCode"), 0, 255));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumberingFormat>(deep);
    }

    /// <summary>
    /// <para>Alignment.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:alignment.</para>
    /// </summary>
    public partial class Alignment : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Alignment class.
        /// </summary>
        public Alignment() : base()
        {
        }

        /// <summary>
        /// <para>Horizontal Alignment</para>
        /// <para>Represents the following attribute in the schema: horizontal</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.HorizontalAlignmentValues>? Horizontal
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.HorizontalAlignmentValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical Alignment</para>
        /// <para>Represents the following attribute in the schema: vertical</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentValues>? Vertical
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Text Rotation</para>
        /// <para>Represents the following attribute in the schema: textRotation</para>
        /// </summary>
        public UInt32Value? TextRotation
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Wrap Text</para>
        /// <para>Represents the following attribute in the schema: wrapText</para>
        /// </summary>
        public BooleanValue? WrapText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Indent</para>
        /// <para>Represents the following attribute in the schema: indent</para>
        /// </summary>
        public UInt32Value? Indent
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relative Indent</para>
        /// <para>Represents the following attribute in the schema: relativeIndent</para>
        /// </summary>
        public Int32Value? RelativeIndent
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Justify Last Line</para>
        /// <para>Represents the following attribute in the schema: justifyLastLine</para>
        /// </summary>
        public BooleanValue? JustifyLastLine
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shrink To Fit</para>
        /// <para>Represents the following attribute in the schema: shrinkToFit</para>
        /// </summary>
        public BooleanValue? ShrinkToFit
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reading Order</para>
        /// <para>Represents the following attribute in the schema: readingOrder</para>
        /// </summary>
        public UInt32Value? ReadingOrder
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mergeCell</para>
        /// <para>Represents the following attribute in the schema: mergeCell</para>
        /// </summary>
        public StringValue? MergeCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:alignment");
            builder.AddElement<Alignment>()
                .AddAttribute("horizontal", a => a.Horizontal)
                .AddAttribute("vertical", a => a.Vertical)
                .AddAttribute("textRotation", a => a.TextRotation)
                .AddAttribute("wrapText", a => a.WrapText)
                .AddAttribute("indent", a => a.Indent)
                .AddAttribute("relativeIndent", a => a.RelativeIndent)
                .AddAttribute("justifyLastLine", a => a.JustifyLastLine)
                .AddAttribute("shrinkToFit", a => a.ShrinkToFit)
                .AddAttribute("readingOrder", a => a.ReadingOrder)
                .AddAttribute("mergeCell", a => a.MergeCell);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:readingOrder"), true, 0, true, 2, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:indent"), true, double.NegativeInfinity, true, 255, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:readingOrder"), true, new string[] { "0", "1", "2" }) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Alignment>(deep);
    }

    /// <summary>
    /// <para>Protection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:protection.</para>
    /// </summary>
    public partial class Protection : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Protection class.
        /// </summary>
        public Protection() : base()
        {
        }

        /// <summary>
        /// <para>Cell Locked</para>
        /// <para>Represents the following attribute in the schema: locked</para>
        /// </summary>
        public BooleanValue? Locked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Cell</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:protection");
            builder.AddElement<Protection>()
                .AddAttribute("locked", a => a.Locked)
                .AddAttribute("hidden", a => a.Hidden);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Protection>(deep);
    }

    /// <summary>
    /// <para>Font Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:font.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Bold" /> <c>&lt;x:b></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Italic" /> <c>&lt;x:i></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Strike" /> <c>&lt;x:strike></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Condense" /> <c>&lt;x:condense></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Extend" /> <c>&lt;x:extend></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Outline" /> <c>&lt;x:outline></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Shadow" /> <c>&lt;x:shadow></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontCharSet" /> <c>&lt;x:charset></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontFamilyNumbering" /> <c>&lt;x:family></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontName" /> <c>&lt;x:name></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontScheme" /> <c>&lt;x:scheme></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FontSize" /> <c>&lt;x:sz></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Underline" /> <c>&lt;x:u></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment" /> <c>&lt;x:vertAlign></c></description></item>
    /// </list>
    /// </remark>
    public partial class Font : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Font class.
        /// </summary>
        public Font() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Font class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Font(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Font class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Font(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Font class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Font(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:font");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Bold>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Italic>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Strike>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Condense>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Extend>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Outline>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Shadow>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontCharSet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontFamilyNumbering>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontName>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontScheme>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FontSize>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Underline>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Bold), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Italic), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Strike), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Condense), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Extend), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Outline), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Shadow), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Underline), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontSize), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontName), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontFamilyNumbering), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontCharSet), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FontScheme), 0, 1)
            };
        }

        /// <summary>
        /// <para>Bold.</para>
        /// <para>Represents the following element tag in the schema: x:b.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Bold? Bold
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Bold>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Italic.</para>
        /// <para>Represents the following element tag in the schema: x:i.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Italic? Italic
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Italic>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Strike Through.</para>
        /// <para>Represents the following element tag in the schema: x:strike.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Strike? Strike
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Strike>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Condense.</para>
        /// <para>Represents the following element tag in the schema: x:condense.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Condense? Condense
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Condense>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Extend.</para>
        /// <para>Represents the following element tag in the schema: x:extend.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Extend? Extend
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Extend>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Outline.</para>
        /// <para>Represents the following element tag in the schema: x:outline.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Outline? Outline
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Outline>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Shadow.</para>
        /// <para>Represents the following element tag in the schema: x:shadow.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Shadow? Shadow
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Shadow>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Underline.</para>
        /// <para>Represents the following element tag in the schema: x:u.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Underline? Underline
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Underline>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Vertical Alignment.</para>
        /// <para>Represents the following element tag in the schema: x:vertAlign.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment? VerticalTextAlignment
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.VerticalTextAlignment>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Font Size.</para>
        /// <para>Represents the following element tag in the schema: x:sz.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FontSize? FontSize
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FontSize>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Color.</para>
        /// <para>Represents the following element tag in the schema: x:color.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Color? Color
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Color>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Font Name.</para>
        /// <para>Represents the following element tag in the schema: x:name.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FontName? FontName
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FontName>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Font Family.</para>
        /// <para>Represents the following element tag in the schema: x:family.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FontFamilyNumbering? FontFamilyNumbering
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FontFamilyNumbering>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Character Set.</para>
        /// <para>Represents the following element tag in the schema: x:charset.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FontCharSet? FontCharSet
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FontCharSet>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Scheme.</para>
        /// <para>Represents the following element tag in the schema: x:scheme.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FontScheme? FontScheme
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FontScheme>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Font>(deep);
    }

    /// <summary>
    /// <para>Fill.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fill.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GradientFill" /> <c>&lt;x:gradientFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PatternFill" /> <c>&lt;x:patternFill></c></description></item>
    /// </list>
    /// </remark>
    public partial class Fill : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Fill class.
        /// </summary>
        public Fill() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fill(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fill class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fill(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fill class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Fill(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fill");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GradientFill>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PatternFill>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PatternFill), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GradientFill), 0, 1)
            };
        }

        /// <summary>
        /// <para>Pattern.</para>
        /// <para>Represents the following element tag in the schema: x:patternFill.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PatternFill? PatternFill
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PatternFill>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Gradient.</para>
        /// <para>Represents the following element tag in the schema: x:gradientFill.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.GradientFill? GradientFill
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.GradientFill>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Fill>(deep);
    }

    /// <summary>
    /// <para>Border Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:border.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StartBorder" /> <c>&lt;x:start></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.EndBorder" /> <c>&lt;x:end></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.LeftBorder" /> <c>&lt;x:left></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RightBorder" /> <c>&lt;x:right></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TopBorder" /> <c>&lt;x:top></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BottomBorder" /> <c>&lt;x:bottom></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DiagonalBorder" /> <c>&lt;x:diagonal></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.VerticalBorder" /> <c>&lt;x:vertical></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.HorizontalBorder" /> <c>&lt;x:horizontal></c></description></item>
    /// </list>
    /// </remark>
    public partial class Border : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Border class.
        /// </summary>
        public Border() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Border class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Border(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Border class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Border(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Border class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Border(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Diagonal Up</para>
        /// <para>Represents the following attribute in the schema: diagonalUp</para>
        /// </summary>
        public BooleanValue? DiagonalUp
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Diagonal Down</para>
        /// <para>Represents the following attribute in the schema: diagonalDown</para>
        /// </summary>
        public BooleanValue? DiagonalDown
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline</para>
        /// <para>Represents the following attribute in the schema: outline</para>
        /// </summary>
        public BooleanValue? Outline
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:border");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StartBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.EndBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.LeftBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RightBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TopBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BottomBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DiagonalBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.VerticalBorder>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.HorizontalBorder>();
            builder.AddElement<Border>()
                .AddAttribute("diagonalUp", a => a.DiagonalUp)
                .AddAttribute("diagonalDown", a => a.DiagonalDown)
                .AddAttribute("outline", a => a.Outline);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StartBorder), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.EndBorder), 0, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.LeftBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RightBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TopBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BottomBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DiagonalBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.VerticalBorder), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.HorizontalBorder), 0, 1)
            };
        }

        /// <summary>
        /// <para>StartBorder, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x:start.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.StartBorder? StartBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.StartBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>EndBorder, this property is only available in Office 2010 and later..</para>
        /// <para>Represents the following element tag in the schema: x:end.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.EndBorder? EndBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.EndBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Left Border.</para>
        /// <para>Represents the following element tag in the schema: x:left.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.LeftBorder? LeftBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.LeftBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Right Border.</para>
        /// <para>Represents the following element tag in the schema: x:right.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RightBorder? RightBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RightBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Top Border.</para>
        /// <para>Represents the following element tag in the schema: x:top.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TopBorder? TopBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TopBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Bottom Border.</para>
        /// <para>Represents the following element tag in the schema: x:bottom.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.BottomBorder? BottomBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.BottomBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Diagonal.</para>
        /// <para>Represents the following element tag in the schema: x:diagonal.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DiagonalBorder? DiagonalBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DiagonalBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Vertical Inner Border.</para>
        /// <para>Represents the following element tag in the schema: x:vertical.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.VerticalBorder? VerticalBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.VerticalBorder>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Horizontal Inner Borders.</para>
        /// <para>Represents the following element tag in the schema: x:horizontal.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.HorizontalBorder? HorizontalBorder
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.HorizontalBorder>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Border>(deep);
    }

    /// <summary>
    /// <para>Color Indexes.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:indexedColors.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RgbColor" /> <c>&lt;x:rgbColor></c></description></item>
    /// </list>
    /// </remark>
    public partial class IndexedColors : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the IndexedColors class.
        /// </summary>
        public IndexedColors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the IndexedColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IndexedColors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IndexedColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IndexedColors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IndexedColors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public IndexedColors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:indexedColors");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RgbColor>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RgbColor), 1, 64)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IndexedColors>(deep);
    }

    /// <summary>
    /// <para>MRU Colors.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mruColors.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class MruColors : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MruColors class.
        /// </summary>
        public MruColors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MruColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MruColors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MruColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MruColors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MruColors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MruColors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mruColors");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 1, 10)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MruColors>(deep);
    }

    /// <summary>
    /// <para>Table Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableStyle.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableStyleElement" /> <c>&lt;x:tableStyleElement></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableStyle : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableStyle class.
        /// </summary>
        public TableStyle() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableStyle(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableStyle(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyle class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableStyle(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Style Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Pivot Style</para>
        /// <para>Represents the following attribute in the schema: pivot</para>
        /// </summary>
        public BooleanValue? Pivot
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table</para>
        /// <para>Represents the following attribute in the schema: table</para>
        /// </summary>
        public BooleanValue? Table
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Table Style Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableStyle");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableStyleElement>();
            builder.AddElement<TableStyle>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("pivot", a => a.Pivot)
                .AddAttribute("table", a => a.Table)
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableStyleElement), 0, 28)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableStyle>(deep);
    }

    /// <summary>
    /// <para>RGB Color.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rgbColor.</para>
    /// </summary>
    public partial class RgbColor : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RgbColor class.
        /// </summary>
        public RgbColor() : base()
        {
        }

        /// <summary>
        /// <para>Alpha Red Green Blue</para>
        /// <para>Represents the following attribute in the schema: rgb</para>
        /// </summary>
        public HexBinaryValue? Rgb
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rgbColor");
            builder.AddElement<RgbColor>()
                .AddAttribute("rgb", a => a.Rgb, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (4L) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RgbColor>(deep);
    }

    /// <summary>
    /// <para>Cell Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellStyle.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellStyle : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellStyle class.
        /// </summary>
        public CellStyle() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyle(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyle(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyle class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellStyle(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>User Defined Cell Style</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Id</para>
        /// <para>Represents the following attribute in the schema: xfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Built-In Style Id</para>
        /// <para>Represents the following attribute in the schema: builtinId</para>
        /// </summary>
        public UInt32Value? BuiltinId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Outline Style</para>
        /// <para>Represents the following attribute in the schema: iLevel</para>
        /// </summary>
        public UInt32Value? OutlineLevel
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Style</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Built In</para>
        /// <para>Represents the following attribute in the schema: customBuiltin</para>
        /// </summary>
        public BooleanValue? CustomBuiltin
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellStyle");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<CellStyle>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("xfId", a => a.FormatId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("builtinId", a => a.BuiltinId)
                .AddAttribute("iLevel", a => a.OutlineLevel)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("customBuiltin", a => a.CustomBuiltin);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:builtinId"), true, 0, true, 53, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:iLevel"), true, 0, true, 7, true));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:xfId"), true, builder.CreateQName("x:cellStyles")));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:xfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:xf"), "x:xf", 0));
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellStyle>(deep);
    }

    /// <summary>
    /// <para>Formatting Elements.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:xf.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Alignment" /> <c>&lt;x:alignment></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Protection" /> <c>&lt;x:protection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellFormat : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellFormat class.
        /// </summary>
        public CellFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellFormat(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Number Format Id</para>
        /// <para>Represents the following attribute in the schema: numFmtId</para>
        /// </summary>
        public UInt32Value? NumberFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Font Id</para>
        /// <para>Represents the following attribute in the schema: fontId</para>
        /// </summary>
        public UInt32Value? FontId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fill Id</para>
        /// <para>Represents the following attribute in the schema: fillId</para>
        /// </summary>
        public UInt32Value? FillId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Border Id</para>
        /// <para>Represents the following attribute in the schema: borderId</para>
        /// </summary>
        public UInt32Value? BorderId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Id</para>
        /// <para>Represents the following attribute in the schema: xfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Quote Prefix</para>
        /// <para>Represents the following attribute in the schema: quotePrefix</para>
        /// </summary>
        public BooleanValue? QuotePrefix
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Pivot Button</para>
        /// <para>Represents the following attribute in the schema: pivotButton</para>
        /// </summary>
        public BooleanValue? PivotButton
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Number Format</para>
        /// <para>Represents the following attribute in the schema: applyNumberFormat</para>
        /// </summary>
        public BooleanValue? ApplyNumberFormat
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Font</para>
        /// <para>Represents the following attribute in the schema: applyFont</para>
        /// </summary>
        public BooleanValue? ApplyFont
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Fill</para>
        /// <para>Represents the following attribute in the schema: applyFill</para>
        /// </summary>
        public BooleanValue? ApplyFill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Border</para>
        /// <para>Represents the following attribute in the schema: applyBorder</para>
        /// </summary>
        public BooleanValue? ApplyBorder
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Alignment</para>
        /// <para>Represents the following attribute in the schema: applyAlignment</para>
        /// </summary>
        public BooleanValue? ApplyAlignment
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Apply Protection</para>
        /// <para>Represents the following attribute in the schema: applyProtection</para>
        /// </summary>
        public BooleanValue? ApplyProtection
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:xf");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Alignment>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Protection>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<CellFormat>()
                .AddAttribute("numFmtId", a => a.NumberFormatId)
                .AddAttribute("fontId", a => a.FontId)
                .AddAttribute("fillId", a => a.FillId)
                .AddAttribute("borderId", a => a.BorderId)
                .AddAttribute("xfId", a => a.FormatId)
                .AddAttribute("quotePrefix", a => a.QuotePrefix)
                .AddAttribute("pivotButton", a => a.PivotButton)
                .AddAttribute("applyNumberFormat", a => a.ApplyNumberFormat)
                .AddAttribute("applyFont", a => a.ApplyFont)
                .AddAttribute("applyFill", a => a.ApplyFill)
                .AddAttribute("applyBorder", a => a.ApplyBorder)
                .AddAttribute("applyAlignment", a => a.ApplyAlignment)
                .AddAttribute("applyProtection", a => a.ApplyProtection);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Alignment), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Protection), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:borderId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:border"), "x:border", 0));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:borderId"), true, 0, true, double.PositiveInfinity, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fillId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:fill"), "x:fill", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fontId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:font"), "x:font", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:xfId"), "/WorkbookPart/WorkbookStylesPart", builder.CreateQName("x:cellStyleXfs"), builder.CreateQName("x:xf"), "x:xf", 0));
        }

        /// <summary>
        /// <para>Alignment.</para>
        /// <para>Represents the following element tag in the schema: x:alignment.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Alignment? Alignment
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Alignment>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Protection.</para>
        /// <para>Represents the following element tag in the schema: x:protection.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Protection? Protection
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Protection>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellFormat>(deep);
    }

    /// <summary>
    /// <para>Font Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:name.</para>
    /// </summary>
    public partial class FontName : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FontName class.
        /// </summary>
        public FontName() : base()
        {
        }

        /// <summary>
        /// <para>String Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:name");
            builder.AddElement<FontName>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { MinLength = (1L) });
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:val"), 1, 31) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontName>(deep);
    }

    /// <summary>
    /// <para>Font Family.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:family.</para>
    /// </summary>
    public partial class FontFamilyNumbering : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FontFamilyNumbering class.
        /// </summary>
        public FontFamilyNumbering() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:family");
            builder.AddElement<FontFamilyNumbering>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (0L), MaxInclusive = (5L) });
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, 0, true, 5, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontFamilyNumbering>(deep);
    }

    /// <summary>
    /// <para>Character Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:charset.</para>
    /// </summary>
    public partial class FontCharSet : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FontCharSet class.
        /// </summary>
        public FontCharSet() : base()
        {
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:charset");
            builder.AddElement<FontCharSet>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (0L), MaxInclusive = (255L) });
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:val"), true, 0, true, 255, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FontCharSet>(deep);
    }

    /// <summary>
    /// <para>Table Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableStyleElement.</para>
    /// </summary>
    public partial class TableStyleElement : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the TableStyleElement class.
        /// </summary>
        public TableStyleElement() : base()
        {
        }

        /// <summary>
        /// <para>Table Style Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableStyleValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableStyleValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Band Size</para>
        /// <para>Represents the following attribute in the schema: size</para>
        /// </summary>
        public UInt32Value? Size
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Formatting Id</para>
        /// <para>Represents the following attribute in the schema: dxfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableStyleElement");
            builder.AddElement<TableStyleElement>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("size", a => a.Size)
                .AddAttribute("dxfId", a => a.FormatId);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:size"), true, 1, true, 9, true));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableStyleElement>(deep);
    }

    /// <summary>
    /// <para>Defined Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:definedName.</para>
    /// </summary>
    public partial class ExternalDefinedName : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalDefinedName class.
        /// </summary>
        public ExternalDefinedName() : base()
        {
        }

        /// <summary>
        /// <para>Defined Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Refers To</para>
        /// <para>Represents the following attribute in the schema: refersTo</para>
        /// </summary>
        public StringValue? RefersTo
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:definedName");
            builder.AddElement<ExternalDefinedName>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("refersTo", a => a.RefersTo)
                .AddAttribute("sheetId", a => a.SheetId);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 65533, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:comment"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:localSheetId"), true, double.NegativeInfinity, true, 32766, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalDefinedName>(deep);
    }

    /// <summary>
    /// <para>External Sheet Data Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetData.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalRow" /> <c>&lt;x:row></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalSheetData : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalSheetData class.
        /// </summary>
        public ExternalSheetData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalSheetData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalSheetData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalSheetData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalSheetData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalSheetData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalSheetData(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Last Refresh Resulted in Error</para>
        /// <para>Represents the following attribute in the schema: refreshError</para>
        /// </summary>
        public BooleanValue? RefreshError
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetData");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalRow>();
            builder.AddElement<ExternalSheetData>()
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("refreshError", a => a.RefreshError);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalRow), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 65533, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalSheetData>(deep);
    }

    /// <summary>
    /// <para>Row.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:row.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalCell" /> <c>&lt;x:cell></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalRow : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalRow class.
        /// </summary>
        public ExternalRow() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalRow class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalRow(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalRow class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalRow(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalRow class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalRow(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Row</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public UInt32Value? RowIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:row");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalCell>();
            builder.AddElement<ExternalRow>()
                .AddAttribute("r", a => a.RowIndex, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalCell), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:r"), true, 1, true, 1048576, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:outlineLevel"), true, 0, true, 7, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:s"), true, 0, true, 65490, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:r"), true, double.NegativeInfinity, true, 1048576, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalRow>(deep);
    }

    /// <summary>
    /// <para>External Cell Data.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cell.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Xstring" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalCell : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalCell class.
        /// </summary>
        public ExternalCell() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalCell(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalCell class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalCell(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalCell class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalCell(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>? DataType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value Metadata</para>
        /// <para>Represents the following attribute in the schema: vm</para>
        /// </summary>
        public UInt32Value? ValueMetaIndex
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cell");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Xstring>();
            builder.AddElement<ExternalCell>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("t", a => a.DataType)
                .AddAttribute("vm", a => a.ValueMetaIndex);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Xstring), 0, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:t"), false, new string[] { "s" }));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:vm"), "/WorkbookPart/CellMetadataPart", null, builder.CreateQName("x:valueMetadata"), "x:valueMetadata", 0));
        }

        /// <summary>
        /// <para>Value.</para>
        /// <para>Represents the following element tag in the schema: x:v.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Xstring? Xstring
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Xstring>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalCell>(deep);
    }

    /// <summary>
    /// <para>DDE Items Collection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ddeItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DdeItem" /> <c>&lt;x:ddeItem></c></description></item>
    /// </list>
    /// </remark>
    public partial class DdeItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DdeItems class.
        /// </summary>
        public DdeItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DdeItems(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ddeItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DdeItem>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DdeItem), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DdeItems>(deep);
    }

    /// <summary>
    /// <para>DDE Item definition.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ddeItem.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Values" /> <c>&lt;x:values></c></description></item>
    /// </list>
    /// </remark>
    public partial class DdeItem : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DdeItem class.
        /// </summary>
        public DdeItem() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeItem(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItem class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeItem(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeItem class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DdeItem(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>DDE Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLE</para>
        /// <para>Represents the following attribute in the schema: ole</para>
        /// </summary>
        public BooleanValue? UseOle
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Advise</para>
        /// <para>Represents the following attribute in the schema: advise</para>
        /// </summary>
        public BooleanValue? Advise
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data is an Image</para>
        /// <para>Represents the following attribute in the schema: preferPic</para>
        /// </summary>
        public BooleanValue? PreferPicture
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ddeItem");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Values>();
            builder.AddElement<DdeItem>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("ole", a => a.UseOle)
                .AddAttribute("advise", a => a.Advise)
                .AddAttribute("preferPic", a => a.PreferPicture);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Values), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeValueConditionToAnother(builder.CreateQName("x:name"), builder.CreateQName("x:ole"), new string[] { "StdDocumentName" }, new string[] { "true" }));
        }

        /// <summary>
        /// <para>DDE Name Values.</para>
        /// <para>Represents the following element tag in the schema: x:values.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Values? Values
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Values>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DdeItem>(deep);
    }

    /// <summary>
    /// <para>DDE Name Values.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:values.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Value" /> <c>&lt;x:value></c></description></item>
    /// </list>
    /// </remark>
    public partial class Values : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Values class.
        /// </summary>
        public Values() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Values class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Values(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Values class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Values(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Values class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Values(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Rows</para>
        /// <para>Represents the following attribute in the schema: rows</para>
        /// </summary>
        public UInt32Value? Rows
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Columns</para>
        /// <para>Represents the following attribute in the schema: cols</para>
        /// </summary>
        public UInt32Value? Columns
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:values");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Value>();
            builder.AddElement<Values>()
                .AddAttribute("rows", a => a.Rows)
                .AddAttribute("cols", a => a.Columns);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Value), 1, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:cols"), true, 1, true, 16384, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:rows"), true, 1, true, 1048576, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Values>(deep);
    }

    /// <summary>
    /// <para>Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:value.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DdeLinkValue" /> <c>&lt;x:val></c></description></item>
    /// </list>
    /// </remark>
    public partial class Value : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Value class.
        /// </summary>
        public Value() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Value class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Value(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Value class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Value(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Value class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Value(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>DDE Value Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DdeValues>? ValueType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DdeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:value");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DdeLinkValue>();
            builder.AddElement<Value>()
                .AddAttribute("t", a => a.ValueType);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DdeLinkValue), 1, 1)
            };
        }

        /// <summary>
        /// <para>DDE Link Value.</para>
        /// <para>Represents the following element tag in the schema: x:val.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DdeLinkValue? DdeLinkValue
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DdeLinkValue>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Value>(deep);
    }

    /// <summary>
    /// <para>OLE Link Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleItem" /> <c>&lt;x:oleItem></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.OleItem" /> <c>&lt;x14:oleItem></c></description></item>
    /// </list>
    /// </remark>
    public partial class OleItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the OleItems class.
        /// </summary>
        public OleItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OleItems(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleItem>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.OleItem>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.OleItem), 1, 1, version: FileFormatVersions.Office2010)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleItems>(deep);
    }

    /// <summary>
    /// <para>External Workbook.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:externalBook.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedNames" /> <c>&lt;x:definedNames></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetDataSet" /> <c>&lt;x:sheetDataSet></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetNames" /> <c>&lt;x:sheetNames></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021.ExternalBookAlternateUrls" /> <c>&lt;xxl21:alternateUrls></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalBook : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalBook class.
        /// </summary>
        public ExternalBook() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalBook class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalBook(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalBook class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalBook(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalBook class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalBook(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Relationship to supporting book file path</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:externalBook");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedNames>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetDataSet>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetNames>();
            builder.AddChild<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021.ExternalBookAlternateUrls>();
            builder.AddElement<ExternalBook>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021.ExternalBookAlternateUrls), 0, 1, version: FileFormatVersions.Microsoft365),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetNames), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedNames), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetDataSet), 0, 1)
            };
        }

        /// <summary>
        /// <para>Alternate URLs and identifiers of the external book, this property is only available in Microsoft365 and later..</para>
        /// <para>Represents the following element tag in the schema: xxl21:alternateUrls.</para>
        /// </summary>
        /// <remark>
        /// xmlns:xxl21 = http://schemas.microsoft.com/office/spreadsheetml/2021/extlinks2021
        /// </remark>
        public DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021.ExternalBookAlternateUrls? ExternalBookAlternateUrls
        {
            get => GetElement<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2021.ExtLinks2021.ExternalBookAlternateUrls>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sheet names of supporting book.</para>
        /// <para>Represents the following element tag in the schema: x:sheetNames.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetNames? SheetNames
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetNames>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Defined names associated with supporting book..</para>
        /// <para>Represents the following element tag in the schema: x:definedNames.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedNames? ExternalDefinedNames
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedNames>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Cached worksheet data associated with supporting book.</para>
        /// <para>Represents the following element tag in the schema: x:sheetDataSet.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SheetDataSet? SheetDataSet
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SheetDataSet>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalBook>(deep);
    }

    /// <summary>
    /// <para>DDE Connection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ddeLink.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DdeItems" /> <c>&lt;x:ddeItems></c></description></item>
    /// </list>
    /// </remark>
    public partial class DdeLink : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DdeLink class.
        /// </summary>
        public DdeLink() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeLink(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DdeLink(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DdeLink class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DdeLink(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Service name</para>
        /// <para>Represents the following attribute in the schema: ddeService</para>
        /// </summary>
        public StringValue? DdeService
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Topic for DDE server</para>
        /// <para>Represents the following attribute in the schema: ddeTopic</para>
        /// </summary>
        public StringValue? DdeTopic
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ddeLink");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DdeItems>();
            builder.AddElement<DdeLink>()
                .AddAttribute("ddeService", a => a.DdeService, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("ddeTopic", a => a.DdeTopic, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DdeItems), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:ddeService"), 1, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:ddeTopic"), 0, 255));
        }

        /// <summary>
        /// <para>DDE Items Collection.</para>
        /// <para>Represents the following element tag in the schema: x:ddeItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DdeItems? DdeItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DdeItems>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DdeLink>(deep);
    }

    /// <summary>
    /// <para>OLE Link.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleLink.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleItems" /> <c>&lt;x:oleItems></c></description></item>
    /// </list>
    /// </remark>
    public partial class OleLink : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the OleLink class.
        /// </summary>
        public OleLink() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleLink(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleLink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleLink(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleLink class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OleLink(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>OLE Link Relationship</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLE Link ProgID</para>
        /// <para>Represents the following attribute in the schema: progId</para>
        /// </summary>
        public StringValue? ProgId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleLink");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleItems>();
            builder.AddElement<OleLink>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("progId", a => a.ProgId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleItems), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:progId"), 1, 255));
        }

        /// <summary>
        /// <para>OLE Link Items.</para>
        /// <para>Represents the following element tag in the schema: x:oleItems.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OleItems? OleItems
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OleItems>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleLink>(deep);
    }

    /// <summary>
    /// <para>Sheet Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetName.</para>
    /// </summary>
    public partial class SheetName : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetName class.
        /// </summary>
        public SheetName() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Name Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetName");
            builder.AddElement<SheetName>()
                .AddAttribute("val", a => a.Val);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:val"), 0, 31));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetName>(deep);
    }

    /// <summary>
    /// <para>Value.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:v.</para>
    /// </summary>
    public partial class Xstring : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the Xstring class.
        /// </summary>
        public Xstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Xstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Xstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:v");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Xstring>(deep);
    }

    /// <summary>
    /// <para>Table Column.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableColumn.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedColumnFormula" /> <c>&lt;x:calculatedColumnFormula></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TotalsRowFormula" /> <c>&lt;x:totalsRowFormula></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.XmlColumnProperties" /> <c>&lt;x:xmlColumnPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableColumn : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableColumn class.
        /// </summary>
        public TableColumn() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableColumn(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumn class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableColumn(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumn class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableColumn(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Field Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Unique Name</para>
        /// <para>Represents the following attribute in the schema: uniqueName</para>
        /// </summary>
        public StringValue? UniqueName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Column name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Function</para>
        /// <para>Represents the following attribute in the schema: totalsRowFunction</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFunctionValues>? TotalsRowFunction
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFunctionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Label</para>
        /// <para>Represents the following attribute in the schema: totalsRowLabel</para>
        /// </summary>
        public StringValue? TotalsRowLabel
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Query Table Field Id</para>
        /// <para>Represents the following attribute in the schema: queryTableFieldId</para>
        /// </summary>
        public UInt32Value? QueryTableFieldId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Cell Format Id</para>
        /// <para>Represents the following attribute in the schema: headerRowDxfId</para>
        /// </summary>
        public UInt32Value? HeaderRowDifferentialFormattingId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data and Insert Row Format Id</para>
        /// <para>Represents the following attribute in the schema: dataDxfId</para>
        /// </summary>
        public UInt32Value? DataFormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Format Id</para>
        /// <para>Represents the following attribute in the schema: totalsRowDxfId</para>
        /// </summary>
        public UInt32Value? TotalsRowDifferentialFormattingId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Header Row Cell Style</para>
        /// <para>Represents the following attribute in the schema: headerRowCellStyle</para>
        /// </summary>
        public StringValue? HeaderRowCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Area Style Name</para>
        /// <para>Represents the following attribute in the schema: dataCellStyle</para>
        /// </summary>
        public StringValue? DataCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Totals Row Style Name</para>
        /// <para>Represents the following attribute in the schema: totalsRowCellStyle</para>
        /// </summary>
        public StringValue? TotalsRowCellStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableColumn");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedColumnFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.XmlColumnProperties>();
            builder.AddElement<TableColumn>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uniqueName", a => a.UniqueName)
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("totalsRowFunction", a => a.TotalsRowFunction)
                .AddAttribute("totalsRowLabel", a => a.TotalsRowLabel)
                .AddAttribute("queryTableFieldId", a => a.QueryTableFieldId)
                .AddAttribute("headerRowDxfId", a => a.HeaderRowDifferentialFormattingId)
                .AddAttribute("dataDxfId", a => a.DataFormatId)
                .AddAttribute("totalsRowDxfId", a => a.TotalsRowDifferentialFormattingId)
                .AddAttribute("headerRowCellStyle", a => a.HeaderRowCellStyle)
                .AddAttribute("dataCellStyle", a => a.DataCellStyle)
                .AddAttribute("totalsRowCellStyle", a => a.TotalsRowCellStyle);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedColumnFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TotalsRowFormula), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.XmlColumnProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeAbsentConditionToValue(builder.CreateQName("x:totalsRowLabel"), builder.CreateQName("x:totalsRowFunction"), "custom"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:headerRowCellStyle"), 1, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:totalsRowCellStyle"), 1, 255));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:queryTableFieldId"), true, 1, true, double.PositiveInfinity, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, double.PositiveInfinity, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:totalsRowLabel"), 0, 32767));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:dataCellStyle"), 1, 255));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dataDxfId"), "/WorkbookPart/WorkbookStylesPart", builder.CreateQName("x:dxfs"), builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:headerRowDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), true, builder.CreateQName("x:table")));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), true, builder.CreateQName("x:table")));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:totalsRowDxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueName"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Calculated Column Formula.</para>
        /// <para>Represents the following element tag in the schema: x:calculatedColumnFormula.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CalculatedColumnFormula? CalculatedColumnFormula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CalculatedColumnFormula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Totals Row Formula.</para>
        /// <para>Represents the following element tag in the schema: x:totalsRowFormula.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TotalsRowFormula? TotalsRowFormula
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFormula>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>XML Column Properties.</para>
        /// <para>Represents the following element tag in the schema: x:xmlColumnPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.XmlColumnProperties? XmlColumnProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.XmlColumnProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableColumn>(deep);
    }

    /// <summary>
    /// <para>Calculated Column Formula.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calculatedColumnFormula.</para>
    /// </summary>
    public partial class CalculatedColumnFormula : TableFormulaType
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedColumnFormula class.
        /// </summary>
        public CalculatedColumnFormula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedColumnFormula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public CalculatedColumnFormula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calculatedColumnFormula");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedColumnFormula>(deep);
    }

    /// <summary>
    /// <para>Totals Row Formula.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:totalsRowFormula.</para>
    /// </summary>
    public partial class TotalsRowFormula : TableFormulaType
    {
        /// <summary>
        /// Initializes a new instance of the TotalsRowFormula class.
        /// </summary>
        public TotalsRowFormula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TotalsRowFormula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public TotalsRowFormula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:totalsRowFormula");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TotalsRowFormula>(deep);
    }

    /// <summary>
    /// <para>Defines the TableFormulaType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class TableFormulaType : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the TableFormulaType class.
        /// </summary>
        protected TableFormulaType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableFormulaType class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        protected TableFormulaType(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>Array</para>
        /// <para>Represents the following attribute in the schema: array</para>
        /// </summary>
        public BooleanValue? Array
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>space</para>
        /// <para>Represents the following attribute in the schema: xml:space</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>? Space
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<TableFormulaType>()
                .AddAttribute("array", a => a.Array)
                .AddAttribute("xml:space", a => a.Space);
        }
    }

    /// <summary>
    /// <para>XML Column Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:xmlColumnPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class XmlColumnProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the XmlColumnProperties class.
        /// </summary>
        public XmlColumnProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlColumnProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlColumnProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlColumnProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public XmlColumnProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlColumnProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public XmlColumnProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>XML Map Id</para>
        /// <para>Represents the following attribute in the schema: mapId</para>
        /// </summary>
        public UInt32Value? MapId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>XPath</para>
        /// <para>Represents the following attribute in the schema: xpath</para>
        /// </summary>
        public StringValue? XPath
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Denormalized</para>
        /// <para>Represents the following attribute in the schema: denormalized</para>
        /// </summary>
        public BooleanValue? Denormalized
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>XML Data Type</para>
        /// <para>Represents the following attribute in the schema: xmlDataType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>? XmlDataType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:xmlColumnPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<XmlColumnProperties>()
                .AddAttribute("mapId", a => a.MapId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("xpath", a => a.XPath, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("denormalized", a => a.Denormalized)
                .AddAttribute("xmlDataType", a => a.XmlDataType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:xpath"), 0, 32000));
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:mapId"), "CustomXmlMappingsPart", builder.CreateQName("x:Map"), "x:Map", builder.CreateQName("x:ID")));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:mapId"), true, 1, true, 21474836477, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<XmlColumnProperties>(deep);
    }

    /// <summary>
    /// <para>Volatile Dependency Type.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:volType.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Main" /> <c>&lt;x:main></c></description></item>
    /// </list>
    /// </remark>
    public partial class VolatileType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the VolatileType class.
        /// </summary>
        public VolatileType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VolatileType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VolatileType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VolatileType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VolatileType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileDependencyValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileDependencyValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:volType");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Main>();
            builder.AddElement<VolatileType>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Main), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VolatileType>(deep);
    }

    /// <summary>
    /// <para>Main.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:main.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Topic" /> <c>&lt;x:tp></c></description></item>
    /// </list>
    /// </remark>
    public partial class Main : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Main class.
        /// </summary>
        public Main() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Main class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Main(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Main class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Main(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Main class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Main(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>First String</para>
        /// <para>Represents the following attribute in the schema: first</para>
        /// </summary>
        public StringValue? First
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:main");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Topic>();
            builder.AddElement<Main>()
                .AddAttribute("first", a => a.First, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Topic), 1, 0)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:first"), 1, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Main>(deep);
    }

    /// <summary>
    /// <para>Topic.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tp.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TopicReferences" /> <c>&lt;x:tr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Subtopic" /> <c>&lt;x:stp></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Xstring" /> <c>&lt;x:v></c></description></item>
    /// </list>
    /// </remark>
    public partial class Topic : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Topic class.
        /// </summary>
        public Topic() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Topic class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Topic(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Topic class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Topic(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Topic class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Topic(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Type</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileValues>? ValueType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tp");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TopicReferences>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Subtopic>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Xstring>();
            builder.AddElement<Topic>()
                .AddAttribute("t", a => a.ValueType);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Xstring), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Subtopic), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TopicReferences), 1, 0)
            };
        }

        /// <summary>
        /// <para>Topic Value.</para>
        /// <para>Represents the following element tag in the schema: x:v.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Xstring? Xstring
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Xstring>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Topic>(deep);
    }

    /// <summary>
    /// <para>References.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tr.</para>
    /// </summary>
    public partial class TopicReferences : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the TopicReferences class.
        /// </summary>
        public TopicReferences() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public StringValue? CellReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Id</para>
        /// <para>Represents the following attribute in the schema: s</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tr");
            builder.AddElement<TopicReferences>()
                .AddAttribute("r", a => a.CellReference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("s", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:s"), true, 1, true, 65534, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TopicReferences>(deep);
    }

    /// <summary>
    /// <para>PivotCache.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotCache.</para>
    /// </summary>
    public partial class PivotCache : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCache class.
        /// </summary>
        public PivotCache() : base()
        {
        }

        /// <summary>
        /// <para>PivotCache Id</para>
        /// <para>Represents the following attribute in the schema: cacheId</para>
        /// </summary>
        public UInt32Value? CacheId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotCache");
            builder.AddElement<PivotCache>()
                .AddAttribute("cacheId", a => a.CacheId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:cacheId"), true, builder.CreateQName("x:pivotCaches")));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCache>(deep);
    }

    /// <summary>
    /// <para>Web Publishing Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPublishObject.</para>
    /// </summary>
    public partial class WebPublishObject : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WebPublishObject class.
        /// </summary>
        public WebPublishObject() : base()
        {
        }

        /// <summary>
        /// <para>Id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Div Id</para>
        /// <para>Represents the following attribute in the schema: divId</para>
        /// </summary>
        public StringValue? DivId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Object</para>
        /// <para>Represents the following attribute in the schema: sourceObject</para>
        /// </summary>
        public StringValue? SourceObject
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination File</para>
        /// <para>Represents the following attribute in the schema: destinationFile</para>
        /// </summary>
        public StringValue? DestinationFile
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Title</para>
        /// <para>Represents the following attribute in the schema: title</para>
        /// </summary>
        public StringValue? Title
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Republish</para>
        /// <para>Represents the following attribute in the schema: autoRepublish</para>
        /// </summary>
        public BooleanValue? AutoRepublish
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPublishObject");
            builder.AddElement<WebPublishObject>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("divId", a => a.DivId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceObject", a => a.SourceObject)
                .AddAttribute("destinationFile", a => a.DestinationFile, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("title", a => a.Title)
                .AddAttribute("autoRepublish", a => a.AutoRepublish);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:title"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sourceObject"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:destinationFile"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:divId"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:id"), true, 1, true, 2147483647, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebPublishObject>(deep);
    }

    /// <summary>
    /// <para>External Reference.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:externalReference.</para>
    /// </summary>
    public partial class ExternalReference : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalReference class.
        /// </summary>
        public ExternalReference() : base()
        {
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:externalReference");
            builder.AddElement<ExternalReference>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalReference>(deep);
    }

    /// <summary>
    /// <para>Custom Workbook View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customWorkbookView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomWorkbookView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomWorkbookView class.
        /// </summary>
        public CustomWorkbookView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomWorkbookView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomWorkbookView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomWorkbookView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Custom View Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom View GUID</para>
        /// <para>Represents the following attribute in the schema: guid</para>
        /// </summary>
        public StringValue? Guid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Update</para>
        /// <para>Represents the following attribute in the schema: autoUpdate</para>
        /// </summary>
        public BooleanValue? AutoUpdate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Merge Interval</para>
        /// <para>Represents the following attribute in the schema: mergeInterval</para>
        /// </summary>
        public UInt32Value? MergeInterval
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Changes Saved Win</para>
        /// <para>Represents the following attribute in the schema: changesSavedWin</para>
        /// </summary>
        public BooleanValue? ChangesSavedWin
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Only Synch</para>
        /// <para>Represents the following attribute in the schema: onlySync</para>
        /// </summary>
        public BooleanValue? OnlySync
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Personal View</para>
        /// <para>Represents the following attribute in the schema: personalView</para>
        /// </summary>
        public BooleanValue? PersonalView
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Print Settings</para>
        /// <para>Represents the following attribute in the schema: includePrintSettings</para>
        /// </summary>
        public BooleanValue? IncludePrintSettings
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Hidden Rows and Columns</para>
        /// <para>Represents the following attribute in the schema: includeHiddenRowCol</para>
        /// </summary>
        public BooleanValue? IncludeHiddenRowColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximized</para>
        /// <para>Represents the following attribute in the schema: maximized</para>
        /// </summary>
        public BooleanValue? Maximized
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimized</para>
        /// <para>Represents the following attribute in the schema: minimized</para>
        /// </summary>
        public BooleanValue? Minimized
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Horizontal Scroll</para>
        /// <para>Represents the following attribute in the schema: showHorizontalScroll</para>
        /// </summary>
        public BooleanValue? ShowHorizontalScroll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Vertical Scroll</para>
        /// <para>Represents the following attribute in the schema: showVerticalScroll</para>
        /// </summary>
        public BooleanValue? ShowVerticalScroll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Sheet Tabs</para>
        /// <para>Represents the following attribute in the schema: showSheetTabs</para>
        /// </summary>
        public BooleanValue? ShowSheetTabs
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Corner (X Coordinate)</para>
        /// <para>Represents the following attribute in the schema: xWindow</para>
        /// </summary>
        public Int32Value? XWindow
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Corner (Y Coordinate)</para>
        /// <para>Represents the following attribute in the schema: yWindow</para>
        /// </summary>
        public Int32Value? YWindow
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Window Width</para>
        /// <para>Represents the following attribute in the schema: windowWidth</para>
        /// </summary>
        public UInt32Value? WindowWidth
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Window Height</para>
        /// <para>Represents the following attribute in the schema: windowHeight</para>
        /// </summary>
        public UInt32Value? WindowHeight
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Tab Ratio</para>
        /// <para>Represents the following attribute in the schema: tabRatio</para>
        /// </summary>
        public UInt32Value? TabRatio
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Sheet in Book View</para>
        /// <para>Represents the following attribute in the schema: activeSheetId</para>
        /// </summary>
        public UInt32Value? ActiveSheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Formula Bar</para>
        /// <para>Represents the following attribute in the schema: showFormulaBar</para>
        /// </summary>
        public BooleanValue? ShowFormulaBar
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Status Bar</para>
        /// <para>Represents the following attribute in the schema: showStatusbar</para>
        /// </summary>
        public BooleanValue? ShowStatusbar
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Comments</para>
        /// <para>Represents the following attribute in the schema: showComments</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CommentsValues>? ShowComments
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CommentsValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Objects</para>
        /// <para>Represents the following attribute in the schema: showObjects</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>? ShowObjects
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customWorkbookView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<CustomWorkbookView>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("guid", a => a.Guid, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("autoUpdate", a => a.AutoUpdate)
                .AddAttribute("mergeInterval", a => a.MergeInterval)
                .AddAttribute("changesSavedWin", a => a.ChangesSavedWin)
                .AddAttribute("onlySync", a => a.OnlySync)
                .AddAttribute("personalView", a => a.PersonalView)
                .AddAttribute("includePrintSettings", a => a.IncludePrintSettings)
                .AddAttribute("includeHiddenRowCol", a => a.IncludeHiddenRowColumn)
                .AddAttribute("maximized", a => a.Maximized)
                .AddAttribute("minimized", a => a.Minimized)
                .AddAttribute("showHorizontalScroll", a => a.ShowHorizontalScroll)
                .AddAttribute("showVerticalScroll", a => a.ShowVerticalScroll)
                .AddAttribute("showSheetTabs", a => a.ShowSheetTabs)
                .AddAttribute("xWindow", a => a.XWindow)
                .AddAttribute("yWindow", a => a.YWindow)
                .AddAttribute("windowWidth", a => a.WindowWidth)
                .AddAttribute("windowHeight", a => a.WindowHeight)
                .AddAttribute("tabRatio", a => a.TabRatio)
                .AddAttribute("activeSheetId", a => a.ActiveSheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("showFormulaBar", a => a.ShowFormulaBar)
                .AddAttribute("showStatusbar", a => a.ShowStatusbar)
                .AddAttribute("showComments", a => a.ShowComments)
                .AddAttribute("showObjects", a => a.ShowObjects);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:windowWidth"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tabRatio"), true, double.NegativeInfinity, true, 1000, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:activeSheetId"), true, 1, true, 65534, true));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:guid"), false, new string[] { "00000000-0000-0000-0000-000000000000" }) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:windowHeight"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomWorkbookView>(deep);
    }

    /// <summary>
    /// <para>Sheet Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheet.</para>
    /// </summary>
    public partial class Sheet : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Sheet class.
        /// </summary>
        public Sheet() : base()
        {
        }

        /// <summary>
        /// <para>Sheet Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Tab Id</para>
        /// <para>Represents the following attribute in the schema: sheetId</para>
        /// </summary>
        public UInt32Value? SheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Visible State</para>
        /// <para>Represents the following attribute in the schema: state</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>? State
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheet");
            builder.AddElement<Sheet>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sheetId", a => a.SheetId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("state", a => a.State)
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValuePatternConstraint(builder.CreateQName("x:name"), @"[^'*\[\]/\\:?]{1}[^*\[\]/\\:?]*"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 31));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:name"), false, null));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:sheetId"), true, null));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 1, true, 65534, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:id"), 0, 255));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Sheet>(deep);
    }

    /// <summary>
    /// <para>Workbook View.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:workbookView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class WorkbookView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WorkbookView class.
        /// </summary>
        public WorkbookView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WorkbookView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Visibility</para>
        /// <para>Represents the following attribute in the schema: visibility</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VisibilityValues>? Visibility
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.VisibilityValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimized</para>
        /// <para>Represents the following attribute in the schema: minimized</para>
        /// </summary>
        public BooleanValue? Minimized
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Horizontal Scroll</para>
        /// <para>Represents the following attribute in the schema: showHorizontalScroll</para>
        /// </summary>
        public BooleanValue? ShowHorizontalScroll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Vertical Scroll</para>
        /// <para>Represents the following attribute in the schema: showVerticalScroll</para>
        /// </summary>
        public BooleanValue? ShowVerticalScroll
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Sheet Tabs</para>
        /// <para>Represents the following attribute in the schema: showSheetTabs</para>
        /// </summary>
        public BooleanValue? ShowSheetTabs
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Upper Left Corner (X Coordinate)</para>
        /// <para>Represents the following attribute in the schema: xWindow</para>
        /// </summary>
        public Int32Value? XWindow
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Upper Left Corner (Y Coordinate)</para>
        /// <para>Represents the following attribute in the schema: yWindow</para>
        /// </summary>
        public Int32Value? YWindow
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Window Width</para>
        /// <para>Represents the following attribute in the schema: windowWidth</para>
        /// </summary>
        public UInt32Value? WindowWidth
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Window Height</para>
        /// <para>Represents the following attribute in the schema: windowHeight</para>
        /// </summary>
        public UInt32Value? WindowHeight
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Tab Ratio</para>
        /// <para>Represents the following attribute in the schema: tabRatio</para>
        /// </summary>
        public UInt32Value? TabRatio
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>First Sheet</para>
        /// <para>Represents the following attribute in the schema: firstSheet</para>
        /// </summary>
        public UInt32Value? FirstSheet
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Active Sheet Index</para>
        /// <para>Represents the following attribute in the schema: activeTab</para>
        /// </summary>
        public UInt32Value? ActiveTab
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>AutoFilter Date Grouping</para>
        /// <para>Represents the following attribute in the schema: autoFilterDateGrouping</para>
        /// </summary>
        public BooleanValue? AutoFilterDateGrouping
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:workbookView");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<WorkbookView>()
                .AddAttribute("visibility", a => a.Visibility)
                .AddAttribute("minimized", a => a.Minimized)
                .AddAttribute("showHorizontalScroll", a => a.ShowHorizontalScroll)
                .AddAttribute("showVerticalScroll", a => a.ShowVerticalScroll)
                .AddAttribute("showSheetTabs", a => a.ShowSheetTabs)
                .AddAttribute("xWindow", a => a.XWindow)
                .AddAttribute("yWindow", a => a.YWindow)
                .AddAttribute("windowWidth", a => a.WindowWidth)
                .AddAttribute("windowHeight", a => a.WindowHeight)
                .AddAttribute("tabRatio", a => a.TabRatio)
                .AddAttribute("firstSheet", a => a.FirstSheet)
                .AddAttribute("activeTab", a => a.ActiveTab)
                .AddAttribute("autoFilterDateGrouping", a => a.AutoFilterDateGrouping);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:windowWidth"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:windowHeight"), true, double.NegativeInfinity, true, 2147483647, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:tabRatio"), true, double.NegativeInfinity, true, 1000, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:activeTab"), true, 0, true, 32766, true));
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorkbookView>(deep);
    }

    /// <summary>
    /// <para>Defined Name.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:definedName.</para>
    /// </summary>
    public partial class DefinedName : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the DefinedName class.
        /// </summary>
        public DefinedName() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DefinedName class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public DefinedName(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>Defined Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Comment</para>
        /// <para>Represents the following attribute in the schema: comment</para>
        /// </summary>
        public StringValue? Comment
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Menu Text</para>
        /// <para>Represents the following attribute in the schema: customMenu</para>
        /// </summary>
        public StringValue? CustomMenu
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description</para>
        /// <para>Represents the following attribute in the schema: description</para>
        /// </summary>
        public StringValue? Description
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Help</para>
        /// <para>Represents the following attribute in the schema: help</para>
        /// </summary>
        public StringValue? Help
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Status Bar</para>
        /// <para>Represents the following attribute in the schema: statusBar</para>
        /// </summary>
        public StringValue? StatusBar
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Local Name Sheet Id</para>
        /// <para>Represents the following attribute in the schema: localSheetId</para>
        /// </summary>
        public UInt32Value? LocalSheetId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden Name</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Function</para>
        /// <para>Represents the following attribute in the schema: function</para>
        /// </summary>
        public BooleanValue? Function
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Procedure</para>
        /// <para>Represents the following attribute in the schema: vbProcedure</para>
        /// </summary>
        public BooleanValue? VbProcedure
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>External Function</para>
        /// <para>Represents the following attribute in the schema: xlm</para>
        /// </summary>
        public BooleanValue? Xlm
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Function Group Id</para>
        /// <para>Represents the following attribute in the schema: functionGroupId</para>
        /// </summary>
        public UInt32Value? FunctionGroupId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shortcut Key</para>
        /// <para>Represents the following attribute in the schema: shortcutKey</para>
        /// </summary>
        public StringValue? ShortcutKey
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Publish To Server</para>
        /// <para>Represents the following attribute in the schema: publishToServer</para>
        /// </summary>
        public BooleanValue? PublishToServer
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Workbook Parameter (Server)</para>
        /// <para>Represents the following attribute in the schema: workbookParameter</para>
        /// </summary>
        public BooleanValue? WorkbookParameter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:definedName");
            builder.AddElement<DefinedName>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("comment", a => a.Comment)
                .AddAttribute("customMenu", a => a.CustomMenu)
                .AddAttribute("description", a => a.Description)
                .AddAttribute("help", a => a.Help)
                .AddAttribute("statusBar", a => a.StatusBar)
                .AddAttribute("localSheetId", a => a.LocalSheetId)
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("function", a => a.Function)
                .AddAttribute("vbProcedure", a => a.VbProcedure)
                .AddAttribute("xlm", a => a.Xlm)
                .AddAttribute("functionGroupId", a => a.FunctionGroupId)
                .AddAttribute("shortcutKey", a => a.ShortcutKey)
                .AddAttribute("publishToServer", a => a.PublishToServer)
                .AddAttribute("workbookParameter", a => a.WorkbookParameter);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 65533, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:comment"), 0, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:localSheetId"), true, double.NegativeInfinity, true, 32766, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DefinedName>(deep);
    }

    /// <summary>
    /// <para>Function Group.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:functionGroup.</para>
    /// </summary>
    public partial class FunctionGroup : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FunctionGroup class.
        /// </summary>
        public FunctionGroup() : base()
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:functionGroup");
            builder.AddElement<FunctionGroup>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 32) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FunctionGroup>(deep);
    }

    /// <summary>
    /// <para>Defines the ObjectAnchor Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:anchor.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FromMarker" /> <c>&lt;x:from></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ToMarker" /> <c>&lt;x:to></c></description></item>
    /// </list>
    /// </remark>
    public partial class ObjectAnchor : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ObjectAnchor class.
        /// </summary>
        public ObjectAnchor() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ObjectAnchor class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ObjectAnchor(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ObjectAnchor class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ObjectAnchor(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ObjectAnchor class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ObjectAnchor(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>moveWithCells</para>
        /// <para>Represents the following attribute in the schema: moveWithCells</para>
        /// </summary>
        public BooleanValue? MoveWithCells
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sizeWithCells</para>
        /// <para>Represents the following attribute in the schema: sizeWithCells</para>
        /// </summary>
        public BooleanValue? SizeWithCells
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>z-order</para>
        /// <para>Represents the following attribute in the schema: z-order</para>
        /// </summary>
        public UInt32Value? ZOrder
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:anchor");
            builder.Availability = FileFormatVersions.Office2010;
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FromMarker>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ToMarker>();
            builder.AddElement<ObjectAnchor>()
                .AddAttribute("moveWithCells", a => a.MoveWithCells)
                .AddAttribute("sizeWithCells", a => a.SizeWithCells)
                .AddAttribute("z-order", a => a.ZOrder);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FromMarker), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ToMarker), 1, 1, version: FileFormatVersions.Office2010)
            };
        }

        /// <summary>
        /// <para>FromMarker.</para>
        /// <para>Represents the following element tag in the schema: x:from.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.FromMarker? FromMarker
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.FromMarker>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ToMarker.</para>
        /// <para>Represents the following element tag in the schema: x:to.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ToMarker? ToMarker
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ToMarker>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ObjectAnchor>(deep);
    }

    /// <summary>
    /// <para>Defines the FromMarker Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:from.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset" /> <c>&lt;xdr:colOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset" /> <c>&lt;xdr:rowOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId" /> <c>&lt;xdr:col></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId" /> <c>&lt;xdr:row></c></description></item>
    /// </list>
    /// </remark>
    public partial class FromMarker : MarkerType
    {
        /// <summary>
        /// Initializes a new instance of the FromMarker class.
        /// </summary>
        public FromMarker() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FromMarker class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FromMarker(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FromMarker class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FromMarker(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FromMarker class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FromMarker(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:from");
            builder.Availability = FileFormatVersions.Office2010;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FromMarker>(deep);
    }

    /// <summary>
    /// <para>Defines the ToMarker Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:to.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset" /> <c>&lt;xdr:colOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset" /> <c>&lt;xdr:rowOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId" /> <c>&lt;xdr:col></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId" /> <c>&lt;xdr:row></c></description></item>
    /// </list>
    /// </remark>
    public partial class ToMarker : MarkerType
    {
        /// <summary>
        /// Initializes a new instance of the ToMarker class.
        /// </summary>
        public ToMarker() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ToMarker class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ToMarker(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ToMarker class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ToMarker(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ToMarker class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ToMarker(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:to");
            builder.Availability = FileFormatVersions.Office2010;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset), 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ToMarker>(deep);
    }

    /// <summary>
    /// <para>Defines the MarkerType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset" /> <c>&lt;xdr:colOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset" /> <c>&lt;xdr:rowOff></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId" /> <c>&lt;xdr:col></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId" /> <c>&lt;xdr:row></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class MarkerType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MarkerType class.
        /// </summary>
        protected MarkerType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MarkerType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected MarkerType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MarkerType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected MarkerType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MarkerType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected MarkerType(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId>();
        }

        /// <summary>
        /// <para>Column).</para>
        /// <para>Represents the following element tag in the schema: xdr:col.</para>
        /// </summary>
        /// <remark>
        /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId? ColumnId
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Column Offset.</para>
        /// <para>Represents the following element tag in the schema: xdr:colOff.</para>
        /// </summary>
        /// <remark>
        /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset? ColumnOffset
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Row.</para>
        /// <para>Represents the following element tag in the schema: xdr:row.</para>
        /// </summary>
        /// <remark>
        /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId? RowId
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Row Offset.</para>
        /// <para>Represents the following element tag in the schema: xdr:rowOff.</para>
        /// </summary>
        /// <remark>
        /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset? RowOffset
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>Defines the ConditionalFormattingRuleExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.Id" /> <c>&lt;x14:id></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormattingRuleExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtension class.
        /// </summary>
        public ConditionalFormattingRuleExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRuleExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRuleExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormattingRuleExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.Id>();
            builder.AddElement<ConditionalFormattingRuleExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.Id), 1, 1, version: FileFormatVersions.Office2010),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormattingRuleExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotHierarchyExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy" /> <c>&lt;x14:pivotHierarchy></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotHierarchyExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtension class.
        /// </summary>
        public PivotHierarchyExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchyExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchyExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotHierarchyExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy>();
            builder.AddElement<PivotHierarchyExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy), 1, 1, version: FileFormatVersions.Office2010),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotHierarchyExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotFieldExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.PivotField" /> <c>&lt;x14:pivotField></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFieldExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFieldExtension class.
        /// </summary>
        public PivotFieldExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFieldExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFieldExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.PivotField>();
            builder.AddElement<PivotFieldExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotField), 1, 1, version: FileFormatVersions.Office2010),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFieldExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheSourceExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SourceConnection" /> <c>&lt;x14:sourceConnection></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheSourceExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheSourceExtension class.
        /// </summary>
        public CacheSourceExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSourceExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSourceExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheSourceExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SourceConnection>();
            builder.AddElement<CacheSourceExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SourceConnection), 1, 1, version: FileFormatVersions.Office2010),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheSourceExtension>(deep);
    }

    /// <summary>
    /// <para>OLE Link Item.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleItem.</para>
    /// </summary>
    public partial class OleItem : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the OleItem class.
        /// </summary>
        public OleItem() : base()
        {
        }

        /// <summary>
        /// <para>OLE Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Icon</para>
        /// <para>Represents the following attribute in the schema: icon</para>
        /// </summary>
        public BooleanValue? Icon
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Advise</para>
        /// <para>Represents the following attribute in the schema: advise</para>
        /// </summary>
        public BooleanValue? Advise
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Object is an Image</para>
        /// <para>Represents the following attribute in the schema: preferPic</para>
        /// </summary>
        public BooleanValue? PreferPicture
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleItem");
            builder.AddElement<OleItem>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("icon", a => a.Icon)
                .AddAttribute("advise", a => a.Advise)
                .AddAttribute("preferPic", a => a.PreferPicture);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, int.MaxValue));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleItem>(deep);
    }

    /// <summary>
    /// <para>Defines the StartBorder Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:start.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class StartBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the StartBorder class.
        /// </summary>
        public StartBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StartBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StartBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StartBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StartBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StartBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StartBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:start");
            builder.Availability = FileFormatVersions.Office2010;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StartBorder>(deep);
    }

    /// <summary>
    /// <para>Defines the EndBorder Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:end.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class EndBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the EndBorder class.
        /// </summary>
        public EndBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EndBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EndBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EndBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EndBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EndBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public EndBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:end");
            builder.Availability = FileFormatVersions.Office2010;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EndBorder>(deep);
    }

    /// <summary>
    /// <para>Left Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:left.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class LeftBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the LeftBorder class.
        /// </summary>
        public LeftBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LeftBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LeftBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LeftBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LeftBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LeftBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LeftBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:left");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LeftBorder>(deep);
    }

    /// <summary>
    /// <para>Right Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:right.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class RightBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the RightBorder class.
        /// </summary>
        public RightBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RightBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RightBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RightBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RightBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RightBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RightBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:right");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RightBorder>(deep);
    }

    /// <summary>
    /// <para>Top Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:top.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class TopBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the TopBorder class.
        /// </summary>
        public TopBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TopBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TopBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TopBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TopBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TopBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TopBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:top");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TopBorder>(deep);
    }

    /// <summary>
    /// <para>Bottom Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:bottom.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class BottomBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the BottomBorder class.
        /// </summary>
        public BottomBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BottomBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BottomBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BottomBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BottomBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BottomBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public BottomBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:bottom");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BottomBorder>(deep);
    }

    /// <summary>
    /// <para>Diagonal.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:diagonal.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiagonalBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the DiagonalBorder class.
        /// </summary>
        public DiagonalBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagonalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagonalBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagonalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagonalBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagonalBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiagonalBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:diagonal");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiagonalBorder>(deep);
    }

    /// <summary>
    /// <para>Vertical Inner Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:vertical.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class VerticalBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the VerticalBorder class.
        /// </summary>
        public VerticalBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VerticalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VerticalBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VerticalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VerticalBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VerticalBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VerticalBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:vertical");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VerticalBorder>(deep);
    }

    /// <summary>
    /// <para>Horizontal Inner Borders.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:horizontal.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class HorizontalBorder : BorderPropertiesType
    {
        /// <summary>
        /// Initializes a new instance of the HorizontalBorder class.
        /// </summary>
        public HorizontalBorder() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the HorizontalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HorizontalBorder(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HorizontalBorder class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HorizontalBorder(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HorizontalBorder class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public HorizontalBorder(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:horizontal");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<HorizontalBorder>(deep);
    }

    /// <summary>
    /// <para>Defines the BorderPropertiesType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class BorderPropertiesType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the BorderPropertiesType class.
        /// </summary>
        protected BorderPropertiesType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BorderPropertiesType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected BorderPropertiesType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BorderPropertiesType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected BorderPropertiesType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BorderPropertiesType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected BorderPropertiesType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Line Style</para>
        /// <para>Represents the following attribute in the schema: style</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.BorderStyleValues>? Style
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.BorderStyleValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.AddElement<BorderPropertiesType>()
                .AddAttribute("style", a => a.Style);
        }

        /// <summary>
        /// <para>Color.</para>
        /// <para>Represents the following element tag in the schema: x:color.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Color? Color
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Color>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>Defines the ControlProperties Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:controlPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor" /> <c>&lt;x:anchor></c></description></item>
    /// </list>
    /// </remark>
    public partial class ControlProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ControlProperties class.
        /// </summary>
        public ControlProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ControlProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ControlProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ControlProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ControlProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ControlProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ControlProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>locked</para>
        /// <para>Represents the following attribute in the schema: locked</para>
        /// </summary>
        public BooleanValue? Locked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>defaultSize</para>
        /// <para>Represents the following attribute in the schema: defaultSize</para>
        /// </summary>
        public BooleanValue? DefaultSize
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>print</para>
        /// <para>Represents the following attribute in the schema: print</para>
        /// </summary>
        public BooleanValue? Print
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disabled</para>
        /// <para>Represents the following attribute in the schema: disabled</para>
        /// </summary>
        public BooleanValue? Disabled
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>recalcAlways</para>
        /// <para>Represents the following attribute in the schema: recalcAlways</para>
        /// </summary>
        public BooleanValue? RecalcAlways
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>uiObject</para>
        /// <para>Represents the following attribute in the schema: uiObject</para>
        /// </summary>
        public BooleanValue? UiObject
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoFill</para>
        /// <para>Represents the following attribute in the schema: autoFill</para>
        /// </summary>
        public BooleanValue? AutoFill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoLine</para>
        /// <para>Represents the following attribute in the schema: autoLine</para>
        /// </summary>
        public BooleanValue? AutoLine
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoPict</para>
        /// <para>Represents the following attribute in the schema: autoPict</para>
        /// </summary>
        public BooleanValue? AutoPict
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>macro</para>
        /// <para>Represents the following attribute in the schema: macro</para>
        /// </summary>
        public StringValue? Macro
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>altText</para>
        /// <para>Represents the following attribute in the schema: altText</para>
        /// </summary>
        public StringValue? AltText
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>linkedCell</para>
        /// <para>Represents the following attribute in the schema: linkedCell</para>
        /// </summary>
        public StringValue? LinkedCell
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>listFillRange</para>
        /// <para>Represents the following attribute in the schema: listFillRange</para>
        /// </summary>
        public StringValue? ListFillRange
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cf</para>
        /// <para>Represents the following attribute in the schema: cf</para>
        /// </summary>
        public StringValue? Cf
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:controlPr");
            builder.Availability = FileFormatVersions.Office2010;
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            builder.AddElement<ControlProperties>()
                .AddAttribute("locked", a => a.Locked)
                .AddAttribute("defaultSize", a => a.DefaultSize)
                .AddAttribute("print", a => a.Print)
                .AddAttribute("disabled", a => a.Disabled)
                .AddAttribute("recalcAlways", a => a.RecalcAlways)
                .AddAttribute("uiObject", a => a.UiObject)
                .AddAttribute("autoFill", a => a.AutoFill)
                .AddAttribute("autoLine", a => a.AutoLine)
                .AddAttribute("autoPict", a => a.AutoPict)
                .AddAttribute("macro", a => a.Macro)
                .AddAttribute("altText", a => a.AltText)
                .AddAttribute("linkedCell", a => a.LinkedCell)
                .AddAttribute("listFillRange", a => a.ListFillRange)
                .AddAttribute("cf", a => a.Cf)
                .AddAttribute("r:id", a => a.Id);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor), 1, 1, version: FileFormatVersions.Office2010)
            };
        }

        /// <summary>
        /// <para>ObjectAnchor.</para>
        /// <para>Represents the following element tag in the schema: x:anchor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor? ObjectAnchor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ControlProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the EmbeddedObjectProperties Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:objectPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor" /> <c>&lt;x:anchor></c></description></item>
    /// </list>
    /// </remark>
    public partial class EmbeddedObjectProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the EmbeddedObjectProperties class.
        /// </summary>
        public EmbeddedObjectProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EmbeddedObjectProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EmbeddedObjectProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EmbeddedObjectProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EmbeddedObjectProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EmbeddedObjectProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public EmbeddedObjectProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>locked</para>
        /// <para>Represents the following attribute in the schema: locked</para>
        /// </summary>
        public BooleanValue? Locked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>defaultSize</para>
        /// <para>Represents the following attribute in the schema: defaultSize</para>
        /// </summary>
        public BooleanValue? DefaultSize
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>print</para>
        /// <para>Represents the following attribute in the schema: print</para>
        /// </summary>
        public BooleanValue? Print
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disabled</para>
        /// <para>Represents the following attribute in the schema: disabled</para>
        /// </summary>
        public BooleanValue? Disabled
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>uiObject</para>
        /// <para>Represents the following attribute in the schema: uiObject</para>
        /// </summary>
        public BooleanValue? UiObject
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoFill</para>
        /// <para>Represents the following attribute in the schema: autoFill</para>
        /// </summary>
        public BooleanValue? AutoFill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoLine</para>
        /// <para>Represents the following attribute in the schema: autoLine</para>
        /// </summary>
        public BooleanValue? AutoLine
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoPict</para>
        /// <para>Represents the following attribute in the schema: autoPict</para>
        /// </summary>
        public BooleanValue? AutoPict
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>macro</para>
        /// <para>Represents the following attribute in the schema: macro</para>
        /// </summary>
        public StringValue? Macro
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>altText</para>
        /// <para>Represents the following attribute in the schema: altText</para>
        /// </summary>
        public StringValue? AltText
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dde</para>
        /// <para>Represents the following attribute in the schema: dde</para>
        /// </summary>
        public BooleanValue? Dde
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:objectPr");
            builder.Availability = FileFormatVersions.Office2010;
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            builder.AddElement<EmbeddedObjectProperties>()
                .AddAttribute("locked", a => a.Locked)
                .AddAttribute("defaultSize", a => a.DefaultSize)
                .AddAttribute("print", a => a.Print)
                .AddAttribute("disabled", a => a.Disabled)
                .AddAttribute("uiObject", a => a.UiObject)
                .AddAttribute("autoFill", a => a.AutoFill)
                .AddAttribute("autoLine", a => a.AutoLine)
                .AddAttribute("autoPict", a => a.AutoPict)
                .AddAttribute("macro", a => a.Macro)
                .AddAttribute("altText", a => a.AltText)
                .AddAttribute("dde", a => a.Dde)
                .AddAttribute("r:id", a => a.Id);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor), 1, 1, version: FileFormatVersions.Office2010)
            };
        }

        /// <summary>
        /// <para>ObjectAnchor.</para>
        /// <para>Represents the following element tag in the schema: x:anchor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor? ObjectAnchor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EmbeddedObjectProperties>(deep);
    }

    /// <summary>
    /// <para>Chart Sheet Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TabColor" /> <c>&lt;x:tabColor></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChartSheetProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartSheetProperties class.
        /// </summary>
        public ChartSheetProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartSheetProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Published</para>
        /// <para>Represents the following attribute in the schema: published</para>
        /// </summary>
        public BooleanValue? Published
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Code Name</para>
        /// <para>Represents the following attribute in the schema: codeName</para>
        /// </summary>
        public StringValue? CodeName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TabColor>();
            builder.AddElement<ChartSheetProperties>()
                .AddAttribute("published", a => a.Published)
                .AddAttribute("codeName", a => a.CodeName);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TabColor), 0, 1)
            };
            builder.AddConstraint(new AttributeValuePatternConstraint(builder.CreateQName("x:codeName"), @"[\p{L}\P{IsBasicLatin}][_\d\p{L}\P{IsBasicLatin}]*"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:codeName"), 0, 32));
        }

        /// <summary>
        /// <para>TabColor.</para>
        /// <para>Represents the following element tag in the schema: x:tabColor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TabColor? TabColor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TabColor>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSheetProperties>(deep);
    }

    /// <summary>
    /// <para>Chart Sheet Views.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartSheetView" /> <c>&lt;x:sheetView></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChartSheetViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartSheetViews class.
        /// </summary>
        public ChartSheetViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSheetViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSheetViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartSheetViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartSheetView>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartSheetView), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSheetViews>(deep);
    }

    /// <summary>
    /// <para>Chart Sheet Protection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetProtection.</para>
    /// </summary>
    public partial class ChartSheetProtection : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartSheetProtection class.
        /// </summary>
        public ChartSheetProtection() : base()
        {
        }

        /// <summary>
        /// <para>Password</para>
        /// <para>Represents the following attribute in the schema: password</para>
        /// </summary>
        public HexBinaryValue? Password
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cryptographic Algorithm Name</para>
        /// <para>Represents the following attribute in the schema: algorithmName</para>
        /// </summary>
        public StringValue? AlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password Hash Value</para>
        /// <para>Represents the following attribute in the schema: hashValue</para>
        /// </summary>
        public Base64BinaryValue? HashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Salt Value for Password Verifier</para>
        /// <para>Represents the following attribute in the schema: saltValue</para>
        /// </summary>
        public Base64BinaryValue? SaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iterations to Run Hashing Algorithm</para>
        /// <para>Represents the following attribute in the schema: spinCount</para>
        /// </summary>
        public UInt32Value? SpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contents</para>
        /// <para>Represents the following attribute in the schema: content</para>
        /// </summary>
        public BooleanValue? Content
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Objects Locked</para>
        /// <para>Represents the following attribute in the schema: objects</para>
        /// </summary>
        public BooleanValue? Objects
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetProtection");
            builder.AddElement<ChartSheetProtection>()
                .AddAttribute("password", a => a.Password, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("algorithmName", a => a.AlgorithmName)
                .AddAttribute("hashValue", a => a.HashValue)
                .AddAttribute("saltValue", a => a.SaltValue)
                .AddAttribute("spinCount", a => a.SpinCount)
                .AddAttribute("content", a => a.Content)
                .AddAttribute("objects", a => a.Objects);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSheetProtection>(deep);
    }

    /// <summary>
    /// <para>Custom Chart Sheet Views.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customSheetViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetView" /> <c>&lt;x:customSheetView></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomChartsheetViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomChartsheetViews class.
        /// </summary>
        public CustomChartsheetViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomChartsheetViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomChartsheetViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomChartsheetViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomChartsheetViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customSheetViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomChartsheetView), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomChartsheetViews>(deep);
    }

    /// <summary>
    /// <para>Drawing.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:drawing.</para>
    /// </summary>
    public partial class Drawing : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Drawing class.
        /// </summary>
        public Drawing() : base()
        {
        }

        /// <summary>
        /// <para>Relationship id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:drawing");
            builder.AddElement<Drawing>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Drawing>(deep);
    }

    /// <summary>
    /// <para>Defines the LegacyDrawing Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:legacyDrawing.</para>
    /// </summary>
    public partial class LegacyDrawing : LegacyDrawingType
    {
        /// <summary>
        /// Initializes a new instance of the LegacyDrawing class.
        /// </summary>
        public LegacyDrawing() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:legacyDrawing");
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LegacyDrawing>(deep);
    }

    /// <summary>
    /// <para>Legacy Drawing Reference in  Header Footer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:legacyDrawingHF.</para>
    /// </summary>
    public partial class LegacyDrawingHeaderFooter : LegacyDrawingType
    {
        /// <summary>
        /// Initializes a new instance of the LegacyDrawingHeaderFooter class.
        /// </summary>
        public LegacyDrawingHeaderFooter() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:legacyDrawingHF");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LegacyDrawingHeaderFooter>(deep);
    }

    /// <summary>
    /// <para>Defines the LegacyDrawingType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class LegacyDrawingType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the LegacyDrawingType class.
        /// </summary>
        protected LegacyDrawingType() : base()
        {
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<LegacyDrawingType>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }
    }

    /// <summary>
    /// <para>Defines the DrawingHeaderFooter Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:drawingHF.</para>
    /// </summary>
    public partial class DrawingHeaderFooter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DrawingHeaderFooter class.
        /// </summary>
        public DrawingHeaderFooter() : base()
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lho</para>
        /// <para>Represents the following attribute in the schema: lho</para>
        /// </summary>
        public UInt32Value? Lho
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lhe</para>
        /// <para>Represents the following attribute in the schema: lhe</para>
        /// </summary>
        public UInt32Value? Lhe
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lhf</para>
        /// <para>Represents the following attribute in the schema: lhf</para>
        /// </summary>
        public UInt32Value? Lhf
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cho</para>
        /// <para>Represents the following attribute in the schema: cho</para>
        /// </summary>
        public UInt32Value? Cho
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>che</para>
        /// <para>Represents the following attribute in the schema: che</para>
        /// </summary>
        public UInt32Value? Che
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>chf</para>
        /// <para>Represents the following attribute in the schema: chf</para>
        /// </summary>
        public UInt32Value? Chf
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rho</para>
        /// <para>Represents the following attribute in the schema: rho</para>
        /// </summary>
        public UInt32Value? Rho
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rhe</para>
        /// <para>Represents the following attribute in the schema: rhe</para>
        /// </summary>
        public UInt32Value? Rhe
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rhf</para>
        /// <para>Represents the following attribute in the schema: rhf</para>
        /// </summary>
        public UInt32Value? Rhf
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lfo</para>
        /// <para>Represents the following attribute in the schema: lfo</para>
        /// </summary>
        public UInt32Value? Lfo
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lfe</para>
        /// <para>Represents the following attribute in the schema: lfe</para>
        /// </summary>
        public UInt32Value? Lfe
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lff</para>
        /// <para>Represents the following attribute in the schema: lff</para>
        /// </summary>
        public UInt32Value? Lff
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cfo</para>
        /// <para>Represents the following attribute in the schema: cfo</para>
        /// </summary>
        public UInt32Value? Cfo
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cfe</para>
        /// <para>Represents the following attribute in the schema: cfe</para>
        /// </summary>
        public UInt32Value? Cfe
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cff</para>
        /// <para>Represents the following attribute in the schema: cff</para>
        /// </summary>
        public UInt32Value? Cff
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rfo</para>
        /// <para>Represents the following attribute in the schema: rfo</para>
        /// </summary>
        public UInt32Value? Rfo
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rfe</para>
        /// <para>Represents the following attribute in the schema: rfe</para>
        /// </summary>
        public UInt32Value? Rfe
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rff</para>
        /// <para>Represents the following attribute in the schema: rff</para>
        /// </summary>
        public UInt32Value? Rff
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:drawingHF");
            builder.AddElement<DrawingHeaderFooter>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("lho", a => a.Lho)
                .AddAttribute("lhe", a => a.Lhe)
                .AddAttribute("lhf", a => a.Lhf)
                .AddAttribute("cho", a => a.Cho)
                .AddAttribute("che", a => a.Che)
                .AddAttribute("chf", a => a.Chf)
                .AddAttribute("rho", a => a.Rho)
                .AddAttribute("rhe", a => a.Rhe)
                .AddAttribute("rhf", a => a.Rhf)
                .AddAttribute("lfo", a => a.Lfo)
                .AddAttribute("lfe", a => a.Lfe)
                .AddAttribute("lff", a => a.Lff)
                .AddAttribute("cfo", a => a.Cfo)
                .AddAttribute("cfe", a => a.Cfe)
                .AddAttribute("cff", a => a.Cff)
                .AddAttribute("rfo", a => a.Rfo)
                .AddAttribute("rfe", a => a.Rfe)
                .AddAttribute("rff", a => a.Rff);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DrawingHeaderFooter>(deep);
    }

    /// <summary>
    /// <para>Defines the Picture Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:picture.</para>
    /// </summary>
    public partial class Picture : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Picture class.
        /// </summary>
        public Picture() : base()
        {
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:picture");
            builder.AddElement<Picture>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Picture>(deep);
    }

    /// <summary>
    /// <para>Defines the WebPublishItems Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPublishItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishItem" /> <c>&lt;x:webPublishItem></c></description></item>
    /// </list>
    /// </remark>
    public partial class WebPublishItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WebPublishItems class.
        /// </summary>
        public WebPublishItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebPublishItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebPublishItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WebPublishItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Web Publishing Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPublishItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishItem>();
            builder.AddElement<WebPublishItems>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishItem), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebPublishItems>(deep);
    }

    /// <summary>
    /// <para>Color Scale.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colorScale.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject" /> <c>&lt;x:cfvo></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorScale : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorScale class.
        /// </summary>
        public ColorScale() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorScale class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorScale(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorScale class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorScale(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorScale class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorScale(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colorScale");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject), 2, 3),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 2, 3)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorScale>(deep);
    }

    /// <summary>
    /// <para>Data Bar.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataBar.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject" /> <c>&lt;x:cfvo></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Color" /> <c>&lt;x:color></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataBar : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataBar class.
        /// </summary>
        public DataBar() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBar class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataBar(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBar class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataBar(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataBar class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataBar(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Minimum Length</para>
        /// <para>Represents the following attribute in the schema: minLength</para>
        /// </summary>
        public UInt32Value? MinLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Length</para>
        /// <para>Represents the following attribute in the schema: maxLength</para>
        /// </summary>
        public UInt32Value? MaxLength
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Values</para>
        /// <para>Represents the following attribute in the schema: showValue</para>
        /// </summary>
        public BooleanValue? ShowValue
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataBar");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Color>();
            builder.AddElement<DataBar>()
                .AddAttribute("minLength", a => a.MinLength)
                .AddAttribute("maxLength", a => a.MaxLength)
                .AddAttribute("showValue", a => a.ShowValue);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject), 2, 2),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Color), 1, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:maxLength"), true, double.NegativeInfinity, true, 100, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:minLength"), true, double.NegativeInfinity, true, 100, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataBar>(deep);
    }

    /// <summary>
    /// <para>Icon Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:iconSet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject" /> <c>&lt;x:cfvo></c></description></item>
    /// </list>
    /// </remark>
    public partial class IconSet : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the IconSet class.
        /// </summary>
        public IconSet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the IconSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IconSet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IconSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IconSet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IconSet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public IconSet(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Icon Set</para>
        /// <para>Represents the following attribute in the schema: iconSet</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>? IconSetValue
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Value</para>
        /// <para>Represents the following attribute in the schema: showValue</para>
        /// </summary>
        public BooleanValue? ShowValue
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Percent</para>
        /// <para>Represents the following attribute in the schema: percent</para>
        /// </summary>
        public BooleanValue? Percent
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reverse Icons</para>
        /// <para>Represents the following attribute in the schema: reverse</para>
        /// </summary>
        public BooleanValue? Reverse
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:iconSet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject>();
            builder.AddElement<IconSet>()
                .AddAttribute("iconSet", a => a.IconSetValue)
                .AddAttribute("showValue", a => a.ShowValue)
                .AddAttribute("percent", a => a.Percent)
                .AddAttribute("reverse", a => a.Reverse);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObject), 2, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IconSet>(deep);
    }

    /// <summary>
    /// <para>Defines the ConditionalFormattingRuleExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormattingRuleExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class.
        /// </summary>
        public ConditionalFormattingRuleExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRuleExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormattingRuleExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormattingRuleExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRuleExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormattingRuleExtensionList>(deep);
    }

    /// <summary>
    /// <para>Data Consolidation References.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataRefs.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataReference" /> <c>&lt;x:dataRef></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataReferences : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataReferences class.
        /// </summary>
        public DataReferences() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataReferences(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataReferences(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataReferences class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataReferences(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Data Consolidation Reference Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataRefs");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataReference>();
            builder.AddElement<DataReferences>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataReference), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataReferences>(deep);
    }

    /// <summary>
    /// <para>Sheet Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TabColor" /> <c>&lt;x:tabColor></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OutlineProperties" /> <c>&lt;x:outlinePr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties" /> <c>&lt;x:pageSetUpPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetProperties class.
        /// </summary>
        public SheetProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Synch Horizontal</para>
        /// <para>Represents the following attribute in the schema: syncHorizontal</para>
        /// </summary>
        public BooleanValue? SyncHorizontal
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Synch Vertical</para>
        /// <para>Represents the following attribute in the schema: syncVertical</para>
        /// </summary>
        public BooleanValue? SyncVertical
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Synch Reference</para>
        /// <para>Represents the following attribute in the schema: syncRef</para>
        /// </summary>
        public StringValue? SyncReference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Transition Formula Evaluation</para>
        /// <para>Represents the following attribute in the schema: transitionEvaluation</para>
        /// </summary>
        public BooleanValue? TransitionEvaluation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Transition Formula Entry</para>
        /// <para>Represents the following attribute in the schema: transitionEntry</para>
        /// </summary>
        public BooleanValue? TransitionEntry
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Published</para>
        /// <para>Represents the following attribute in the schema: published</para>
        /// </summary>
        public BooleanValue? Published
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Code Name</para>
        /// <para>Represents the following attribute in the schema: codeName</para>
        /// </summary>
        public StringValue? CodeName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter Mode</para>
        /// <para>Represents the following attribute in the schema: filterMode</para>
        /// </summary>
        public BooleanValue? FilterMode
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Enable Conditional Formatting Calculations</para>
        /// <para>Represents the following attribute in the schema: enableFormatConditionsCalculation</para>
        /// </summary>
        public BooleanValue? EnableFormatConditionsCalculation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TabColor>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OutlineProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties>();
            builder.AddElement<SheetProperties>()
                .AddAttribute("syncHorizontal", a => a.SyncHorizontal)
                .AddAttribute("syncVertical", a => a.SyncVertical)
                .AddAttribute("syncRef", a => a.SyncReference)
                .AddAttribute("transitionEvaluation", a => a.TransitionEvaluation)
                .AddAttribute("transitionEntry", a => a.TransitionEntry)
                .AddAttribute("published", a => a.Published)
                .AddAttribute("codeName", a => a.CodeName)
                .AddAttribute("filterMode", a => a.FilterMode)
                .AddAttribute("enableFormatConditionsCalculation", a => a.EnableFormatConditionsCalculation);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TabColor), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OutlineProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties), 0, 1)
            };
            builder.AddConstraint(new AttributeValuePatternConstraint(builder.CreateQName("x:codeName"), @"[\p{L}\P{IsBasicLatin}][_\d\p{L}\P{IsBasicLatin}]*"));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:codeName"), 0, 32));
        }

        /// <summary>
        /// <para>Sheet Tab Color.</para>
        /// <para>Represents the following element tag in the schema: x:tabColor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TabColor? TabColor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TabColor>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Outline Properties.</para>
        /// <para>Represents the following element tag in the schema: x:outlinePr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.OutlineProperties? OutlineProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.OutlineProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Page Setup Properties.</para>
        /// <para>Represents the following element tag in the schema: x:pageSetUpPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties? PageSetupProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PageSetupProperties>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetProperties>(deep);
    }

    /// <summary>
    /// <para>Dialog Sheet Views.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetView" /> <c>&lt;x:sheetView></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetViews class.
        /// </summary>
        public SheetViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetView), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetViews>(deep);
    }

    /// <summary>
    /// <para>Dialog Sheet Format Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetFormatPr.</para>
    /// </summary>
    public partial class SheetFormatProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetFormatProperties class.
        /// </summary>
        public SheetFormatProperties() : base()
        {
        }

        /// <summary>
        /// <para>Base Column Width</para>
        /// <para>Represents the following attribute in the schema: baseColWidth</para>
        /// </summary>
        public UInt32Value? BaseColumnWidth
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Column Width</para>
        /// <para>Represents the following attribute in the schema: defaultColWidth</para>
        /// </summary>
        public DoubleValue? DefaultColumnWidth
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Row Height</para>
        /// <para>Represents the following attribute in the schema: defaultRowHeight</para>
        /// </summary>
        public DoubleValue? DefaultRowHeight
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Height</para>
        /// <para>Represents the following attribute in the schema: customHeight</para>
        /// </summary>
        public BooleanValue? CustomHeight
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hidden By Default</para>
        /// <para>Represents the following attribute in the schema: zeroHeight</para>
        /// </summary>
        public BooleanValue? ZeroHeight
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Thick Top Border</para>
        /// <para>Represents the following attribute in the schema: thickTop</para>
        /// </summary>
        public BooleanValue? ThickTop
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Thick Bottom Border</para>
        /// <para>Represents the following attribute in the schema: thickBottom</para>
        /// </summary>
        public BooleanValue? ThickBottom
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Outline Row</para>
        /// <para>Represents the following attribute in the schema: outlineLevelRow</para>
        /// </summary>
        public ByteValue? OutlineLevelRow
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Column Outline Level</para>
        /// <para>Represents the following attribute in the schema: outlineLevelCol</para>
        /// </summary>
        public ByteValue? OutlineLevelColumn
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dyDescent, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: x14ac:dyDescent</para>
        /// </summary>
        /// <remark>
        /// xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
        /// </remark>
        public DoubleValue? DyDescent
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetFormatPr");
            builder.AddElement<SheetFormatProperties>()
                .AddAttribute("baseColWidth", a => a.BaseColumnWidth)
                .AddAttribute("defaultColWidth", a => a.DefaultColumnWidth)
                .AddAttribute("defaultRowHeight", a => a.DefaultRowHeight, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("customHeight", a => a.CustomHeight)
                .AddAttribute("zeroHeight", a => a.ZeroHeight)
                .AddAttribute("thickTop", a => a.ThickTop)
                .AddAttribute("thickBottom", a => a.ThickBottom)
                .AddAttribute("outlineLevelRow", a => a.OutlineLevelRow)
                .AddAttribute("outlineLevelCol", a => a.OutlineLevelColumn)
                .AddAttribute("x14ac:dyDescent", a => a.DyDescent, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:outlineLevelCol"), true, 0, true, 7, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:outlineLevelRow"), true, 0, true, 7, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:baseColWidth"), true, double.NegativeInfinity, true, 255, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:defaultColWidth"), true, 0, true, 65535, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetFormatProperties>(deep);
    }

    /// <summary>
    /// <para>Sheet Protection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetProtection.</para>
    /// </summary>
    public partial class SheetProtection : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetProtection class.
        /// </summary>
        public SheetProtection() : base()
        {
        }

        /// <summary>
        /// <para>Password</para>
        /// <para>Represents the following attribute in the schema: password</para>
        /// </summary>
        public HexBinaryValue? Password
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cryptographic Algorithm Name</para>
        /// <para>Represents the following attribute in the schema: algorithmName</para>
        /// </summary>
        public StringValue? AlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password Hash Value</para>
        /// <para>Represents the following attribute in the schema: hashValue</para>
        /// </summary>
        public Base64BinaryValue? HashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Salt Value for Password Verifier</para>
        /// <para>Represents the following attribute in the schema: saltValue</para>
        /// </summary>
        public Base64BinaryValue? SaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iterations to Run Hashing Algorithm</para>
        /// <para>Represents the following attribute in the schema: spinCount</para>
        /// </summary>
        public UInt32Value? SpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Locked</para>
        /// <para>Represents the following attribute in the schema: sheet</para>
        /// </summary>
        public BooleanValue? Sheet
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Objects Locked</para>
        /// <para>Represents the following attribute in the schema: objects</para>
        /// </summary>
        public BooleanValue? Objects
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Scenarios Locked</para>
        /// <para>Represents the following attribute in the schema: scenarios</para>
        /// </summary>
        public BooleanValue? Scenarios
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Cells Locked</para>
        /// <para>Represents the following attribute in the schema: formatCells</para>
        /// </summary>
        public BooleanValue? FormatCells
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Columns Locked</para>
        /// <para>Represents the following attribute in the schema: formatColumns</para>
        /// </summary>
        public BooleanValue? FormatColumns
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Rows Locked</para>
        /// <para>Represents the following attribute in the schema: formatRows</para>
        /// </summary>
        public BooleanValue? FormatRows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Columns Locked</para>
        /// <para>Represents the following attribute in the schema: insertColumns</para>
        /// </summary>
        public BooleanValue? InsertColumns
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Rows Locked</para>
        /// <para>Represents the following attribute in the schema: insertRows</para>
        /// </summary>
        public BooleanValue? InsertRows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Insert Hyperlinks Locked</para>
        /// <para>Represents the following attribute in the schema: insertHyperlinks</para>
        /// </summary>
        public BooleanValue? InsertHyperlinks
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Delete Columns Locked</para>
        /// <para>Represents the following attribute in the schema: deleteColumns</para>
        /// </summary>
        public BooleanValue? DeleteColumns
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Delete Rows Locked</para>
        /// <para>Represents the following attribute in the schema: deleteRows</para>
        /// </summary>
        public BooleanValue? DeleteRows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Select Locked Cells Locked</para>
        /// <para>Represents the following attribute in the schema: selectLockedCells</para>
        /// </summary>
        public BooleanValue? SelectLockedCells
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sort Locked</para>
        /// <para>Represents the following attribute in the schema: sort</para>
        /// </summary>
        public BooleanValue? Sort
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>AutoFilter Locked</para>
        /// <para>Represents the following attribute in the schema: autoFilter</para>
        /// </summary>
        public BooleanValue? AutoFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Pivot Tables Locked</para>
        /// <para>Represents the following attribute in the schema: pivotTables</para>
        /// </summary>
        public BooleanValue? PivotTables
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Select Unlocked Cells Locked</para>
        /// <para>Represents the following attribute in the schema: selectUnlockedCells</para>
        /// </summary>
        public BooleanValue? SelectUnlockedCells
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetProtection");
            builder.AddElement<SheetProtection>()
                .AddAttribute("password", a => a.Password, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("algorithmName", a => a.AlgorithmName)
                .AddAttribute("hashValue", a => a.HashValue)
                .AddAttribute("saltValue", a => a.SaltValue)
                .AddAttribute("spinCount", a => a.SpinCount)
                .AddAttribute("sheet", a => a.Sheet)
                .AddAttribute("objects", a => a.Objects)
                .AddAttribute("scenarios", a => a.Scenarios)
                .AddAttribute("formatCells", a => a.FormatCells)
                .AddAttribute("formatColumns", a => a.FormatColumns)
                .AddAttribute("formatRows", a => a.FormatRows)
                .AddAttribute("insertColumns", a => a.InsertColumns)
                .AddAttribute("insertRows", a => a.InsertRows)
                .AddAttribute("insertHyperlinks", a => a.InsertHyperlinks)
                .AddAttribute("deleteColumns", a => a.DeleteColumns)
                .AddAttribute("deleteRows", a => a.DeleteRows)
                .AddAttribute("selectLockedCells", a => a.SelectLockedCells)
                .AddAttribute("sort", a => a.Sort)
                .AddAttribute("autoFilter", a => a.AutoFilter)
                .AddAttribute("pivotTables", a => a.PivotTables)
                .AddAttribute("selectUnlockedCells", a => a.SelectUnlockedCells);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetProtection>(deep);
    }

    /// <summary>
    /// <para>Custom Sheet Views.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customSheetViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomSheetView" /> <c>&lt;x:customSheetView></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomSheetViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomSheetViews class.
        /// </summary>
        public CustomSheetViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomSheetViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomSheetViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomSheetViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomSheetViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customSheetViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomSheetView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomSheetView), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomSheetViews>(deep);
    }

    /// <summary>
    /// <para>Defines the OleObjects Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleObjects.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.OleObject" /> <c>&lt;x:oleObject></c></description></item>
    /// </list>
    /// </remark>
    public partial class OleObjects : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the OleObjects class.
        /// </summary>
        public OleObjects() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObjects class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleObjects(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObjects class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public OleObjects(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OleObjects class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public OleObjects(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleObjects");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.OleObject>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.OleObject), 1, 65535)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleObjects>(deep);
    }

    /// <summary>
    /// <para>Defines the Controls Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:controls.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Control" /> <c>&lt;x:control></c></description></item>
    /// </list>
    /// </remark>
    public partial class Controls : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Controls class.
        /// </summary>
        public Controls() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Controls class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Controls(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Controls class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Controls(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Controls class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Controls(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:controls");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Control>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Control), 1, 65535)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Controls>(deep);
    }

    /// <summary>
    /// <para>Macro Sheet Dimensions.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dimension.</para>
    /// </summary>
    public partial class SheetDimension : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetDimension class.
        /// </summary>
        public SheetDimension() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dimension");
            builder.AddElement<SheetDimension>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:uniqueName"), true, null));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:caption"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 65535) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:uniqueName"), 1, 32767) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetDimension>(deep);
    }

    /// <summary>
    /// <para>Column Information.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cols.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Column" /> <c>&lt;x:col></c></description></item>
    /// </list>
    /// </remark>
    public partial class Columns : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Columns class.
        /// </summary>
        public Columns() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Columns class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Columns(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Columns class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Columns(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Columns class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Columns(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cols");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Column>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Column), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Columns>(deep);
    }

    /// <summary>
    /// <para>Sheet Data.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetData.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Row" /> <c>&lt;x:row></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetData : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetData class.
        /// </summary>
        public SheetData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetData");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Row>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Row), 0, 0)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:sheetId"), true, 0, true, 65533, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetData>(deep);
    }

    /// <summary>
    /// <para>Data Consolidation.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataConsolidate.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataReferences" /> <c>&lt;x:dataRefs></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataConsolidate : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataConsolidate class.
        /// </summary>
        public DataConsolidate() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataConsolidate class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataConsolidate(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataConsolidate class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataConsolidate(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataConsolidate class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataConsolidate(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Function Index</para>
        /// <para>Represents the following attribute in the schema: function</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>? Function
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use Left Column Labels</para>
        /// <para>Represents the following attribute in the schema: leftLabels</para>
        /// </summary>
        public BooleanValue? LeftLabels
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>startLabels, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: startLabels</para>
        /// </summary>
        public BooleanValue? StartLabels
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Labels In Top Row</para>
        /// <para>Represents the following attribute in the schema: topLabels</para>
        /// </summary>
        public BooleanValue? TopLabels
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Link</para>
        /// <para>Represents the following attribute in the schema: link</para>
        /// </summary>
        public BooleanValue? Link
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataConsolidate");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataReferences>();
            builder.AddElement<DataConsolidate>()
                .AddAttribute("function", a => a.Function)
                .AddAttribute("leftLabels", a => a.LeftLabels)
                .AddAttribute("startLabels", a => a.StartLabels, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                })
                .AddAttribute("topLabels", a => a.TopLabels)
                .AddAttribute("link", a => a.Link);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataReferences), 0, 1)
            };
        }

        /// <summary>
        /// <para>Data Consolidation References.</para>
        /// <para>Represents the following element tag in the schema: x:dataRefs.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.DataReferences? DataReferences
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.DataReferences>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataConsolidate>(deep);
    }

    /// <summary>
    /// <para>Conditional Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:conditionalFormatting.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRule" /> <c>&lt;x:cfRule></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormatting : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormatting class.
        /// </summary>
        public ConditionalFormatting() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatting class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormatting(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatting class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormatting(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormatting class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormatting(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>PivotTable Conditional Formatting</para>
        /// <para>Represents the following attribute in the schema: pivot</para>
        /// </summary>
        public BooleanValue? Pivot
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sequence of References</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:conditionalFormatting");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRule>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddElement<ConditionalFormatting>()
                .AddAttribute("pivot", a => a.Pivot)
                .AddAttribute("sqref", a => a.SequenceOfReferences);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingRule), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sqref"), 1, int.MaxValue));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormatting>(deep);
    }

    /// <summary>
    /// <para>Custom Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customProperties.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomProperty" /> <c>&lt;x:customPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomProperties class.
        /// </summary>
        public CustomProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customProperties");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomProperty>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomProperty), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomProperties>(deep);
    }

    /// <summary>
    /// <para>OLAP Member Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mps.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MemberProperty" /> <c>&lt;x:mp></c></description></item>
    /// </list>
    /// </remark>
    public partial class MemberProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MemberProperties class.
        /// </summary>
        public MemberProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MemberProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MemberProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MemberProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MemberProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MemberProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MemberProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>OLAP Member Properties Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mps");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MemberProperty>();
            builder.AddElement<MemberProperties>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MemberProperty), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MemberProperties>(deep);
    }

    /// <summary>
    /// <para>Members.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:members.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Member" /> <c>&lt;x:member></c></description></item>
    /// </list>
    /// </remark>
    public partial class Members : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Members class.
        /// </summary>
        public Members() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Members class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Members(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Members class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Members(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Members class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Members(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hierarchy Level</para>
        /// <para>Represents the following attribute in the schema: level</para>
        /// </summary>
        public UInt32Value? Level
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:members");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Member>();
            builder.AddElement<Members>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("level", a => a.Level);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Member), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Members>(deep);
    }

    /// <summary>
    /// <para>Future Feature Data Storage Area.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotHierarchyExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtensionList class.
        /// </summary>
        public PivotHierarchyExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchyExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchyExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchyExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotHierarchyExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotHierarchyExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotHierarchyExtensionList>(deep);
    }

    /// <summary>
    /// <para>Field Items.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:items.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Item" /> <c>&lt;x:item></c></description></item>
    /// </list>
    /// </remark>
    public partial class Items : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Items class.
        /// </summary>
        public Items() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Items class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Items(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Items class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Items(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Items class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Items(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:items");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Item>();
            builder.AddElement<Items>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Item), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Items>(deep);
    }

    /// <summary>
    /// <para>AutoSort Scope.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:autoSortScope.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotArea" /> <c>&lt;x:pivotArea></c></description></item>
    /// </list>
    /// </remark>
    public partial class AutoSortScope : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the AutoSortScope class.
        /// </summary>
        public AutoSortScope() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoSortScope class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AutoSortScope(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoSortScope class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AutoSortScope(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AutoSortScope class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AutoSortScope(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:autoSortScope");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotArea), 1, 1)
            };
        }

        /// <summary>
        /// <para>Auto Sort Scope.</para>
        /// <para>Represents the following element tag in the schema: x:pivotArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.PivotArea? PivotArea
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.PivotArea>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AutoSortScope>(deep);
    }

    /// <summary>
    /// <para>Future Feature Data Storage Area.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFieldExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFieldExtensionList class.
        /// </summary>
        public PivotFieldExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFieldExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFieldExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFieldExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFieldExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFieldExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the WorksheetSource Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:worksheetSource.</para>
    /// </summary>
    public partial class WorksheetSource : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WorksheetSource class.
        /// </summary>
        public WorksheetSource() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Named Range</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sheet Name</para>
        /// <para>Represents the following attribute in the schema: sheet</para>
        /// </summary>
        public StringValue? Sheet
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship Id</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:worksheetSource");
            builder.AddElement<WorksheetSource>()
                .AddAttribute("ref", a => a.Reference)
                .AddAttribute("name", a => a.Name)
                .AddAttribute("sheet", a => a.Sheet)
                .AddAttribute("r:id", a => a.Id);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sheet"), 0, 31));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:id")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorksheetSource>(deep);
    }

    /// <summary>
    /// <para>Defines the Consolidation Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:consolidation.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Pages" /> <c>&lt;x:pages></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RangeSets" /> <c>&lt;x:rangeSets></c></description></item>
    /// </list>
    /// </remark>
    public partial class Consolidation : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Consolidation class.
        /// </summary>
        public Consolidation() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Consolidation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Consolidation(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Consolidation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Consolidation(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Consolidation class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Consolidation(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Auto Page</para>
        /// <para>Represents the following attribute in the schema: autoPage</para>
        /// </summary>
        public BooleanValue? AutoPage
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:consolidation");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Pages>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RangeSets>();
            builder.AddElement<Consolidation>()
                .AddAttribute("autoPage", a => a.AutoPage);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Pages), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RangeSets), 1, 1)
            };
        }

        /// <summary>
        /// <para>Page Item Values.</para>
        /// <para>Represents the following element tag in the schema: x:pages.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Pages? Pages
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Pages>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Range Sets.</para>
        /// <para>Represents the following element tag in the schema: x:rangeSets.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.RangeSets? RangeSets
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.RangeSets>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Consolidation>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheSourceExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheSourceExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheSourceExtensionList class.
        /// </summary>
        public CacheSourceExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSourceExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSourceExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSourceExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheSourceExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheSourceExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the CommentProperties Class.</para>
    /// <para>This class is available in Office 2010 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:commentPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor" /> <c>&lt;x:anchor></c></description></item>
    /// </list>
    /// </remark>
    public partial class CommentProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CommentProperties class.
        /// </summary>
        public CommentProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CommentProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CommentProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CommentProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>locked</para>
        /// <para>Represents the following attribute in the schema: locked</para>
        /// </summary>
        public BooleanValue? Locked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>defaultSize</para>
        /// <para>Represents the following attribute in the schema: defaultSize</para>
        /// </summary>
        public BooleanValue? DefaultSize
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>print</para>
        /// <para>Represents the following attribute in the schema: print</para>
        /// </summary>
        public BooleanValue? Print
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>disabled</para>
        /// <para>Represents the following attribute in the schema: disabled</para>
        /// </summary>
        public BooleanValue? Disabled
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>uiObject</para>
        /// <para>Represents the following attribute in the schema: uiObject</para>
        /// </summary>
        public BooleanValue? UiObject
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoFill</para>
        /// <para>Represents the following attribute in the schema: autoFill</para>
        /// </summary>
        public BooleanValue? AutoFill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoLine</para>
        /// <para>Represents the following attribute in the schema: autoLine</para>
        /// </summary>
        public BooleanValue? AutoLine
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>altText</para>
        /// <para>Represents the following attribute in the schema: altText</para>
        /// </summary>
        public StringValue? AltText
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>textHAlign</para>
        /// <para>Represents the following attribute in the schema: textHAlign</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextHorizontalAlignmentValues>? TextHAlign
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextHorizontalAlignmentValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>textVAlign</para>
        /// <para>Represents the following attribute in the schema: textVAlign</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextVerticalAlignmentValues>? TextVAlign
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextVerticalAlignmentValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>lockText</para>
        /// <para>Represents the following attribute in the schema: lockText</para>
        /// </summary>
        public BooleanValue? LockText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>justLastX</para>
        /// <para>Represents the following attribute in the schema: justLastX</para>
        /// </summary>
        public BooleanValue? JustLastX
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>autoScale</para>
        /// <para>Represents the following attribute in the schema: autoScale</para>
        /// </summary>
        public BooleanValue? AutoScale
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rowHidden</para>
        /// <para>Represents the following attribute in the schema: rowHidden</para>
        /// </summary>
        public BooleanValue? RowHidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>colHidden</para>
        /// <para>Represents the following attribute in the schema: colHidden</para>
        /// </summary>
        public BooleanValue? ColHidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:commentPr");
            builder.Availability = FileFormatVersions.Office2010;
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            builder.AddElement<CommentProperties>()
                .AddAttribute("locked", a => a.Locked)
                .AddAttribute("defaultSize", a => a.DefaultSize)
                .AddAttribute("print", a => a.Print)
                .AddAttribute("disabled", a => a.Disabled)
                .AddAttribute("uiObject", a => a.UiObject)
                .AddAttribute("autoFill", a => a.AutoFill)
                .AddAttribute("autoLine", a => a.AutoLine)
                .AddAttribute("altText", a => a.AltText)
                .AddAttribute("textHAlign", a => a.TextHAlign)
                .AddAttribute("textVAlign", a => a.TextVAlign)
                .AddAttribute("lockText", a => a.LockText)
                .AddAttribute("justLastX", a => a.JustLastX)
                .AddAttribute("autoScale", a => a.AutoScale)
                .AddAttribute("rowHidden", a => a.RowHidden)
                .AddAttribute("colHidden", a => a.ColHidden);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor), 1, 1, version: FileFormatVersions.Office2010)
            };
        }

        /// <summary>
        /// <para>ObjectAnchor.</para>
        /// <para>Represents the following element tag in the schema: x:anchor.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor? ObjectAnchor
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ObjectAnchor>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CommentProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the SortCondition Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sortCondition.</para>
    /// </summary>
    public partial class SortCondition : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SortCondition class.
        /// </summary>
        public SortCondition() : base()
        {
        }

        /// <summary>
        /// <para>Descending</para>
        /// <para>Represents the following attribute in the schema: descending</para>
        /// </summary>
        public BooleanValue? Descending
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sort By</para>
        /// <para>Represents the following attribute in the schema: sortBy</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortByValues>? SortBy
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortByValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom List</para>
        /// <para>Represents the following attribute in the schema: customList</para>
        /// </summary>
        public StringValue? CustomList
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Format Id</para>
        /// <para>Represents the following attribute in the schema: dxfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Icon Set</para>
        /// <para>Represents the following attribute in the schema: iconSet</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>? IconSet
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Icon Id</para>
        /// <para>Represents the following attribute in the schema: iconId</para>
        /// </summary>
        public UInt32Value? IconId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sortCondition");
            builder.AddElement<SortCondition>()
                .AddAttribute("descending", a => a.Descending)
                .AddAttribute("sortBy", a => a.SortBy)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("customList", a => a.CustomList)
                .AddAttribute("dxfId", a => a.FormatId)
                .AddAttribute("iconSet", a => a.IconSet)
                .AddAttribute("iconId", a => a.IconId);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SortCondition>(deep);
    }

    /// <summary>
    /// <para>Filter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:filter.</para>
    /// </summary>
    public partial class Filter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Filter class.
        /// </summary>
        public Filter() : base()
        {
        }

        /// <summary>
        /// <para>Filter Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:filter");
            builder.AddElement<Filter>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:fld"), ".", null, builder.CreateQName("x:pivotField"), "x:pivotField", 0));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:id"), false, null));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:iMeasureFld"), ".", null, builder.CreateQName("x:pivotField"), "x:pivotField", 0));
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:iMeasureHier"), ".", null, builder.CreateQName("x:pivotHierarchy"), "x:pivotHierarchy", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Filter>(deep);
    }

    /// <summary>
    /// <para>Date Grouping.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dateGroupItem.</para>
    /// </summary>
    public partial class DateGroupItem : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DateGroupItem class.
        /// </summary>
        public DateGroupItem() : base()
        {
        }

        /// <summary>
        /// <para>Year</para>
        /// <para>Represents the following attribute in the schema: year</para>
        /// </summary>
        public UInt16Value? Year
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Month</para>
        /// <para>Represents the following attribute in the schema: month</para>
        /// </summary>
        public UInt16Value? Month
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Day</para>
        /// <para>Represents the following attribute in the schema: day</para>
        /// </summary>
        public UInt16Value? Day
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hour</para>
        /// <para>Represents the following attribute in the schema: hour</para>
        /// </summary>
        public UInt16Value? Hour
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minute</para>
        /// <para>Represents the following attribute in the schema: minute</para>
        /// </summary>
        public UInt16Value? Minute
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Second</para>
        /// <para>Represents the following attribute in the schema: second</para>
        /// </summary>
        public UInt16Value? Second
        {
            get => GetAttribute<UInt16Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Date Time Grouping</para>
        /// <para>Represents the following attribute in the schema: dateTimeGrouping</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DateTimeGroupingValues>? DateTimeGrouping
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DateTimeGroupingValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dateGroupItem");
            builder.AddElement<DateGroupItem>()
                .AddAttribute("year", a => a.Year, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("month", a => a.Month)
                .AddAttribute("day", a => a.Day)
                .AddAttribute("hour", a => a.Hour)
                .AddAttribute("minute", a => a.Minute)
                .AddAttribute("second", a => a.Second)
                .AddAttribute("dateTimeGrouping", a => a.DateTimeGrouping, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:day"), true, 1, true, 31, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:hour"), true, 0, true, 23, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:minute"), true, 0, true, 59, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:month"), true, 1, true, 12, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:second"), true, 0, true, 59, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:year"), true, 1000, true, 9999, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DateGroupItem>(deep);
    }

    /// <summary>
    /// <para>Filter Criteria.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:filters.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DateGroupItem" /> <c>&lt;x:dateGroupItem></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Filter" /> <c>&lt;x:filter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.Filter" /> <c>&lt;x14:filter></c></description></item>
    /// </list>
    /// </remark>
    public partial class Filters : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Filters class.
        /// </summary>
        public Filters() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Filters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Filters(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Filters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Filters(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Filters class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Filters(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Filter by Blank</para>
        /// <para>Represents the following attribute in the schema: blank</para>
        /// </summary>
        public BooleanValue? Blank
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calendar Type</para>
        /// <para>Represents the following attribute in the schema: calendarType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalendarValues>? CalendarType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalendarValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:filters");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DateGroupItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Filter>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.Filter>();
            builder.AddElement<Filters>()
                .AddAttribute("blank", a => a.Blank)
                .AddAttribute("calendarType", a => a.CalendarType);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.Filter), 0, 0, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Filter), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DateGroupItem), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Filters>(deep);
    }

    /// <summary>
    /// <para>Top 10.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:top10.</para>
    /// </summary>
    public partial class Top10 : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Top10 class.
        /// </summary>
        public Top10() : base()
        {
        }

        /// <summary>
        /// <para>Top</para>
        /// <para>Represents the following attribute in the schema: top</para>
        /// </summary>
        public BooleanValue? Top
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter by Percent</para>
        /// <para>Represents the following attribute in the schema: percent</para>
        /// </summary>
        public BooleanValue? Percent
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top or Bottom Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter Value</para>
        /// <para>Represents the following attribute in the schema: filterVal</para>
        /// </summary>
        public DoubleValue? FilterValue
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:top10");
            builder.AddElement<Top10>()
                .AddAttribute("top", a => a.Top)
                .AddAttribute("percent", a => a.Percent)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("filterVal", a => a.FilterValue);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Top10>(deep);
    }

    /// <summary>
    /// <para>Custom Filters.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customFilters.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomFilter" /> <c>&lt;x:customFilter></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomFilters : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomFilters class.
        /// </summary>
        public CustomFilters() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomFilters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomFilters(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomFilters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomFilters(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomFilters class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomFilters(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>And</para>
        /// <para>Represents the following attribute in the schema: and</para>
        /// </summary>
        public BooleanValue? And
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customFilters");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomFilter>();
            builder.AddElement<CustomFilters>()
                .AddAttribute("and", a => a.And);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomFilter), 1, 2)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomFilters>(deep);
    }

    /// <summary>
    /// <para>Dynamic Filter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dynamicFilter.</para>
    /// </summary>
    public partial class DynamicFilter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DynamicFilter class.
        /// </summary>
        public DynamicFilter() : base()
        {
        }

        /// <summary>
        /// <para>Dynamic filter type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DynamicFilterValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.DynamicFilterValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Max Value</para>
        /// <para>Represents the following attribute in the schema: maxVal</para>
        /// </summary>
        public DoubleValue? MaxVal
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>valIso, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: valIso</para>
        /// </summary>
        public DateTimeValue? ValIso
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>maxValIso, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: maxValIso</para>
        /// </summary>
        public DateTimeValue? MaxValIso
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dynamicFilter");
            builder.AddElement<DynamicFilter>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("val", a => a.Val)
                .AddAttribute("maxVal", a => a.MaxVal)
                .AddAttribute("valIso", a => a.ValIso, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                })
                .AddAttribute("maxValIso", a => a.MaxValIso, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DynamicFilter>(deep);
    }

    /// <summary>
    /// <para>Color Filter Criteria.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colorFilter.</para>
    /// </summary>
    public partial class ColorFilter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorFilter class.
        /// </summary>
        public ColorFilter() : base()
        {
        }

        /// <summary>
        /// <para>Differential Format Record Id</para>
        /// <para>Represents the following attribute in the schema: dxfId</para>
        /// </summary>
        public UInt32Value? FormatId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter By Cell Color</para>
        /// <para>Represents the following attribute in the schema: cellColor</para>
        /// </summary>
        public BooleanValue? CellColor
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colorFilter");
            builder.AddElement<ColorFilter>()
                .AddAttribute("dxfId", a => a.FormatId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("cellColor", a => a.CellColor);
            builder.AddConstraint(new IndexReferenceConstraint(builder.CreateQName("x:dxfId"), "/WorkbookPart/WorkbookStylesPart", null, builder.CreateQName("x:dxf"), "x:dxf", 0));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorFilter>(deep);
    }

    /// <summary>
    /// <para>Icon Filter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:iconFilter.</para>
    /// </summary>
    public partial class IconFilter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the IconFilter class.
        /// </summary>
        public IconFilter() : base()
        {
        }

        /// <summary>
        /// <para>Icon Set</para>
        /// <para>Represents the following attribute in the schema: iconSet</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>? IconSet
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Icon Id</para>
        /// <para>Represents the following attribute in the schema: iconId</para>
        /// </summary>
        public UInt32Value? IconId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:iconFilter");
            builder.AddElement<IconFilter>()
                .AddAttribute("iconSet", a => a.IconSet, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("iconId", a => a.IconId);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IconFilter>(deep);
    }

    /// <summary>
    /// <para>Defines the SlicerCacheDefinitionExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables" /> <c>&lt;x15:slicerCachePivotTables></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData" /> <c>&lt;x15:slicerCacheHideItemsWithNoData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache" /> <c>&lt;x15:tableSlicerCache></c></description></item>
    /// </list>
    /// </remark>
    public partial class SlicerCacheDefinitionExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SlicerCacheDefinitionExtension class.
        /// </summary>
        public SlicerCacheDefinitionExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SlicerCacheDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SlicerCacheDefinitionExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SlicerCacheDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SlicerCacheDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SlicerCacheDefinitionExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SlicerCacheDefinitionExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache>();
            builder.AddElement<SlicerCacheDefinitionExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SlicerCacheDefinitionExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotFilterExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState" /> <c>&lt;x15:movingPeriodState></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotFilter" /> <c>&lt;x15:pivotFilter></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFilterExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFilterExtension class.
        /// </summary>
        public PivotFilterExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilterExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilterExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFilterExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotFilter>();
            builder.AddElement<PivotFilterExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotFilter), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFilterExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the QueryTableExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.QueryTable" /> <c>&lt;x15:queryTable></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableExtension class.
        /// </summary>
        public QueryTableExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.QueryTable>();
            builder.AddElement<QueryTableExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.QueryTable), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the DatabaseProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dbPr.</para>
    /// </summary>
    public partial class DatabaseProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the DatabaseProperties class.
        /// </summary>
        public DatabaseProperties() : base()
        {
        }

        /// <summary>
        /// <para>Connection String</para>
        /// <para>Represents the following attribute in the schema: connection</para>
        /// </summary>
        public StringValue? Connection
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Command Text</para>
        /// <para>Represents the following attribute in the schema: command</para>
        /// </summary>
        public StringValue? Command
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Command Text</para>
        /// <para>Represents the following attribute in the schema: serverCommand</para>
        /// </summary>
        public StringValue? ServerCommand
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLE DB Command Type</para>
        /// <para>Represents the following attribute in the schema: commandType</para>
        /// </summary>
        public UInt32Value? CommandType
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dbPr");
            builder.AddElement<DatabaseProperties>()
                .AddAttribute("connection", a => a.Connection, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("command", a => a.Command)
                .AddAttribute("serverCommand", a => a.ServerCommand)
                .AddAttribute("commandType", a => a.CommandType);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:commandType"), true, 1, true, 5, true));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:connection"), 0, 65535) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DatabaseProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the OlapProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:olapPr.</para>
    /// </summary>
    public partial class OlapProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the OlapProperties class.
        /// </summary>
        public OlapProperties() : base()
        {
        }

        /// <summary>
        /// <para>Local Cube</para>
        /// <para>Represents the following attribute in the schema: local</para>
        /// </summary>
        public BooleanValue? Local
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Local Cube Connection</para>
        /// <para>Represents the following attribute in the schema: localConnection</para>
        /// </summary>
        public StringValue? LocalConnection
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Local Refresh</para>
        /// <para>Represents the following attribute in the schema: localRefresh</para>
        /// </summary>
        public BooleanValue? LocalRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Send Locale to OLAP</para>
        /// <para>Represents the following attribute in the schema: sendLocale</para>
        /// </summary>
        public BooleanValue? SendLocale
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Drill Through Count</para>
        /// <para>Represents the following attribute in the schema: rowDrillCount</para>
        /// </summary>
        public UInt32Value? RowDrillCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLAP Fill Formatting</para>
        /// <para>Represents the following attribute in the schema: serverFill</para>
        /// </summary>
        public BooleanValue? ServerFill
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLAP Number Format</para>
        /// <para>Represents the following attribute in the schema: serverNumberFormat</para>
        /// </summary>
        public BooleanValue? ServerNumberFormat
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLAP Server Font</para>
        /// <para>Represents the following attribute in the schema: serverFont</para>
        /// </summary>
        public BooleanValue? ServerFont
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>OLAP Font Formatting</para>
        /// <para>Represents the following attribute in the schema: serverFontColor</para>
        /// </summary>
        public BooleanValue? ServerFontColor
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:olapPr");
            builder.AddElement<OlapProperties>()
                .AddAttribute("local", a => a.Local)
                .AddAttribute("localConnection", a => a.LocalConnection)
                .AddAttribute("localRefresh", a => a.LocalRefresh)
                .AddAttribute("sendLocale", a => a.SendLocale)
                .AddAttribute("rowDrillCount", a => a.RowDrillCount)
                .AddAttribute("serverFill", a => a.ServerFill)
                .AddAttribute("serverNumberFormat", a => a.ServerNumberFormat)
                .AddAttribute("serverFont", a => a.ServerFont)
                .AddAttribute("serverFontColor", a => a.ServerFontColor);
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:rowDrillCount"), true, 1, true, 1048576, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OlapProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the WebQueryProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Tables" /> <c>&lt;x:tables></c></description></item>
    /// </list>
    /// </remark>
    public partial class WebQueryProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WebQueryProperties class.
        /// </summary>
        public WebQueryProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebQueryProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebQueryProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebQueryProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebQueryProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebQueryProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WebQueryProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>XML Source</para>
        /// <para>Represents the following attribute in the schema: xml</para>
        /// </summary>
        public BooleanValue? XmlSource
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Import XML Source Data</para>
        /// <para>Represents the following attribute in the schema: sourceData</para>
        /// </summary>
        public BooleanValue? SourceData
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parse PRE</para>
        /// <para>Represents the following attribute in the schema: parsePre</para>
        /// </summary>
        public BooleanValue? ParsePreTag
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Consecutive Delimiters</para>
        /// <para>Represents the following attribute in the schema: consecutive</para>
        /// </summary>
        public BooleanValue? Consecutive
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Use First Row</para>
        /// <para>Represents the following attribute in the schema: firstRow</para>
        /// </summary>
        public BooleanValue? FirstRow
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Created in Excel 97</para>
        /// <para>Represents the following attribute in the schema: xl97</para>
        /// </summary>
        public BooleanValue? CreatedInExcel97
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Dates as Text</para>
        /// <para>Represents the following attribute in the schema: textDates</para>
        /// </summary>
        public BooleanValue? TextDates
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Refreshed in Excel 2000</para>
        /// <para>Represents the following attribute in the schema: xl2000</para>
        /// </summary>
        public BooleanValue? RefreshedInExcel2000
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>URL</para>
        /// <para>Represents the following attribute in the schema: url</para>
        /// </summary>
        public StringValue? Url
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Web Post</para>
        /// <para>Represents the following attribute in the schema: post</para>
        /// </summary>
        public StringValue? Post
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>HTML Tables Only</para>
        /// <para>Represents the following attribute in the schema: htmlTables</para>
        /// </summary>
        public BooleanValue? HtmlTables
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>HTML Formatting Handling</para>
        /// <para>Represents the following attribute in the schema: htmlFormat</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.HtmlFormattingValues>? HtmlFormat
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.HtmlFormattingValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Edit Query URL</para>
        /// <para>Represents the following attribute in the schema: editPage</para>
        /// </summary>
        public StringValue? EditPage
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Tables>();
            builder.AddElement<WebQueryProperties>()
                .AddAttribute("xml", a => a.XmlSource)
                .AddAttribute("sourceData", a => a.SourceData)
                .AddAttribute("parsePre", a => a.ParsePreTag)
                .AddAttribute("consecutive", a => a.Consecutive)
                .AddAttribute("firstRow", a => a.FirstRow)
                .AddAttribute("xl97", a => a.CreatedInExcel97)
                .AddAttribute("textDates", a => a.TextDates)
                .AddAttribute("xl2000", a => a.RefreshedInExcel2000)
                .AddAttribute("url", a => a.Url)
                .AddAttribute("post", a => a.Post)
                .AddAttribute("htmlTables", a => a.HtmlTables)
                .AddAttribute("htmlFormat", a => a.HtmlFormat)
                .AddAttribute("editPage", a => a.EditPage);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Tables), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:url"), 1, int.MaxValue));
        }

        /// <summary>
        /// <para>Tables.</para>
        /// <para>Represents the following element tag in the schema: x:tables.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Tables? Tables
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Tables>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebQueryProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the TextProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:textPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TextFields" /> <c>&lt;x:textFields></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TextProperties class.
        /// </summary>
        public TextProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>prompt</para>
        /// <para>Represents the following attribute in the schema: prompt</para>
        /// </summary>
        public BooleanValue? Prompt
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>fileType</para>
        /// <para>Represents the following attribute in the schema: fileType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FileTypeValues>? FileType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.FileTypeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>codePage</para>
        /// <para>Represents the following attribute in the schema: codePage</para>
        /// </summary>
        public UInt32Value? CodePage
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>characterSet</para>
        /// <para>Represents the following attribute in the schema: characterSet</para>
        /// </summary>
        public StringValue? TextCharacterSet
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>firstRow</para>
        /// <para>Represents the following attribute in the schema: firstRow</para>
        /// </summary>
        public UInt32Value? FirstRow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sourceFile</para>
        /// <para>Represents the following attribute in the schema: sourceFile</para>
        /// </summary>
        public StringValue? SourceFile
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>delimited</para>
        /// <para>Represents the following attribute in the schema: delimited</para>
        /// </summary>
        public BooleanValue? Delimited
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>decimal</para>
        /// <para>Represents the following attribute in the schema: decimal</para>
        /// </summary>
        public StringValue? Decimal
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>thousands</para>
        /// <para>Represents the following attribute in the schema: thousands</para>
        /// </summary>
        public StringValue? Thousands
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>tab</para>
        /// <para>Represents the following attribute in the schema: tab</para>
        /// </summary>
        public BooleanValue? TabAsDelimiter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>space</para>
        /// <para>Represents the following attribute in the schema: space</para>
        /// </summary>
        public BooleanValue? Space
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>comma</para>
        /// <para>Represents the following attribute in the schema: comma</para>
        /// </summary>
        public BooleanValue? Comma
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>semicolon</para>
        /// <para>Represents the following attribute in the schema: semicolon</para>
        /// </summary>
        public BooleanValue? Semicolon
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>consecutive</para>
        /// <para>Represents the following attribute in the schema: consecutive</para>
        /// </summary>
        public BooleanValue? Consecutive
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>qualifier</para>
        /// <para>Represents the following attribute in the schema: qualifier</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.QualifierValues>? Qualifier
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.QualifierValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>delimiter</para>
        /// <para>Represents the following attribute in the schema: delimiter</para>
        /// </summary>
        public StringValue? Delimiter
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:textPr");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TextFields>();
            builder.AddElement<TextProperties>()
                .AddAttribute("prompt", a => a.Prompt)
                .AddAttribute("fileType", a => a.FileType)
                .AddAttribute("codePage", a => a.CodePage)
                .AddAttribute("characterSet", a => a.TextCharacterSet)
                .AddAttribute("firstRow", a => a.FirstRow)
                .AddAttribute("sourceFile", a => a.SourceFile)
                .AddAttribute("delimited", a => a.Delimited)
                .AddAttribute("decimal", a => a.Decimal)
                .AddAttribute("thousands", a => a.Thousands)
                .AddAttribute("tab", a => a.TabAsDelimiter)
                .AddAttribute("space", a => a.Space)
                .AddAttribute("comma", a => a.Comma)
                .AddAttribute("semicolon", a => a.Semicolon)
                .AddAttribute("consecutive", a => a.Consecutive)
                .AddAttribute("qualifier", a => a.Qualifier)
                .AddAttribute("delimiter", a => a.Delimiter);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TextFields), 0, 1)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:decimal"), 1, 255));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:thousands"), 1, 255));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:firstRow"), true, double.NegativeInfinity, true, 2147483647, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:sourceFile"), 1, 218) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeRequiredConditionToValue(builder.CreateQName("x:sourceFile"), builder.CreateQName("x:prompt") , "false") { Application = ApplicationType.Excel });
        }

        /// <summary>
        /// <para>TextFields.</para>
        /// <para>Represents the following element tag in the schema: x:textFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.TextFields? TextFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.TextFields>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the Parameters Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:parameters.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Parameter" /> <c>&lt;x:parameter></c></description></item>
    /// </list>
    /// </remark>
    public partial class Parameters : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Parameters class.
        /// </summary>
        public Parameters() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Parameters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Parameters(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Parameters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Parameters(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Parameters class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Parameters(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Parameter Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:parameters");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Parameter>();
            builder.AddElement<Parameters>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Parameter), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Parameters>(deep);
    }

    /// <summary>
    /// <para>Defines the ConnectionExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConnectionExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConnectionExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConnectionExtensionList class.
        /// </summary>
        public ConnectionExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConnectionExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConnectionExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConnectionExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConnectionExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the ConnectionExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.Connection" /> <c>&lt;x14:connection></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.Connection" /> <c>&lt;x15:connection></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConnectionExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConnectionExtension class.
        /// </summary>
        public ConnectionExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConnectionExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.Connection>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.Connection>();
            builder.AddElement<ConnectionExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.Connection), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.Connection), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConnectionExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the TextFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:textFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TextField" /> <c>&lt;x:textField></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TextFields class.
        /// </summary>
        public TextFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Count of Fields</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:textFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TextField>();
            builder.AddElement<TextFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TextField), 1, 2001)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextFields>(deep);
    }

    /// <summary>
    /// <para>Defines the SharedItems Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sharedItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.BooleanItem" /> <c>&lt;x:b></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DateTimeItem" /> <c>&lt;x:d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ErrorItem" /> <c>&lt;x:e></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MissingItem" /> <c>&lt;x:m></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberItem" /> <c>&lt;x:n></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StringItem" /> <c>&lt;x:s></c></description></item>
    /// </list>
    /// </remark>
    public partial class SharedItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SharedItems class.
        /// </summary>
        public SharedItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SharedItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SharedItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SharedItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Contains Semi Mixed Data Types</para>
        /// <para>Represents the following attribute in the schema: containsSemiMixedTypes</para>
        /// </summary>
        public BooleanValue? ContainsSemiMixedTypes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Non Date</para>
        /// <para>Represents the following attribute in the schema: containsNonDate</para>
        /// </summary>
        public BooleanValue? ContainsNonDate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Date</para>
        /// <para>Represents the following attribute in the schema: containsDate</para>
        /// </summary>
        public BooleanValue? ContainsDate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains String</para>
        /// <para>Represents the following attribute in the schema: containsString</para>
        /// </summary>
        public BooleanValue? ContainsString
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Blank</para>
        /// <para>Represents the following attribute in the schema: containsBlank</para>
        /// </summary>
        public BooleanValue? ContainsBlank
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Mixed Data Types</para>
        /// <para>Represents the following attribute in the schema: containsMixedTypes</para>
        /// </summary>
        public BooleanValue? ContainsMixedTypes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Numbers</para>
        /// <para>Represents the following attribute in the schema: containsNumber</para>
        /// </summary>
        public BooleanValue? ContainsNumber
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contains Integer</para>
        /// <para>Represents the following attribute in the schema: containsInteger</para>
        /// </summary>
        public BooleanValue? ContainsInteger
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Numeric Value</para>
        /// <para>Represents the following attribute in the schema: minValue</para>
        /// </summary>
        public DoubleValue? MinValue
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Numeric Value</para>
        /// <para>Represents the following attribute in the schema: maxValue</para>
        /// </summary>
        public DoubleValue? MaxValue
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Date Time</para>
        /// <para>Represents the following attribute in the schema: minDate</para>
        /// </summary>
        public DateTimeValue? MinDate
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Maximum Date Time Value</para>
        /// <para>Represents the following attribute in the schema: maxDate</para>
        /// </summary>
        public DateTimeValue? MaxDate
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shared Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Long Text</para>
        /// <para>Represents the following attribute in the schema: longText</para>
        /// </summary>
        public BooleanValue? LongText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sharedItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.BooleanItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DateTimeItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ErrorItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MissingItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberItem>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StringItem>();
            builder.AddElement<SharedItems>()
                .AddAttribute("containsSemiMixedTypes", a => a.ContainsSemiMixedTypes)
                .AddAttribute("containsNonDate", a => a.ContainsNonDate)
                .AddAttribute("containsDate", a => a.ContainsDate)
                .AddAttribute("containsString", a => a.ContainsString)
                .AddAttribute("containsBlank", a => a.ContainsBlank)
                .AddAttribute("containsMixedTypes", a => a.ContainsMixedTypes)
                .AddAttribute("containsNumber", a => a.ContainsNumber)
                .AddAttribute("containsInteger", a => a.ContainsInteger)
                .AddAttribute("minValue", a => a.MinValue)
                .AddAttribute("maxValue", a => a.MaxValue)
                .AddAttribute("minDate", a => a.MinDate)
                .AddAttribute("maxDate", a => a.MaxDate)
                .AddAttribute("count", a => a.Count)
                .AddAttribute("longText", a => a.LongText);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MissingItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.BooleanItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ErrorItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StringItem), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DateTimeItem), 1, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:maxValue"), false, new string[] { "NaN", "INF", "-INF" }));
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("x:minValue"), false, new string[] { "NaN", "INF", "-INF" }));
            builder.AddConstraint(new AttributeValueLessEqualToAnother(builder.CreateQName("x:minValue"), builder.CreateQName("x:maxValue"), true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SharedItems>(deep);
    }

    /// <summary>
    /// <para>Defines the FieldGroup Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fieldGroup.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DiscreteProperties" /> <c>&lt;x:discretePr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GroupItems" /> <c>&lt;x:groupItems></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RangeProperties" /> <c>&lt;x:rangePr></c></description></item>
    /// </list>
    /// </remark>
    public partial class FieldGroup : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FieldGroup class.
        /// </summary>
        public FieldGroup() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldGroup class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FieldGroup(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldGroup class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FieldGroup(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldGroup class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FieldGroup(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Parent</para>
        /// <para>Represents the following attribute in the schema: par</para>
        /// </summary>
        public UInt32Value? ParentId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Field Base</para>
        /// <para>Represents the following attribute in the schema: base</para>
        /// </summary>
        public UInt32Value? Base
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fieldGroup");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DiscreteProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GroupItems>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RangeProperties>();
            builder.AddElement<FieldGroup>()
                .AddAttribute("par", a => a.ParentId)
                .AddAttribute("base", a => a.Base);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                {
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RangeProperties), 0, 1),
                    new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DiscreteProperties), 0, 1)
                },
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GroupItems), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FieldGroup>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheFieldExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheFieldExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheFieldExtensionList class.
        /// </summary>
        public CacheFieldExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFieldExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheFieldExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheFieldExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheFieldExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheFieldExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.CacheField" /> <c>&lt;x14:cacheField></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames" /> <c>&lt;x15:cachedUniqueNames></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheFieldExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheFieldExtension class.
        /// </summary>
        public CacheFieldExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFieldExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFieldExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheFieldExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.CacheField>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames>();
            builder.AddElement<CacheFieldExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.CacheField), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheFieldExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the FieldsUsage Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fieldsUsage.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FieldUsage" /> <c>&lt;x:fieldUsage></c></description></item>
    /// </list>
    /// </remark>
    public partial class FieldsUsage : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FieldsUsage class.
        /// </summary>
        public FieldsUsage() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldsUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FieldsUsage(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldsUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FieldsUsage(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FieldsUsage class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FieldsUsage(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fieldsUsage");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FieldUsage>();
            builder.AddElement<FieldsUsage>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FieldUsage), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FieldsUsage>(deep);
    }

    /// <summary>
    /// <para>Defines the GroupLevels Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:groupLevels.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.GroupLevel" /> <c>&lt;x:groupLevel></c></description></item>
    /// </list>
    /// </remark>
    public partial class GroupLevels : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the GroupLevels class.
        /// </summary>
        public GroupLevels() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupLevels(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GroupLevels(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GroupLevels class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GroupLevels(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Grouping Level Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:groupLevels");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.GroupLevel>();
            builder.AddElement<GroupLevels>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.GroupLevel), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GroupLevels>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheHierarchyExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheHierarchyExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtensionList class.
        /// </summary>
        public CacheHierarchyExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchyExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchyExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheHierarchyExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheHierarchyExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheHierarchyExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheHierarchyExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy" /> <c>&lt;x14:cacheHierarchy></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy" /> <c>&lt;x15:cacheHierarchy></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheHierarchyExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtension class.
        /// </summary>
        public CacheHierarchyExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchyExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchyExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchyExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheHierarchyExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy>();
            builder.AddElement<CacheHierarchyExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheHierarchyExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the CalculatedMemberExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedMemberExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtensionList class.
        /// </summary>
        public CalculatedMemberExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMemberExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMemberExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedMemberExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedMemberExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedMemberExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the CalculatedMemberExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember" /> <c>&lt;x14:calculatedMember></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember" /> <c>&lt;x15:calculatedMember></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedMemberExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtension class.
        /// </summary>
        public CalculatedMemberExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMemberExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMemberExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMemberExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedMemberExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember>();
            builder.AddElement<CalculatedMemberExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedMemberExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the DataFieldExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataFieldExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataFieldExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataFieldExtensionList class.
        /// </summary>
        public DataFieldExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFieldExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataFieldExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataFieldExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataFieldExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataFieldExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the DataFieldExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.DataField" /> <c>&lt;x14:dataField></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.DataField" /> <c>&lt;x15:dataField></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataFieldExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataFieldExtension class.
        /// </summary>
        public DataFieldExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFieldExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFieldExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataFieldExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.DataField>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.DataField>();
            builder.AddElement<DataFieldExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.DataField), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.DataField), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataFieldExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotFilterExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFilterExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFilterExtensionList class.
        /// </summary>
        public PivotFilterExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilterExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilterExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilterExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFilterExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFilterExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFilterExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the QueryTableRefresh Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:queryTableRefresh.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableDeletedFields" /> <c>&lt;x:queryTableDeletedFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableFields" /> <c>&lt;x:queryTableFields></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SortState" /> <c>&lt;x:sortState></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableRefresh : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableRefresh class.
        /// </summary>
        public QueryTableRefresh() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableRefresh class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableRefresh(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableRefresh class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableRefresh(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableRefresh class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableRefresh(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Preserve Sort and Filter Layout</para>
        /// <para>Represents the following attribute in the schema: preserveSortFilterLayout</para>
        /// </summary>
        public BooleanValue? PreserveSortFilterLayout
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Next Field Id Wrapped</para>
        /// <para>Represents the following attribute in the schema: fieldIdWrapped</para>
        /// </summary>
        public BooleanValue? FieldIdWrapped
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Headers In Last Refresh</para>
        /// <para>Represents the following attribute in the schema: headersInLastRefresh</para>
        /// </summary>
        public BooleanValue? HeadersInLastRefresh
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Refresh Version</para>
        /// <para>Represents the following attribute in the schema: minimumVersion</para>
        /// </summary>
        public ByteValue? MinimumVersion
        {
            get => GetAttribute<ByteValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Next field id</para>
        /// <para>Represents the following attribute in the schema: nextId</para>
        /// </summary>
        public UInt32Value? NextId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Columns Left</para>
        /// <para>Represents the following attribute in the schema: unboundColumnsLeft</para>
        /// </summary>
        public UInt32Value? UnboundColumnsLeft
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Columns Right</para>
        /// <para>Represents the following attribute in the schema: unboundColumnsRight</para>
        /// </summary>
        public UInt32Value? UnboundColumnsRight
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:queryTableRefresh");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableDeletedFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableFields>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            builder.AddElement<QueryTableRefresh>()
                .AddAttribute("preserveSortFilterLayout", a => a.PreserveSortFilterLayout)
                .AddAttribute("fieldIdWrapped", a => a.FieldIdWrapped)
                .AddAttribute("headersInLastRefresh", a => a.HeadersInLastRefresh)
                .AddAttribute("minimumVersion", a => a.MinimumVersion)
                .AddAttribute("nextId", a => a.NextId)
                .AddAttribute("unboundColumnsLeft", a => a.UnboundColumnsLeft)
                .AddAttribute("unboundColumnsRight", a => a.UnboundColumnsRight);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableFields), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableDeletedFields), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SortState), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:unboundColumnsLeft"), true, double.NegativeInfinity, true, 16383, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:unboundColumnsRight"), true, double.NegativeInfinity, true, 16383, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:nextId"), true, double.NegativeInfinity, true, 65535, true));
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:minimumVersion"), true, 0, true, 31, true));
        }

        /// <summary>
        /// <para>Query table fields.</para>
        /// <para>Represents the following element tag in the schema: x:queryTableFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.QueryTableFields? QueryTableFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.QueryTableFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Deleted Fields.</para>
        /// <para>Represents the following element tag in the schema: x:queryTableDeletedFields.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.QueryTableDeletedFields? QueryTableDeletedFields
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.QueryTableDeletedFields>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sort State.</para>
        /// <para>Represents the following element tag in the schema: x:sortState.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.SortState? SortState
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.SortState>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableRefresh>(deep);
    }

    /// <summary>
    /// <para>Defines the QueryTableExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryTableExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class QueryTableExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the QueryTableExtensionList class.
        /// </summary>
        public QueryTableExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public QueryTableExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTableExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public QueryTableExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryTableExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryTableExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<QueryTableExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the SheetCalculationProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetCalcPr.</para>
    /// </summary>
    public partial class SheetCalculationProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetCalculationProperties class.
        /// </summary>
        public SheetCalculationProperties() : base()
        {
        }

        /// <summary>
        /// <para>Full Calculation On Load</para>
        /// <para>Represents the following attribute in the schema: fullCalcOnLoad</para>
        /// </summary>
        public BooleanValue? FullCalculationOnLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetCalcPr");
            builder.AddElement<SheetCalculationProperties>()
                .AddAttribute("fullCalcOnLoad", a => a.FullCalculationOnLoad);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetCalculationProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the ProtectedRanges Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:protectedRanges.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ProtectedRange" /> <c>&lt;x:protectedRange></c></description></item>
    /// </list>
    /// </remark>
    public partial class ProtectedRanges : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ProtectedRanges class.
        /// </summary>
        public ProtectedRanges() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ProtectedRanges class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ProtectedRanges(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ProtectedRanges class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ProtectedRanges(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ProtectedRanges class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ProtectedRanges(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:protectedRanges");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ProtectedRange>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ProtectedRange), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ProtectedRanges>(deep);
    }

    /// <summary>
    /// <para>Defines the Scenarios Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:scenarios.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Scenario" /> <c>&lt;x:scenario></c></description></item>
    /// </list>
    /// </remark>
    public partial class Scenarios : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Scenarios class.
        /// </summary>
        public Scenarios() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenarios class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scenarios(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenarios class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scenarios(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scenarios class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Scenarios(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Current Scenario</para>
        /// <para>Represents the following attribute in the schema: current</para>
        /// </summary>
        public UInt32Value? Current
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Last Shown Scenario</para>
        /// <para>Represents the following attribute in the schema: show</para>
        /// </summary>
        public UInt32Value? Show
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sequence of References</para>
        /// <para>Represents the following attribute in the schema: sqref</para>
        /// </summary>
        public ListValue<StringValue>? SequenceOfReferences
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:scenarios");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Scenario>();
            builder.AddElement<Scenarios>()
                .AddAttribute("current", a => a.Current)
                .AddAttribute("show", a => a.Show)
                .AddAttribute("sqref", a => a.SequenceOfReferences);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Scenario), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Scenarios>(deep);
    }

    /// <summary>
    /// <para>Defines the MergeCells Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:mergeCells.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MergeCell" /> <c>&lt;x:mergeCell></c></description></item>
    /// </list>
    /// </remark>
    public partial class MergeCells : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MergeCells class.
        /// </summary>
        public MergeCells() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MergeCells class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MergeCells(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MergeCells class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MergeCells(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MergeCells class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MergeCells(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:mergeCells");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MergeCell>();
            builder.AddElement<MergeCells>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MergeCell), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MergeCells>(deep);
    }

    /// <summary>
    /// <para>Defines the DataValidations Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataValidations.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataValidation" /> <c>&lt;x:dataValidation></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataValidations : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataValidations class.
        /// </summary>
        public DataValidations() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidations class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataValidations(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidations class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataValidations(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataValidations class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataValidations(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Disable Prompts</para>
        /// <para>Represents the following attribute in the schema: disablePrompts</para>
        /// </summary>
        public BooleanValue? DisablePrompts
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Corner (X Coodrinate)</para>
        /// <para>Represents the following attribute in the schema: xWindow</para>
        /// </summary>
        public UInt32Value? XWindow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Top Left Corner (Y Coordinate)</para>
        /// <para>Represents the following attribute in the schema: yWindow</para>
        /// </summary>
        public UInt32Value? YWindow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Validation Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataValidations");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataValidation>();
            builder.AddElement<DataValidations>()
                .AddAttribute("disablePrompts", a => a.DisablePrompts)
                .AddAttribute("xWindow", a => a.XWindow)
                .AddAttribute("yWindow", a => a.YWindow)
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataValidation), 1, 65534)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:xWindow"), true, double.NegativeInfinity, true, 65535, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:yWindow"), true, double.NegativeInfinity, true, 65535, true) { Application = ApplicationType.Excel });
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:count"), true, double.NegativeInfinity, true, 65535, true) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataValidations>(deep);
    }

    /// <summary>
    /// <para>Defines the Hyperlinks Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:hyperlinks.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Hyperlink" /> <c>&lt;x:hyperlink></c></description></item>
    /// </list>
    /// </remark>
    public partial class Hyperlinks : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Hyperlinks class.
        /// </summary>
        public Hyperlinks() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Hyperlinks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Hyperlinks(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Hyperlinks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Hyperlinks(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Hyperlinks class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Hyperlinks(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:hyperlinks");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Hyperlink>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Hyperlink), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Hyperlinks>(deep);
    }

    /// <summary>
    /// <para>Defines the CellWatches Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellWatches.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellWatch" /> <c>&lt;x:cellWatch></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellWatches : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellWatches class.
        /// </summary>
        public CellWatches() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellWatches class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellWatches(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellWatches class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellWatches(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellWatches class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellWatches(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellWatches");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellWatch>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellWatch), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellWatches>(deep);
    }

    /// <summary>
    /// <para>Defines the IgnoredErrors Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ignoredErrors.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.IgnoredError" /> <c>&lt;x:ignoredError></c></description></item>
    /// </list>
    /// </remark>
    public partial class IgnoredErrors : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the IgnoredErrors class.
        /// </summary>
        public IgnoredErrors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the IgnoredErrors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IgnoredErrors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IgnoredErrors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IgnoredErrors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IgnoredErrors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public IgnoredErrors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ignoredErrors");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.IgnoredError>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.IgnoredError), 1, 9),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IgnoredErrors>(deep);
    }

    /// <summary>
    /// <para>Defines the TableParts Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableParts.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TablePart" /> <c>&lt;x:tablePart></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableParts : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableParts class.
        /// </summary>
        public TableParts() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableParts class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableParts(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableParts class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableParts(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableParts class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableParts(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableParts");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TablePart>();
            builder.AddElement<TableParts>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TablePart), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableParts>(deep);
    }

    /// <summary>
    /// <para>Defines the WorksheetExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorksheetExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class WorksheetExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WorksheetExtensionList class.
        /// </summary>
        public WorksheetExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorksheetExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorksheetExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WorksheetExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorksheetExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorksheetExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorksheetExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the WorksheetExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings" /> <c>&lt;x14:conditionalFormattings></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.DataValidations" /> <c>&lt;x14:dataValidations></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors" /> <c>&lt;x14:ignoredErrors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges" /> <c>&lt;x14:protectedRanges></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SlicerList" /> <c>&lt;x14:slicerList></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups" /> <c>&lt;x14:sparklineGroups></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences" /> <c>&lt;x15:timelineRefs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.WebExtensions" /> <c>&lt;x15:webExtensions></c></description></item>
    /// </list>
    /// </remark>
    public partial class WorksheetExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WorksheetExtension class.
        /// </summary>
        public WorksheetExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorksheetExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorksheetExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorksheetExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WorksheetExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.DataValidations>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SlicerList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.WebExtensions>();
            builder.AddElement<WorksheetExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.DataValidations), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerList), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.WebExtensions), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorksheetExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the NumberingFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:numFmts.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.NumberingFormat" /> <c>&lt;x:numFmt></c></description></item>
    /// </list>
    /// </remark>
    public partial class NumberingFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the NumberingFormats class.
        /// </summary>
        public NumberingFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberingFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumberingFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberingFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumberingFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumberingFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NumberingFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Number Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:numFmts");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.NumberingFormat>();
            builder.AddElement<NumberingFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.NumberingFormat), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumberingFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the Fonts Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fonts.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Font" /> <c>&lt;x:font></c></description></item>
    /// </list>
    /// </remark>
    public partial class Fonts : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Fonts class.
        /// </summary>
        public Fonts() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fonts class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fonts(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fonts class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fonts(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fonts class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Fonts(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Font Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>knownFonts, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: x14ac:knownFonts</para>
        /// </summary>
        /// <remark>
        /// xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
        /// </remark>
        public BooleanValue? KnownFonts
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fonts");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Font>();
            builder.AddElement<Fonts>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("x14ac:knownFonts", a => a.KnownFonts, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Font), 0, 65491)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Fonts>(deep);
    }

    /// <summary>
    /// <para>Defines the Fills Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fills.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Fill" /> <c>&lt;x:fill></c></description></item>
    /// </list>
    /// </remark>
    public partial class Fills : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Fills class.
        /// </summary>
        public Fills() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fills class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fills(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fills class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Fills(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Fills class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Fills(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Fill Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fills");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Fill>();
            builder.AddElement<Fills>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Fill), 1, 65430)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Fills>(deep);
    }

    /// <summary>
    /// <para>Defines the Borders Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:borders.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Border" /> <c>&lt;x:border></c></description></item>
    /// </list>
    /// </remark>
    public partial class Borders : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Borders class.
        /// </summary>
        public Borders() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Borders class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Borders(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Borders class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Borders(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Borders class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Borders(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Border Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:borders");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Border>();
            builder.AddElement<Borders>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Border), 0, 65430)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Borders>(deep);
    }

    /// <summary>
    /// <para>Defines the CellStyleFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellStyleXfs.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormat" /> <c>&lt;x:xf></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellStyleFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellStyleFormats class.
        /// </summary>
        public CellStyleFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyleFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyleFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyleFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyleFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyleFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellStyleFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Style Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellStyleXfs");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellFormat>();
            builder.AddElement<CellStyleFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormat), 1, 65430)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellStyleFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the CellFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellXfs.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellFormat" /> <c>&lt;x:xf></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellFormats class.
        /// </summary>
        public CellFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellXfs");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellFormat>();
            builder.AddElement<CellFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellFormat), 1, 65430)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the CellStyles Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cellStyles.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CellStyle" /> <c>&lt;x:cellStyle></c></description></item>
    /// </list>
    /// </remark>
    public partial class CellStyles : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CellStyles class.
        /// </summary>
        public CellStyles() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyles class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyles(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyles class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CellStyles(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CellStyles class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CellStyles(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Style Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cellStyles");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CellStyle>();
            builder.AddElement<CellStyles>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CellStyle), 1, 65430)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CellStyles>(deep);
    }

    /// <summary>
    /// <para>Defines the DifferentialFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dxfs.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat" /> <c>&lt;x:dxf></c></description></item>
    /// </list>
    /// </remark>
    public partial class DifferentialFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DifferentialFormats class.
        /// </summary>
        public DifferentialFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DifferentialFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DifferentialFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DifferentialFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DifferentialFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dxfs");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat>();
            builder.AddElement<DifferentialFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DifferentialFormat), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DifferentialFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the TableStyles Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableStyles.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableStyle" /> <c>&lt;x:tableStyle></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableStyles : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableStyles class.
        /// </summary>
        public TableStyles() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyles class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableStyles(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyles class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableStyles(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableStyles class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableStyles(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Table Style Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Table Style</para>
        /// <para>Represents the following attribute in the schema: defaultTableStyle</para>
        /// </summary>
        public StringValue? DefaultTableStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Pivot Style</para>
        /// <para>Represents the following attribute in the schema: defaultPivotStyle</para>
        /// </summary>
        public StringValue? DefaultPivotStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableStyles");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableStyle>();
            builder.AddElement<TableStyles>()
                .AddAttribute("count", a => a.Count)
                .AddAttribute("defaultTableStyle", a => a.DefaultTableStyle)
                .AddAttribute("defaultPivotStyle", a => a.DefaultPivotStyle);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableStyle), 0, 0)
            };
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:defaultTableStyle"), 1, 255));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableStyles>(deep);
    }

    /// <summary>
    /// <para>Defines the Colors Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colors.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.IndexedColors" /> <c>&lt;x:indexedColors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MruColors" /> <c>&lt;x:mruColors></c></description></item>
    /// </list>
    /// </remark>
    public partial class Colors : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Colors class.
        /// </summary>
        public Colors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Colors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Colors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Colors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Colors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Colors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Colors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colors");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.IndexedColors>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MruColors>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.IndexedColors), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MruColors), 0, 1)
            };
        }

        /// <summary>
        /// <para>Color Indexes.</para>
        /// <para>Represents the following element tag in the schema: x:indexedColors.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.IndexedColors? IndexedColors
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.IndexedColors>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>MRU Colors.</para>
        /// <para>Represents the following element tag in the schema: x:mruColors.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.MruColors? MruColors
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.MruColors>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Colors>(deep);
    }

    /// <summary>
    /// <para>Defines the StylesheetExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.StylesheetExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class StylesheetExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StylesheetExtensionList class.
        /// </summary>
        public StylesheetExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StylesheetExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StylesheetExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StylesheetExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.StylesheetExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.StylesheetExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StylesheetExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the StylesheetExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats" /> <c>&lt;x14:dxfs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats" /> <c>&lt;x15:dxfs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles" /> <c>&lt;x14:slicerStyles></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles" /> <c>&lt;x15:timelineStyles></c></description></item>
    /// </list>
    /// </remark>
    public partial class StylesheetExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StylesheetExtension class.
        /// </summary>
        public StylesheetExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StylesheetExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StylesheetExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StylesheetExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StylesheetExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles>();
            builder.AddElement<StylesheetExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles), 1, 1, version: FileFormatVersions.Office2013),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StylesheetExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the Location Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:location.</para>
    /// </summary>
    public partial class Location : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Location class.
        /// </summary>
        public Location() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>First Header Row</para>
        /// <para>Represents the following attribute in the schema: firstHeaderRow</para>
        /// </summary>
        public UInt32Value? FirstHeaderRow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>PivotTable Data First Row</para>
        /// <para>Represents the following attribute in the schema: firstDataRow</para>
        /// </summary>
        public UInt32Value? FirstDataRow
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>First Data Column</para>
        /// <para>Represents the following attribute in the schema: firstDataCol</para>
        /// </summary>
        public UInt32Value? FirstDataColumn
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Rows Per Page Count</para>
        /// <para>Represents the following attribute in the schema: rowPageCount</para>
        /// </summary>
        public UInt32Value? RowPageCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Columns Per Page</para>
        /// <para>Represents the following attribute in the schema: colPageCount</para>
        /// </summary>
        public UInt32Value? ColumnsPerPage
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:location");
            builder.AddElement<Location>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("firstHeaderRow", a => a.FirstHeaderRow, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("firstDataRow", a => a.FirstDataRow, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("firstDataCol", a => a.FirstDataColumn, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("rowPageCount", a => a.RowPageCount)
                .AddAttribute("colPageCount", a => a.ColumnsPerPage);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Location>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotField" /> <c>&lt;x:pivotField></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFields class.
        /// </summary>
        public PivotFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotField>();
            builder.AddElement<PivotFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotField), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFields>(deep);
    }

    /// <summary>
    /// <para>Defines the RowFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rowFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Field" /> <c>&lt;x:field></c></description></item>
    /// </list>
    /// </remark>
    public partial class RowFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RowFields class.
        /// </summary>
        public RowFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RowFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Repeated Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rowFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Field>();
            builder.AddElement<RowFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Field), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowFields>(deep);
    }

    /// <summary>
    /// <para>Defines the RowItems Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rowItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowItem" /> <c>&lt;x:i></c></description></item>
    /// </list>
    /// </remark>
    public partial class RowItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RowItems class.
        /// </summary>
        public RowItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RowItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Items in a Row Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rowItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowItem>();
            builder.AddElement<RowItems>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowItem), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowItems>(deep);
    }

    /// <summary>
    /// <para>Defines the ColumnFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Field" /> <c>&lt;x:field></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColumnFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColumnFields class.
        /// </summary>
        public ColumnFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColumnFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Repeated Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Field>();
            builder.AddElement<ColumnFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Field), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColumnFields>(deep);
    }

    /// <summary>
    /// <para>Defines the ColumnItems Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowItem" /> <c>&lt;x:i></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColumnItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColumnItems class.
        /// </summary>
        public ColumnItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColumnItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Column Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowItem>();
            builder.AddElement<ColumnItems>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowItem), 1, 1048576)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColumnItems>(deep);
    }

    /// <summary>
    /// <para>Defines the PageFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pageFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PageField" /> <c>&lt;x:pageField></c></description></item>
    /// </list>
    /// </remark>
    public partial class PageFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PageFields class.
        /// </summary>
        public PageFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PageFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PageFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PageFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PageFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Page Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pageFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PageField>();
            builder.AddElement<PageFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PageField), 1, 256)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageFields>(deep);
    }

    /// <summary>
    /// <para>Defines the DataFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dataFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DataField" /> <c>&lt;x:dataField></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataFields class.
        /// </summary>
        public DataFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Data Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dataFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DataField>();
            builder.AddElement<DataFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DataField), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataFields>(deep);
    }

    /// <summary>
    /// <para>Defines the Formats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:formats.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Format" /> <c>&lt;x:format></c></description></item>
    /// </list>
    /// </remark>
    public partial class Formats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Formats class.
        /// </summary>
        public Formats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Formats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Formats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Formats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Formats Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:formats");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Format>();
            builder.AddElement<Formats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Format), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Formats>(deep);
    }

    /// <summary>
    /// <para>Defines the ConditionalFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:conditionalFormats.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ConditionalFormat" /> <c>&lt;x:conditionalFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConditionalFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConditionalFormats class.
        /// </summary>
        public ConditionalFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConditionalFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConditionalFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConditionalFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Conditional Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:conditionalFormats");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormat>();
            builder.AddElement<ConditionalFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ConditionalFormat), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConditionalFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the ChartFormats Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:chartFormats.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ChartFormat" /> <c>&lt;x:chartFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChartFormats : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChartFormats class.
        /// </summary>
        public ChartFormats() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartFormats(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormats class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartFormats(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartFormats class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartFormats(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Format Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:chartFormats");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ChartFormat>();
            builder.AddElement<ChartFormats>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ChartFormat), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartFormats>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotHierarchies Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotHierarchies.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotHierarchy" /> <c>&lt;x:pivotHierarchy></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotHierarchies : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotHierarchies class.
        /// </summary>
        public PivotHierarchies() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchies class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchies(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchies class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotHierarchies(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotHierarchies class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotHierarchies(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>OLAP Hierarchy Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotHierarchies");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotHierarchy>();
            builder.AddElement<PivotHierarchies>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotHierarchy), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotHierarchies>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotTableStyle Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotTableStyleInfo.</para>
    /// </summary>
    public partial class PivotTableStyle : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotTableStyle class.
        /// </summary>
        public PivotTableStyle() : base()
        {
        }

        /// <summary>
        /// <para>Table Style Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Row Header Formatting</para>
        /// <para>Represents the following attribute in the schema: showRowHeaders</para>
        /// </summary>
        public BooleanValue? ShowRowHeaders
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Table Style Column Header Formatting</para>
        /// <para>Represents the following attribute in the schema: showColHeaders</para>
        /// </summary>
        public BooleanValue? ShowColumnHeaders
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Row Stripes</para>
        /// <para>Represents the following attribute in the schema: showRowStripes</para>
        /// </summary>
        public BooleanValue? ShowRowStripes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Column Stripes</para>
        /// <para>Represents the following attribute in the schema: showColStripes</para>
        /// </summary>
        public BooleanValue? ShowColumnStripes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Last Column</para>
        /// <para>Represents the following attribute in the schema: showLastColumn</para>
        /// </summary>
        public BooleanValue? ShowLastColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotTableStyleInfo");
            builder.AddElement<PivotTableStyle>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("showRowHeaders", a => a.ShowRowHeaders)
                .AddAttribute("showColHeaders", a => a.ShowColumnHeaders)
                .AddAttribute("showRowStripes", a => a.ShowRowStripes)
                .AddAttribute("showColStripes", a => a.ShowColumnStripes)
                .AddAttribute("showLastColumn", a => a.ShowLastColumn);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 0, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotTableStyle>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotFilters Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:filters.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotFilter" /> <c>&lt;x:filter></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotFilters : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotFilters class.
        /// </summary>
        public PivotFilters() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilters(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilters class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotFilters(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotFilters class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotFilters(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Pivot Filter Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:filters");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotFilter>();
            builder.AddElement<PivotFilters>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotFilter), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotFilters>(deep);
    }

    /// <summary>
    /// <para>Defines the RowHierarchiesUsage Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:rowHierarchiesUsage.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.RowHierarchyUsage" /> <c>&lt;x:rowHierarchyUsage></c></description></item>
    /// </list>
    /// </remark>
    public partial class RowHierarchiesUsage : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RowHierarchiesUsage class.
        /// </summary>
        public RowHierarchiesUsage() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowHierarchiesUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowHierarchiesUsage(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowHierarchiesUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RowHierarchiesUsage(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RowHierarchiesUsage class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RowHierarchiesUsage(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Item Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:rowHierarchiesUsage");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.RowHierarchyUsage>();
            builder.AddElement<RowHierarchiesUsage>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.RowHierarchyUsage), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RowHierarchiesUsage>(deep);
    }

    /// <summary>
    /// <para>Defines the ColumnHierarchiesUsage Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:colHierarchiesUsage.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchyUsage" /> <c>&lt;x:colHierarchyUsage></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColumnHierarchiesUsage : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColumnHierarchiesUsage class.
        /// </summary>
        public ColumnHierarchiesUsage() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnHierarchiesUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnHierarchiesUsage(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnHierarchiesUsage class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColumnHierarchiesUsage(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColumnHierarchiesUsage class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColumnHierarchiesUsage(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Items Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:colHierarchiesUsage");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchyUsage>();
            builder.AddElement<ColumnHierarchiesUsage>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ColumnHierarchyUsage), 1, 16384)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColumnHierarchiesUsage>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotTableDefinitionExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotTableDefinitionExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtensionList class.
        /// </summary>
        public PivotTableDefinitionExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinitionExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinitionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotTableDefinitionExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotTableDefinitionExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotTableDefinitionExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotTableDefinitionExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition" /> <c>&lt;x14:pivotTableDefinition></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotTableData" /> <c>&lt;x15:pivotTableData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings" /> <c>&lt;x15:pivotTableUISettings></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.PivotVersionInfo" /> <c>&lt;xxpvi:pivotVersionInfo></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotTableDefinitionExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtension class.
        /// </summary>
        public PivotTableDefinitionExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinitionExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotTableDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotTableDefinitionExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotTableDefinitionExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotTableData>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings>();
            builder.AddChild<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.PivotVersionInfo>();
            builder.AddElement<PivotTableDefinitionExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableData), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.PivotVersionInfo), 1, 1, version: FileFormatVersions.Microsoft365),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotTableDefinitionExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheSource Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cacheSource.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Consolidation" /> <c>&lt;x:consolidation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorksheetSource" /> <c>&lt;x:worksheetSource></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheSource : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheSource class.
        /// </summary>
        public CacheSource() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSource class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSource(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSource class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheSource(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheSource class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheSource(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SourceValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.SourceValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>connectionId</para>
        /// <para>Represents the following attribute in the schema: connectionId</para>
        /// </summary>
        public UInt32Value? ConnectionId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cacheSource");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Consolidation>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorksheetSource>();
            builder.AddElement<CacheSource>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("connectionId", a => a.ConnectionId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorksheetSource), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Consolidation), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtensionList), 0, 1)
            };
            builder.AddConstraint(new ReferenceExistConstraint(builder.CreateQName("x:connectionId"), "/WorkbookPart/ConnectionsPart", builder.CreateQName("x:connection"), "x:connection", builder.CreateQName("x:id")));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("x:connectionId"), true, null));
        }

        /// <summary>
        /// <para>WorksheetSource.</para>
        /// <para>Represents the following element tag in the schema: x:worksheetSource.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.WorksheetSource? WorksheetSource
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.WorksheetSource>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Consolidation.</para>
        /// <para>Represents the following element tag in the schema: x:consolidation.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Consolidation? Consolidation
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Consolidation>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CacheSourceExtensionList.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtensionList? CacheSourceExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.CacheSourceExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheSource>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheFields Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cacheFields.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheField" /> <c>&lt;x:cacheField></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheFields : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheFields class.
        /// </summary>
        public CacheFields() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFields(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFields class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheFields(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheFields class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheFields(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Field Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cacheFields");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheField>();
            builder.AddElement<CacheFields>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheField), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheFields>(deep);
    }

    /// <summary>
    /// <para>Defines the CacheHierarchies Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:cacheHierarchies.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CacheHierarchy" /> <c>&lt;x:cacheHierarchy></c></description></item>
    /// </list>
    /// </remark>
    public partial class CacheHierarchies : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CacheHierarchies class.
        /// </summary>
        public CacheHierarchies() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchies class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchies(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchies class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CacheHierarchies(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CacheHierarchies class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CacheHierarchies(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Hierarchy Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:cacheHierarchies");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CacheHierarchy>();
            builder.AddElement<CacheHierarchies>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CacheHierarchy), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CacheHierarchies>(deep);
    }

    /// <summary>
    /// <para>Defines the Kpis Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:kpis.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Kpi" /> <c>&lt;x:kpi></c></description></item>
    /// </list>
    /// </remark>
    public partial class Kpis : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Kpis class.
        /// </summary>
        public Kpis() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Kpis class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Kpis(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Kpis class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Kpis(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Kpis class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Kpis(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>KPI Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:kpis");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Kpi>();
            builder.AddElement<Kpis>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Kpi), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Kpis>(deep);
    }

    /// <summary>
    /// <para>Defines the TupleCache Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tupleCache.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExtensionList" /> <c>&lt;x:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Entries" /> <c>&lt;x:entries></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.QueryCache" /> <c>&lt;x:queryCache></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ServerFormats" /> <c>&lt;x:serverFormats></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Sets" /> <c>&lt;x:sets></c></description></item>
    /// </list>
    /// </remark>
    public partial class TupleCache : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TupleCache class.
        /// </summary>
        public TupleCache() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TupleCache(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TupleCache(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TupleCache class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TupleCache(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tupleCache");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Entries>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.QueryCache>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ServerFormats>();
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Sets>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Entries), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Sets), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.QueryCache), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ServerFormats), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Entries.</para>
        /// <para>Represents the following element tag in the schema: x:entries.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Entries? Entries
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Entries>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Sets.</para>
        /// <para>Represents the following element tag in the schema: x:sets.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.Sets? Sets
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.Sets>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>OLAP Query Cache.</para>
        /// <para>Represents the following element tag in the schema: x:queryCache.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.QueryCache? QueryCache
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.QueryCache>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Server Formats.</para>
        /// <para>Represents the following element tag in the schema: x:serverFormats.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ServerFormats? ServerFormats
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ServerFormats>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Future Feature Data Storage Area.</para>
        /// <para>Represents the following element tag in the schema: x:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Spreadsheet.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Spreadsheet.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TupleCache>(deep);
    }

    /// <summary>
    /// <para>Defines the CalculatedItems Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calculatedItems.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedItem" /> <c>&lt;x:calculatedItem></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedItems : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedItems class.
        /// </summary>
        public CalculatedItems() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedItems(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItems class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedItems(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedItems class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedItems(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Calculated Item Formula Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calculatedItems");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedItem>();
            builder.AddElement<CalculatedItems>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedItem), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedItems>(deep);
    }

    /// <summary>
    /// <para>Defines the CalculatedMembers Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calculatedMembers.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CalculatedMember" /> <c>&lt;x:calculatedMember></c></description></item>
    /// </list>
    /// </remark>
    public partial class CalculatedMembers : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculatedMembers class.
        /// </summary>
        public CalculatedMembers() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMembers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMembers(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMembers class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CalculatedMembers(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CalculatedMembers class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CalculatedMembers(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Calculated Members Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calculatedMembers");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CalculatedMember>();
            builder.AddElement<CalculatedMembers>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CalculatedMember), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculatedMembers>(deep);
    }

    /// <summary>
    /// <para>Defines the Dimensions Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:dimensions.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Dimension" /> <c>&lt;x:dimension></c></description></item>
    /// </list>
    /// </remark>
    public partial class Dimensions : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Dimensions class.
        /// </summary>
        public Dimensions() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Dimensions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Dimensions(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Dimensions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Dimensions(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Dimensions class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Dimensions(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>OLAP Dimensions Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:dimensions");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Dimension>();
            builder.AddElement<Dimensions>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Dimension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Dimensions>(deep);
    }

    /// <summary>
    /// <para>Defines the MeasureGroups Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:measureGroups.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MeasureGroup" /> <c>&lt;x:measureGroup></c></description></item>
    /// </list>
    /// </remark>
    public partial class MeasureGroups : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the MeasureGroups class.
        /// </summary>
        public MeasureGroups() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MeasureGroups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MeasureGroups(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MeasureGroups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MeasureGroups(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MeasureGroups class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MeasureGroups(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Measure Group Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:measureGroups");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MeasureGroup>();
            builder.AddElement<MeasureGroups>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MeasureGroup), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MeasureGroups>(deep);
    }

    /// <summary>
    /// <para>Defines the Maps Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:maps.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.MeasureDimensionMap" /> <c>&lt;x:map></c></description></item>
    /// </list>
    /// </remark>
    public partial class Maps : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Maps class.
        /// </summary>
        public Maps() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Maps class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Maps(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Maps class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Maps(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Maps class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Maps(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Measure Group Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:maps");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.MeasureDimensionMap>();
            builder.AddElement<Maps>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.MeasureDimensionMap), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Maps>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotCacheDefinitionExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCacheDefinitionExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtensionList class.
        /// </summary>
        public PivotCacheDefinitionExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinitionExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinitionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCacheDefinitionExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotCacheDefinitionExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCacheDefinitionExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotCacheDefinitionExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition" /> <c>&lt;x14:pivotCacheDefinition></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled" /> <c>&lt;x15:pivotCacheDecoupled></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion" /> <c>&lt;x15:pivotCacheIdVersion></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition" /> <c>&lt;x15:timelinePivotCacheDefinition></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2021.Excel.Pivot.Xsdboolean" /> <c>&lt;xxpim:implicitMeasureSupport></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.CacheVersionInfo" /> <c>&lt;xxpvi:cacheVersionInfo></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCacheDefinitionExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtension class.
        /// </summary>
        public PivotCacheDefinitionExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinitionExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCacheDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCacheDefinitionExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCacheDefinitionExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2021.Excel.Pivot.Xsdboolean>();
            builder.AddChild<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.CacheVersionInfo>();
            builder.AddElement<PivotCacheDefinitionExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2021.Excel.Pivot.Xsdboolean), 1, 1, version: FileFormatVersions.Office2021),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office.SpreadSheetML.Y2022.PivotVersionInfo.CacheVersionInfo), 1, 1, version: FileFormatVersions.Microsoft365),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCacheDefinitionExtension>(deep);
    }

    /// <summary>
    /// <para>Sheet names of supporting book.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetNames.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.SheetName" /> <c>&lt;x:sheetName></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetNames : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetNames class.
        /// </summary>
        public SheetNames() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetNames(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetNames(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetNames class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetNames(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetNames");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.SheetName>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.SheetName), 1, 65534)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetNames>(deep);
    }

    /// <summary>
    /// <para>Defined names associated with supporting book..</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:definedNames.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedName" /> <c>&lt;x:definedName></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalDefinedNames : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalDefinedNames class.
        /// </summary>
        public ExternalDefinedNames() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalDefinedNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalDefinedNames(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalDefinedNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalDefinedNames(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalDefinedNames class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalDefinedNames(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:definedNames");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedName>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalDefinedName), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalDefinedNames>(deep);
    }

    /// <summary>
    /// <para>Cached worksheet data associated with supporting book.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheetDataSet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalSheetData" /> <c>&lt;x:sheetData></c></description></item>
    /// </list>
    /// </remark>
    public partial class SheetDataSet : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SheetDataSet class.
        /// </summary>
        public SheetDataSet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetDataSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetDataSet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetDataSet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SheetDataSet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SheetDataSet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SheetDataSet(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheetDataSet");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalSheetData>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalSheetData), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SheetDataSet>(deep);
    }

    /// <summary>
    /// <para>Table Columns.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableColumns.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableColumn" /> <c>&lt;x:tableColumn></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableColumns : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableColumns class.
        /// </summary>
        public TableColumns() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumns class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableColumns(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumns class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableColumns(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableColumns class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableColumns(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Column Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableColumns");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableColumn>();
            builder.AddElement<TableColumns>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableColumn), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableColumns>(deep);
    }

    /// <summary>
    /// <para>Table Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:tableStyleInfo.</para>
    /// </summary>
    public partial class TableStyleInfo : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the TableStyleInfo class.
        /// </summary>
        public TableStyleInfo() : base()
        {
        }

        /// <summary>
        /// <para>Style Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show First Column</para>
        /// <para>Represents the following attribute in the schema: showFirstColumn</para>
        /// </summary>
        public BooleanValue? ShowFirstColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Last Column</para>
        /// <para>Represents the following attribute in the schema: showLastColumn</para>
        /// </summary>
        public BooleanValue? ShowLastColumn
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Row Stripes</para>
        /// <para>Represents the following attribute in the schema: showRowStripes</para>
        /// </summary>
        public BooleanValue? ShowRowStripes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Column Stripes</para>
        /// <para>Represents the following attribute in the schema: showColumnStripes</para>
        /// </summary>
        public BooleanValue? ShowColumnStripes
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:tableStyleInfo");
            builder.AddElement<TableStyleInfo>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("showFirstColumn", a => a.ShowFirstColumn)
                .AddAttribute("showLastColumn", a => a.ShowLastColumn)
                .AddAttribute("showRowStripes", a => a.ShowRowStripes)
                .AddAttribute("showColumnStripes", a => a.ShowColumnStripes);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:name"), 1, 255) { Application = ApplicationType.Excel });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableStyleInfo>(deep);
    }

    /// <summary>
    /// <para>Future Feature Data Storage Area.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.TableExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableExtensionList class.
        /// </summary>
        public TableExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.TableExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.TableExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the TableExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.Table" /> <c>&lt;x14:table></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.MsForms.MsForm" /> <c>&lt;xlmsforms:msForm></c></description></item>
    /// </list>
    /// </remark>
    public partial class TableExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TableExtension class.
        /// </summary>
        public TableExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TableExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TableExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TableExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.Table>();
            builder.AddChild<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.MsForms.MsForm>();
            builder.AddElement<TableExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.Table), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.MsForms.MsForm), 1, 1, version: FileFormatVersions.Microsoft365),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TableExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the FileVersion Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fileVersion.</para>
    /// </summary>
    public partial class FileVersion : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FileVersion class.
        /// </summary>
        public FileVersion() : base()
        {
        }

        /// <summary>
        /// <para>Application Name</para>
        /// <para>Represents the following attribute in the schema: appName</para>
        /// </summary>
        public StringValue? ApplicationName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Last Edited Version</para>
        /// <para>Represents the following attribute in the schema: lastEdited</para>
        /// </summary>
        public StringValue? LastEdited
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Lowest Edited Version</para>
        /// <para>Represents the following attribute in the schema: lowestEdited</para>
        /// </summary>
        public StringValue? LowestEdited
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Build Version</para>
        /// <para>Represents the following attribute in the schema: rupBuild</para>
        /// </summary>
        public StringValue? BuildVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Code Name</para>
        /// <para>Represents the following attribute in the schema: codeName</para>
        /// </summary>
        public StringValue? CodeName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fileVersion");
            builder.AddElement<FileVersion>()
                .AddAttribute("appName", a => a.ApplicationName)
                .AddAttribute("lastEdited", a => a.LastEdited)
                .AddAttribute("lowestEdited", a => a.LowestEdited)
                .AddAttribute("rupBuild", a => a.BuildVersion)
                .AddAttribute("codeName", a => a.CodeName, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                });
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:appName"), 0, 65535));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:lastEdited"), 0, 65535));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:lowestEdited"), 0, 65535));
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:rupBuild"), 0, 65535));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FileVersion>(deep);
    }

    /// <summary>
    /// <para>Defines the FileSharing Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fileSharing.</para>
    /// </summary>
    public partial class FileSharing : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FileSharing class.
        /// </summary>
        public FileSharing() : base()
        {
        }

        /// <summary>
        /// <para>Read Only Recommended</para>
        /// <para>Represents the following attribute in the schema: readOnlyRecommended</para>
        /// </summary>
        public BooleanValue? ReadOnlyRecommended
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>User Name</para>
        /// <para>Represents the following attribute in the schema: userName</para>
        /// </summary>
        public StringValue? UserName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Write Reservation Password</para>
        /// <para>Represents the following attribute in the schema: reservationPassword</para>
        /// </summary>
        public HexBinaryValue? ReservationPassword
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password hash algorithm</para>
        /// <para>Represents the following attribute in the schema: algorithmName</para>
        /// </summary>
        public StringValue? AlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password hash</para>
        /// <para>Represents the following attribute in the schema: hashValue</para>
        /// </summary>
        public Base64BinaryValue? HashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Salt for password hash</para>
        /// <para>Represents the following attribute in the schema: saltValue</para>
        /// </summary>
        public Base64BinaryValue? SaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Spin count for password hash</para>
        /// <para>Represents the following attribute in the schema: spinCount</para>
        /// </summary>
        public UInt32Value? SpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fileSharing");
            builder.AddElement<FileSharing>()
                .AddAttribute("readOnlyRecommended", a => a.ReadOnlyRecommended)
                .AddAttribute("userName", a => a.UserName)
                .AddAttribute("reservationPassword", a => a.ReservationPassword, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("algorithmName", a => a.AlgorithmName)
                .AddAttribute("hashValue", a => a.HashValue)
                .AddAttribute("saltValue", a => a.SaltValue)
                .AddAttribute("spinCount", a => a.SpinCount);
            builder.AddConstraint(new AttributeValueLengthConstraint(builder.CreateQName("x:userName"), 1, 54));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FileSharing>(deep);
    }

    /// <summary>
    /// <para>Defines the WorkbookProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:workbookPr.</para>
    /// </summary>
    public partial class WorkbookProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WorkbookProperties class.
        /// </summary>
        public WorkbookProperties() : base()
        {
        }

        /// <summary>
        /// <para>Date 1904</para>
        /// <para>Represents the following attribute in the schema: date1904</para>
        /// </summary>
        public BooleanValue? Date1904
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dateCompatibility, this property is only available in Office 2010 and later.</para>
        /// <para>Represents the following attribute in the schema: dateCompatibility</para>
        /// </summary>
        public BooleanValue? DateCompatibility
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Objects</para>
        /// <para>Represents the following attribute in the schema: showObjects</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>? ShowObjects
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Border Unselected Table</para>
        /// <para>Represents the following attribute in the schema: showBorderUnselectedTables</para>
        /// </summary>
        public BooleanValue? ShowBorderUnselectedTables
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Filter Privacy</para>
        /// <para>Represents the following attribute in the schema: filterPrivacy</para>
        /// </summary>
        public BooleanValue? FilterPrivacy
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Prompted Solutions</para>
        /// <para>Represents the following attribute in the schema: promptedSolutions</para>
        /// </summary>
        public BooleanValue? PromptedSolutions
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Ink Annotations</para>
        /// <para>Represents the following attribute in the schema: showInkAnnotation</para>
        /// </summary>
        public BooleanValue? ShowInkAnnotation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Create Backup File</para>
        /// <para>Represents the following attribute in the schema: backupFile</para>
        /// </summary>
        public BooleanValue? BackupFile
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Save External Link Values</para>
        /// <para>Represents the following attribute in the schema: saveExternalLinkValues</para>
        /// </summary>
        public BooleanValue? SaveExternalLinkValues
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Update Links Behavior</para>
        /// <para>Represents the following attribute in the schema: updateLinks</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.UpdateLinksBehaviorValues>? UpdateLinks
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.UpdateLinksBehaviorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Code Name</para>
        /// <para>Represents the following attribute in the schema: codeName</para>
        /// </summary>
        public StringValue? CodeName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Pivot Field List</para>
        /// <para>Represents the following attribute in the schema: hidePivotFieldList</para>
        /// </summary>
        public BooleanValue? HidePivotFieldList
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Show Pivot Chart Filter</para>
        /// <para>Represents the following attribute in the schema: showPivotChartFilter</para>
        /// </summary>
        public BooleanValue? ShowPivotChartFilter
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Allow Refresh Query</para>
        /// <para>Represents the following attribute in the schema: allowRefreshQuery</para>
        /// </summary>
        public BooleanValue? AllowRefreshQuery
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Publish Items</para>
        /// <para>Represents the following attribute in the schema: publishItems</para>
        /// </summary>
        public BooleanValue? PublishItems
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Check Compatibility On Save</para>
        /// <para>Represents the following attribute in the schema: checkCompatibility</para>
        /// </summary>
        public BooleanValue? CheckCompatibility
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Auto Compress Pictures</para>
        /// <para>Represents the following attribute in the schema: autoCompressPictures</para>
        /// </summary>
        public BooleanValue? AutoCompressPictures
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Refresh all Connections on Open</para>
        /// <para>Represents the following attribute in the schema: refreshAllConnections</para>
        /// </summary>
        public BooleanValue? RefreshAllConnections
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Theme Version</para>
        /// <para>Represents the following attribute in the schema: defaultThemeVersion</para>
        /// </summary>
        public UInt32Value? DefaultThemeVersion
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:workbookPr");
            builder.AddElement<WorkbookProperties>()
                .AddAttribute("date1904", a => a.Date1904)
                .AddAttribute("dateCompatibility", a => a.DateCompatibility, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2010));
                })
                .AddAttribute("showObjects", a => a.ShowObjects)
                .AddAttribute("showBorderUnselectedTables", a => a.ShowBorderUnselectedTables)
                .AddAttribute("filterPrivacy", a => a.FilterPrivacy)
                .AddAttribute("promptedSolutions", a => a.PromptedSolutions)
                .AddAttribute("showInkAnnotation", a => a.ShowInkAnnotation)
                .AddAttribute("backupFile", a => a.BackupFile)
                .AddAttribute("saveExternalLinkValues", a => a.SaveExternalLinkValues)
                .AddAttribute("updateLinks", a => a.UpdateLinks)
                .AddAttribute("codeName", a => a.CodeName)
                .AddAttribute("hidePivotFieldList", a => a.HidePivotFieldList)
                .AddAttribute("showPivotChartFilter", a => a.ShowPivotChartFilter)
                .AddAttribute("allowRefreshQuery", a => a.AllowRefreshQuery)
                .AddAttribute("publishItems", a => a.PublishItems)
                .AddAttribute("checkCompatibility", a => a.CheckCompatibility)
                .AddAttribute("autoCompressPictures", a => a.AutoCompressPictures)
                .AddAttribute("refreshAllConnections", a => a.RefreshAllConnections)
                .AddAttribute("defaultThemeVersion", a => a.DefaultThemeVersion);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorkbookProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the WorkbookProtection Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:workbookProtection.</para>
    /// </summary>
    public partial class WorkbookProtection : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WorkbookProtection class.
        /// </summary>
        public WorkbookProtection() : base()
        {
        }

        /// <summary>
        /// <para>Workbook Password</para>
        /// <para>Represents the following attribute in the schema: workbookPassword</para>
        /// </summary>
        public HexBinaryValue? WorkbookPassword
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revisions Password</para>
        /// <para>Represents the following attribute in the schema: revisionsPassword</para>
        /// </summary>
        public HexBinaryValue? RevisionsPassword
        {
            get => GetAttribute<HexBinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Lock Structure</para>
        /// <para>Represents the following attribute in the schema: lockStructure</para>
        /// </summary>
        public BooleanValue? LockStructure
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Lock Windows</para>
        /// <para>Represents the following attribute in the schema: lockWindows</para>
        /// </summary>
        public BooleanValue? LockWindows
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Lock Revisions</para>
        /// <para>Represents the following attribute in the schema: lockRevision</para>
        /// </summary>
        public BooleanValue? LockRevision
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cryptographic Algorithm Name</para>
        /// <para>Represents the following attribute in the schema: revisionsAlgorithmName</para>
        /// </summary>
        public StringValue? RevisionsAlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password Hash Value</para>
        /// <para>Represents the following attribute in the schema: revisionsHashValue</para>
        /// </summary>
        public Base64BinaryValue? RevisionsHashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Salt Value for Password Verifier</para>
        /// <para>Represents the following attribute in the schema: revisionsSaltValue</para>
        /// </summary>
        public Base64BinaryValue? RevisionsSaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iterations to Run Hashing Algorithm</para>
        /// <para>Represents the following attribute in the schema: revisionsSpinCount</para>
        /// </summary>
        public UInt32Value? RevisionsSpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Cryptographic Algorithm Name</para>
        /// <para>Represents the following attribute in the schema: workbookAlgorithmName</para>
        /// </summary>
        public StringValue? WorkbookAlgorithmName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Password Hash Value</para>
        /// <para>Represents the following attribute in the schema: workbookHashValue</para>
        /// </summary>
        public Base64BinaryValue? WorkbookHashValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Salt Value for Password Verifier</para>
        /// <para>Represents the following attribute in the schema: workbookSaltValue</para>
        /// </summary>
        public Base64BinaryValue? WorkbookSaltValue
        {
            get => GetAttribute<Base64BinaryValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iterations to Run Hashing Algorithm</para>
        /// <para>Represents the following attribute in the schema: workbookSpinCount</para>
        /// </summary>
        public UInt32Value? WorkbookSpinCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:workbookProtection");
            builder.AddElement<WorkbookProtection>()
                .AddAttribute("workbookPassword", a => a.WorkbookPassword, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("revisionsPassword", a => a.RevisionsPassword, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Length = (2L) });
                })
                .AddAttribute("lockStructure", a => a.LockStructure)
                .AddAttribute("lockWindows", a => a.LockWindows)
                .AddAttribute("lockRevision", a => a.LockRevision)
                .AddAttribute("revisionsAlgorithmName", a => a.RevisionsAlgorithmName)
                .AddAttribute("revisionsHashValue", a => a.RevisionsHashValue)
                .AddAttribute("revisionsSaltValue", a => a.RevisionsSaltValue)
                .AddAttribute("revisionsSpinCount", a => a.RevisionsSpinCount)
                .AddAttribute("workbookAlgorithmName", a => a.WorkbookAlgorithmName)
                .AddAttribute("workbookHashValue", a => a.WorkbookHashValue)
                .AddAttribute("workbookSaltValue", a => a.WorkbookSaltValue)
                .AddAttribute("workbookSpinCount", a => a.WorkbookSpinCount);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorkbookProtection>(deep);
    }

    /// <summary>
    /// <para>Defines the BookViews Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:bookViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorkbookView" /> <c>&lt;x:workbookView></c></description></item>
    /// </list>
    /// </remark>
    public partial class BookViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the BookViews class.
        /// </summary>
        public BookViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BookViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BookViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BookViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BookViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BookViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public BookViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:bookViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorkbookView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorkbookView), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BookViews>(deep);
    }

    /// <summary>
    /// <para>Defines the Sheets Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:sheets.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.Sheet" /> <c>&lt;x:sheet></c></description></item>
    /// </list>
    /// </remark>
    public partial class Sheets : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Sheets class.
        /// </summary>
        public Sheets() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sheets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Sheets(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sheets class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Sheets(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Sheets class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Sheets(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:sheets");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.Sheet>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.Sheet), 1, 32767)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Sheets>(deep);
    }

    /// <summary>
    /// <para>Defines the FunctionGroups Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:functionGroups.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.FunctionGroup" /> <c>&lt;x:functionGroup></c></description></item>
    /// </list>
    /// </remark>
    public partial class FunctionGroups : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the FunctionGroups class.
        /// </summary>
        public FunctionGroups() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FunctionGroups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FunctionGroups(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FunctionGroups class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FunctionGroups(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FunctionGroups class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FunctionGroups(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Built-in Function Group Count</para>
        /// <para>Represents the following attribute in the schema: builtInGroupCount</para>
        /// </summary>
        public UInt32Value? BuiltInGroupCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:functionGroups");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.FunctionGroup>();
            builder.AddElement<FunctionGroups>()
                .AddAttribute("builtInGroupCount", a => a.BuiltInGroupCount);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.FunctionGroup), 0, 255)
            };
            builder.AddConstraint(new AttributeValueRangeConstraint(builder.CreateQName("x:builtInGroupCount"), true, double.NegativeInfinity, true, 255, true));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FunctionGroups>(deep);
    }

    /// <summary>
    /// <para>Defines the ExternalReferences Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:externalReferences.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.ExternalReference" /> <c>&lt;x:externalReference></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExternalReferences : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExternalReferences class.
        /// </summary>
        public ExternalReferences() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalReferences(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalReferences class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExternalReferences(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExternalReferences class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExternalReferences(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:externalReferences");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.ExternalReference>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.ExternalReference), 1, 65534)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalReferences>(deep);
    }

    /// <summary>
    /// <para>Defines the DefinedNames Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:definedNames.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.DefinedName" /> <c>&lt;x:definedName></c></description></item>
    /// </list>
    /// </remark>
    public partial class DefinedNames : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DefinedNames class.
        /// </summary>
        public DefinedNames() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DefinedNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DefinedNames(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DefinedNames class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DefinedNames(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DefinedNames class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DefinedNames(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:definedNames");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.DefinedName>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.DefinedName), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DefinedNames>(deep);
    }

    /// <summary>
    /// <para>Defines the CalculationProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:calcPr.</para>
    /// </summary>
    public partial class CalculationProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the CalculationProperties class.
        /// </summary>
        public CalculationProperties() : base()
        {
        }

        /// <summary>
        /// <para>Calculation Id</para>
        /// <para>Represents the following attribute in the schema: calcId</para>
        /// </summary>
        public UInt32Value? CalculationId
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculation Mode</para>
        /// <para>Represents the following attribute in the schema: calcMode</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalculateModeValues>? CalculationMode
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalculateModeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Full Calculation On Load</para>
        /// <para>Represents the following attribute in the schema: fullCalcOnLoad</para>
        /// </summary>
        public BooleanValue? FullCalculationOnLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference Mode</para>
        /// <para>Represents the following attribute in the schema: refMode</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ReferenceModeValues>? ReferenceMode
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.ReferenceModeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculation Iteration</para>
        /// <para>Represents the following attribute in the schema: iterate</para>
        /// </summary>
        public BooleanValue? Iterate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iteration Count</para>
        /// <para>Represents the following attribute in the schema: iterateCount</para>
        /// </summary>
        public UInt32Value? IterateCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Iterative Calculation Delta</para>
        /// <para>Represents the following attribute in the schema: iterateDelta</para>
        /// </summary>
        public DoubleValue? IterateDelta
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Full Precision Calculation</para>
        /// <para>Represents the following attribute in the schema: fullPrecision</para>
        /// </summary>
        public BooleanValue? FullPrecision
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calc Completed</para>
        /// <para>Represents the following attribute in the schema: calcCompleted</para>
        /// </summary>
        public BooleanValue? CalculationCompleted
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Calculate On Save</para>
        /// <para>Represents the following attribute in the schema: calcOnSave</para>
        /// </summary>
        public BooleanValue? CalculationOnSave
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Concurrent Calculations</para>
        /// <para>Represents the following attribute in the schema: concurrentCalc</para>
        /// </summary>
        public BooleanValue? ConcurrentCalculation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Concurrent Thread Manual Count</para>
        /// <para>Represents the following attribute in the schema: concurrentManualCount</para>
        /// </summary>
        public UInt32Value? ConcurrentManualCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Force Full Calculation</para>
        /// <para>Represents the following attribute in the schema: forceFullCalc</para>
        /// </summary>
        public BooleanValue? ForceFullCalculation
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:calcPr");
            builder.AddElement<CalculationProperties>()
                .AddAttribute("calcId", a => a.CalculationId)
                .AddAttribute("calcMode", a => a.CalculationMode)
                .AddAttribute("fullCalcOnLoad", a => a.FullCalculationOnLoad)
                .AddAttribute("refMode", a => a.ReferenceMode)
                .AddAttribute("iterate", a => a.Iterate)
                .AddAttribute("iterateCount", a => a.IterateCount)
                .AddAttribute("iterateDelta", a => a.IterateDelta)
                .AddAttribute("fullPrecision", a => a.FullPrecision)
                .AddAttribute("calcCompleted", a => a.CalculationCompleted)
                .AddAttribute("calcOnSave", a => a.CalculationOnSave)
                .AddAttribute("concurrentCalc", a => a.ConcurrentCalculation)
                .AddAttribute("concurrentManualCount", a => a.ConcurrentManualCount)
                .AddAttribute("forceFullCalc", a => a.ForceFullCalculation);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CalculationProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the OleSize Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:oleSize.</para>
    /// </summary>
    public partial class OleSize : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the OleSize class.
        /// </summary>
        public OleSize() : base()
        {
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:oleSize");
            builder.AddElement<OleSize>()
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OleSize>(deep);
    }

    /// <summary>
    /// <para>Defines the CustomWorkbookViews Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:customWorkbookViews.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookView" /> <c>&lt;x:customWorkbookView></c></description></item>
    /// </list>
    /// </remark>
    public partial class CustomWorkbookViews : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CustomWorkbookViews class.
        /// </summary>
        public CustomWorkbookViews() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomWorkbookViews(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookViews class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CustomWorkbookViews(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CustomWorkbookViews class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CustomWorkbookViews(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:customWorkbookViews");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.CustomWorkbookView), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CustomWorkbookViews>(deep);
    }

    /// <summary>
    /// <para>Defines the PivotCaches Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:pivotCaches.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.PivotCache" /> <c>&lt;x:pivotCache></c></description></item>
    /// </list>
    /// </remark>
    public partial class PivotCaches : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PivotCaches class.
        /// </summary>
        public PivotCaches() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCaches class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCaches(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCaches class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PivotCaches(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PivotCaches class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PivotCaches(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:pivotCaches");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.PivotCache>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.PivotCache), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PivotCaches>(deep);
    }

    /// <summary>
    /// <para>Defines the WebPublishing Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPublishing.</para>
    /// </summary>
    public partial class WebPublishing : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the WebPublishing class.
        /// </summary>
        public WebPublishing() : base()
        {
        }

        /// <summary>
        /// <para>css</para>
        /// <para>Represents the following attribute in the schema: css</para>
        /// </summary>
        public BooleanValue? UseCss
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>thicket</para>
        /// <para>Represents the following attribute in the schema: thicket</para>
        /// </summary>
        public BooleanValue? Thicket
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>longFileNames</para>
        /// <para>Represents the following attribute in the schema: longFileNames</para>
        /// </summary>
        public BooleanValue? LongFileNames
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>vml</para>
        /// <para>Represents the following attribute in the schema: vml</para>
        /// </summary>
        public BooleanValue? UseVml
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>allowPng</para>
        /// <para>Represents the following attribute in the schema: allowPng</para>
        /// </summary>
        public BooleanValue? AllowPng
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>targetScreenSize</para>
        /// <para>Represents the following attribute in the schema: targetScreenSize</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TargetScreenSizeValues>? TargetScreenSize
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Spreadsheet.TargetScreenSizeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>dpi</para>
        /// <para>Represents the following attribute in the schema: dpi</para>
        /// </summary>
        public UInt32Value? Dpi
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>codePage</para>
        /// <para>Represents the following attribute in the schema: codePage</para>
        /// </summary>
        public UInt32Value? CodePage
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>characterSet</para>
        /// <para>Represents the following attribute in the schema: characterSet</para>
        /// </summary>
        public StringValue? CharacterSet
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPublishing");
            builder.AddElement<WebPublishing>()
                .AddAttribute("css", a => a.UseCss)
                .AddAttribute("thicket", a => a.Thicket)
                .AddAttribute("longFileNames", a => a.LongFileNames)
                .AddAttribute("vml", a => a.UseVml)
                .AddAttribute("allowPng", a => a.AllowPng)
                .AddAttribute("targetScreenSize", a => a.TargetScreenSize)
                .AddAttribute("dpi", a => a.Dpi)
                .AddAttribute("codePage", a => a.CodePage)
                .AddAttribute("characterSet", a => a.CharacterSet);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebPublishing>(deep);
    }

    /// <summary>
    /// <para>Defines the FileRecoveryProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:fileRecoveryPr.</para>
    /// </summary>
    public partial class FileRecoveryProperties : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the FileRecoveryProperties class.
        /// </summary>
        public FileRecoveryProperties() : base()
        {
        }

        /// <summary>
        /// <para>Auto Recover</para>
        /// <para>Represents the following attribute in the schema: autoRecover</para>
        /// </summary>
        public BooleanValue? AutoRecover
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Crash Save</para>
        /// <para>Represents the following attribute in the schema: crashSave</para>
        /// </summary>
        public BooleanValue? CrashSave
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Extract Load</para>
        /// <para>Represents the following attribute in the schema: dataExtractLoad</para>
        /// </summary>
        public BooleanValue? DataExtractLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Repair Load</para>
        /// <para>Represents the following attribute in the schema: repairLoad</para>
        /// </summary>
        public BooleanValue? RepairLoad
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:fileRecoveryPr");
            builder.AddElement<FileRecoveryProperties>()
                .AddAttribute("autoRecover", a => a.AutoRecover)
                .AddAttribute("crashSave", a => a.CrashSave)
                .AddAttribute("dataExtractLoad", a => a.DataExtractLoad)
                .AddAttribute("repairLoad", a => a.RepairLoad);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FileRecoveryProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the WebPublishObjects Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:webPublishObjects.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WebPublishObject" /> <c>&lt;x:webPublishObject></c></description></item>
    /// </list>
    /// </remark>
    public partial class WebPublishObjects : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WebPublishObjects class.
        /// </summary>
        public WebPublishObjects() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishObjects class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebPublishObjects(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishObjects class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WebPublishObjects(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WebPublishObjects class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WebPublishObjects(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public UInt32Value? Count
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:webPublishObjects");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WebPublishObject>();
            builder.AddElement<WebPublishObjects>()
                .AddAttribute("count", a => a.Count);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WebPublishObject), 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WebPublishObjects>(deep);
    }

    /// <summary>
    /// <para>Defines the WorkbookExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Spreadsheet.WorkbookExtension" /> <c>&lt;x:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class WorkbookExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WorkbookExtensionList class.
        /// </summary>
        public WorkbookExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WorkbookExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Spreadsheet.WorkbookExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Spreadsheet.WorkbookExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorkbookExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the WorkbookExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is x:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.PivotCaches" /> <c>&lt;x14:pivotCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotCaches" /> <c>&lt;x15:pivotCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches" /> <c>&lt;x15:timelineCachePivotCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.DefinedNames" /> <c>&lt;x14:definedNames></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches" /> <c>&lt;x14:slicerCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches" /> <c>&lt;x15:slicerCaches></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties" /> <c>&lt;x14:workbookPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.DataModel" /> <c>&lt;x15:dataModel></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences" /> <c>&lt;x15:pivotTableReferences></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences" /> <c>&lt;x15:timelineCacheRefs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties" /> <c>&lt;x15:workbookPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.ExternalCodeService.ExternalCodeService" /> <c>&lt;xlecs:externalCodeService></c></description></item>
    /// </list>
    /// </remark>
    public partial class WorkbookExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the WorkbookExtension class.
        /// </summary>
        public WorkbookExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public WorkbookExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the WorkbookExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public WorkbookExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("x:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.PivotCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.DefinedNames>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.DataModel>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences>();
            builder.AddChild<DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.ExternalCodeService.ExternalCodeService>();
            builder.AddElement<WorkbookExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.DefinedNames), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotCaches), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties), 1, 1, version: FileFormatVersions.Office2010),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCaches), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2013.Excel.DataModel), 1, 1, version: FileFormatVersions.Office2013),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office.SpreadSheetML.Y2023.ExternalCodeService.ExternalCodeService), 1, 1, version: FileFormatVersions.Microsoft365),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<WorkbookExtension>(deep);
    }

    /// <summary>
    /// Filter Operator
    /// </summary>
    public readonly record struct FilterOperatorValues : IEnumValue, IEnumValueFactory<FilterOperatorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FilterOperatorValues enum instance
        /// </summary>
        public FilterOperatorValues(string value) => _value = value;
        FilterOperatorValues IEnumValueFactory<FilterOperatorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "equal" => true,
            "lessThan" => true,
            "lessThanOrEqual" => true,
            "notEqual" => true,
            "greaterThanOrEqual" => true,
            "greaterThan" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "equal";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Equal.
        /// <para>When the item is serialized out as xml, its value is "equal".</para>
        /// </summary>
        public static FilterOperatorValues Equal => new("equal");
        /// <summary>
        /// Less Than.
        /// <para>When the item is serialized out as xml, its value is "lessThan".</para>
        /// </summary>
        public static FilterOperatorValues LessThan => new("lessThan");
        /// <summary>
        /// Less Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
        /// </summary>
        public static FilterOperatorValues LessThanOrEqual => new("lessThanOrEqual");
        /// <summary>
        /// Not Equal.
        /// <para>When the item is serialized out as xml, its value is "notEqual".</para>
        /// </summary>
        public static FilterOperatorValues NotEqual => new("notEqual");
        /// <summary>
        /// Greater Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
        /// </summary>
        public static FilterOperatorValues GreaterThanOrEqual => new("greaterThanOrEqual");
        /// <summary>
        /// Greater Than.
        /// <para>When the item is serialized out as xml, its value is "greaterThan".</para>
        /// </summary>
        public static FilterOperatorValues GreaterThan => new("greaterThan");
    
    }

    /// <summary>
    /// Dynamic Filter
    /// </summary>
    public readonly record struct DynamicFilterValues : IEnumValue, IEnumValueFactory<DynamicFilterValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DynamicFilterValues enum instance
        /// </summary>
        public DynamicFilterValues(string value) => _value = value;
        DynamicFilterValues IEnumValueFactory<DynamicFilterValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "null" => true,
            "aboveAverage" => true,
            "belowAverage" => true,
            "tomorrow" => true,
            "today" => true,
            "yesterday" => true,
            "nextWeek" => true,
            "thisWeek" => true,
            "lastWeek" => true,
            "nextMonth" => true,
            "thisMonth" => true,
            "lastMonth" => true,
            "nextQuarter" => true,
            "thisQuarter" => true,
            "lastQuarter" => true,
            "nextYear" => true,
            "thisYear" => true,
            "lastYear" => true,
            "yearToDate" => true,
            "Q1" => true,
            "Q2" => true,
            "Q3" => true,
            "Q4" => true,
            "M1" => true,
            "M2" => true,
            "M3" => true,
            "M4" => true,
            "M5" => true,
            "M6" => true,
            "M7" => true,
            "M8" => true,
            "M9" => true,
            "M10" => true,
            "M11" => true,
            "M12" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "null";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Null.
        /// <para>When the item is serialized out as xml, its value is "null".</para>
        /// </summary>
        public static DynamicFilterValues Null => new("null");
        /// <summary>
        /// Above Average.
        /// <para>When the item is serialized out as xml, its value is "aboveAverage".</para>
        /// </summary>
        public static DynamicFilterValues AboveAverage => new("aboveAverage");
        /// <summary>
        /// Below Average.
        /// <para>When the item is serialized out as xml, its value is "belowAverage".</para>
        /// </summary>
        public static DynamicFilterValues BelowAverage => new("belowAverage");
        /// <summary>
        /// Tomorrow.
        /// <para>When the item is serialized out as xml, its value is "tomorrow".</para>
        /// </summary>
        public static DynamicFilterValues Tomorrow => new("tomorrow");
        /// <summary>
        /// Today.
        /// <para>When the item is serialized out as xml, its value is "today".</para>
        /// </summary>
        public static DynamicFilterValues Today => new("today");
        /// <summary>
        /// Yesterday.
        /// <para>When the item is serialized out as xml, its value is "yesterday".</para>
        /// </summary>
        public static DynamicFilterValues Yesterday => new("yesterday");
        /// <summary>
        /// Next Week.
        /// <para>When the item is serialized out as xml, its value is "nextWeek".</para>
        /// </summary>
        public static DynamicFilterValues NextWeek => new("nextWeek");
        /// <summary>
        /// This Week.
        /// <para>When the item is serialized out as xml, its value is "thisWeek".</para>
        /// </summary>
        public static DynamicFilterValues ThisWeek => new("thisWeek");
        /// <summary>
        /// Last Week.
        /// <para>When the item is serialized out as xml, its value is "lastWeek".</para>
        /// </summary>
        public static DynamicFilterValues LastWeek => new("lastWeek");
        /// <summary>
        /// Next Month.
        /// <para>When the item is serialized out as xml, its value is "nextMonth".</para>
        /// </summary>
        public static DynamicFilterValues NextMonth => new("nextMonth");
        /// <summary>
        /// This Month.
        /// <para>When the item is serialized out as xml, its value is "thisMonth".</para>
        /// </summary>
        public static DynamicFilterValues ThisMonth => new("thisMonth");
        /// <summary>
        /// Last Month.
        /// <para>When the item is serialized out as xml, its value is "lastMonth".</para>
        /// </summary>
        public static DynamicFilterValues LastMonth => new("lastMonth");
        /// <summary>
        /// Next Quarter.
        /// <para>When the item is serialized out as xml, its value is "nextQuarter".</para>
        /// </summary>
        public static DynamicFilterValues NextQuarter => new("nextQuarter");
        /// <summary>
        /// This Quarter.
        /// <para>When the item is serialized out as xml, its value is "thisQuarter".</para>
        /// </summary>
        public static DynamicFilterValues ThisQuarter => new("thisQuarter");
        /// <summary>
        /// Last Quarter.
        /// <para>When the item is serialized out as xml, its value is "lastQuarter".</para>
        /// </summary>
        public static DynamicFilterValues LastQuarter => new("lastQuarter");
        /// <summary>
        /// Next Year.
        /// <para>When the item is serialized out as xml, its value is "nextYear".</para>
        /// </summary>
        public static DynamicFilterValues NextYear => new("nextYear");
        /// <summary>
        /// This Year.
        /// <para>When the item is serialized out as xml, its value is "thisYear".</para>
        /// </summary>
        public static DynamicFilterValues ThisYear => new("thisYear");
        /// <summary>
        /// Last Year.
        /// <para>When the item is serialized out as xml, its value is "lastYear".</para>
        /// </summary>
        public static DynamicFilterValues LastYear => new("lastYear");
        /// <summary>
        /// Year To Date.
        /// <para>When the item is serialized out as xml, its value is "yearToDate".</para>
        /// </summary>
        public static DynamicFilterValues YearToDate => new("yearToDate");
        /// <summary>
        /// 1st Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q1".</para>
        /// </summary>
        public static DynamicFilterValues Quarter1 => new("Q1");
        /// <summary>
        /// 2nd Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q2".</para>
        /// </summary>
        public static DynamicFilterValues Quarter2 => new("Q2");
        /// <summary>
        /// 3rd Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q3".</para>
        /// </summary>
        public static DynamicFilterValues Quarter3 => new("Q3");
        /// <summary>
        /// 4th Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q4".</para>
        /// </summary>
        public static DynamicFilterValues Quarter4 => new("Q4");
        /// <summary>
        /// 1st Month.
        /// <para>When the item is serialized out as xml, its value is "M1".</para>
        /// </summary>
        public static DynamicFilterValues January => new("M1");
        /// <summary>
        /// 2nd Month.
        /// <para>When the item is serialized out as xml, its value is "M2".</para>
        /// </summary>
        public static DynamicFilterValues February => new("M2");
        /// <summary>
        /// 3rd Month.
        /// <para>When the item is serialized out as xml, its value is "M3".</para>
        /// </summary>
        public static DynamicFilterValues March => new("M3");
        /// <summary>
        /// 4th Month.
        /// <para>When the item is serialized out as xml, its value is "M4".</para>
        /// </summary>
        public static DynamicFilterValues April => new("M4");
        /// <summary>
        /// 5th Month.
        /// <para>When the item is serialized out as xml, its value is "M5".</para>
        /// </summary>
        public static DynamicFilterValues May => new("M5");
        /// <summary>
        /// 6th Month.
        /// <para>When the item is serialized out as xml, its value is "M6".</para>
        /// </summary>
        public static DynamicFilterValues June => new("M6");
        /// <summary>
        /// 7th Month.
        /// <para>When the item is serialized out as xml, its value is "M7".</para>
        /// </summary>
        public static DynamicFilterValues July => new("M7");
        /// <summary>
        /// 8th Month.
        /// <para>When the item is serialized out as xml, its value is "M8".</para>
        /// </summary>
        public static DynamicFilterValues August => new("M8");
        /// <summary>
        /// 9th Month.
        /// <para>When the item is serialized out as xml, its value is "M9".</para>
        /// </summary>
        public static DynamicFilterValues September => new("M9");
        /// <summary>
        /// 10th Month.
        /// <para>When the item is serialized out as xml, its value is "M10".</para>
        /// </summary>
        public static DynamicFilterValues October => new("M10");
        /// <summary>
        /// 11th Month.
        /// <para>When the item is serialized out as xml, its value is "M11".</para>
        /// </summary>
        public static DynamicFilterValues November => new("M11");
        /// <summary>
        /// 12th Month.
        /// <para>When the item is serialized out as xml, its value is "M12".</para>
        /// </summary>
        public static DynamicFilterValues December => new("M12");
    
    }

    /// <summary>
    /// Icon Set Type
    /// </summary>
    public readonly record struct IconSetValues : IEnumValue, IEnumValueFactory<IconSetValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new IconSetValues enum instance
        /// </summary>
        public IconSetValues(string value) => _value = value;
        IconSetValues IEnumValueFactory<IconSetValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "3Arrows" => true,
            "3ArrowsGray" => true,
            "3Flags" => true,
            "3TrafficLights1" => true,
            "3TrafficLights2" => true,
            "3Signs" => true,
            "3Symbols" => true,
            "3Symbols2" => true,
            "4Arrows" => true,
            "4ArrowsGray" => true,
            "4RedToBlack" => true,
            "4Rating" => true,
            "4TrafficLights" => true,
            "5Arrows" => true,
            "5ArrowsGray" => true,
            "5Rating" => true,
            "5Quarters" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "3Arrows";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 3 Arrows.
        /// <para>When the item is serialized out as xml, its value is "3Arrows".</para>
        /// </summary>
        public static IconSetValues ThreeArrows => new("3Arrows");
        /// <summary>
        /// 3 Arrows  (Gray).
        /// <para>When the item is serialized out as xml, its value is "3ArrowsGray".</para>
        /// </summary>
        public static IconSetValues ThreeArrowsGray => new("3ArrowsGray");
        /// <summary>
        /// 3 Flags.
        /// <para>When the item is serialized out as xml, its value is "3Flags".</para>
        /// </summary>
        public static IconSetValues ThreeFlags => new("3Flags");
        /// <summary>
        /// 3 Traffic Lights.
        /// <para>When the item is serialized out as xml, its value is "3TrafficLights1".</para>
        /// </summary>
        public static IconSetValues ThreeTrafficLights1 => new("3TrafficLights1");
        /// <summary>
        /// 3 Traffic Lights Black.
        /// <para>When the item is serialized out as xml, its value is "3TrafficLights2".</para>
        /// </summary>
        public static IconSetValues ThreeTrafficLights2 => new("3TrafficLights2");
        /// <summary>
        /// 3 Signs.
        /// <para>When the item is serialized out as xml, its value is "3Signs".</para>
        /// </summary>
        public static IconSetValues ThreeSigns => new("3Signs");
        /// <summary>
        /// 3 Symbols Circled.
        /// <para>When the item is serialized out as xml, its value is "3Symbols".</para>
        /// </summary>
        public static IconSetValues ThreeSymbols => new("3Symbols");
        /// <summary>
        /// 3 Symbols.
        /// <para>When the item is serialized out as xml, its value is "3Symbols2".</para>
        /// </summary>
        public static IconSetValues ThreeSymbols2 => new("3Symbols2");
        /// <summary>
        /// 4 Arrows.
        /// <para>When the item is serialized out as xml, its value is "4Arrows".</para>
        /// </summary>
        public static IconSetValues FourArrows => new("4Arrows");
        /// <summary>
        /// 4 Arrows (Gray).
        /// <para>When the item is serialized out as xml, its value is "4ArrowsGray".</para>
        /// </summary>
        public static IconSetValues FourArrowsGray => new("4ArrowsGray");
        /// <summary>
        /// 4 Red To Black.
        /// <para>When the item is serialized out as xml, its value is "4RedToBlack".</para>
        /// </summary>
        public static IconSetValues FourRedToBlack => new("4RedToBlack");
        /// <summary>
        /// 4 Ratings.
        /// <para>When the item is serialized out as xml, its value is "4Rating".</para>
        /// </summary>
        public static IconSetValues FourRating => new("4Rating");
        /// <summary>
        /// 4 Traffic Lights.
        /// <para>When the item is serialized out as xml, its value is "4TrafficLights".</para>
        /// </summary>
        public static IconSetValues FourTrafficLights => new("4TrafficLights");
        /// <summary>
        /// 5 Arrows.
        /// <para>When the item is serialized out as xml, its value is "5Arrows".</para>
        /// </summary>
        public static IconSetValues FiveArrows => new("5Arrows");
        /// <summary>
        /// 5 Arrows (Gray).
        /// <para>When the item is serialized out as xml, its value is "5ArrowsGray".</para>
        /// </summary>
        public static IconSetValues FiveArrowsGray => new("5ArrowsGray");
        /// <summary>
        /// 5 Ratings Icon Set.
        /// <para>When the item is serialized out as xml, its value is "5Rating".</para>
        /// </summary>
        public static IconSetValues FiveRating => new("5Rating");
        /// <summary>
        /// 5 Quarters.
        /// <para>When the item is serialized out as xml, its value is "5Quarters".</para>
        /// </summary>
        public static IconSetValues FiveQuarters => new("5Quarters");
    
    }

    /// <summary>
    /// Sort By
    /// </summary>
    public readonly record struct SortByValues : IEnumValue, IEnumValueFactory<SortByValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SortByValues enum instance
        /// </summary>
        public SortByValues(string value) => _value = value;
        SortByValues IEnumValueFactory<SortByValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "value" => true,
            "cellColor" => true,
            "fontColor" => true,
            "icon" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "value";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Value.
        /// <para>When the item is serialized out as xml, its value is "value".</para>
        /// </summary>
        public static SortByValues Value => new("value");
        /// <summary>
        /// Sort by Cell Color.
        /// <para>When the item is serialized out as xml, its value is "cellColor".</para>
        /// </summary>
        public static SortByValues CellColor => new("cellColor");
        /// <summary>
        /// Sort by Font Color.
        /// <para>When the item is serialized out as xml, its value is "fontColor".</para>
        /// </summary>
        public static SortByValues FontColor => new("fontColor");
        /// <summary>
        /// Sort by Icon.
        /// <para>When the item is serialized out as xml, its value is "icon".</para>
        /// </summary>
        public static SortByValues Icon => new("icon");
    
    }

    /// <summary>
    /// Sort Method
    /// </summary>
    public readonly record struct SortMethodValues : IEnumValue, IEnumValueFactory<SortMethodValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SortMethodValues enum instance
        /// </summary>
        public SortMethodValues(string value) => _value = value;
        SortMethodValues IEnumValueFactory<SortMethodValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "stroke" => true,
            "pinYin" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "stroke";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Sort by Stroke.
        /// <para>When the item is serialized out as xml, its value is "stroke".</para>
        /// </summary>
        public static SortMethodValues Stroke => new("stroke");
        /// <summary>
        /// PinYin Sort.
        /// <para>When the item is serialized out as xml, its value is "pinYin".</para>
        /// </summary>
        public static SortMethodValues PinYin => new("pinYin");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static SortMethodValues None => new("none");
    
    }

    /// <summary>
    /// Calendar Type
    /// </summary>
    public readonly record struct CalendarValues : IEnumValue, IEnumValueFactory<CalendarValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CalendarValues enum instance
        /// </summary>
        public CalendarValues(string value) => _value = value;
        CalendarValues IEnumValueFactory<CalendarValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "gregorian" => true,
            "gregorianUs" => true,
            "japan" => true,
            "taiwan" => true,
            "korea" => true,
            "hijri" => true,
            "thai" => true,
            "hebrew" => true,
            "gregorianMeFrench" => true,
            "gregorianArabic" => true,
            "gregorianXlitEnglish" => true,
            "gregorianXlitFrench" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// No Calendar Type.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static CalendarValues None => new("none");
        /// <summary>
        /// Gregorian.
        /// <para>When the item is serialized out as xml, its value is "gregorian".</para>
        /// </summary>
        public static CalendarValues Gregorian => new("gregorian");
        /// <summary>
        /// Gregorian (U.S.) Calendar.
        /// <para>When the item is serialized out as xml, its value is "gregorianUs".</para>
        /// </summary>
        public static CalendarValues GregorianUs => new("gregorianUs");
        /// <summary>
        /// Japanese Emperor Era Calendar.
        /// <para>When the item is serialized out as xml, its value is "japan".</para>
        /// </summary>
        public static CalendarValues Japan => new("japan");
        /// <summary>
        /// Taiwan Era Calendar.
        /// <para>When the item is serialized out as xml, its value is "taiwan".</para>
        /// </summary>
        public static CalendarValues Taiwan => new("taiwan");
        /// <summary>
        /// Korean Tangun Era Calendar.
        /// <para>When the item is serialized out as xml, its value is "korea".</para>
        /// </summary>
        public static CalendarValues Korea => new("korea");
        /// <summary>
        /// Hijri (Arabic Lunar) Calendar.
        /// <para>When the item is serialized out as xml, its value is "hijri".</para>
        /// </summary>
        public static CalendarValues Hijri => new("hijri");
        /// <summary>
        /// Thai Calendar.
        /// <para>When the item is serialized out as xml, its value is "thai".</para>
        /// </summary>
        public static CalendarValues Thai => new("thai");
        /// <summary>
        /// Hebrew (Lunar) Calendar.
        /// <para>When the item is serialized out as xml, its value is "hebrew".</para>
        /// </summary>
        public static CalendarValues Hebrew => new("hebrew");
        /// <summary>
        /// Gregorian Middle East French Calendar.
        /// <para>When the item is serialized out as xml, its value is "gregorianMeFrench".</para>
        /// </summary>
        public static CalendarValues GregorianMiddleEastFrench => new("gregorianMeFrench");
        /// <summary>
        /// Gregorian Arabic Calendar.
        /// <para>When the item is serialized out as xml, its value is "gregorianArabic".</para>
        /// </summary>
        public static CalendarValues GregorianArabic => new("gregorianArabic");
        /// <summary>
        /// Gregorian Transliterated English Calendar.
        /// <para>When the item is serialized out as xml, its value is "gregorianXlitEnglish".</para>
        /// </summary>
        public static CalendarValues GregorianTransliteratedEnglish => new("gregorianXlitEnglish");
        /// <summary>
        /// Gregorian Transliterated French Calendar.
        /// <para>When the item is serialized out as xml, its value is "gregorianXlitFrench".</para>
        /// </summary>
        public static CalendarValues GregorianTransliteratedFrench => new("gregorianXlitFrench");
    
    }

    /// <summary>
    /// Date Time Grouping
    /// </summary>
    public readonly record struct DateTimeGroupingValues : IEnumValue, IEnumValueFactory<DateTimeGroupingValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DateTimeGroupingValues enum instance
        /// </summary>
        public DateTimeGroupingValues(string value) => _value = value;
        DateTimeGroupingValues IEnumValueFactory<DateTimeGroupingValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "year" => true,
            "month" => true,
            "day" => true,
            "hour" => true,
            "minute" => true,
            "second" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "year";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Group by Year.
        /// <para>When the item is serialized out as xml, its value is "year".</para>
        /// </summary>
        public static DateTimeGroupingValues Year => new("year");
        /// <summary>
        /// Month.
        /// <para>When the item is serialized out as xml, its value is "month".</para>
        /// </summary>
        public static DateTimeGroupingValues Month => new("month");
        /// <summary>
        /// Day.
        /// <para>When the item is serialized out as xml, its value is "day".</para>
        /// </summary>
        public static DateTimeGroupingValues Day => new("day");
        /// <summary>
        /// Group by Hour.
        /// <para>When the item is serialized out as xml, its value is "hour".</para>
        /// </summary>
        public static DateTimeGroupingValues Hour => new("hour");
        /// <summary>
        /// Group by Minute.
        /// <para>When the item is serialized out as xml, its value is "minute".</para>
        /// </summary>
        public static DateTimeGroupingValues Minute => new("minute");
        /// <summary>
        /// Second.
        /// <para>When the item is serialized out as xml, its value is "second".</para>
        /// </summary>
        public static DateTimeGroupingValues Second => new("second");
    
    }

    /// <summary>
    /// HTML Formatting Handling
    /// </summary>
    public readonly record struct HtmlFormattingValues : IEnumValue, IEnumValueFactory<HtmlFormattingValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HtmlFormattingValues enum instance
        /// </summary>
        public HtmlFormattingValues(string value) => _value = value;
        HtmlFormattingValues IEnumValueFactory<HtmlFormattingValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "rtf" => true,
            "all" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// No Formatting.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static HtmlFormattingValues None => new("none");
        /// <summary>
        /// Honor Rich Text.
        /// <para>When the item is serialized out as xml, its value is "rtf".</para>
        /// </summary>
        public static HtmlFormattingValues HonorRichText => new("rtf");
        /// <summary>
        /// All.
        /// <para>When the item is serialized out as xml, its value is "all".</para>
        /// </summary>
        public static HtmlFormattingValues All => new("all");
    
    }

    /// <summary>
    /// Parameter Type
    /// </summary>
    public readonly record struct ParameterValues : IEnumValue, IEnumValueFactory<ParameterValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ParameterValues enum instance
        /// </summary>
        public ParameterValues(string value) => _value = value;
        ParameterValues IEnumValueFactory<ParameterValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "prompt" => true,
            "value" => true,
            "cell" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "prompt";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Prompt on Refresh.
        /// <para>When the item is serialized out as xml, its value is "prompt".</para>
        /// </summary>
        public static ParameterValues Prompt => new("prompt");
        /// <summary>
        /// Value.
        /// <para>When the item is serialized out as xml, its value is "value".</para>
        /// </summary>
        public static ParameterValues Value => new("value");
        /// <summary>
        /// Parameter From Cell.
        /// <para>When the item is serialized out as xml, its value is "cell".</para>
        /// </summary>
        public static ParameterValues Cell => new("cell");
    
    }

    /// <summary>
    /// File Type
    /// </summary>
    public readonly record struct FileTypeValues : IEnumValue, IEnumValueFactory<FileTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FileTypeValues enum instance
        /// </summary>
        public FileTypeValues(string value) => _value = value;
        FileTypeValues IEnumValueFactory<FileTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "mac" => true,
            "win" => true,
            "dos" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "mac";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Macintosh.
        /// <para>When the item is serialized out as xml, its value is "mac".</para>
        /// </summary>
        public static FileTypeValues Mac => new("mac");
        /// <summary>
        /// Windows (ANSI).
        /// <para>When the item is serialized out as xml, its value is "win".</para>
        /// </summary>
        public static FileTypeValues Win => new("win");
        /// <summary>
        /// DOS.
        /// <para>When the item is serialized out as xml, its value is "dos".</para>
        /// </summary>
        public static FileTypeValues Dos => new("dos");
    
    }

    /// <summary>
    /// Qualifier
    /// </summary>
    public readonly record struct QualifierValues : IEnumValue, IEnumValueFactory<QualifierValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new QualifierValues enum instance
        /// </summary>
        public QualifierValues(string value) => _value = value;
        QualifierValues IEnumValueFactory<QualifierValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "doubleQuote" => true,
            "singleQuote" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "doubleQuote";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Double Quote.
        /// <para>When the item is serialized out as xml, its value is "doubleQuote".</para>
        /// </summary>
        public static QualifierValues DoubleQuote => new("doubleQuote");
        /// <summary>
        /// Single Quote.
        /// <para>When the item is serialized out as xml, its value is "singleQuote".</para>
        /// </summary>
        public static QualifierValues SingleQuote => new("singleQuote");
        /// <summary>
        /// No Text Qualifier.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static QualifierValues None => new("none");
    
    }

    /// <summary>
    /// Text Field Data Type
    /// </summary>
    public readonly record struct ExternalConnectionValues : IEnumValue, IEnumValueFactory<ExternalConnectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ExternalConnectionValues enum instance
        /// </summary>
        public ExternalConnectionValues(string value) => _value = value;
        ExternalConnectionValues IEnumValueFactory<ExternalConnectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "general" => true,
            "text" => true,
            "MDY" => true,
            "DMY" => true,
            "YMD" => true,
            "MYD" => true,
            "DYM" => true,
            "YDM" => true,
            "skip" => true,
            "EMD" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "general";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// General.
        /// <para>When the item is serialized out as xml, its value is "general".</para>
        /// </summary>
        public static ExternalConnectionValues General => new("general");
        /// <summary>
        /// Text.
        /// <para>When the item is serialized out as xml, its value is "text".</para>
        /// </summary>
        public static ExternalConnectionValues Text => new("text");
        /// <summary>
        /// Month Day Year.
        /// <para>When the item is serialized out as xml, its value is "MDY".</para>
        /// </summary>
        public static ExternalConnectionValues MonthDayYear => new("MDY");
        /// <summary>
        /// Day Month Year.
        /// <para>When the item is serialized out as xml, its value is "DMY".</para>
        /// </summary>
        public static ExternalConnectionValues DayMonthYear => new("DMY");
        /// <summary>
        /// Year Month Day.
        /// <para>When the item is serialized out as xml, its value is "YMD".</para>
        /// </summary>
        public static ExternalConnectionValues YearMonthDay => new("YMD");
        /// <summary>
        /// Month Day Year.
        /// <para>When the item is serialized out as xml, its value is "MYD".</para>
        /// </summary>
        public static ExternalConnectionValues MonthYearDay => new("MYD");
        /// <summary>
        /// Day Year Month.
        /// <para>When the item is serialized out as xml, its value is "DYM".</para>
        /// </summary>
        public static ExternalConnectionValues DayYearMonth => new("DYM");
        /// <summary>
        /// Year Day Month.
        /// <para>When the item is serialized out as xml, its value is "YDM".</para>
        /// </summary>
        public static ExternalConnectionValues YearDayMonth => new("YDM");
        /// <summary>
        /// Skip Field.
        /// <para>When the item is serialized out as xml, its value is "skip".</para>
        /// </summary>
        public static ExternalConnectionValues Skip => new("skip");
        /// <summary>
        /// East Asian Year Month Day.
        /// <para>When the item is serialized out as xml, its value is "EMD".</para>
        /// </summary>
        public static ExternalConnectionValues EMD => new("EMD");
    
    }

    /// <summary>
    /// Credentials Method
    /// </summary>
    public readonly record struct CredentialsMethodValues : IEnumValue, IEnumValueFactory<CredentialsMethodValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CredentialsMethodValues enum instance
        /// </summary>
        public CredentialsMethodValues(string value) => _value = value;
        CredentialsMethodValues IEnumValueFactory<CredentialsMethodValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "integrated" => true,
            "none" => true,
            "stored" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "integrated";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Integrated Authentication.
        /// <para>When the item is serialized out as xml, its value is "integrated".</para>
        /// </summary>
        public static CredentialsMethodValues Integrated => new("integrated");
        /// <summary>
        /// No Credentials.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static CredentialsMethodValues None => new("none");
        /// <summary>
        /// Stored Credentials.
        /// <para>When the item is serialized out as xml, its value is "stored".</para>
        /// </summary>
        public static CredentialsMethodValues Stored => new("stored");
    
    }

    /// <summary>
    /// PivotCache Type
    /// </summary>
    public readonly record struct SourceValues : IEnumValue, IEnumValueFactory<SourceValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SourceValues enum instance
        /// </summary>
        public SourceValues(string value) => _value = value;
        SourceValues IEnumValueFactory<SourceValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "worksheet" => true,
            "external" => true,
            "consolidation" => true,
            "scenario" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "worksheet";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Worksheet.
        /// <para>When the item is serialized out as xml, its value is "worksheet".</para>
        /// </summary>
        public static SourceValues Worksheet => new("worksheet");
        /// <summary>
        /// External.
        /// <para>When the item is serialized out as xml, its value is "external".</para>
        /// </summary>
        public static SourceValues External => new("external");
        /// <summary>
        /// Consolidation Ranges.
        /// <para>When the item is serialized out as xml, its value is "consolidation".</para>
        /// </summary>
        public static SourceValues Consolidation => new("consolidation");
        /// <summary>
        /// Scenario Summary Report.
        /// <para>When the item is serialized out as xml, its value is "scenario".</para>
        /// </summary>
        public static SourceValues Scenario => new("scenario");
    
    }

    /// <summary>
    /// Values Group By
    /// </summary>
    public readonly record struct GroupByValues : IEnumValue, IEnumValueFactory<GroupByValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GroupByValues enum instance
        /// </summary>
        public GroupByValues(string value) => _value = value;
        GroupByValues IEnumValueFactory<GroupByValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "range" => true,
            "seconds" => true,
            "minutes" => true,
            "hours" => true,
            "days" => true,
            "months" => true,
            "quarters" => true,
            "years" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "range";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Group By Numeric Ranges.
        /// <para>When the item is serialized out as xml, its value is "range".</para>
        /// </summary>
        public static GroupByValues Range => new("range");
        /// <summary>
        /// Seconds.
        /// <para>When the item is serialized out as xml, its value is "seconds".</para>
        /// </summary>
        public static GroupByValues Seconds => new("seconds");
        /// <summary>
        /// Minutes.
        /// <para>When the item is serialized out as xml, its value is "minutes".</para>
        /// </summary>
        public static GroupByValues Minutes => new("minutes");
        /// <summary>
        /// Hours.
        /// <para>When the item is serialized out as xml, its value is "hours".</para>
        /// </summary>
        public static GroupByValues Hours => new("hours");
        /// <summary>
        /// Days.
        /// <para>When the item is serialized out as xml, its value is "days".</para>
        /// </summary>
        public static GroupByValues Days => new("days");
        /// <summary>
        /// Months.
        /// <para>When the item is serialized out as xml, its value is "months".</para>
        /// </summary>
        public static GroupByValues Months => new("months");
        /// <summary>
        /// Quarters.
        /// <para>When the item is serialized out as xml, its value is "quarters".</para>
        /// </summary>
        public static GroupByValues Quarters => new("quarters");
        /// <summary>
        /// Years.
        /// <para>When the item is serialized out as xml, its value is "years".</para>
        /// </summary>
        public static GroupByValues Years => new("years");
    
    }

    /// <summary>
    /// Set Sort Order
    /// </summary>
    public readonly record struct SortValues : IEnumValue, IEnumValueFactory<SortValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SortValues enum instance
        /// </summary>
        public SortValues(string value) => _value = value;
        SortValues IEnumValueFactory<SortValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "ascending" => true,
            "descending" => true,
            "ascendingAlpha" => true,
            "descendingAlpha" => true,
            "ascendingNatural" => true,
            "descendingNatural" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static SortValues None => new("none");
        /// <summary>
        /// Ascending.
        /// <para>When the item is serialized out as xml, its value is "ascending".</para>
        /// </summary>
        public static SortValues Ascending => new("ascending");
        /// <summary>
        /// Descending.
        /// <para>When the item is serialized out as xml, its value is "descending".</para>
        /// </summary>
        public static SortValues Descending => new("descending");
        /// <summary>
        /// Ascending Alpha.
        /// <para>When the item is serialized out as xml, its value is "ascendingAlpha".</para>
        /// </summary>
        public static SortValues AscendingAlpha => new("ascendingAlpha");
        /// <summary>
        /// Alphabetic Order Descending.
        /// <para>When the item is serialized out as xml, its value is "descendingAlpha".</para>
        /// </summary>
        public static SortValues DescendingAlpha => new("descendingAlpha");
        /// <summary>
        /// Ascending Natural.
        /// <para>When the item is serialized out as xml, its value is "ascendingNatural".</para>
        /// </summary>
        public static SortValues AscendingNatural => new("ascendingNatural");
        /// <summary>
        /// Natural Order Descending.
        /// <para>When the item is serialized out as xml, its value is "descendingNatural".</para>
        /// </summary>
        public static SortValues DescendingNatural => new("descendingNatural");
    
    }

    /// <summary>
    /// Conditional Formatting Scope
    /// </summary>
    public readonly record struct ScopeValues : IEnumValue, IEnumValueFactory<ScopeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ScopeValues enum instance
        /// </summary>
        public ScopeValues(string value) => _value = value;
        ScopeValues IEnumValueFactory<ScopeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "selection" => true,
            "data" => true,
            "field" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "selection";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Selection.
        /// <para>When the item is serialized out as xml, its value is "selection".</para>
        /// </summary>
        public static ScopeValues Selection => new("selection");
        /// <summary>
        /// Data Fields.
        /// <para>When the item is serialized out as xml, its value is "data".</para>
        /// </summary>
        public static ScopeValues Data => new("data");
        /// <summary>
        /// Field Intersections.
        /// <para>When the item is serialized out as xml, its value is "field".</para>
        /// </summary>
        public static ScopeValues Field => new("field");
    
    }

    /// <summary>
    /// Top N Evaluation Type
    /// </summary>
    public readonly record struct RuleValues : IEnumValue, IEnumValueFactory<RuleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RuleValues enum instance
        /// </summary>
        public RuleValues(string value) => _value = value;
        RuleValues IEnumValueFactory<RuleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "all" => true,
            "row" => true,
            "column" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top N None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static RuleValues None => new("none");
        /// <summary>
        /// All.
        /// <para>When the item is serialized out as xml, its value is "all".</para>
        /// </summary>
        public static RuleValues All => new("all");
        /// <summary>
        /// Row Top N.
        /// <para>When the item is serialized out as xml, its value is "row".</para>
        /// </summary>
        public static RuleValues Row => new("row");
        /// <summary>
        /// Column Top N.
        /// <para>When the item is serialized out as xml, its value is "column".</para>
        /// </summary>
        public static RuleValues Column => new("column");
    
    }

    /// <summary>
    /// Show Data As
    /// </summary>
    public readonly record struct ShowDataAsValues : IEnumValue, IEnumValueFactory<ShowDataAsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ShowDataAsValues enum instance
        /// </summary>
        public ShowDataAsValues(string value) => _value = value;
        ShowDataAsValues IEnumValueFactory<ShowDataAsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "normal" => true,
            "difference" => true,
            "percent" => true,
            "percentDiff" => true,
            "runTotal" => true,
            "percentOfRow" => true,
            "percentOfCol" => true,
            "percentOfTotal" => true,
            "index" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "normal";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Normal Data Type.
        /// <para>When the item is serialized out as xml, its value is "normal".</para>
        /// </summary>
        public static ShowDataAsValues Normal => new("normal");
        /// <summary>
        /// Difference.
        /// <para>When the item is serialized out as xml, its value is "difference".</para>
        /// </summary>
        public static ShowDataAsValues Difference => new("difference");
        /// <summary>
        /// Percentage Of.
        /// <para>When the item is serialized out as xml, its value is "percent".</para>
        /// </summary>
        public static ShowDataAsValues Percent => new("percent");
        /// <summary>
        /// Percentage Difference.
        /// <para>When the item is serialized out as xml, its value is "percentDiff".</para>
        /// </summary>
        public static ShowDataAsValues PercentageDifference => new("percentDiff");
        /// <summary>
        /// Running Total.
        /// <para>When the item is serialized out as xml, its value is "runTotal".</para>
        /// </summary>
        public static ShowDataAsValues RunTotal => new("runTotal");
        /// <summary>
        /// Percentage of Row.
        /// <para>When the item is serialized out as xml, its value is "percentOfRow".</para>
        /// </summary>
        public static ShowDataAsValues PercentOfRaw => new("percentOfRow");
        /// <summary>
        /// Percent of Column.
        /// <para>When the item is serialized out as xml, its value is "percentOfCol".</para>
        /// </summary>
        public static ShowDataAsValues PercentOfColumn => new("percentOfCol");
        /// <summary>
        /// Percentage of Total.
        /// <para>When the item is serialized out as xml, its value is "percentOfTotal".</para>
        /// </summary>
        public static ShowDataAsValues PercentOfTotal => new("percentOfTotal");
        /// <summary>
        /// Index.
        /// <para>When the item is serialized out as xml, its value is "index".</para>
        /// </summary>
        public static ShowDataAsValues Index => new("index");
    
    }

    /// <summary>
    /// PivotItem Type
    /// </summary>
    public readonly record struct ItemValues : IEnumValue, IEnumValueFactory<ItemValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ItemValues enum instance
        /// </summary>
        public ItemValues(string value) => _value = value;
        ItemValues IEnumValueFactory<ItemValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "data" => true,
            "default" => true,
            "sum" => true,
            "countA" => true,
            "avg" => true,
            "max" => true,
            "min" => true,
            "product" => true,
            "count" => true,
            "stdDev" => true,
            "stdDevP" => true,
            "var" => true,
            "varP" => true,
            "grand" => true,
            "blank" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "data";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Data.
        /// <para>When the item is serialized out as xml, its value is "data".</para>
        /// </summary>
        public static ItemValues Data => new("data");
        /// <summary>
        /// Default.
        /// <para>When the item is serialized out as xml, its value is "default".</para>
        /// </summary>
        public static ItemValues Default => new("default");
        /// <summary>
        /// Sum.
        /// <para>When the item is serialized out as xml, its value is "sum".</para>
        /// </summary>
        public static ItemValues Sum => new("sum");
        /// <summary>
        /// CountA.
        /// <para>When the item is serialized out as xml, its value is "countA".</para>
        /// </summary>
        public static ItemValues CountA => new("countA");
        /// <summary>
        /// Average.
        /// <para>When the item is serialized out as xml, its value is "avg".</para>
        /// </summary>
        public static ItemValues Average => new("avg");
        /// <summary>
        /// Max.
        /// <para>When the item is serialized out as xml, its value is "max".</para>
        /// </summary>
        public static ItemValues Maximum => new("max");
        /// <summary>
        /// Min.
        /// <para>When the item is serialized out as xml, its value is "min".</para>
        /// </summary>
        public static ItemValues Minimum => new("min");
        /// <summary>
        /// Product.
        /// <para>When the item is serialized out as xml, its value is "product".</para>
        /// </summary>
        public static ItemValues Product => new("product");
        /// <summary>
        /// Count.
        /// <para>When the item is serialized out as xml, its value is "count".</para>
        /// </summary>
        public static ItemValues Count => new("count");
        /// <summary>
        /// stdDev.
        /// <para>When the item is serialized out as xml, its value is "stdDev".</para>
        /// </summary>
        public static ItemValues StandardDeviation => new("stdDev");
        /// <summary>
        /// StdDevP.
        /// <para>When the item is serialized out as xml, its value is "stdDevP".</para>
        /// </summary>
        public static ItemValues StandardDeviationP => new("stdDevP");
        /// <summary>
        /// Var.
        /// <para>When the item is serialized out as xml, its value is "var".</para>
        /// </summary>
        public static ItemValues Variance => new("var");
        /// <summary>
        /// VarP.
        /// <para>When the item is serialized out as xml, its value is "varP".</para>
        /// </summary>
        public static ItemValues VarianceP => new("varP");
        /// <summary>
        /// Grand Total Item.
        /// <para>When the item is serialized out as xml, its value is "grand".</para>
        /// </summary>
        public static ItemValues Grand => new("grand");
        /// <summary>
        /// Blank Pivot Item.
        /// <para>When the item is serialized out as xml, its value is "blank".</para>
        /// </summary>
        public static ItemValues Blank => new("blank");
    
    }

    /// <summary>
    /// Field Sort Type
    /// </summary>
    public readonly record struct FieldSortValues : IEnumValue, IEnumValueFactory<FieldSortValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FieldSortValues enum instance
        /// </summary>
        public FieldSortValues(string value) => _value = value;
        FieldSortValues IEnumValueFactory<FieldSortValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "manual" => true,
            "ascending" => true,
            "descending" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "manual";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Manual Sort.
        /// <para>When the item is serialized out as xml, its value is "manual".</para>
        /// </summary>
        public static FieldSortValues Manual => new("manual");
        /// <summary>
        /// Ascending.
        /// <para>When the item is serialized out as xml, its value is "ascending".</para>
        /// </summary>
        public static FieldSortValues Ascending => new("ascending");
        /// <summary>
        /// Descending.
        /// <para>When the item is serialized out as xml, its value is "descending".</para>
        /// </summary>
        public static FieldSortValues Descending => new("descending");
    
    }

    /// <summary>
    /// Pivot Filter Types
    /// </summary>
    public readonly record struct PivotFilterValues : IEnumValue, IEnumValueFactory<PivotFilterValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PivotFilterValues enum instance
        /// </summary>
        public PivotFilterValues(string value) => _value = value;
        PivotFilterValues IEnumValueFactory<PivotFilterValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "unknown" => true,
            "count" => true,
            "percent" => true,
            "sum" => true,
            "captionEqual" => true,
            "captionNotEqual" => true,
            "captionBeginsWith" => true,
            "captionNotBeginsWith" => true,
            "captionEndsWith" => true,
            "captionNotEndsWith" => true,
            "captionContains" => true,
            "captionNotContains" => true,
            "captionGreaterThan" => true,
            "captionGreaterThanOrEqual" => true,
            "captionLessThan" => true,
            "captionLessThanOrEqual" => true,
            "captionBetween" => true,
            "captionNotBetween" => true,
            "valueEqual" => true,
            "valueNotEqual" => true,
            "valueGreaterThan" => true,
            "valueGreaterThanOrEqual" => true,
            "valueLessThan" => true,
            "valueLessThanOrEqual" => true,
            "valueBetween" => true,
            "valueNotBetween" => true,
            "dateEqual" => true,
            "dateNotEqual" => true,
            "dateOlderThan" => true,
            "dateOlderThanOrEqual" => true,
            "dateNewerThan" => true,
            "dateNewerThanOrEqual" => true,
            "dateBetween" => true,
            "dateNotBetween" => true,
            "tomorrow" => true,
            "today" => true,
            "yesterday" => true,
            "nextWeek" => true,
            "thisWeek" => true,
            "lastWeek" => true,
            "nextMonth" => true,
            "thisMonth" => true,
            "lastMonth" => true,
            "nextQuarter" => true,
            "thisQuarter" => true,
            "lastQuarter" => true,
            "nextYear" => true,
            "thisYear" => true,
            "lastYear" => true,
            "yearToDate" => true,
            "Q1" => true,
            "Q2" => true,
            "Q3" => true,
            "Q4" => true,
            "M1" => true,
            "M2" => true,
            "M3" => true,
            "M4" => true,
            "M5" => true,
            "M6" => true,
            "M7" => true,
            "M8" => true,
            "M9" => true,
            "M10" => true,
            "M11" => true,
            "M12" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "unknown";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Unknown.
        /// <para>When the item is serialized out as xml, its value is "unknown".</para>
        /// </summary>
        public static PivotFilterValues Unknown => new("unknown");
        /// <summary>
        /// Count.
        /// <para>When the item is serialized out as xml, its value is "count".</para>
        /// </summary>
        public static PivotFilterValues Count => new("count");
        /// <summary>
        /// Percent.
        /// <para>When the item is serialized out as xml, its value is "percent".</para>
        /// </summary>
        public static PivotFilterValues Percent => new("percent");
        /// <summary>
        /// Sum.
        /// <para>When the item is serialized out as xml, its value is "sum".</para>
        /// </summary>
        public static PivotFilterValues Sum => new("sum");
        /// <summary>
        /// Caption Equals.
        /// <para>When the item is serialized out as xml, its value is "captionEqual".</para>
        /// </summary>
        public static PivotFilterValues CaptionEqual => new("captionEqual");
        /// <summary>
        /// Caption Not Equal.
        /// <para>When the item is serialized out as xml, its value is "captionNotEqual".</para>
        /// </summary>
        public static PivotFilterValues CaptionNotEqual => new("captionNotEqual");
        /// <summary>
        /// Caption Begins With.
        /// <para>When the item is serialized out as xml, its value is "captionBeginsWith".</para>
        /// </summary>
        public static PivotFilterValues CaptionBeginsWith => new("captionBeginsWith");
        /// <summary>
        /// Caption Does Not Begin With.
        /// <para>When the item is serialized out as xml, its value is "captionNotBeginsWith".</para>
        /// </summary>
        public static PivotFilterValues CaptionNotBeginsWith => new("captionNotBeginsWith");
        /// <summary>
        /// Caption Ends With.
        /// <para>When the item is serialized out as xml, its value is "captionEndsWith".</para>
        /// </summary>
        public static PivotFilterValues CaptionEndsWith => new("captionEndsWith");
        /// <summary>
        /// Caption Does Not End With.
        /// <para>When the item is serialized out as xml, its value is "captionNotEndsWith".</para>
        /// </summary>
        public static PivotFilterValues CaptionNotEndsWith => new("captionNotEndsWith");
        /// <summary>
        /// Caption Contains.
        /// <para>When the item is serialized out as xml, its value is "captionContains".</para>
        /// </summary>
        public static PivotFilterValues CaptionContains => new("captionContains");
        /// <summary>
        /// Caption Does Not Contain.
        /// <para>When the item is serialized out as xml, its value is "captionNotContains".</para>
        /// </summary>
        public static PivotFilterValues CaptionNotContains => new("captionNotContains");
        /// <summary>
        /// Caption Is Greater Than.
        /// <para>When the item is serialized out as xml, its value is "captionGreaterThan".</para>
        /// </summary>
        public static PivotFilterValues CaptionGreaterThan => new("captionGreaterThan");
        /// <summary>
        /// Caption Is Greater Than Or Equal To.
        /// <para>When the item is serialized out as xml, its value is "captionGreaterThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues CaptionGreaterThanOrEqual => new("captionGreaterThanOrEqual");
        /// <summary>
        /// Caption Is Less Than.
        /// <para>When the item is serialized out as xml, its value is "captionLessThan".</para>
        /// </summary>
        public static PivotFilterValues CaptionLessThan => new("captionLessThan");
        /// <summary>
        /// Caption Is Less Than Or Equal To.
        /// <para>When the item is serialized out as xml, its value is "captionLessThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues CaptionLessThanOrEqual => new("captionLessThanOrEqual");
        /// <summary>
        /// Caption Is Between.
        /// <para>When the item is serialized out as xml, its value is "captionBetween".</para>
        /// </summary>
        public static PivotFilterValues CaptionBetween => new("captionBetween");
        /// <summary>
        /// Caption Is Not Between.
        /// <para>When the item is serialized out as xml, its value is "captionNotBetween".</para>
        /// </summary>
        public static PivotFilterValues CaptionNotBetween => new("captionNotBetween");
        /// <summary>
        /// Value Equal.
        /// <para>When the item is serialized out as xml, its value is "valueEqual".</para>
        /// </summary>
        public static PivotFilterValues ValueEqual => new("valueEqual");
        /// <summary>
        /// Value Not Equal.
        /// <para>When the item is serialized out as xml, its value is "valueNotEqual".</para>
        /// </summary>
        public static PivotFilterValues ValueNotEqual => new("valueNotEqual");
        /// <summary>
        /// Value Greater Than.
        /// <para>When the item is serialized out as xml, its value is "valueGreaterThan".</para>
        /// </summary>
        public static PivotFilterValues ValueGreaterThan => new("valueGreaterThan");
        /// <summary>
        /// Value Greater Than Or Equal To.
        /// <para>When the item is serialized out as xml, its value is "valueGreaterThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues ValueGreaterThanOrEqual => new("valueGreaterThanOrEqual");
        /// <summary>
        /// Value Less Than.
        /// <para>When the item is serialized out as xml, its value is "valueLessThan".</para>
        /// </summary>
        public static PivotFilterValues ValueLessThan => new("valueLessThan");
        /// <summary>
        /// Value Less Than Or Equal To.
        /// <para>When the item is serialized out as xml, its value is "valueLessThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues ValueLessThanOrEqual => new("valueLessThanOrEqual");
        /// <summary>
        /// Value Between.
        /// <para>When the item is serialized out as xml, its value is "valueBetween".</para>
        /// </summary>
        public static PivotFilterValues ValueBetween => new("valueBetween");
        /// <summary>
        /// Value Not Between.
        /// <para>When the item is serialized out as xml, its value is "valueNotBetween".</para>
        /// </summary>
        public static PivotFilterValues ValueNotBetween => new("valueNotBetween");
        /// <summary>
        /// Date Equals.
        /// <para>When the item is serialized out as xml, its value is "dateEqual".</para>
        /// </summary>
        public static PivotFilterValues DateEqual => new("dateEqual");
        /// <summary>
        /// Date Does Not Equal.
        /// <para>When the item is serialized out as xml, its value is "dateNotEqual".</para>
        /// </summary>
        public static PivotFilterValues DateNotEqual => new("dateNotEqual");
        /// <summary>
        /// Date Older Than.
        /// <para>When the item is serialized out as xml, its value is "dateOlderThan".</para>
        /// </summary>
        public static PivotFilterValues DateOlderThan => new("dateOlderThan");
        /// <summary>
        /// Date Older Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "dateOlderThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues DateOlderThanOrEqual => new("dateOlderThanOrEqual");
        /// <summary>
        /// Date Newer Than.
        /// <para>When the item is serialized out as xml, its value is "dateNewerThan".</para>
        /// </summary>
        public static PivotFilterValues DateNewerThan => new("dateNewerThan");
        /// <summary>
        /// Date Newer Than or Equal To.
        /// <para>When the item is serialized out as xml, its value is "dateNewerThanOrEqual".</para>
        /// </summary>
        public static PivotFilterValues DateNewerThanOrEqual => new("dateNewerThanOrEqual");
        /// <summary>
        /// Date Between.
        /// <para>When the item is serialized out as xml, its value is "dateBetween".</para>
        /// </summary>
        public static PivotFilterValues DateBetween => new("dateBetween");
        /// <summary>
        /// Date Not Between.
        /// <para>When the item is serialized out as xml, its value is "dateNotBetween".</para>
        /// </summary>
        public static PivotFilterValues DateNotBetween => new("dateNotBetween");
        /// <summary>
        /// Tomorrow.
        /// <para>When the item is serialized out as xml, its value is "tomorrow".</para>
        /// </summary>
        public static PivotFilterValues Tomorrow => new("tomorrow");
        /// <summary>
        /// Today.
        /// <para>When the item is serialized out as xml, its value is "today".</para>
        /// </summary>
        public static PivotFilterValues Today => new("today");
        /// <summary>
        /// Yesterday.
        /// <para>When the item is serialized out as xml, its value is "yesterday".</para>
        /// </summary>
        public static PivotFilterValues Yesterday => new("yesterday");
        /// <summary>
        /// Next Week.
        /// <para>When the item is serialized out as xml, its value is "nextWeek".</para>
        /// </summary>
        public static PivotFilterValues NextWeek => new("nextWeek");
        /// <summary>
        /// This Week.
        /// <para>When the item is serialized out as xml, its value is "thisWeek".</para>
        /// </summary>
        public static PivotFilterValues ThisWeek => new("thisWeek");
        /// <summary>
        /// Last Week.
        /// <para>When the item is serialized out as xml, its value is "lastWeek".</para>
        /// </summary>
        public static PivotFilterValues LastWeek => new("lastWeek");
        /// <summary>
        /// Next Month.
        /// <para>When the item is serialized out as xml, its value is "nextMonth".</para>
        /// </summary>
        public static PivotFilterValues NextMonth => new("nextMonth");
        /// <summary>
        /// This Month.
        /// <para>When the item is serialized out as xml, its value is "thisMonth".</para>
        /// </summary>
        public static PivotFilterValues ThisMonth => new("thisMonth");
        /// <summary>
        /// Last Month.
        /// <para>When the item is serialized out as xml, its value is "lastMonth".</para>
        /// </summary>
        public static PivotFilterValues LastMonth => new("lastMonth");
        /// <summary>
        /// Next Quarter.
        /// <para>When the item is serialized out as xml, its value is "nextQuarter".</para>
        /// </summary>
        public static PivotFilterValues NextQuarter => new("nextQuarter");
        /// <summary>
        /// This Quarter.
        /// <para>When the item is serialized out as xml, its value is "thisQuarter".</para>
        /// </summary>
        public static PivotFilterValues ThisQuarter => new("thisQuarter");
        /// <summary>
        /// Last Quarter.
        /// <para>When the item is serialized out as xml, its value is "lastQuarter".</para>
        /// </summary>
        public static PivotFilterValues LastQuarter => new("lastQuarter");
        /// <summary>
        /// Next Year.
        /// <para>When the item is serialized out as xml, its value is "nextYear".</para>
        /// </summary>
        public static PivotFilterValues NextYear => new("nextYear");
        /// <summary>
        /// This Year.
        /// <para>When the item is serialized out as xml, its value is "thisYear".</para>
        /// </summary>
        public static PivotFilterValues ThisYear => new("thisYear");
        /// <summary>
        /// Last Year.
        /// <para>When the item is serialized out as xml, its value is "lastYear".</para>
        /// </summary>
        public static PivotFilterValues LastYear => new("lastYear");
        /// <summary>
        /// Year-To-Date.
        /// <para>When the item is serialized out as xml, its value is "yearToDate".</para>
        /// </summary>
        public static PivotFilterValues YearToDate => new("yearToDate");
        /// <summary>
        /// First Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q1".</para>
        /// </summary>
        public static PivotFilterValues Quarter1 => new("Q1");
        /// <summary>
        /// Second Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q2".</para>
        /// </summary>
        public static PivotFilterValues Quarter2 => new("Q2");
        /// <summary>
        /// Third Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q3".</para>
        /// </summary>
        public static PivotFilterValues Quarter3 => new("Q3");
        /// <summary>
        /// Fourth Quarter.
        /// <para>When the item is serialized out as xml, its value is "Q4".</para>
        /// </summary>
        public static PivotFilterValues Quarter4 => new("Q4");
        /// <summary>
        /// January.
        /// <para>When the item is serialized out as xml, its value is "M1".</para>
        /// </summary>
        public static PivotFilterValues January => new("M1");
        /// <summary>
        /// Dates in February.
        /// <para>When the item is serialized out as xml, its value is "M2".</para>
        /// </summary>
        public static PivotFilterValues February => new("M2");
        /// <summary>
        /// Dates in March.
        /// <para>When the item is serialized out as xml, its value is "M3".</para>
        /// </summary>
        public static PivotFilterValues March => new("M3");
        /// <summary>
        /// Dates in April.
        /// <para>When the item is serialized out as xml, its value is "M4".</para>
        /// </summary>
        public static PivotFilterValues April => new("M4");
        /// <summary>
        /// Dates in May.
        /// <para>When the item is serialized out as xml, its value is "M5".</para>
        /// </summary>
        public static PivotFilterValues May => new("M5");
        /// <summary>
        /// Dates in June.
        /// <para>When the item is serialized out as xml, its value is "M6".</para>
        /// </summary>
        public static PivotFilterValues June => new("M6");
        /// <summary>
        /// Dates in July.
        /// <para>When the item is serialized out as xml, its value is "M7".</para>
        /// </summary>
        public static PivotFilterValues July => new("M7");
        /// <summary>
        /// Dates in August.
        /// <para>When the item is serialized out as xml, its value is "M8".</para>
        /// </summary>
        public static PivotFilterValues August => new("M8");
        /// <summary>
        /// Dates in September.
        /// <para>When the item is serialized out as xml, its value is "M9".</para>
        /// </summary>
        public static PivotFilterValues September => new("M9");
        /// <summary>
        /// Dates in October.
        /// <para>When the item is serialized out as xml, its value is "M10".</para>
        /// </summary>
        public static PivotFilterValues October => new("M10");
        /// <summary>
        /// Dates in November.
        /// <para>When the item is serialized out as xml, its value is "M11".</para>
        /// </summary>
        public static PivotFilterValues November => new("M11");
        /// <summary>
        /// Dates in December.
        /// <para>When the item is serialized out as xml, its value is "M12".</para>
        /// </summary>
        public static PivotFilterValues December => new("M12");
    
    }

    /// <summary>
    /// PivotTable Format Types
    /// </summary>
    public readonly record struct FormatActionValues : IEnumValue, IEnumValueFactory<FormatActionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FormatActionValues enum instance
        /// </summary>
        public FormatActionValues(string value) => _value = value;
        FormatActionValues IEnumValueFactory<FormatActionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "blank" => true,
            "formatting" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "blank";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Blank.
        /// <para>When the item is serialized out as xml, its value is "blank".</para>
        /// </summary>
        public static FormatActionValues Blank => new("blank");
        /// <summary>
        /// Formatting.
        /// <para>When the item is serialized out as xml, its value is "formatting".</para>
        /// </summary>
        public static FormatActionValues Formatting => new("formatting");
    
    }

    /// <summary>
    /// PivotTable Axis
    /// </summary>
    public readonly record struct PivotTableAxisValues : IEnumValue, IEnumValueFactory<PivotTableAxisValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PivotTableAxisValues enum instance
        /// </summary>
        public PivotTableAxisValues(string value) => _value = value;
        PivotTableAxisValues IEnumValueFactory<PivotTableAxisValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "axisRow" => true,
            "axisCol" => true,
            "axisPage" => true,
            "axisValues" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "axisRow";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Row Axis.
        /// <para>When the item is serialized out as xml, its value is "axisRow".</para>
        /// </summary>
        public static PivotTableAxisValues AxisRow => new("axisRow");
        /// <summary>
        /// Column Axis.
        /// <para>When the item is serialized out as xml, its value is "axisCol".</para>
        /// </summary>
        public static PivotTableAxisValues AxisColumn => new("axisCol");
        /// <summary>
        /// Include Count Filter.
        /// <para>When the item is serialized out as xml, its value is "axisPage".</para>
        /// </summary>
        public static PivotTableAxisValues AxisPage => new("axisPage");
        /// <summary>
        /// Values Axis.
        /// <para>When the item is serialized out as xml, its value is "axisValues".</para>
        /// </summary>
        public static PivotTableAxisValues AxisValues => new("axisValues");
    
    }

    /// <summary>
    /// Grow Shrink Type
    /// </summary>
    public readonly record struct GrowShrinkValues : IEnumValue, IEnumValueFactory<GrowShrinkValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GrowShrinkValues enum instance
        /// </summary>
        public GrowShrinkValues(string value) => _value = value;
        GrowShrinkValues IEnumValueFactory<GrowShrinkValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "insertDelete" => true,
            "insertClear" => true,
            "overwriteClear" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "insertDelete";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Insert and Delete On Refresh.
        /// <para>When the item is serialized out as xml, its value is "insertDelete".</para>
        /// </summary>
        public static GrowShrinkValues InsertDelete => new("insertDelete");
        /// <summary>
        /// Insert and Clear On Refresh.
        /// <para>When the item is serialized out as xml, its value is "insertClear".</para>
        /// </summary>
        public static GrowShrinkValues InsertClear => new("insertClear");
        /// <summary>
        /// Overwrite and Clear On Refresh.
        /// <para>When the item is serialized out as xml, its value is "overwriteClear".</para>
        /// </summary>
        public static GrowShrinkValues OverwriteClear => new("overwriteClear");
    
    }

    /// <summary>
    /// Phonetic Type
    /// </summary>
    public readonly record struct PhoneticValues : IEnumValue, IEnumValueFactory<PhoneticValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PhoneticValues enum instance
        /// </summary>
        public PhoneticValues(string value) => _value = value;
        PhoneticValues IEnumValueFactory<PhoneticValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "halfwidthKatakana" => true,
            "fullwidthKatakana" => true,
            "Hiragana" => true,
            "noConversion" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "halfwidthKatakana";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Half-Width Katakana.
        /// <para>When the item is serialized out as xml, its value is "halfwidthKatakana".</para>
        /// </summary>
        public static PhoneticValues HalfWidthKatakana => new("halfwidthKatakana");
        /// <summary>
        /// Full-Width Katakana.
        /// <para>When the item is serialized out as xml, its value is "fullwidthKatakana".</para>
        /// </summary>
        public static PhoneticValues FullWidthKatakana => new("fullwidthKatakana");
        /// <summary>
        /// Hiragana.
        /// <para>When the item is serialized out as xml, its value is "Hiragana".</para>
        /// </summary>
        public static PhoneticValues Hiragana => new("Hiragana");
        /// <summary>
        /// No Conversion.
        /// <para>When the item is serialized out as xml, its value is "noConversion".</para>
        /// </summary>
        public static PhoneticValues NoConversion => new("noConversion");
    
    }

    /// <summary>
    /// Phonetic Alignment Types
    /// </summary>
    public readonly record struct PhoneticAlignmentValues : IEnumValue, IEnumValueFactory<PhoneticAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PhoneticAlignmentValues enum instance
        /// </summary>
        public PhoneticAlignmentValues(string value) => _value = value;
        PhoneticAlignmentValues IEnumValueFactory<PhoneticAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "noControl" => true,
            "left" => true,
            "center" => true,
            "distributed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "noControl";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// No Control.
        /// <para>When the item is serialized out as xml, its value is "noControl".</para>
        /// </summary>
        public static PhoneticAlignmentValues NoControl => new("noControl");
        /// <summary>
        /// Left Alignment.
        /// <para>When the item is serialized out as xml, its value is "left".</para>
        /// </summary>
        public static PhoneticAlignmentValues Left => new("left");
        /// <summary>
        /// Center Alignment.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// </summary>
        public static PhoneticAlignmentValues Center => new("center");
        /// <summary>
        /// Distributed.
        /// <para>When the item is serialized out as xml, its value is "distributed".</para>
        /// </summary>
        public static PhoneticAlignmentValues Distributed => new("distributed");
    
    }

    /// <summary>
    /// Row Column Action Type
    /// </summary>
    public readonly record struct RowColumnActionValues : IEnumValue, IEnumValueFactory<RowColumnActionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RowColumnActionValues enum instance
        /// </summary>
        public RowColumnActionValues(string value) => _value = value;
        RowColumnActionValues IEnumValueFactory<RowColumnActionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "insertRow" => true,
            "deleteRow" => true,
            "insertCol" => true,
            "deleteCol" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "insertRow";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Insert Row.
        /// <para>When the item is serialized out as xml, its value is "insertRow".</para>
        /// </summary>
        public static RowColumnActionValues InsertRow => new("insertRow");
        /// <summary>
        /// Delete Row.
        /// <para>When the item is serialized out as xml, its value is "deleteRow".</para>
        /// </summary>
        public static RowColumnActionValues DeleteRow => new("deleteRow");
        /// <summary>
        /// Column Insert.
        /// <para>When the item is serialized out as xml, its value is "insertCol".</para>
        /// </summary>
        public static RowColumnActionValues ColumnInsert => new("insertCol");
        /// <summary>
        /// Delete Column.
        /// <para>When the item is serialized out as xml, its value is "deleteCol".</para>
        /// </summary>
        public static RowColumnActionValues DeleteColumn => new("deleteCol");
    
    }

    /// <summary>
    /// Revision Action Types
    /// </summary>
    public readonly record struct RevisionActionValues : IEnumValue, IEnumValueFactory<RevisionActionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RevisionActionValues enum instance
        /// </summary>
        public RevisionActionValues(string value) => _value = value;
        RevisionActionValues IEnumValueFactory<RevisionActionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "add" => true,
            "delete" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "add";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Add.
        /// <para>When the item is serialized out as xml, its value is "add".</para>
        /// </summary>
        public static RevisionActionValues Add => new("add");
        /// <summary>
        /// Delete.
        /// <para>When the item is serialized out as xml, its value is "delete".</para>
        /// </summary>
        public static RevisionActionValues Delete => new("delete");
    
    }

    /// <summary>
    /// Formula Expression Type
    /// </summary>
    public readonly record struct FormulaExpressionValues : IEnumValue, IEnumValueFactory<FormulaExpressionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FormulaExpressionValues enum instance
        /// </summary>
        public FormulaExpressionValues(string value) => _value = value;
        FormulaExpressionValues IEnumValueFactory<FormulaExpressionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "ref" => true,
            "refError" => true,
            "area" => true,
            "areaError" => true,
            "computedArea" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "ref";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Reference.
        /// <para>When the item is serialized out as xml, its value is "ref".</para>
        /// </summary>
        public static FormulaExpressionValues Reference => new("ref");
        /// <summary>
        /// Reference Is Error.
        /// <para>When the item is serialized out as xml, its value is "refError".</para>
        /// </summary>
        public static FormulaExpressionValues ReferenceError => new("refError");
        /// <summary>
        /// Area.
        /// <para>When the item is serialized out as xml, its value is "area".</para>
        /// </summary>
        public static FormulaExpressionValues Area => new("area");
        /// <summary>
        /// Area Error.
        /// <para>When the item is serialized out as xml, its value is "areaError".</para>
        /// </summary>
        public static FormulaExpressionValues AreaError => new("areaError");
        /// <summary>
        /// Computed Area.
        /// <para>When the item is serialized out as xml, its value is "computedArea".</para>
        /// </summary>
        public static FormulaExpressionValues ComputedArea => new("computedArea");
    
    }

    /// <summary>
    /// Formula Type
    /// </summary>
    public readonly record struct CellFormulaValues : IEnumValue, IEnumValueFactory<CellFormulaValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CellFormulaValues enum instance
        /// </summary>
        public CellFormulaValues(string value) => _value = value;
        CellFormulaValues IEnumValueFactory<CellFormulaValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "normal" => true,
            "array" => true,
            "dataTable" => true,
            "shared" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "normal";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Normal.
        /// <para>When the item is serialized out as xml, its value is "normal".</para>
        /// </summary>
        public static CellFormulaValues Normal => new("normal");
        /// <summary>
        /// Array Entered.
        /// <para>When the item is serialized out as xml, its value is "array".</para>
        /// </summary>
        public static CellFormulaValues Array => new("array");
        /// <summary>
        /// Table Formula.
        /// <para>When the item is serialized out as xml, its value is "dataTable".</para>
        /// </summary>
        public static CellFormulaValues DataTable => new("dataTable");
        /// <summary>
        /// Shared Formula.
        /// <para>When the item is serialized out as xml, its value is "shared".</para>
        /// </summary>
        public static CellFormulaValues Shared => new("shared");
    
    }

    /// <summary>
    /// Pane Types
    /// </summary>
    public readonly record struct PaneValues : IEnumValue, IEnumValueFactory<PaneValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PaneValues enum instance
        /// </summary>
        public PaneValues(string value) => _value = value;
        PaneValues IEnumValueFactory<PaneValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "bottomRight" => true,
            "topRight" => true,
            "bottomLeft" => true,
            "topLeft" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "bottomRight";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Bottom Right Pane.
        /// <para>When the item is serialized out as xml, its value is "bottomRight".</para>
        /// </summary>
        public static PaneValues BottomRight => new("bottomRight");
        /// <summary>
        /// Top Right Pane.
        /// <para>When the item is serialized out as xml, its value is "topRight".</para>
        /// </summary>
        public static PaneValues TopRight => new("topRight");
        /// <summary>
        /// Bottom Left Pane.
        /// <para>When the item is serialized out as xml, its value is "bottomLeft".</para>
        /// </summary>
        public static PaneValues BottomLeft => new("bottomLeft");
        /// <summary>
        /// Top Left Pane.
        /// <para>When the item is serialized out as xml, its value is "topLeft".</para>
        /// </summary>
        public static PaneValues TopLeft => new("topLeft");
    
    }

    /// <summary>
    /// Sheet View Type
    /// </summary>
    public readonly record struct SheetViewValues : IEnumValue, IEnumValueFactory<SheetViewValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SheetViewValues enum instance
        /// </summary>
        public SheetViewValues(string value) => _value = value;
        SheetViewValues IEnumValueFactory<SheetViewValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "normal" => true,
            "pageBreakPreview" => true,
            "pageLayout" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "normal";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Normal View.
        /// <para>When the item is serialized out as xml, its value is "normal".</para>
        /// </summary>
        public static SheetViewValues Normal => new("normal");
        /// <summary>
        /// Page Break Preview.
        /// <para>When the item is serialized out as xml, its value is "pageBreakPreview".</para>
        /// </summary>
        public static SheetViewValues PageBreakPreview => new("pageBreakPreview");
        /// <summary>
        /// Page Layout View.
        /// <para>When the item is serialized out as xml, its value is "pageLayout".</para>
        /// </summary>
        public static SheetViewValues PageLayout => new("pageLayout");
    
    }

    /// <summary>
    /// Data Consolidation Functions
    /// </summary>
    public readonly record struct DataConsolidateFunctionValues : IEnumValue, IEnumValueFactory<DataConsolidateFunctionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataConsolidateFunctionValues enum instance
        /// </summary>
        public DataConsolidateFunctionValues(string value) => _value = value;
        DataConsolidateFunctionValues IEnumValueFactory<DataConsolidateFunctionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "average" => true,
            "count" => true,
            "countNums" => true,
            "max" => true,
            "min" => true,
            "product" => true,
            "stdDev" => true,
            "stdDevp" => true,
            "sum" => true,
            "var" => true,
            "varp" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "average";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Average.
        /// <para>When the item is serialized out as xml, its value is "average".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Average => new("average");
        /// <summary>
        /// Count.
        /// <para>When the item is serialized out as xml, its value is "count".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Count => new("count");
        /// <summary>
        /// CountNums.
        /// <para>When the item is serialized out as xml, its value is "countNums".</para>
        /// </summary>
        public static DataConsolidateFunctionValues CountNumbers => new("countNums");
        /// <summary>
        /// Maximum.
        /// <para>When the item is serialized out as xml, its value is "max".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Maximum => new("max");
        /// <summary>
        /// Minimum.
        /// <para>When the item is serialized out as xml, its value is "min".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Minimum => new("min");
        /// <summary>
        /// Product.
        /// <para>When the item is serialized out as xml, its value is "product".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Product => new("product");
        /// <summary>
        /// StdDev.
        /// <para>When the item is serialized out as xml, its value is "stdDev".</para>
        /// </summary>
        public static DataConsolidateFunctionValues StandardDeviation => new("stdDev");
        /// <summary>
        /// StdDevP.
        /// <para>When the item is serialized out as xml, its value is "stdDevp".</para>
        /// </summary>
        public static DataConsolidateFunctionValues StandardDeviationP => new("stdDevp");
        /// <summary>
        /// Sum.
        /// <para>When the item is serialized out as xml, its value is "sum".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Sum => new("sum");
        /// <summary>
        /// Variance.
        /// <para>When the item is serialized out as xml, its value is "var".</para>
        /// </summary>
        public static DataConsolidateFunctionValues Variance => new("var");
        /// <summary>
        /// VarP.
        /// <para>When the item is serialized out as xml, its value is "varp".</para>
        /// </summary>
        public static DataConsolidateFunctionValues VarianceP => new("varp");
    
    }

    /// <summary>
    /// Data Validation Type
    /// </summary>
    public readonly record struct DataValidationValues : IEnumValue, IEnumValueFactory<DataValidationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataValidationValues enum instance
        /// </summary>
        public DataValidationValues(string value) => _value = value;
        DataValidationValues IEnumValueFactory<DataValidationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "whole" => true,
            "decimal" => true,
            "list" => true,
            "date" => true,
            "time" => true,
            "textLength" => true,
            "custom" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static DataValidationValues None => new("none");
        /// <summary>
        /// Whole Number.
        /// <para>When the item is serialized out as xml, its value is "whole".</para>
        /// </summary>
        public static DataValidationValues Whole => new("whole");
        /// <summary>
        /// Decimal.
        /// <para>When the item is serialized out as xml, its value is "decimal".</para>
        /// </summary>
        public static DataValidationValues Decimal => new("decimal");
        /// <summary>
        /// List.
        /// <para>When the item is serialized out as xml, its value is "list".</para>
        /// </summary>
        public static DataValidationValues List => new("list");
        /// <summary>
        /// Date.
        /// <para>When the item is serialized out as xml, its value is "date".</para>
        /// </summary>
        public static DataValidationValues Date => new("date");
        /// <summary>
        /// Time.
        /// <para>When the item is serialized out as xml, its value is "time".</para>
        /// </summary>
        public static DataValidationValues Time => new("time");
        /// <summary>
        /// Text Length.
        /// <para>When the item is serialized out as xml, its value is "textLength".</para>
        /// </summary>
        public static DataValidationValues TextLength => new("textLength");
        /// <summary>
        /// Custom.
        /// <para>When the item is serialized out as xml, its value is "custom".</para>
        /// </summary>
        public static DataValidationValues Custom => new("custom");
    
    }

    /// <summary>
    /// Data Validation Operator
    /// </summary>
    public readonly record struct DataValidationOperatorValues : IEnumValue, IEnumValueFactory<DataValidationOperatorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataValidationOperatorValues enum instance
        /// </summary>
        public DataValidationOperatorValues(string value) => _value = value;
        DataValidationOperatorValues IEnumValueFactory<DataValidationOperatorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "between" => true,
            "notBetween" => true,
            "equal" => true,
            "notEqual" => true,
            "lessThan" => true,
            "lessThanOrEqual" => true,
            "greaterThan" => true,
            "greaterThanOrEqual" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "between";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Between.
        /// <para>When the item is serialized out as xml, its value is "between".</para>
        /// </summary>
        public static DataValidationOperatorValues Between => new("between");
        /// <summary>
        /// Not Between.
        /// <para>When the item is serialized out as xml, its value is "notBetween".</para>
        /// </summary>
        public static DataValidationOperatorValues NotBetween => new("notBetween");
        /// <summary>
        /// Equal.
        /// <para>When the item is serialized out as xml, its value is "equal".</para>
        /// </summary>
        public static DataValidationOperatorValues Equal => new("equal");
        /// <summary>
        /// Not Equal.
        /// <para>When the item is serialized out as xml, its value is "notEqual".</para>
        /// </summary>
        public static DataValidationOperatorValues NotEqual => new("notEqual");
        /// <summary>
        /// Less Than.
        /// <para>When the item is serialized out as xml, its value is "lessThan".</para>
        /// </summary>
        public static DataValidationOperatorValues LessThan => new("lessThan");
        /// <summary>
        /// Less Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
        /// </summary>
        public static DataValidationOperatorValues LessThanOrEqual => new("lessThanOrEqual");
        /// <summary>
        /// Greater Than.
        /// <para>When the item is serialized out as xml, its value is "greaterThan".</para>
        /// </summary>
        public static DataValidationOperatorValues GreaterThan => new("greaterThan");
        /// <summary>
        /// Greater Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
        /// </summary>
        public static DataValidationOperatorValues GreaterThanOrEqual => new("greaterThanOrEqual");
    
    }

    /// <summary>
    /// Data Validation Error Styles
    /// </summary>
    public readonly record struct DataValidationErrorStyleValues : IEnumValue, IEnumValueFactory<DataValidationErrorStyleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataValidationErrorStyleValues enum instance
        /// </summary>
        public DataValidationErrorStyleValues(string value) => _value = value;
        DataValidationErrorStyleValues IEnumValueFactory<DataValidationErrorStyleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "stop" => true,
            "warning" => true,
            "information" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "stop";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Stop Icon.
        /// <para>When the item is serialized out as xml, its value is "stop".</para>
        /// </summary>
        public static DataValidationErrorStyleValues Stop => new("stop");
        /// <summary>
        /// Warning Icon.
        /// <para>When the item is serialized out as xml, its value is "warning".</para>
        /// </summary>
        public static DataValidationErrorStyleValues Warning => new("warning");
        /// <summary>
        /// Information Icon.
        /// <para>When the item is serialized out as xml, its value is "information".</para>
        /// </summary>
        public static DataValidationErrorStyleValues Information => new("information");
    
    }

    /// <summary>
    /// Data Validation IME Mode
    /// </summary>
    public readonly record struct DataValidationImeModeValues : IEnumValue, IEnumValueFactory<DataValidationImeModeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataValidationImeModeValues enum instance
        /// </summary>
        public DataValidationImeModeValues(string value) => _value = value;
        DataValidationImeModeValues IEnumValueFactory<DataValidationImeModeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "noControl" => true,
            "off" => true,
            "on" => true,
            "disabled" => true,
            "hiragana" => true,
            "fullKatakana" => true,
            "halfKatakana" => true,
            "fullAlpha" => true,
            "halfAlpha" => true,
            "fullHangul" => true,
            "halfHangul" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "noControl";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// IME Mode Not Controlled.
        /// <para>When the item is serialized out as xml, its value is "noControl".</para>
        /// </summary>
        public static DataValidationImeModeValues NoControl => new("noControl");
        /// <summary>
        /// IME Off.
        /// <para>When the item is serialized out as xml, its value is "off".</para>
        /// </summary>
        public static DataValidationImeModeValues Off => new("off");
        /// <summary>
        /// IME On.
        /// <para>When the item is serialized out as xml, its value is "on".</para>
        /// </summary>
        public static DataValidationImeModeValues On => new("on");
        /// <summary>
        /// Disabled IME Mode.
        /// <para>When the item is serialized out as xml, its value is "disabled".</para>
        /// </summary>
        public static DataValidationImeModeValues Disabled => new("disabled");
        /// <summary>
        /// Hiragana IME Mode.
        /// <para>When the item is serialized out as xml, its value is "hiragana".</para>
        /// </summary>
        public static DataValidationImeModeValues Hiragana => new("hiragana");
        /// <summary>
        /// Full Katakana IME Mode.
        /// <para>When the item is serialized out as xml, its value is "fullKatakana".</para>
        /// </summary>
        public static DataValidationImeModeValues FullKatakana => new("fullKatakana");
        /// <summary>
        /// Half-Width Katakana.
        /// <para>When the item is serialized out as xml, its value is "halfKatakana".</para>
        /// </summary>
        public static DataValidationImeModeValues HalfKatakana => new("halfKatakana");
        /// <summary>
        /// Full-Width Alpha-Numeric IME Mode.
        /// <para>When the item is serialized out as xml, its value is "fullAlpha".</para>
        /// </summary>
        public static DataValidationImeModeValues FullAlpha => new("fullAlpha");
        /// <summary>
        /// Half Alpha IME.
        /// <para>When the item is serialized out as xml, its value is "halfAlpha".</para>
        /// </summary>
        public static DataValidationImeModeValues HalfAlpha => new("halfAlpha");
        /// <summary>
        /// Full Width Hangul.
        /// <para>When the item is serialized out as xml, its value is "fullHangul".</para>
        /// </summary>
        public static DataValidationImeModeValues FullHangul => new("fullHangul");
        /// <summary>
        /// Half-Width Hangul IME Mode.
        /// <para>When the item is serialized out as xml, its value is "halfHangul".</para>
        /// </summary>
        public static DataValidationImeModeValues HalfHangul => new("halfHangul");
    
    }

    /// <summary>
    /// Conditional Format Type
    /// </summary>
    public readonly record struct ConditionalFormatValues : IEnumValue, IEnumValueFactory<ConditionalFormatValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConditionalFormatValues enum instance
        /// </summary>
        public ConditionalFormatValues(string value) => _value = value;
        ConditionalFormatValues IEnumValueFactory<ConditionalFormatValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "expression" => true,
            "cellIs" => true,
            "colorScale" => true,
            "dataBar" => true,
            "iconSet" => true,
            "top10" => true,
            "uniqueValues" => true,
            "duplicateValues" => true,
            "containsText" => true,
            "notContainsText" => true,
            "beginsWith" => true,
            "endsWith" => true,
            "containsBlanks" => true,
            "notContainsBlanks" => true,
            "containsErrors" => true,
            "notContainsErrors" => true,
            "timePeriod" => true,
            "aboveAverage" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "expression";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Expression.
        /// <para>When the item is serialized out as xml, its value is "expression".</para>
        /// </summary>
        public static ConditionalFormatValues Expression => new("expression");
        /// <summary>
        /// Cell Is.
        /// <para>When the item is serialized out as xml, its value is "cellIs".</para>
        /// </summary>
        public static ConditionalFormatValues CellIs => new("cellIs");
        /// <summary>
        /// Color Scale.
        /// <para>When the item is serialized out as xml, its value is "colorScale".</para>
        /// </summary>
        public static ConditionalFormatValues ColorScale => new("colorScale");
        /// <summary>
        /// Data Bar.
        /// <para>When the item is serialized out as xml, its value is "dataBar".</para>
        /// </summary>
        public static ConditionalFormatValues DataBar => new("dataBar");
        /// <summary>
        /// Icon Set.
        /// <para>When the item is serialized out as xml, its value is "iconSet".</para>
        /// </summary>
        public static ConditionalFormatValues IconSet => new("iconSet");
        /// <summary>
        /// Top 10.
        /// <para>When the item is serialized out as xml, its value is "top10".</para>
        /// </summary>
        public static ConditionalFormatValues Top10 => new("top10");
        /// <summary>
        /// Unique Values.
        /// <para>When the item is serialized out as xml, its value is "uniqueValues".</para>
        /// </summary>
        public static ConditionalFormatValues UniqueValues => new("uniqueValues");
        /// <summary>
        /// Duplicate Values.
        /// <para>When the item is serialized out as xml, its value is "duplicateValues".</para>
        /// </summary>
        public static ConditionalFormatValues DuplicateValues => new("duplicateValues");
        /// <summary>
        /// Contains Text.
        /// <para>When the item is serialized out as xml, its value is "containsText".</para>
        /// </summary>
        public static ConditionalFormatValues ContainsText => new("containsText");
        /// <summary>
        /// Does Not Contain Text.
        /// <para>When the item is serialized out as xml, its value is "notContainsText".</para>
        /// </summary>
        public static ConditionalFormatValues NotContainsText => new("notContainsText");
        /// <summary>
        /// Begins With.
        /// <para>When the item is serialized out as xml, its value is "beginsWith".</para>
        /// </summary>
        public static ConditionalFormatValues BeginsWith => new("beginsWith");
        /// <summary>
        /// Ends With.
        /// <para>When the item is serialized out as xml, its value is "endsWith".</para>
        /// </summary>
        public static ConditionalFormatValues EndsWith => new("endsWith");
        /// <summary>
        /// Contains Blanks.
        /// <para>When the item is serialized out as xml, its value is "containsBlanks".</para>
        /// </summary>
        public static ConditionalFormatValues ContainsBlanks => new("containsBlanks");
        /// <summary>
        /// Contains No Blanks.
        /// <para>When the item is serialized out as xml, its value is "notContainsBlanks".</para>
        /// </summary>
        public static ConditionalFormatValues NotContainsBlanks => new("notContainsBlanks");
        /// <summary>
        /// Contains Errors.
        /// <para>When the item is serialized out as xml, its value is "containsErrors".</para>
        /// </summary>
        public static ConditionalFormatValues ContainsErrors => new("containsErrors");
        /// <summary>
        /// Contains No Errors.
        /// <para>When the item is serialized out as xml, its value is "notContainsErrors".</para>
        /// </summary>
        public static ConditionalFormatValues NotContainsErrors => new("notContainsErrors");
        /// <summary>
        /// Time Period.
        /// <para>When the item is serialized out as xml, its value is "timePeriod".</para>
        /// </summary>
        public static ConditionalFormatValues TimePeriod => new("timePeriod");
        /// <summary>
        /// Above or Below Average.
        /// <para>When the item is serialized out as xml, its value is "aboveAverage".</para>
        /// </summary>
        public static ConditionalFormatValues AboveAverage => new("aboveAverage");
    
    }

    /// <summary>
    /// Time Period Types
    /// </summary>
    public readonly record struct TimePeriodValues : IEnumValue, IEnumValueFactory<TimePeriodValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TimePeriodValues enum instance
        /// </summary>
        public TimePeriodValues(string value) => _value = value;
        TimePeriodValues IEnumValueFactory<TimePeriodValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "today" => true,
            "yesterday" => true,
            "tomorrow" => true,
            "last7Days" => true,
            "thisMonth" => true,
            "lastMonth" => true,
            "nextMonth" => true,
            "thisWeek" => true,
            "lastWeek" => true,
            "nextWeek" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "today";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Today.
        /// <para>When the item is serialized out as xml, its value is "today".</para>
        /// </summary>
        public static TimePeriodValues Today => new("today");
        /// <summary>
        /// Yesterday.
        /// <para>When the item is serialized out as xml, its value is "yesterday".</para>
        /// </summary>
        public static TimePeriodValues Yesterday => new("yesterday");
        /// <summary>
        /// Tomorrow.
        /// <para>When the item is serialized out as xml, its value is "tomorrow".</para>
        /// </summary>
        public static TimePeriodValues Tomorrow => new("tomorrow");
        /// <summary>
        /// Last 7 Days.
        /// <para>When the item is serialized out as xml, its value is "last7Days".</para>
        /// </summary>
        public static TimePeriodValues Last7Days => new("last7Days");
        /// <summary>
        /// This Month.
        /// <para>When the item is serialized out as xml, its value is "thisMonth".</para>
        /// </summary>
        public static TimePeriodValues ThisMonth => new("thisMonth");
        /// <summary>
        /// Last Month.
        /// <para>When the item is serialized out as xml, its value is "lastMonth".</para>
        /// </summary>
        public static TimePeriodValues LastMonth => new("lastMonth");
        /// <summary>
        /// Next Month.
        /// <para>When the item is serialized out as xml, its value is "nextMonth".</para>
        /// </summary>
        public static TimePeriodValues NextMonth => new("nextMonth");
        /// <summary>
        /// This Week.
        /// <para>When the item is serialized out as xml, its value is "thisWeek".</para>
        /// </summary>
        public static TimePeriodValues ThisWeek => new("thisWeek");
        /// <summary>
        /// Last Week.
        /// <para>When the item is serialized out as xml, its value is "lastWeek".</para>
        /// </summary>
        public static TimePeriodValues LastWeek => new("lastWeek");
        /// <summary>
        /// Next Week.
        /// <para>When the item is serialized out as xml, its value is "nextWeek".</para>
        /// </summary>
        public static TimePeriodValues NextWeek => new("nextWeek");
    
    }

    /// <summary>
    /// Conditional Format Operators
    /// </summary>
    public readonly record struct ConditionalFormattingOperatorValues : IEnumValue, IEnumValueFactory<ConditionalFormattingOperatorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConditionalFormattingOperatorValues enum instance
        /// </summary>
        public ConditionalFormattingOperatorValues(string value) => _value = value;
        ConditionalFormattingOperatorValues IEnumValueFactory<ConditionalFormattingOperatorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "lessThan" => true,
            "lessThanOrEqual" => true,
            "equal" => true,
            "notEqual" => true,
            "greaterThanOrEqual" => true,
            "greaterThan" => true,
            "between" => true,
            "notBetween" => true,
            "containsText" => true,
            "notContains" => true,
            "beginsWith" => true,
            "endsWith" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "lessThan";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Less Than.
        /// <para>When the item is serialized out as xml, its value is "lessThan".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues LessThan => new("lessThan");
        /// <summary>
        /// Less Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues LessThanOrEqual => new("lessThanOrEqual");
        /// <summary>
        /// Equal.
        /// <para>When the item is serialized out as xml, its value is "equal".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues Equal => new("equal");
        /// <summary>
        /// Not Equal.
        /// <para>When the item is serialized out as xml, its value is "notEqual".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues NotEqual => new("notEqual");
        /// <summary>
        /// Greater Than Or Equal.
        /// <para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues GreaterThanOrEqual => new("greaterThanOrEqual");
        /// <summary>
        /// Greater Than.
        /// <para>When the item is serialized out as xml, its value is "greaterThan".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues GreaterThan => new("greaterThan");
        /// <summary>
        /// Between.
        /// <para>When the item is serialized out as xml, its value is "between".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues Between => new("between");
        /// <summary>
        /// Not Between.
        /// <para>When the item is serialized out as xml, its value is "notBetween".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues NotBetween => new("notBetween");
        /// <summary>
        /// Contains.
        /// <para>When the item is serialized out as xml, its value is "containsText".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues ContainsText => new("containsText");
        /// <summary>
        /// Does Not Contain.
        /// <para>When the item is serialized out as xml, its value is "notContains".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues NotContains => new("notContains");
        /// <summary>
        /// Begins With.
        /// <para>When the item is serialized out as xml, its value is "beginsWith".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues BeginsWith => new("beginsWith");
        /// <summary>
        /// Ends With.
        /// <para>When the item is serialized out as xml, its value is "endsWith".</para>
        /// </summary>
        public static ConditionalFormattingOperatorValues EndsWith => new("endsWith");
    
    }

    /// <summary>
    /// Conditional Format Value Object Type
    /// </summary>
    public readonly record struct ConditionalFormatValueObjectValues : IEnumValue, IEnumValueFactory<ConditionalFormatValueObjectValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConditionalFormatValueObjectValues enum instance
        /// </summary>
        public ConditionalFormatValueObjectValues(string value) => _value = value;
        ConditionalFormatValueObjectValues IEnumValueFactory<ConditionalFormatValueObjectValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "num" => true,
            "percent" => true,
            "max" => true,
            "min" => true,
            "formula" => true,
            "percentile" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "num";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Number.
        /// <para>When the item is serialized out as xml, its value is "num".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Number => new("num");
        /// <summary>
        /// Percent.
        /// <para>When the item is serialized out as xml, its value is "percent".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Percent => new("percent");
        /// <summary>
        /// Maximum.
        /// <para>When the item is serialized out as xml, its value is "max".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Max => new("max");
        /// <summary>
        /// Minimum.
        /// <para>When the item is serialized out as xml, its value is "min".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Min => new("min");
        /// <summary>
        /// Formula.
        /// <para>When the item is serialized out as xml, its value is "formula".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Formula => new("formula");
        /// <summary>
        /// Percentile.
        /// <para>When the item is serialized out as xml, its value is "percentile".</para>
        /// </summary>
        public static ConditionalFormatValueObjectValues Percentile => new("percentile");
    
    }

    /// <summary>
    /// Page Order
    /// </summary>
    public readonly record struct PageOrderValues : IEnumValue, IEnumValueFactory<PageOrderValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PageOrderValues enum instance
        /// </summary>
        public PageOrderValues(string value) => _value = value;
        PageOrderValues IEnumValueFactory<PageOrderValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "downThenOver" => true,
            "overThenDown" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "downThenOver";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Down Then Over.
        /// <para>When the item is serialized out as xml, its value is "downThenOver".</para>
        /// </summary>
        public static PageOrderValues DownThenOver => new("downThenOver");
        /// <summary>
        /// Over Then Down.
        /// <para>When the item is serialized out as xml, its value is "overThenDown".</para>
        /// </summary>
        public static PageOrderValues OverThenDown => new("overThenDown");
    
    }

    /// <summary>
    /// Orientation
    /// </summary>
    public readonly record struct OrientationValues : IEnumValue, IEnumValueFactory<OrientationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new OrientationValues enum instance
        /// </summary>
        public OrientationValues(string value) => _value = value;
        OrientationValues IEnumValueFactory<OrientationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "default" => true,
            "portrait" => true,
            "landscape" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "default";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Default.
        /// <para>When the item is serialized out as xml, its value is "default".</para>
        /// </summary>
        public static OrientationValues Default => new("default");
        /// <summary>
        /// Portrait.
        /// <para>When the item is serialized out as xml, its value is "portrait".</para>
        /// </summary>
        public static OrientationValues Portrait => new("portrait");
        /// <summary>
        /// Landscape.
        /// <para>When the item is serialized out as xml, its value is "landscape".</para>
        /// </summary>
        public static OrientationValues Landscape => new("landscape");
    
    }

    /// <summary>
    /// Cell Comments
    /// </summary>
    public readonly record struct CellCommentsValues : IEnumValue, IEnumValueFactory<CellCommentsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CellCommentsValues enum instance
        /// </summary>
        public CellCommentsValues(string value) => _value = value;
        CellCommentsValues IEnumValueFactory<CellCommentsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "asDisplayed" => true,
            "atEnd" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static CellCommentsValues None => new("none");
        /// <summary>
        /// Print Comments As Displayed.
        /// <para>When the item is serialized out as xml, its value is "asDisplayed".</para>
        /// </summary>
        public static CellCommentsValues AsDisplayed => new("asDisplayed");
        /// <summary>
        /// Print At End.
        /// <para>When the item is serialized out as xml, its value is "atEnd".</para>
        /// </summary>
        public static CellCommentsValues AtEnd => new("atEnd");
    
    }

    /// <summary>
    /// Print Errors
    /// </summary>
    public readonly record struct PrintErrorValues : IEnumValue, IEnumValueFactory<PrintErrorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PrintErrorValues enum instance
        /// </summary>
        public PrintErrorValues(string value) => _value = value;
        PrintErrorValues IEnumValueFactory<PrintErrorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "displayed" => true,
            "blank" => true,
            "dash" => true,
            "NA" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "displayed";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Display Cell Errors.
        /// <para>When the item is serialized out as xml, its value is "displayed".</para>
        /// </summary>
        public static PrintErrorValues Displayed => new("displayed");
        /// <summary>
        /// Show Cell Errors As Blank.
        /// <para>When the item is serialized out as xml, its value is "blank".</para>
        /// </summary>
        public static PrintErrorValues Blank => new("blank");
        /// <summary>
        /// Dash Cell Errors.
        /// <para>When the item is serialized out as xml, its value is "dash".</para>
        /// </summary>
        public static PrintErrorValues Dash => new("dash");
        /// <summary>
        /// NA.
        /// <para>When the item is serialized out as xml, its value is "NA".</para>
        /// </summary>
        public static PrintErrorValues NA => new("NA");
    
    }

    /// <summary>
    /// Data View Aspect Type
    /// </summary>
    public readonly record struct DataViewAspectValues : IEnumValue, IEnumValueFactory<DataViewAspectValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataViewAspectValues enum instance
        /// </summary>
        public DataViewAspectValues(string value) => _value = value;
        DataViewAspectValues IEnumValueFactory<DataViewAspectValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "DVASPECT_CONTENT" => true,
            "DVASPECT_ICON" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "DVASPECT_CONTENT";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Object Display Content.
        /// <para>When the item is serialized out as xml, its value is "DVASPECT_CONTENT".</para>
        /// </summary>
        public static DataViewAspectValues DataViewAspectContent => new("DVASPECT_CONTENT");
        /// <summary>
        /// Object Display Icon.
        /// <para>When the item is serialized out as xml, its value is "DVASPECT_ICON".</para>
        /// </summary>
        public static DataViewAspectValues DataViewAspectIcon => new("DVASPECT_ICON");
    
    }

    /// <summary>
    /// OLE Update Types
    /// </summary>
    public readonly record struct OleUpdateValues : IEnumValue, IEnumValueFactory<OleUpdateValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new OleUpdateValues enum instance
        /// </summary>
        public OleUpdateValues(string value) => _value = value;
        OleUpdateValues IEnumValueFactory<OleUpdateValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "OLEUPDATE_ALWAYS" => true,
            "OLEUPDATE_ONCALL" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "OLEUPDATE_ALWAYS";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Always Update OLE.
        /// <para>When the item is serialized out as xml, its value is "OLEUPDATE_ALWAYS".</para>
        /// </summary>
        public static OleUpdateValues OleUpdateAlways => new("OLEUPDATE_ALWAYS");
        /// <summary>
        /// Update OLE On Call.
        /// <para>When the item is serialized out as xml, its value is "OLEUPDATE_ONCALL".</para>
        /// </summary>
        public static OleUpdateValues OleUpdateOnCall => new("OLEUPDATE_ONCALL");
    
    }

    /// <summary>
    /// Web Source Type
    /// </summary>
    public readonly record struct WebSourceValues : IEnumValue, IEnumValueFactory<WebSourceValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new WebSourceValues enum instance
        /// </summary>
        public WebSourceValues(string value) => _value = value;
        WebSourceValues IEnumValueFactory<WebSourceValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "sheet" => true,
            "printArea" => true,
            "autoFilter" => true,
            "range" => true,
            "chart" => true,
            "pivotTable" => true,
            "query" => true,
            "label" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "sheet";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// All Sheet Content.
        /// <para>When the item is serialized out as xml, its value is "sheet".</para>
        /// </summary>
        public static WebSourceValues Sheet => new("sheet");
        /// <summary>
        /// Print Area.
        /// <para>When the item is serialized out as xml, its value is "printArea".</para>
        /// </summary>
        public static WebSourceValues PrintArea => new("printArea");
        /// <summary>
        /// AutoFilter.
        /// <para>When the item is serialized out as xml, its value is "autoFilter".</para>
        /// </summary>
        public static WebSourceValues AutoFilter => new("autoFilter");
        /// <summary>
        /// Range.
        /// <para>When the item is serialized out as xml, its value is "range".</para>
        /// </summary>
        public static WebSourceValues Range => new("range");
        /// <summary>
        /// Chart.
        /// <para>When the item is serialized out as xml, its value is "chart".</para>
        /// </summary>
        public static WebSourceValues Chart => new("chart");
        /// <summary>
        /// PivotTable.
        /// <para>When the item is serialized out as xml, its value is "pivotTable".</para>
        /// </summary>
        public static WebSourceValues PivotTable => new("pivotTable");
        /// <summary>
        /// QueryTable.
        /// <para>When the item is serialized out as xml, its value is "query".</para>
        /// </summary>
        public static WebSourceValues Query => new("query");
        /// <summary>
        /// Label.
        /// <para>When the item is serialized out as xml, its value is "label".</para>
        /// </summary>
        public static WebSourceValues Label => new("label");
    
    }

    /// <summary>
    /// Pane State
    /// </summary>
    public readonly record struct PaneStateValues : IEnumValue, IEnumValueFactory<PaneStateValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PaneStateValues enum instance
        /// </summary>
        public PaneStateValues(string value) => _value = value;
        PaneStateValues IEnumValueFactory<PaneStateValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "split" => true,
            "frozen" => true,
            "frozenSplit" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "split";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Split.
        /// <para>When the item is serialized out as xml, its value is "split".</para>
        /// </summary>
        public static PaneStateValues Split => new("split");
        /// <summary>
        /// Frozen.
        /// <para>When the item is serialized out as xml, its value is "frozen".</para>
        /// </summary>
        public static PaneStateValues Frozen => new("frozen");
        /// <summary>
        /// Frozen Split.
        /// <para>When the item is serialized out as xml, its value is "frozenSplit".</para>
        /// </summary>
        public static PaneStateValues FrozenSplit => new("frozenSplit");
    
    }

    /// <summary>
    /// MDX Function Type
    /// </summary>
    public readonly record struct MdxFunctionValues : IEnumValue, IEnumValueFactory<MdxFunctionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new MdxFunctionValues enum instance
        /// </summary>
        public MdxFunctionValues(string value) => _value = value;
        MdxFunctionValues IEnumValueFactory<MdxFunctionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "m" => true,
            "v" => true,
            "s" => true,
            "c" => true,
            "r" => true,
            "p" => true,
            "k" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "m";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Cube Member.
        /// <para>When the item is serialized out as xml, its value is "m".</para>
        /// </summary>
        public static MdxFunctionValues CubeMember => new("m");
        /// <summary>
        /// Cube Value.
        /// <para>When the item is serialized out as xml, its value is "v".</para>
        /// </summary>
        public static MdxFunctionValues CubeValue => new("v");
        /// <summary>
        /// Cube Set.
        /// <para>When the item is serialized out as xml, its value is "s".</para>
        /// </summary>
        public static MdxFunctionValues CubeSet => new("s");
        /// <summary>
        /// Cube Set Count.
        /// <para>When the item is serialized out as xml, its value is "c".</para>
        /// </summary>
        public static MdxFunctionValues CubeSetCount => new("c");
        /// <summary>
        /// Cube Ranked Member.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static MdxFunctionValues CubeRankedMember => new("r");
        /// <summary>
        /// Cube Member Property.
        /// <para>When the item is serialized out as xml, its value is "p".</para>
        /// </summary>
        public static MdxFunctionValues CubeMemberProperty => new("p");
        /// <summary>
        /// Cube KPI Member.
        /// <para>When the item is serialized out as xml, its value is "k".</para>
        /// </summary>
        public static MdxFunctionValues CubeKPIMember => new("k");
    
    }

    /// <summary>
    /// MDX Set Order
    /// </summary>
    public readonly record struct MdxSetOrderValues : IEnumValue, IEnumValueFactory<MdxSetOrderValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new MdxSetOrderValues enum instance
        /// </summary>
        public MdxSetOrderValues(string value) => _value = value;
        MdxSetOrderValues IEnumValueFactory<MdxSetOrderValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "u" => true,
            "a" => true,
            "d" => true,
            "aa" => true,
            "ad" => true,
            "na" => true,
            "nd" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "u";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Unsorted.
        /// <para>When the item is serialized out as xml, its value is "u".</para>
        /// </summary>
        public static MdxSetOrderValues Unsorted => new("u");
        /// <summary>
        /// Ascending.
        /// <para>When the item is serialized out as xml, its value is "a".</para>
        /// </summary>
        public static MdxSetOrderValues Ascending => new("a");
        /// <summary>
        /// Descending.
        /// <para>When the item is serialized out as xml, its value is "d".</para>
        /// </summary>
        public static MdxSetOrderValues Descending => new("d");
        /// <summary>
        /// Alpha Ascending Sort Order.
        /// <para>When the item is serialized out as xml, its value is "aa".</para>
        /// </summary>
        public static MdxSetOrderValues AlphaAscendingSortOrder => new("aa");
        /// <summary>
        /// Alpha Descending Sort Order.
        /// <para>When the item is serialized out as xml, its value is "ad".</para>
        /// </summary>
        public static MdxSetOrderValues AlphaDescendingSortOrder => new("ad");
        /// <summary>
        /// Natural Ascending.
        /// <para>When the item is serialized out as xml, its value is "na".</para>
        /// </summary>
        public static MdxSetOrderValues NaturalAscending => new("na");
        /// <summary>
        /// Natural Descending.
        /// <para>When the item is serialized out as xml, its value is "nd".</para>
        /// </summary>
        public static MdxSetOrderValues NaturalDescending => new("nd");
    
    }

    /// <summary>
    /// MDX KPI Property
    /// </summary>
    public readonly record struct MdxKPIPropertyValues : IEnumValue, IEnumValueFactory<MdxKPIPropertyValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new MdxKPIPropertyValues enum instance
        /// </summary>
        public MdxKPIPropertyValues(string value) => _value = value;
        MdxKPIPropertyValues IEnumValueFactory<MdxKPIPropertyValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "v" => true,
            "g" => true,
            "s" => true,
            "t" => true,
            "w" => true,
            "m" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "v";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Value.
        /// <para>When the item is serialized out as xml, its value is "v".</para>
        /// </summary>
        public static MdxKPIPropertyValues Value => new("v");
        /// <summary>
        /// Goal.
        /// <para>When the item is serialized out as xml, its value is "g".</para>
        /// </summary>
        public static MdxKPIPropertyValues Goal => new("g");
        /// <summary>
        /// Status.
        /// <para>When the item is serialized out as xml, its value is "s".</para>
        /// </summary>
        public static MdxKPIPropertyValues Status => new("s");
        /// <summary>
        /// Trend.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static MdxKPIPropertyValues Trend => new("t");
        /// <summary>
        /// Weight.
        /// <para>When the item is serialized out as xml, its value is "w".</para>
        /// </summary>
        public static MdxKPIPropertyValues Weight => new("w");
        /// <summary>
        /// Current Time Member.
        /// <para>When the item is serialized out as xml, its value is "m".</para>
        /// </summary>
        public static MdxKPIPropertyValues Time => new("m");
    
    }

    /// <summary>
    /// Border Line Styles
    /// </summary>
    public readonly record struct BorderStyleValues : IEnumValue, IEnumValueFactory<BorderStyleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new BorderStyleValues enum instance
        /// </summary>
        public BorderStyleValues(string value) => _value = value;
        BorderStyleValues IEnumValueFactory<BorderStyleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "thin" => true,
            "medium" => true,
            "dashed" => true,
            "dotted" => true,
            "thick" => true,
            "double" => true,
            "hair" => true,
            "mediumDashed" => true,
            "dashDot" => true,
            "mediumDashDot" => true,
            "dashDotDot" => true,
            "mediumDashDotDot" => true,
            "slantDashDot" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static BorderStyleValues None => new("none");
        /// <summary>
        /// Thin Border.
        /// <para>When the item is serialized out as xml, its value is "thin".</para>
        /// </summary>
        public static BorderStyleValues Thin => new("thin");
        /// <summary>
        /// Medium Border.
        /// <para>When the item is serialized out as xml, its value is "medium".</para>
        /// </summary>
        public static BorderStyleValues Medium => new("medium");
        /// <summary>
        /// Dashed.
        /// <para>When the item is serialized out as xml, its value is "dashed".</para>
        /// </summary>
        public static BorderStyleValues Dashed => new("dashed");
        /// <summary>
        /// Dotted.
        /// <para>When the item is serialized out as xml, its value is "dotted".</para>
        /// </summary>
        public static BorderStyleValues Dotted => new("dotted");
        /// <summary>
        /// Thick Line Border.
        /// <para>When the item is serialized out as xml, its value is "thick".</para>
        /// </summary>
        public static BorderStyleValues Thick => new("thick");
        /// <summary>
        /// Double Line.
        /// <para>When the item is serialized out as xml, its value is "double".</para>
        /// </summary>
        public static BorderStyleValues Double => new("double");
        /// <summary>
        /// Hairline Border.
        /// <para>When the item is serialized out as xml, its value is "hair".</para>
        /// </summary>
        public static BorderStyleValues Hair => new("hair");
        /// <summary>
        /// Medium Dashed.
        /// <para>When the item is serialized out as xml, its value is "mediumDashed".</para>
        /// </summary>
        public static BorderStyleValues MediumDashed => new("mediumDashed");
        /// <summary>
        /// Dash Dot.
        /// <para>When the item is serialized out as xml, its value is "dashDot".</para>
        /// </summary>
        public static BorderStyleValues DashDot => new("dashDot");
        /// <summary>
        /// Medium Dash Dot.
        /// <para>When the item is serialized out as xml, its value is "mediumDashDot".</para>
        /// </summary>
        public static BorderStyleValues MediumDashDot => new("mediumDashDot");
        /// <summary>
        /// Dash Dot Dot.
        /// <para>When the item is serialized out as xml, its value is "dashDotDot".</para>
        /// </summary>
        public static BorderStyleValues DashDotDot => new("dashDotDot");
        /// <summary>
        /// Medium Dash Dot Dot.
        /// <para>When the item is serialized out as xml, its value is "mediumDashDotDot".</para>
        /// </summary>
        public static BorderStyleValues MediumDashDotDot => new("mediumDashDotDot");
        /// <summary>
        /// Slant Dash Dot.
        /// <para>When the item is serialized out as xml, its value is "slantDashDot".</para>
        /// </summary>
        public static BorderStyleValues SlantDashDot => new("slantDashDot");
    
    }

    /// <summary>
    /// Pattern Type
    /// </summary>
    public readonly record struct PatternValues : IEnumValue, IEnumValueFactory<PatternValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PatternValues enum instance
        /// </summary>
        public PatternValues(string value) => _value = value;
        PatternValues IEnumValueFactory<PatternValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "solid" => true,
            "mediumGray" => true,
            "darkGray" => true,
            "lightGray" => true,
            "darkHorizontal" => true,
            "darkVertical" => true,
            "darkDown" => true,
            "darkUp" => true,
            "darkGrid" => true,
            "darkTrellis" => true,
            "lightHorizontal" => true,
            "lightVertical" => true,
            "lightDown" => true,
            "lightUp" => true,
            "lightGrid" => true,
            "lightTrellis" => true,
            "gray125" => true,
            "gray0625" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static PatternValues None => new("none");
        /// <summary>
        /// Solid.
        /// <para>When the item is serialized out as xml, its value is "solid".</para>
        /// </summary>
        public static PatternValues Solid => new("solid");
        /// <summary>
        /// Medium Gray.
        /// <para>When the item is serialized out as xml, its value is "mediumGray".</para>
        /// </summary>
        public static PatternValues MediumGray => new("mediumGray");
        /// <summary>
        /// Dary Gray.
        /// <para>When the item is serialized out as xml, its value is "darkGray".</para>
        /// </summary>
        public static PatternValues DarkGray => new("darkGray");
        /// <summary>
        /// Light Gray.
        /// <para>When the item is serialized out as xml, its value is "lightGray".</para>
        /// </summary>
        public static PatternValues LightGray => new("lightGray");
        /// <summary>
        /// Dark Horizontal.
        /// <para>When the item is serialized out as xml, its value is "darkHorizontal".</para>
        /// </summary>
        public static PatternValues DarkHorizontal => new("darkHorizontal");
        /// <summary>
        /// Dark Vertical.
        /// <para>When the item is serialized out as xml, its value is "darkVertical".</para>
        /// </summary>
        public static PatternValues DarkVertical => new("darkVertical");
        /// <summary>
        /// Dark Down.
        /// <para>When the item is serialized out as xml, its value is "darkDown".</para>
        /// </summary>
        public static PatternValues DarkDown => new("darkDown");
        /// <summary>
        /// Dark Up.
        /// <para>When the item is serialized out as xml, its value is "darkUp".</para>
        /// </summary>
        public static PatternValues DarkUp => new("darkUp");
        /// <summary>
        /// Dark Grid.
        /// <para>When the item is serialized out as xml, its value is "darkGrid".</para>
        /// </summary>
        public static PatternValues DarkGrid => new("darkGrid");
        /// <summary>
        /// Dark Trellis.
        /// <para>When the item is serialized out as xml, its value is "darkTrellis".</para>
        /// </summary>
        public static PatternValues DarkTrellis => new("darkTrellis");
        /// <summary>
        /// Light Horizontal.
        /// <para>When the item is serialized out as xml, its value is "lightHorizontal".</para>
        /// </summary>
        public static PatternValues LightHorizontal => new("lightHorizontal");
        /// <summary>
        /// Light Vertical.
        /// <para>When the item is serialized out as xml, its value is "lightVertical".</para>
        /// </summary>
        public static PatternValues LightVertical => new("lightVertical");
        /// <summary>
        /// Light Down.
        /// <para>When the item is serialized out as xml, its value is "lightDown".</para>
        /// </summary>
        public static PatternValues LightDown => new("lightDown");
        /// <summary>
        /// Light Up.
        /// <para>When the item is serialized out as xml, its value is "lightUp".</para>
        /// </summary>
        public static PatternValues LightUp => new("lightUp");
        /// <summary>
        /// Light Grid.
        /// <para>When the item is serialized out as xml, its value is "lightGrid".</para>
        /// </summary>
        public static PatternValues LightGrid => new("lightGrid");
        /// <summary>
        /// Light Trellis.
        /// <para>When the item is serialized out as xml, its value is "lightTrellis".</para>
        /// </summary>
        public static PatternValues LightTrellis => new("lightTrellis");
        /// <summary>
        /// Gray 0.125.
        /// <para>When the item is serialized out as xml, its value is "gray125".</para>
        /// </summary>
        public static PatternValues Gray125 => new("gray125");
        /// <summary>
        /// Gray 0.0625.
        /// <para>When the item is serialized out as xml, its value is "gray0625".</para>
        /// </summary>
        public static PatternValues Gray0625 => new("gray0625");
    
    }

    /// <summary>
    /// Gradient Type
    /// </summary>
    public readonly record struct GradientValues : IEnumValue, IEnumValueFactory<GradientValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GradientValues enum instance
        /// </summary>
        public GradientValues(string value) => _value = value;
        GradientValues IEnumValueFactory<GradientValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "linear" => true,
            "path" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "linear";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Linear Gradient.
        /// <para>When the item is serialized out as xml, its value is "linear".</para>
        /// </summary>
        public static GradientValues Linear => new("linear");
        /// <summary>
        /// Path.
        /// <para>When the item is serialized out as xml, its value is "path".</para>
        /// </summary>
        public static GradientValues Path => new("path");
    
    }

    /// <summary>
    /// Horizontal Alignment Type
    /// </summary>
    public readonly record struct HorizontalAlignmentValues : IEnumValue, IEnumValueFactory<HorizontalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HorizontalAlignmentValues enum instance
        /// </summary>
        public HorizontalAlignmentValues(string value) => _value = value;
        HorizontalAlignmentValues IEnumValueFactory<HorizontalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "general" => true,
            "left" => true,
            "center" => true,
            "right" => true,
            "fill" => true,
            "justify" => true,
            "centerContinuous" => true,
            "distributed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "general";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// General Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "general".</para>
        /// </summary>
        public static HorizontalAlignmentValues General => new("general");
        /// <summary>
        /// Left Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "left".</para>
        /// </summary>
        public static HorizontalAlignmentValues Left => new("left");
        /// <summary>
        /// Centered Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// </summary>
        public static HorizontalAlignmentValues Center => new("center");
        /// <summary>
        /// Right Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "right".</para>
        /// </summary>
        public static HorizontalAlignmentValues Right => new("right");
        /// <summary>
        /// Fill.
        /// <para>When the item is serialized out as xml, its value is "fill".</para>
        /// </summary>
        public static HorizontalAlignmentValues Fill => new("fill");
        /// <summary>
        /// Justify.
        /// <para>When the item is serialized out as xml, its value is "justify".</para>
        /// </summary>
        public static HorizontalAlignmentValues Justify => new("justify");
        /// <summary>
        /// Center Continuous Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "centerContinuous".</para>
        /// </summary>
        public static HorizontalAlignmentValues CenterContinuous => new("centerContinuous");
        /// <summary>
        /// Distributed Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "distributed".</para>
        /// </summary>
        public static HorizontalAlignmentValues Distributed => new("distributed");
    
    }

    /// <summary>
    /// Vertical Alignment Types
    /// </summary>
    public readonly record struct VerticalAlignmentValues : IEnumValue, IEnumValueFactory<VerticalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VerticalAlignmentValues enum instance
        /// </summary>
        public VerticalAlignmentValues(string value) => _value = value;
        VerticalAlignmentValues IEnumValueFactory<VerticalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "top" => true,
            "center" => true,
            "bottom" => true,
            "justify" => true,
            "distributed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "top";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Align Top.
        /// <para>When the item is serialized out as xml, its value is "top".</para>
        /// </summary>
        public static VerticalAlignmentValues Top => new("top");
        /// <summary>
        /// Centered Vertical Alignment.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// </summary>
        public static VerticalAlignmentValues Center => new("center");
        /// <summary>
        /// Aligned To Bottom.
        /// <para>When the item is serialized out as xml, its value is "bottom".</para>
        /// </summary>
        public static VerticalAlignmentValues Bottom => new("bottom");
        /// <summary>
        /// Justified Vertically.
        /// <para>When the item is serialized out as xml, its value is "justify".</para>
        /// </summary>
        public static VerticalAlignmentValues Justify => new("justify");
        /// <summary>
        /// Distributed Vertical Alignment.
        /// <para>When the item is serialized out as xml, its value is "distributed".</para>
        /// </summary>
        public static VerticalAlignmentValues Distributed => new("distributed");
    
    }

    /// <summary>
    /// Table Style Type
    /// </summary>
    public readonly record struct TableStyleValues : IEnumValue, IEnumValueFactory<TableStyleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TableStyleValues enum instance
        /// </summary>
        public TableStyleValues(string value) => _value = value;
        TableStyleValues IEnumValueFactory<TableStyleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "wholeTable" => true,
            "headerRow" => true,
            "totalRow" => true,
            "firstColumn" => true,
            "lastColumn" => true,
            "firstRowStripe" => true,
            "secondRowStripe" => true,
            "firstColumnStripe" => true,
            "secondColumnStripe" => true,
            "firstHeaderCell" => true,
            "lastHeaderCell" => true,
            "firstTotalCell" => true,
            "lastTotalCell" => true,
            "firstSubtotalColumn" => true,
            "secondSubtotalColumn" => true,
            "thirdSubtotalColumn" => true,
            "firstSubtotalRow" => true,
            "secondSubtotalRow" => true,
            "thirdSubtotalRow" => true,
            "blankRow" => true,
            "firstColumnSubheading" => true,
            "secondColumnSubheading" => true,
            "thirdColumnSubheading" => true,
            "firstRowSubheading" => true,
            "secondRowSubheading" => true,
            "thirdRowSubheading" => true,
            "pageFieldLabels" => true,
            "pageFieldValues" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "wholeTable";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Whole Table Style.
        /// <para>When the item is serialized out as xml, its value is "wholeTable".</para>
        /// </summary>
        public static TableStyleValues WholeTable => new("wholeTable");
        /// <summary>
        /// Header Row Style.
        /// <para>When the item is serialized out as xml, its value is "headerRow".</para>
        /// </summary>
        public static TableStyleValues HeaderRow => new("headerRow");
        /// <summary>
        /// Total Row Style.
        /// <para>When the item is serialized out as xml, its value is "totalRow".</para>
        /// </summary>
        public static TableStyleValues TotalRow => new("totalRow");
        /// <summary>
        /// First Column Style.
        /// <para>When the item is serialized out as xml, its value is "firstColumn".</para>
        /// </summary>
        public static TableStyleValues FirstColumn => new("firstColumn");
        /// <summary>
        /// Last Column Style.
        /// <para>When the item is serialized out as xml, its value is "lastColumn".</para>
        /// </summary>
        public static TableStyleValues LastColumn => new("lastColumn");
        /// <summary>
        /// First Row Stripe Style.
        /// <para>When the item is serialized out as xml, its value is "firstRowStripe".</para>
        /// </summary>
        public static TableStyleValues FirstRowStripe => new("firstRowStripe");
        /// <summary>
        /// Second Row Stripe Style.
        /// <para>When the item is serialized out as xml, its value is "secondRowStripe".</para>
        /// </summary>
        public static TableStyleValues SecondRowStripe => new("secondRowStripe");
        /// <summary>
        /// First Column Stripe Style.
        /// <para>When the item is serialized out as xml, its value is "firstColumnStripe".</para>
        /// </summary>
        public static TableStyleValues FirstColumnStripe => new("firstColumnStripe");
        /// <summary>
        /// Second Column Stripe Style.
        /// <para>When the item is serialized out as xml, its value is "secondColumnStripe".</para>
        /// </summary>
        public static TableStyleValues SecondColumnStripe => new("secondColumnStripe");
        /// <summary>
        /// First Header Row Style.
        /// <para>When the item is serialized out as xml, its value is "firstHeaderCell".</para>
        /// </summary>
        public static TableStyleValues FirstHeaderCell => new("firstHeaderCell");
        /// <summary>
        /// Last Header Style.
        /// <para>When the item is serialized out as xml, its value is "lastHeaderCell".</para>
        /// </summary>
        public static TableStyleValues LastHeaderCell => new("lastHeaderCell");
        /// <summary>
        /// First Total Row Style.
        /// <para>When the item is serialized out as xml, its value is "firstTotalCell".</para>
        /// </summary>
        public static TableStyleValues FirstTotalCell => new("firstTotalCell");
        /// <summary>
        /// Last Total Row Style.
        /// <para>When the item is serialized out as xml, its value is "lastTotalCell".</para>
        /// </summary>
        public static TableStyleValues LastTotalCell => new("lastTotalCell");
        /// <summary>
        /// First Subtotal Column Style.
        /// <para>When the item is serialized out as xml, its value is "firstSubtotalColumn".</para>
        /// </summary>
        public static TableStyleValues FirstSubtotalColumn => new("firstSubtotalColumn");
        /// <summary>
        /// Second Subtotal Column Style.
        /// <para>When the item is serialized out as xml, its value is "secondSubtotalColumn".</para>
        /// </summary>
        public static TableStyleValues SecondSubtotalColumn => new("secondSubtotalColumn");
        /// <summary>
        /// Third Subtotal Column Style.
        /// <para>When the item is serialized out as xml, its value is "thirdSubtotalColumn".</para>
        /// </summary>
        public static TableStyleValues ThirdSubtotalColumn => new("thirdSubtotalColumn");
        /// <summary>
        /// First Subtotal Row Style.
        /// <para>When the item is serialized out as xml, its value is "firstSubtotalRow".</para>
        /// </summary>
        public static TableStyleValues FirstSubtotalRow => new("firstSubtotalRow");
        /// <summary>
        /// Second Subtotal Row Style.
        /// <para>When the item is serialized out as xml, its value is "secondSubtotalRow".</para>
        /// </summary>
        public static TableStyleValues SecondSubtotalRow => new("secondSubtotalRow");
        /// <summary>
        /// Third Subtotal Row Style.
        /// <para>When the item is serialized out as xml, its value is "thirdSubtotalRow".</para>
        /// </summary>
        public static TableStyleValues ThirdSubtotalRow => new("thirdSubtotalRow");
        /// <summary>
        /// Blank Row Style.
        /// <para>When the item is serialized out as xml, its value is "blankRow".</para>
        /// </summary>
        public static TableStyleValues BlankRow => new("blankRow");
        /// <summary>
        /// First Column Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "firstColumnSubheading".</para>
        /// </summary>
        public static TableStyleValues FirstColumnSubheading => new("firstColumnSubheading");
        /// <summary>
        /// Second Column Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "secondColumnSubheading".</para>
        /// </summary>
        public static TableStyleValues SecondColumnSubheading => new("secondColumnSubheading");
        /// <summary>
        /// Third Column Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "thirdColumnSubheading".</para>
        /// </summary>
        public static TableStyleValues ThirdColumnSubheading => new("thirdColumnSubheading");
        /// <summary>
        /// First Row Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "firstRowSubheading".</para>
        /// </summary>
        public static TableStyleValues FirstRowSubheading => new("firstRowSubheading");
        /// <summary>
        /// Second Row Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "secondRowSubheading".</para>
        /// </summary>
        public static TableStyleValues SecondRowSubheading => new("secondRowSubheading");
        /// <summary>
        /// Third Row Subheading Style.
        /// <para>When the item is serialized out as xml, its value is "thirdRowSubheading".</para>
        /// </summary>
        public static TableStyleValues ThirdRowSubheading => new("thirdRowSubheading");
        /// <summary>
        /// Page Field Labels Style.
        /// <para>When the item is serialized out as xml, its value is "pageFieldLabels".</para>
        /// </summary>
        public static TableStyleValues PageFieldLabels => new("pageFieldLabels");
        /// <summary>
        /// Page Field Values Style.
        /// <para>When the item is serialized out as xml, its value is "pageFieldValues".</para>
        /// </summary>
        public static TableStyleValues PageFieldValues => new("pageFieldValues");
    
    }

    /// <summary>
    /// Vertical Alignment Run Types
    /// </summary>
    public readonly record struct VerticalAlignmentRunValues : IEnumValue, IEnumValueFactory<VerticalAlignmentRunValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VerticalAlignmentRunValues enum instance
        /// </summary>
        public VerticalAlignmentRunValues(string value) => _value = value;
        VerticalAlignmentRunValues IEnumValueFactory<VerticalAlignmentRunValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "baseline" => true,
            "superscript" => true,
            "subscript" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "baseline";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Baseline.
        /// <para>When the item is serialized out as xml, its value is "baseline".</para>
        /// </summary>
        public static VerticalAlignmentRunValues Baseline => new("baseline");
        /// <summary>
        /// Superscript.
        /// <para>When the item is serialized out as xml, its value is "superscript".</para>
        /// </summary>
        public static VerticalAlignmentRunValues Superscript => new("superscript");
        /// <summary>
        /// Subscript.
        /// <para>When the item is serialized out as xml, its value is "subscript".</para>
        /// </summary>
        public static VerticalAlignmentRunValues Subscript => new("subscript");
    
    }

    /// <summary>
    /// Font scheme Styles
    /// </summary>
    public readonly record struct FontSchemeValues : IEnumValue, IEnumValueFactory<FontSchemeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FontSchemeValues enum instance
        /// </summary>
        public FontSchemeValues(string value) => _value = value;
        FontSchemeValues IEnumValueFactory<FontSchemeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "major" => true,
            "minor" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static FontSchemeValues None => new("none");
        /// <summary>
        /// Major Font.
        /// <para>When the item is serialized out as xml, its value is "major".</para>
        /// </summary>
        public static FontSchemeValues Major => new("major");
        /// <summary>
        /// Minor Font.
        /// <para>When the item is serialized out as xml, its value is "minor".</para>
        /// </summary>
        public static FontSchemeValues Minor => new("minor");
    
    }

    /// <summary>
    /// Underline Types
    /// </summary>
    public readonly record struct UnderlineValues : IEnumValue, IEnumValueFactory<UnderlineValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new UnderlineValues enum instance
        /// </summary>
        public UnderlineValues(string value) => _value = value;
        UnderlineValues IEnumValueFactory<UnderlineValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "single" => true,
            "double" => true,
            "singleAccounting" => true,
            "doubleAccounting" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "single";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Single Underline.
        /// <para>When the item is serialized out as xml, its value is "single".</para>
        /// </summary>
        public static UnderlineValues Single => new("single");
        /// <summary>
        /// Double Underline.
        /// <para>When the item is serialized out as xml, its value is "double".</para>
        /// </summary>
        public static UnderlineValues Double => new("double");
        /// <summary>
        /// Accounting Single Underline.
        /// <para>When the item is serialized out as xml, its value is "singleAccounting".</para>
        /// </summary>
        public static UnderlineValues SingleAccounting => new("singleAccounting");
        /// <summary>
        /// Accounting Double Underline.
        /// <para>When the item is serialized out as xml, its value is "doubleAccounting".</para>
        /// </summary>
        public static UnderlineValues DoubleAccounting => new("doubleAccounting");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static UnderlineValues None => new("none");
    
    }

    /// <summary>
    /// DDE Value Types
    /// </summary>
    public readonly record struct DdeValues : IEnumValue, IEnumValueFactory<DdeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DdeValues enum instance
        /// </summary>
        public DdeValues(string value) => _value = value;
        DdeValues IEnumValueFactory<DdeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "nil" => true,
            "b" => true,
            "n" => true,
            "e" => true,
            "str" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "nil";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Nil.
        /// <para>When the item is serialized out as xml, its value is "nil".</para>
        /// </summary>
        public static DdeValues Nil => new("nil");
        /// <summary>
        /// Boolean.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static DdeValues Boolean => new("b");
        /// <summary>
        /// Real Number.
        /// <para>When the item is serialized out as xml, its value is "n".</para>
        /// </summary>
        public static DdeValues RealNumber => new("n");
        /// <summary>
        /// Error.
        /// <para>When the item is serialized out as xml, its value is "e".</para>
        /// </summary>
        public static DdeValues Error => new("e");
        /// <summary>
        /// String.
        /// <para>When the item is serialized out as xml, its value is "str".</para>
        /// </summary>
        public static DdeValues String => new("str");
    
    }

    /// <summary>
    /// Table Type
    /// </summary>
    public readonly record struct TableValues : IEnumValue, IEnumValueFactory<TableValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TableValues enum instance
        /// </summary>
        public TableValues(string value) => _value = value;
        TableValues IEnumValueFactory<TableValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "worksheet" => true,
            "xml" => true,
            "queryTable" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "worksheet";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Worksheet.
        /// <para>When the item is serialized out as xml, its value is "worksheet".</para>
        /// </summary>
        public static TableValues Worksheet => new("worksheet");
        /// <summary>
        /// XML.
        /// <para>When the item is serialized out as xml, its value is "xml".</para>
        /// </summary>
        public static TableValues Xml => new("xml");
        /// <summary>
        /// Query Table.
        /// <para>When the item is serialized out as xml, its value is "queryTable".</para>
        /// </summary>
        public static TableValues QueryTable => new("queryTable");
    
    }

    /// <summary>
    /// Totals Row Function Types
    /// </summary>
    public readonly record struct TotalsRowFunctionValues : IEnumValue, IEnumValueFactory<TotalsRowFunctionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TotalsRowFunctionValues enum instance
        /// </summary>
        public TotalsRowFunctionValues(string value) => _value = value;
        TotalsRowFunctionValues IEnumValueFactory<TotalsRowFunctionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "sum" => true,
            "min" => true,
            "max" => true,
            "average" => true,
            "count" => true,
            "countNums" => true,
            "stdDev" => true,
            "var" => true,
            "custom" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static TotalsRowFunctionValues None => new("none");
        /// <summary>
        /// Sum.
        /// <para>When the item is serialized out as xml, its value is "sum".</para>
        /// </summary>
        public static TotalsRowFunctionValues Sum => new("sum");
        /// <summary>
        /// Minimum.
        /// <para>When the item is serialized out as xml, its value is "min".</para>
        /// </summary>
        public static TotalsRowFunctionValues Minimum => new("min");
        /// <summary>
        /// Maximum.
        /// <para>When the item is serialized out as xml, its value is "max".</para>
        /// </summary>
        public static TotalsRowFunctionValues Maximum => new("max");
        /// <summary>
        /// Average.
        /// <para>When the item is serialized out as xml, its value is "average".</para>
        /// </summary>
        public static TotalsRowFunctionValues Average => new("average");
        /// <summary>
        /// Non Empty Cell Count.
        /// <para>When the item is serialized out as xml, its value is "count".</para>
        /// </summary>
        public static TotalsRowFunctionValues Count => new("count");
        /// <summary>
        /// Count Numbers.
        /// <para>When the item is serialized out as xml, its value is "countNums".</para>
        /// </summary>
        public static TotalsRowFunctionValues CountNumbers => new("countNums");
        /// <summary>
        /// StdDev.
        /// <para>When the item is serialized out as xml, its value is "stdDev".</para>
        /// </summary>
        public static TotalsRowFunctionValues StandardDeviation => new("stdDev");
        /// <summary>
        /// Var.
        /// <para>When the item is serialized out as xml, its value is "var".</para>
        /// </summary>
        public static TotalsRowFunctionValues Variance => new("var");
        /// <summary>
        /// Custom Formula.
        /// <para>When the item is serialized out as xml, its value is "custom".</para>
        /// </summary>
        public static TotalsRowFunctionValues Custom => new("custom");
    
    }

    /// <summary>
    /// XML Data Types
    /// </summary>
    public readonly record struct XmlDataValues : IEnumValue, IEnumValueFactory<XmlDataValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new XmlDataValues enum instance
        /// </summary>
        public XmlDataValues(string value) => _value = value;
        XmlDataValues IEnumValueFactory<XmlDataValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "string" => true,
            "normalizedString" => true,
            "token" => true,
            "byte" => true,
            "unsignedByte" => true,
            "base64Binary" => true,
            "hexBinary" => true,
            "integer" => true,
            "positiveInteger" => true,
            "negativeInteger" => true,
            "nonPositiveInteger" => true,
            "nonNegativeInteger" => true,
            "int" => true,
            "unsignedInt" => true,
            "long" => true,
            "unsignedLong" => true,
            "short" => true,
            "unsignedShort" => true,
            "decimal" => true,
            "float" => true,
            "double" => true,
            "boolean" => true,
            "time" => true,
            "dateTime" => true,
            "duration" => true,
            "date" => true,
            "gMonth" => true,
            "gYear" => true,
            "gYearMonth" => true,
            "gDay" => true,
            "gMonthDay" => true,
            "Name" => true,
            "QName" => true,
            "NCName" => true,
            "anyURI" => true,
            "language" => true,
            "ID" => true,
            "IDREF" => true,
            "IDREFS" => true,
            "ENTITY" => true,
            "ENTITIES" => true,
            "NOTATION" => true,
            "NMTOKEN" => true,
            "NMTOKENS" => true,
            "anyType" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "string";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// String.
        /// <para>When the item is serialized out as xml, its value is "string".</para>
        /// </summary>
        public static XmlDataValues String => new("string");
        /// <summary>
        /// Normalized String.
        /// <para>When the item is serialized out as xml, its value is "normalizedString".</para>
        /// </summary>
        public static XmlDataValues NormalizedString => new("normalizedString");
        /// <summary>
        /// Token.
        /// <para>When the item is serialized out as xml, its value is "token".</para>
        /// </summary>
        public static XmlDataValues Token => new("token");
        /// <summary>
        /// Byte.
        /// <para>When the item is serialized out as xml, its value is "byte".</para>
        /// </summary>
        public static XmlDataValues Byte => new("byte");
        /// <summary>
        /// Unsigned Byte.
        /// <para>When the item is serialized out as xml, its value is "unsignedByte".</para>
        /// </summary>
        public static XmlDataValues UnsignedByte => new("unsignedByte");
        /// <summary>
        /// Base 64 Encoded Binary.
        /// <para>When the item is serialized out as xml, its value is "base64Binary".</para>
        /// </summary>
        public static XmlDataValues Base64Binary => new("base64Binary");
        /// <summary>
        /// Hex Binary.
        /// <para>When the item is serialized out as xml, its value is "hexBinary".</para>
        /// </summary>
        public static XmlDataValues HexBinary => new("hexBinary");
        /// <summary>
        /// Integer.
        /// <para>When the item is serialized out as xml, its value is "integer".</para>
        /// </summary>
        public static XmlDataValues Integer => new("integer");
        /// <summary>
        /// Positive Integer.
        /// <para>When the item is serialized out as xml, its value is "positiveInteger".</para>
        /// </summary>
        public static XmlDataValues PositiveInteger => new("positiveInteger");
        /// <summary>
        /// Negative Integer.
        /// <para>When the item is serialized out as xml, its value is "negativeInteger".</para>
        /// </summary>
        public static XmlDataValues NegativeInteger => new("negativeInteger");
        /// <summary>
        /// Non Positive Integer.
        /// <para>When the item is serialized out as xml, its value is "nonPositiveInteger".</para>
        /// </summary>
        public static XmlDataValues NonPositiveInteger => new("nonPositiveInteger");
        /// <summary>
        /// Non Negative Integer.
        /// <para>When the item is serialized out as xml, its value is "nonNegativeInteger".</para>
        /// </summary>
        public static XmlDataValues NonNegativeInteger => new("nonNegativeInteger");
        /// <summary>
        /// Integer.
        /// <para>When the item is serialized out as xml, its value is "int".</para>
        /// </summary>
        public static XmlDataValues Int => new("int");
        /// <summary>
        /// Unsigned Integer.
        /// <para>When the item is serialized out as xml, its value is "unsignedInt".</para>
        /// </summary>
        public static XmlDataValues UnsignedInteger => new("unsignedInt");
        /// <summary>
        /// Long.
        /// <para>When the item is serialized out as xml, its value is "long".</para>
        /// </summary>
        public static XmlDataValues Long => new("long");
        /// <summary>
        /// Unsigned Long.
        /// <para>When the item is serialized out as xml, its value is "unsignedLong".</para>
        /// </summary>
        public static XmlDataValues UnsignedLong => new("unsignedLong");
        /// <summary>
        /// Short.
        /// <para>When the item is serialized out as xml, its value is "short".</para>
        /// </summary>
        public static XmlDataValues Short => new("short");
        /// <summary>
        /// Unsigned Short.
        /// <para>When the item is serialized out as xml, its value is "unsignedShort".</para>
        /// </summary>
        public static XmlDataValues UnsignedShort => new("unsignedShort");
        /// <summary>
        /// Decimal.
        /// <para>When the item is serialized out as xml, its value is "decimal".</para>
        /// </summary>
        public static XmlDataValues Decimal => new("decimal");
        /// <summary>
        /// Float.
        /// <para>When the item is serialized out as xml, its value is "float".</para>
        /// </summary>
        public static XmlDataValues Float => new("float");
        /// <summary>
        /// Double.
        /// <para>When the item is serialized out as xml, its value is "double".</para>
        /// </summary>
        public static XmlDataValues Double => new("double");
        /// <summary>
        /// Boolean.
        /// <para>When the item is serialized out as xml, its value is "boolean".</para>
        /// </summary>
        public static XmlDataValues Boolean => new("boolean");
        /// <summary>
        /// Time.
        /// <para>When the item is serialized out as xml, its value is "time".</para>
        /// </summary>
        public static XmlDataValues Time => new("time");
        /// <summary>
        /// Date Time.
        /// <para>When the item is serialized out as xml, its value is "dateTime".</para>
        /// </summary>
        public static XmlDataValues DateTime => new("dateTime");
        /// <summary>
        /// Duration.
        /// <para>When the item is serialized out as xml, its value is "duration".</para>
        /// </summary>
        public static XmlDataValues Duration => new("duration");
        /// <summary>
        /// Date.
        /// <para>When the item is serialized out as xml, its value is "date".</para>
        /// </summary>
        public static XmlDataValues Date => new("date");
        /// <summary>
        /// gMonth.
        /// <para>When the item is serialized out as xml, its value is "gMonth".</para>
        /// </summary>
        public static XmlDataValues Gmonth => new("gMonth");
        /// <summary>
        /// gYear.
        /// <para>When the item is serialized out as xml, its value is "gYear".</para>
        /// </summary>
        public static XmlDataValues Gyear => new("gYear");
        /// <summary>
        /// gYearMonth.
        /// <para>When the item is serialized out as xml, its value is "gYearMonth".</para>
        /// </summary>
        public static XmlDataValues GYearMonth => new("gYearMonth");
        /// <summary>
        /// gDay.
        /// <para>When the item is serialized out as xml, its value is "gDay".</para>
        /// </summary>
        public static XmlDataValues Gday => new("gDay");
        /// <summary>
        /// gMonthDays.
        /// <para>When the item is serialized out as xml, its value is "gMonthDay".</para>
        /// </summary>
        public static XmlDataValues GMonthDay => new("gMonthDay");
        /// <summary>
        /// Name.
        /// <para>When the item is serialized out as xml, its value is "Name".</para>
        /// </summary>
        public static XmlDataValues Name => new("Name");
        /// <summary>
        /// Qname.
        /// <para>When the item is serialized out as xml, its value is "QName".</para>
        /// </summary>
        public static XmlDataValues Qname => new("QName");
        /// <summary>
        /// NCName.
        /// <para>When the item is serialized out as xml, its value is "NCName".</para>
        /// </summary>
        public static XmlDataValues NCName => new("NCName");
        /// <summary>
        /// Any URI.
        /// <para>When the item is serialized out as xml, its value is "anyURI".</para>
        /// </summary>
        public static XmlDataValues AnyURI => new("anyURI");
        /// <summary>
        /// Language.
        /// <para>When the item is serialized out as xml, its value is "language".</para>
        /// </summary>
        public static XmlDataValues Language => new("language");
        /// <summary>
        /// ID.
        /// <para>When the item is serialized out as xml, its value is "ID".</para>
        /// </summary>
        public static XmlDataValues Id => new("ID");
        /// <summary>
        /// IDREF.
        /// <para>When the item is serialized out as xml, its value is "IDREF".</para>
        /// </summary>
        public static XmlDataValues IdRef => new("IDREF");
        /// <summary>
        /// IDREFS.
        /// <para>When the item is serialized out as xml, its value is "IDREFS".</para>
        /// </summary>
        public static XmlDataValues IdRefs => new("IDREFS");
        /// <summary>
        /// ENTITY.
        /// <para>When the item is serialized out as xml, its value is "ENTITY".</para>
        /// </summary>
        public static XmlDataValues Entity => new("ENTITY");
        /// <summary>
        /// ENTITIES.
        /// <para>When the item is serialized out as xml, its value is "ENTITIES".</para>
        /// </summary>
        public static XmlDataValues Entities => new("ENTITIES");
        /// <summary>
        /// Notation.
        /// <para>When the item is serialized out as xml, its value is "NOTATION".</para>
        /// </summary>
        public static XmlDataValues Notation => new("NOTATION");
        /// <summary>
        /// NMTOKEN.
        /// <para>When the item is serialized out as xml, its value is "NMTOKEN".</para>
        /// </summary>
        public static XmlDataValues NMToken => new("NMTOKEN");
        /// <summary>
        /// NMTOKENS.
        /// <para>When the item is serialized out as xml, its value is "NMTOKENS".</para>
        /// </summary>
        public static XmlDataValues NMTokens => new("NMTOKENS");
        /// <summary>
        /// Any Type.
        /// <para>When the item is serialized out as xml, its value is "anyType".</para>
        /// </summary>
        public static XmlDataValues AnyType => new("anyType");
    
    }

    /// <summary>
    /// Volatile Dependency Types
    /// </summary>
    public readonly record struct VolatileDependencyValues : IEnumValue, IEnumValueFactory<VolatileDependencyValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VolatileDependencyValues enum instance
        /// </summary>
        public VolatileDependencyValues(string value) => _value = value;
        VolatileDependencyValues IEnumValueFactory<VolatileDependencyValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "realTimeData" => true,
            "olapFunctions" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "realTimeData";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Real Time Data.
        /// <para>When the item is serialized out as xml, its value is "realTimeData".</para>
        /// </summary>
        public static VolatileDependencyValues RealTimeData => new("realTimeData");
        /// <summary>
        /// OLAP Formulas.
        /// <para>When the item is serialized out as xml, its value is "olapFunctions".</para>
        /// </summary>
        public static VolatileDependencyValues OlapFunctions => new("olapFunctions");
    
    }

    /// <summary>
    /// Volatile Dependency Value Types
    /// </summary>
    public readonly record struct VolatileValues : IEnumValue, IEnumValueFactory<VolatileValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VolatileValues enum instance
        /// </summary>
        public VolatileValues(string value) => _value = value;
        VolatileValues IEnumValueFactory<VolatileValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "b" => true,
            "n" => true,
            "e" => true,
            "s" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "b";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Boolean.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static VolatileValues Boolean => new("b");
        /// <summary>
        /// Real Number.
        /// <para>When the item is serialized out as xml, its value is "n".</para>
        /// </summary>
        public static VolatileValues RealNumber => new("n");
        /// <summary>
        /// Error.
        /// <para>When the item is serialized out as xml, its value is "e".</para>
        /// </summary>
        public static VolatileValues Error => new("e");
        /// <summary>
        /// String.
        /// <para>When the item is serialized out as xml, its value is "s".</para>
        /// </summary>
        public static VolatileValues String => new("s");
    
    }

    /// <summary>
    /// Visibility Types
    /// </summary>
    public readonly record struct VisibilityValues : IEnumValue, IEnumValueFactory<VisibilityValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VisibilityValues enum instance
        /// </summary>
        public VisibilityValues(string value) => _value = value;
        VisibilityValues IEnumValueFactory<VisibilityValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "visible" => true,
            "hidden" => true,
            "veryHidden" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "visible";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Visible.
        /// <para>When the item is serialized out as xml, its value is "visible".</para>
        /// </summary>
        public static VisibilityValues Visible => new("visible");
        /// <summary>
        /// Hidden.
        /// <para>When the item is serialized out as xml, its value is "hidden".</para>
        /// </summary>
        public static VisibilityValues Hidden => new("hidden");
        /// <summary>
        /// Very Hidden.
        /// <para>When the item is serialized out as xml, its value is "veryHidden".</para>
        /// </summary>
        public static VisibilityValues VeryHidden => new("veryHidden");
    
    }

    /// <summary>
    /// Comment Display Types
    /// </summary>
    public readonly record struct CommentsValues : IEnumValue, IEnumValueFactory<CommentsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CommentsValues enum instance
        /// </summary>
        public CommentsValues(string value) => _value = value;
        CommentsValues IEnumValueFactory<CommentsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "commNone" => true,
            "commIndicator" => true,
            "commIndAndComment" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "commNone";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// No Comments.
        /// <para>When the item is serialized out as xml, its value is "commNone".</para>
        /// </summary>
        public static CommentsValues CommentNone => new("commNone");
        /// <summary>
        /// Show Comment Indicator.
        /// <para>When the item is serialized out as xml, its value is "commIndicator".</para>
        /// </summary>
        public static CommentsValues CommentIndicator => new("commIndicator");
        /// <summary>
        /// Show Comment and Indicator.
        /// <para>When the item is serialized out as xml, its value is "commIndAndComment".</para>
        /// </summary>
        public static CommentsValues CommentIndicatorAndComment => new("commIndAndComment");
    
    }

    /// <summary>
    /// Object Display Types
    /// </summary>
    public readonly record struct ObjectDisplayValues : IEnumValue, IEnumValueFactory<ObjectDisplayValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ObjectDisplayValues enum instance
        /// </summary>
        public ObjectDisplayValues(string value) => _value = value;
        ObjectDisplayValues IEnumValueFactory<ObjectDisplayValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "all" => true,
            "placeholders" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "all";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// All.
        /// <para>When the item is serialized out as xml, its value is "all".</para>
        /// </summary>
        public static ObjectDisplayValues All => new("all");
        /// <summary>
        /// Show Placeholders.
        /// <para>When the item is serialized out as xml, its value is "placeholders".</para>
        /// </summary>
        public static ObjectDisplayValues Placeholders => new("placeholders");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static ObjectDisplayValues None => new("none");
    
    }

    /// <summary>
    /// Sheet Visibility Types
    /// </summary>
    public readonly record struct SheetStateValues : IEnumValue, IEnumValueFactory<SheetStateValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SheetStateValues enum instance
        /// </summary>
        public SheetStateValues(string value) => _value = value;
        SheetStateValues IEnumValueFactory<SheetStateValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "visible" => true,
            "hidden" => true,
            "veryHidden" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "visible";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Visible.
        /// <para>When the item is serialized out as xml, its value is "visible".</para>
        /// </summary>
        public static SheetStateValues Visible => new("visible");
        /// <summary>
        /// Hidden.
        /// <para>When the item is serialized out as xml, its value is "hidden".</para>
        /// </summary>
        public static SheetStateValues Hidden => new("hidden");
        /// <summary>
        /// Very Hidden.
        /// <para>When the item is serialized out as xml, its value is "veryHidden".</para>
        /// </summary>
        public static SheetStateValues VeryHidden => new("veryHidden");
    
    }

    /// <summary>
    /// Update Links Behavior Types
    /// </summary>
    public readonly record struct UpdateLinksBehaviorValues : IEnumValue, IEnumValueFactory<UpdateLinksBehaviorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new UpdateLinksBehaviorValues enum instance
        /// </summary>
        public UpdateLinksBehaviorValues(string value) => _value = value;
        UpdateLinksBehaviorValues IEnumValueFactory<UpdateLinksBehaviorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "userSet" => true,
            "never" => true,
            "always" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "userSet";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// User Set.
        /// <para>When the item is serialized out as xml, its value is "userSet".</para>
        /// </summary>
        public static UpdateLinksBehaviorValues UserSet => new("userSet");
        /// <summary>
        /// Never Update Links.
        /// <para>When the item is serialized out as xml, its value is "never".</para>
        /// </summary>
        public static UpdateLinksBehaviorValues Never => new("never");
        /// <summary>
        /// Always Update Links.
        /// <para>When the item is serialized out as xml, its value is "always".</para>
        /// </summary>
        public static UpdateLinksBehaviorValues Always => new("always");
    
    }

    /// <summary>
    /// Calculation Mode
    /// </summary>
    public readonly record struct CalculateModeValues : IEnumValue, IEnumValueFactory<CalculateModeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CalculateModeValues enum instance
        /// </summary>
        public CalculateModeValues(string value) => _value = value;
        CalculateModeValues IEnumValueFactory<CalculateModeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "manual" => true,
            "auto" => true,
            "autoNoTable" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "manual";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Manual Calculation Mode.
        /// <para>When the item is serialized out as xml, its value is "manual".</para>
        /// </summary>
        public static CalculateModeValues Manual => new("manual");
        /// <summary>
        /// Automatic.
        /// <para>When the item is serialized out as xml, its value is "auto".</para>
        /// </summary>
        public static CalculateModeValues Auto => new("auto");
        /// <summary>
        /// Automatic Calculation (No Tables).
        /// <para>When the item is serialized out as xml, its value is "autoNoTable".</para>
        /// </summary>
        public static CalculateModeValues AutoNoTable => new("autoNoTable");
    
    }

    /// <summary>
    /// Reference Mode
    /// </summary>
    public readonly record struct ReferenceModeValues : IEnumValue, IEnumValueFactory<ReferenceModeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ReferenceModeValues enum instance
        /// </summary>
        public ReferenceModeValues(string value) => _value = value;
        ReferenceModeValues IEnumValueFactory<ReferenceModeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "A1" => true,
            "R1C1" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "A1";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// A1 Mode.
        /// <para>When the item is serialized out as xml, its value is "A1".</para>
        /// </summary>
        public static ReferenceModeValues A1 => new("A1");
        /// <summary>
        /// R1C1 Reference Mode.
        /// <para>When the item is serialized out as xml, its value is "R1C1".</para>
        /// </summary>
        public static ReferenceModeValues R1C1 => new("R1C1");
    
    }

    /// <summary>
    /// Target Screen Size Types
    /// </summary>
    public readonly record struct TargetScreenSizeValues : IEnumValue, IEnumValueFactory<TargetScreenSizeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TargetScreenSizeValues enum instance
        /// </summary>
        public TargetScreenSizeValues(string value) => _value = value;
        TargetScreenSizeValues IEnumValueFactory<TargetScreenSizeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "544x376" => true,
            "640x480" => true,
            "720x512" => true,
            "800x600" => true,
            "1024x768" => true,
            "1152x882" => true,
            "1152x900" => true,
            "1280x1024" => true,
            "1600x1200" => true,
            "1800x1440" => true,
            "1920x1200" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "544x376";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 544 x 376 Resolution.
        /// <para>When the item is serialized out as xml, its value is "544x376".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz544x376 => new("544x376");
        /// <summary>
        /// 640 x 480 Resolution.
        /// <para>When the item is serialized out as xml, its value is "640x480".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz640x480 => new("640x480");
        /// <summary>
        /// 720 x 512 Resolution.
        /// <para>When the item is serialized out as xml, its value is "720x512".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz720x512 => new("720x512");
        /// <summary>
        /// 800 x 600 Resolution.
        /// <para>When the item is serialized out as xml, its value is "800x600".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz800x600 => new("800x600");
        /// <summary>
        /// 1024 x 768 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1024x768".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1024x768 => new("1024x768");
        /// <summary>
        /// 1152 x 882 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1152x882".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1152x882 => new("1152x882");
        /// <summary>
        /// 1152 x 900 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1152x900".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1152x900 => new("1152x900");
        /// <summary>
        /// 1280 x 1024 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1280x1024".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1280x1024 => new("1280x1024");
        /// <summary>
        /// 1600 x 1200 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1600x1200".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1600x1200 => new("1600x1200");
        /// <summary>
        /// 1800 x 1440 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1800x1440".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1800x1440 => new("1800x1440");
        /// <summary>
        /// 1920 x 1200 Resolution.
        /// <para>When the item is serialized out as xml, its value is "1920x1200".</para>
        /// </summary>
        public static TargetScreenSizeValues Sz1920x1200 => new("1920x1200");
    
    }

    /// <summary>
    /// Defines the TextHorizontalAlignmentValues enumeration.
    /// </summary>
    public readonly record struct TextHorizontalAlignmentValues : IEnumValue, IEnumValueFactory<TextHorizontalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextHorizontalAlignmentValues enum instance
        /// </summary>
        public TextHorizontalAlignmentValues(string value) => _value = value;
        TextHorizontalAlignmentValues IEnumValueFactory<TextHorizontalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "left" => true,
            "center" => true,
            "right" => true,
            "justify" => true,
            "distributed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "left";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// left.
        /// <para>When the item is serialized out as xml, its value is "left".</para>
        /// </summary>
        public static TextHorizontalAlignmentValues Left => new("left");
        /// <summary>
        /// center.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// </summary>
        public static TextHorizontalAlignmentValues Center => new("center");
        /// <summary>
        /// right.
        /// <para>When the item is serialized out as xml, its value is "right".</para>
        /// </summary>
        public static TextHorizontalAlignmentValues Right => new("right");
        /// <summary>
        /// justify.
        /// <para>When the item is serialized out as xml, its value is "justify".</para>
        /// </summary>
        public static TextHorizontalAlignmentValues Justify => new("justify");
        /// <summary>
        /// distributed.
        /// <para>When the item is serialized out as xml, its value is "distributed".</para>
        /// </summary>
        public static TextHorizontalAlignmentValues Distributed => new("distributed");
    
    }

    /// <summary>
    /// Defines the TextVerticalAlignmentValues enumeration.
    /// </summary>
    public readonly record struct TextVerticalAlignmentValues : IEnumValue, IEnumValueFactory<TextVerticalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextVerticalAlignmentValues enum instance
        /// </summary>
        public TextVerticalAlignmentValues(string value) => _value = value;
        TextVerticalAlignmentValues IEnumValueFactory<TextVerticalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "top" => true,
            "center" => true,
            "bottom" => true,
            "justify" => true,
            "distributed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "top";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// top.
        /// <para>When the item is serialized out as xml, its value is "top".</para>
        /// </summary>
        public static TextVerticalAlignmentValues Top => new("top");
        /// <summary>
        /// center.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// </summary>
        public static TextVerticalAlignmentValues Center => new("center");
        /// <summary>
        /// bottom.
        /// <para>When the item is serialized out as xml, its value is "bottom".</para>
        /// </summary>
        public static TextVerticalAlignmentValues Bottom => new("bottom");
        /// <summary>
        /// justify.
        /// <para>When the item is serialized out as xml, its value is "justify".</para>
        /// </summary>
        public static TextVerticalAlignmentValues Justify => new("justify");
        /// <summary>
        /// distributed.
        /// <para>When the item is serialized out as xml, its value is "distributed".</para>
        /// </summary>
        public static TextVerticalAlignmentValues Distributed => new("distributed");
    
    }

    /// <summary>
    /// Cell Type
    /// </summary>
    public readonly record struct CellValues : IEnumValue, IEnumValueFactory<CellValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CellValues enum instance
        /// </summary>
        public CellValues(string value) => _value = value;
        CellValues IEnumValueFactory<CellValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "b" => true,
            "n" => true,
            "e" => true,
            "s" => true,
            "str" => true,
            "inlineStr" => true,
            "d" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "b";
        FileFormatVersions IEnumValue.Version => InternalValue switch
        {
            "d" => FileFormatVersions.Office2010,
            _ => FileFormatVersions.Office2007,
        };
        /// <summary>
        /// Boolean.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static CellValues Boolean => new("b");
        /// <summary>
        /// Number.
        /// <para>When the item is serialized out as xml, its value is "n".</para>
        /// </summary>
        public static CellValues Number => new("n");
        /// <summary>
        /// Error.
        /// <para>When the item is serialized out as xml, its value is "e".</para>
        /// </summary>
        public static CellValues Error => new("e");
        /// <summary>
        /// Shared String.
        /// <para>When the item is serialized out as xml, its value is "s".</para>
        /// </summary>
        public static CellValues SharedString => new("s");
        /// <summary>
        /// String.
        /// <para>When the item is serialized out as xml, its value is "str".</para>
        /// </summary>
        public static CellValues String => new("str");
        /// <summary>
        /// Inline String.
        /// <para>When the item is serialized out as xml, its value is "inlineStr".</para>
        /// </summary>
        public static CellValues InlineString => new("inlineStr");
        /// <summary>
        /// d.
        /// <para>When the item is serialized out as xml, its value is "d".</para>
        /// <para>This item is only available in Office 2010 and later.</para>
        /// </summary>
        public static CellValues Date => new("d");
    
    }

    /// <summary>
    /// Rule Type
    /// </summary>
    public readonly record struct PivotAreaValues : IEnumValue, IEnumValueFactory<PivotAreaValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PivotAreaValues enum instance
        /// </summary>
        public PivotAreaValues(string value) => _value = value;
        PivotAreaValues IEnumValueFactory<PivotAreaValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "normal" => true,
            "data" => true,
            "all" => true,
            "origin" => true,
            "button" => true,
            "topRight" => true,
            "topEnd" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => InternalValue switch
        {
            "topEnd" => FileFormatVersions.Office2010,
            _ => FileFormatVersions.Office2007,
        };
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static PivotAreaValues None => new("none");
        /// <summary>
        /// Normal.
        /// <para>When the item is serialized out as xml, its value is "normal".</para>
        /// </summary>
        public static PivotAreaValues Normal => new("normal");
        /// <summary>
        /// Data.
        /// <para>When the item is serialized out as xml, its value is "data".</para>
        /// </summary>
        public static PivotAreaValues Data => new("data");
        /// <summary>
        /// All.
        /// <para>When the item is serialized out as xml, its value is "all".</para>
        /// </summary>
        public static PivotAreaValues All => new("all");
        /// <summary>
        /// Origin.
        /// <para>When the item is serialized out as xml, its value is "origin".</para>
        /// </summary>
        public static PivotAreaValues Origin => new("origin");
        /// <summary>
        /// Field Button.
        /// <para>When the item is serialized out as xml, its value is "button".</para>
        /// </summary>
        public static PivotAreaValues Button => new("button");
        /// <summary>
        /// Top Right.
        /// <para>When the item is serialized out as xml, its value is "topRight".</para>
        /// </summary>
        public static PivotAreaValues TopRight => new("topRight");
        /// <summary>
        /// topEnd.
        /// <para>When the item is serialized out as xml, its value is "topEnd".</para>
        /// <para>This item is only available in Office 2010 and later.</para>
        /// </summary>
        public static PivotAreaValues TopEnd => new("topEnd");
    
    }

    /// <summary>
    /// Document Conformance Class Value
    /// </summary>
    public readonly record struct ConformanceClass : IEnumValue, IEnumValueFactory<ConformanceClass>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConformanceClass enum instance
        /// </summary>
        public ConformanceClass(string value) => _value = value;
        ConformanceClass IEnumValueFactory<ConformanceClass>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "strict" => true,
            "transitional" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "strict";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Office Open XML Strict.
        /// <para>When the item is serialized out as xml, its value is "strict".</para>
        /// </summary>
        public static ConformanceClass Enumstrict => new("strict");
        /// <summary>
        /// Office Open XML Transitional.
        /// <para>When the item is serialized out as xml, its value is "transitional".</para>
        /// </summary>
        public static ConformanceClass Enumtransitional => new("transitional");
    
    }
}