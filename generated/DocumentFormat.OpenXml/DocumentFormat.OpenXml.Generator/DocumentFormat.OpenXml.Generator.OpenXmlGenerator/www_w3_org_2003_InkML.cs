// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.EMMA;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using DocumentFormat.OpenXml.Validation.Semantic;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.InkML
{
    /// <summary>
    /// <para>Defines the Ink Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:ink.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Annotation" /> <c>&lt;inkml:annotation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.AnnotationXml" /> <c>&lt;inkml:annotationXML></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Context" /> <c>&lt;inkml:context></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Definitions" /> <c>&lt;inkml:definitions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Trace" /> <c>&lt;inkml:trace></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceGroup" /> <c>&lt;inkml:traceGroup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceView" /> <c>&lt;inkml:traceView></c></description></item>
    /// </list>
    /// </remark>
    public partial class Ink : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the Ink class.
        /// </summary>
        public Ink() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Ink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Ink(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Ink class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Ink(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Ink class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Ink(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>documentID</para>
        /// <para>Represents the following attribute in the schema: documentID</para>
        /// </summary>
        public StringValue? DocumentId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:ink");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Annotation>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.AnnotationXml>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Context>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Definitions>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Trace>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceGroup>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceView>();
            builder.AddElement<Ink>()
                .AddAttribute("documentID", a => a.DocumentId, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Annotation), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.AnnotationXml), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Definitions), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Context), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Trace), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceGroup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceView), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Ink>(deep);
    }

    /// <summary>
    /// <para>Defines the Bind Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:bind.</para>
    /// </summary>
    public partial class Bind : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Bind class.
        /// </summary>
        public Bind() : base()
        {
        }

        /// <summary>
        /// <para>source</para>
        /// <para>Represents the following attribute in the schema: source</para>
        /// </summary>
        public StringValue? Source
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>target</para>
        /// <para>Represents the following attribute in the schema: target</para>
        /// </summary>
        public StringValue? Target
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>column</para>
        /// <para>Represents the following attribute in the schema: column</para>
        /// </summary>
        public StringValue? Column
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>variable</para>
        /// <para>Represents the following attribute in the schema: variable</para>
        /// </summary>
        public StringValue? Variable
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:bind");
            builder.AddElement<Bind>()
                .AddAttribute("source", a => a.Source)
                .AddAttribute("target", a => a.Target)
                .AddAttribute("column", a => a.Column)
                .AddAttribute("variable", a => a.Variable);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Bind>(deep);
    }

    /// <summary>
    /// <para>Defines the Table Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:table.</para>
    /// </summary>
    public partial class Table : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the Table class.
        /// </summary>
        public Table() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Table class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Table(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>apply</para>
        /// <para>Represents the following attribute in the schema: apply</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.TableApplyValues>? Apply
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.TableApplyValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>interpolation</para>
        /// <para>Represents the following attribute in the schema: interpolation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.TableInterpolationValues>? Interpolation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.TableInterpolationValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:table");
            builder.AddElement<Table>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("apply", a => a.Apply)
                .AddAttribute("interpolation", a => a.Interpolation);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Table>(deep);
    }

    /// <summary>
    /// <para>Defines the Matrix Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:matrix.</para>
    /// </summary>
    public partial class Matrix : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the Matrix class.
        /// </summary>
        public Matrix() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Matrix class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Matrix(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:matrix");
            builder.AddElement<Matrix>()
                .AddAttribute("xml:id", a => a.Id);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Matrix>(deep);
    }

    /// <summary>
    /// <para>Defines the Mapping Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:mapping.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Bind" /> <c>&lt;inkml:bind></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Mapping" /> <c>&lt;inkml:mapping></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Matrix" /> <c>&lt;inkml:matrix></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Table" /> <c>&lt;inkml:table></c></description></item>
    /// </list>
    /// </remark>
    public partial class Mapping : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Mapping class.
        /// </summary>
        public Mapping() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mapping class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Mapping(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mapping class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Mapping(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Mapping class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Mapping(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.MappingTypeValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.MappingTypeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mappingRef</para>
        /// <para>Represents the following attribute in the schema: mappingRef</para>
        /// </summary>
        public StringValue? MappingRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:mapping");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Bind>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Mapping>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Matrix>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Table>();
            builder.AddElement<Mapping>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("type", a => a.Type)
                .AddAttribute("mappingRef", a => a.MappingRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                {
                    new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Bind), 0, 0),
                    new CompositeParticle.Builder(ParticleType.Choice, 0, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Table), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Matrix), 1, 1)
                    }
                },
                new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                {
                    new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Mapping), 0, 0)
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Mapping>(deep);
    }

    /// <summary>
    /// <para>Defines the Channel Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:channel.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Mapping" /> <c>&lt;inkml:mapping></c></description></item>
    /// </list>
    /// </remark>
    public partial class Channel : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Channel class.
        /// </summary>
        public Channel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Channel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Channel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Channel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Channel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Channel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Channel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.ChannelDataTypeValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.ChannelDataTypeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>default</para>
        /// <para>Represents the following attribute in the schema: default</para>
        /// </summary>
        public StringValue? Default
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>min</para>
        /// <para>Represents the following attribute in the schema: min</para>
        /// </summary>
        public DecimalValue? Min
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>max</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public DecimalValue? Max
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>orientation</para>
        /// <para>Represents the following attribute in the schema: orientation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.ChannelValueOrientationValues>? Orientation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.ChannelValueOrientationValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>respectTo</para>
        /// <para>Represents the following attribute in the schema: respectTo</para>
        /// </summary>
        public StringValue? RespectTo
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>units</para>
        /// <para>Represents the following attribute in the schema: units</para>
        /// </summary>
        public StringValue? Units
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:channel");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Mapping>();
            builder.AddElement<Channel>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardChannelNameValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("type", a => a.Type)
                .AddAttribute("default", a => a.Default, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DecimalValue>(NumberValidator.Instance);
                        union.AddValidator<BooleanValue>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("min", a => a.Min)
                .AddAttribute("max", a => a.Max)
                .AddAttribute("orientation", a => a.Orientation)
                .AddAttribute("respectTo", a => a.RespectTo, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("units", a => a.Units, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Mapping), 0, 0)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("inkml:units"), true, new string[] { "dev", "in", "cm", "deg", "rad", "s", "lb", "g" }) { Version = FileFormatVersions.Office2010 });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Channel>(deep);
    }

    /// <summary>
    /// <para>Defines the IntermittentChannels Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:intermittentChannels.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Channel" /> <c>&lt;inkml:channel></c></description></item>
    /// </list>
    /// </remark>
    public partial class IntermittentChannels : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the IntermittentChannels class.
        /// </summary>
        public IntermittentChannels() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the IntermittentChannels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IntermittentChannels(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IntermittentChannels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public IntermittentChannels(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the IntermittentChannels class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public IntermittentChannels(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:intermittentChannels");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Channel>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Channel), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<IntermittentChannels>(deep);
    }

    /// <summary>
    /// <para>Defines the ChannelProperty Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:channelProperty.</para>
    /// </summary>
    public partial class ChannelProperty : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ChannelProperty class.
        /// </summary>
        public ChannelProperty() : base()
        {
        }

        /// <summary>
        /// <para>channel</para>
        /// <para>Represents the following attribute in the schema: channel</para>
        /// </summary>
        public StringValue? Channel
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>value</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public DecimalValue? Value
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>units</para>
        /// <para>Represents the following attribute in the schema: units</para>
        /// </summary>
        public StringValue? Units
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:channelProperty");
            builder.AddElement<ChannelProperty>()
                .AddAttribute("channel", a => a.Channel, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardChannelNameValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardChannelPropertyNameValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("units", a => a.Units, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("inkml:units"), true, new string[] { "dev", "in", "cm", "deg", "rad", "s", "lb", "g" }) { Version = FileFormatVersions.Office2010 });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChannelProperty>(deep);
    }

    /// <summary>
    /// <para>Defines the TraceFormat Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:traceFormat.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Channel" /> <c>&lt;inkml:channel></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.IntermittentChannels" /> <c>&lt;inkml:intermittentChannels></c></description></item>
    /// </list>
    /// </remark>
    public partial class TraceFormat : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TraceFormat class.
        /// </summary>
        public TraceFormat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceFormat(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceFormat class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceFormat(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceFormat class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TraceFormat(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:traceFormat");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Channel>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.IntermittentChannels>();
            builder.AddElement<TraceFormat>()
                .AddAttribute("xml:id", a => a.Id);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Channel), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.IntermittentChannels), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TraceFormat>(deep);
    }

    /// <summary>
    /// <para>Defines the SampleRate Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:sampleRate.</para>
    /// </summary>
    public partial class SampleRate : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SampleRate class.
        /// </summary>
        public SampleRate() : base()
        {
        }

        /// <summary>
        /// <para>uniform</para>
        /// <para>Represents the following attribute in the schema: uniform</para>
        /// </summary>
        public BooleanValue? Uniform
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>value</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public DecimalValue? Value
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:sampleRate");
            builder.AddElement<SampleRate>()
                .AddAttribute("uniform", a => a.Uniform)
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SampleRate>(deep);
    }

    /// <summary>
    /// <para>Defines the Latency Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:latency.</para>
    /// </summary>
    public partial class Latency : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Latency class.
        /// </summary>
        public Latency() : base()
        {
        }

        /// <summary>
        /// <para>value</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public DecimalValue? Value
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:latency");
            builder.AddElement<Latency>()
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Latency>(deep);
    }

    /// <summary>
    /// <para>Defines the ActiveArea Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:activeArea.</para>
    /// </summary>
    public partial class ActiveArea : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ActiveArea class.
        /// </summary>
        public ActiveArea() : base()
        {
        }

        /// <summary>
        /// <para>size</para>
        /// <para>Represents the following attribute in the schema: size</para>
        /// </summary>
        public StringValue? Size
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>height</para>
        /// <para>Represents the following attribute in the schema: height</para>
        /// </summary>
        public DecimalValue? Height
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>width</para>
        /// <para>Represents the following attribute in the schema: width</para>
        /// </summary>
        public DecimalValue? Width
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>units</para>
        /// <para>Represents the following attribute in the schema: units</para>
        /// </summary>
        public StringValue? Units
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:activeArea");
            builder.AddElement<ActiveArea>()
                .AddAttribute("size", a => a.Size)
                .AddAttribute("height", a => a.Height)
                .AddAttribute("width", a => a.Width)
                .AddAttribute("units", a => a.Units, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("inkml:units"), true, new string[] { "dev", "in", "cm", "deg", "rad", "s", "lb", "g" }) { Version = FileFormatVersions.Office2010 });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ActiveArea>(deep);
    }

    /// <summary>
    /// <para>Defines the SourceProperty Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:srcProperty.</para>
    /// </summary>
    public partial class SourceProperty : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the SourceProperty class.
        /// </summary>
        public SourceProperty() : base()
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>value</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public DecimalValue? Value
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>units</para>
        /// <para>Represents the following attribute in the schema: units</para>
        /// </summary>
        public StringValue? Units
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:srcProperty");
            builder.AddElement<SourceProperty>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("units", a => a.Units, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("inkml:units"), true, new string[] { "dev", "in", "cm", "deg", "rad", "s", "lb", "g" }) { Version = FileFormatVersions.Office2010 });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SourceProperty>(deep);
    }

    /// <summary>
    /// <para>Defines the ChannelProperties Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:channelProperties.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.ChannelProperty" /> <c>&lt;inkml:channelProperty></c></description></item>
    /// </list>
    /// </remark>
    public partial class ChannelProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ChannelProperties class.
        /// </summary>
        public ChannelProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChannelProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChannelProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChannelProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChannelProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChannelProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChannelProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:channelProperties");
            builder.AddChild<DocumentFormat.OpenXml.InkML.ChannelProperty>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.ChannelProperty), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChannelProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the Annotation Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:annotation.</para>
    /// </summary>
    public partial class Annotation : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the Annotation class.
        /// </summary>
        public Annotation() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Annotation class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Annotation(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>encoding</para>
        /// <para>Represents the following attribute in the schema: encoding</para>
        /// </summary>
        public StringValue? Encoding
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:annotation");
            builder.AddElement<Annotation>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("encoding", a => a.Encoding);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Annotation>(deep);
    }

    /// <summary>
    /// <para>Defines the AnnotationXml Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:annotationXML.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.EMMA.Emma" /> <c>&lt;emma:emma></c></description></item>
    /// </list>
    /// </remark>
    public partial class AnnotationXml : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the AnnotationXml class.
        /// </summary>
        public AnnotationXml() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AnnotationXml class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AnnotationXml(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AnnotationXml class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AnnotationXml(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AnnotationXml class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AnnotationXml(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>encoding</para>
        /// <para>Represents the following attribute in the schema: encoding</para>
        /// </summary>
        public StringValue? Encoding
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>href</para>
        /// <para>Represents the following attribute in the schema: href</para>
        /// </summary>
        public StringValue? Href
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:annotationXML");
            builder.AddChild<DocumentFormat.OpenXml.EMMA.Emma>();
            builder.AddElement<AnnotationXml>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("encoding", a => a.Encoding)
                .AddAttribute("href", a => a.Href, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.EMMA.Emma), 0, 1)
            };
        }

        /// <summary>
        /// <para>Emma.</para>
        /// <para>Represents the following element tag in the schema: emma:emma.</para>
        /// </summary>
        /// <remark>
        /// xmlns:emma = http://www.w3.org/2003/04/emma
        /// </remark>
        public DocumentFormat.OpenXml.EMMA.Emma? Emma
        {
            get => GetElement<DocumentFormat.OpenXml.EMMA.Emma>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AnnotationXml>(deep);
    }

    /// <summary>
    /// <para>Defines the BrushProperty Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:brushProperty.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Annotation" /> <c>&lt;inkml:annotation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.AnnotationXml" /> <c>&lt;inkml:annotationXML></c></description></item>
    /// </list>
    /// </remark>
    public partial class BrushProperty : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the BrushProperty class.
        /// </summary>
        public BrushProperty() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BrushProperty class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BrushProperty(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BrushProperty class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public BrushProperty(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the BrushProperty class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public BrushProperty(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>value</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public StringValue? Value
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>units</para>
        /// <para>Represents the following attribute in the schema: units</para>
        /// </summary>
        public StringValue? Units
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:brushProperty");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Annotation>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.AnnotationXml>();
            builder.AddElement<BrushProperty>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardBrushPropertyNameValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("value", a => a.Value, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DecimalValue>(NumberValidator.Instance);
                        union.AddValidator<BooleanValue>(NumberValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.PenTipShapeValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.RasterOperationValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("units", a => a.Units, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerLengthUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerTimeUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerMassForceUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerAngleUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.InkML.StandardPerOtherUnitsValues>>(EnumValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Annotation), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.AnnotationXml), 0, 0)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("inkml:units"), true, new string[] { "dev", "in", "cm", "deg", "rad", "s", "lb", "g" }) { Version = FileFormatVersions.Office2010 });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BrushProperty>(deep);
    }

    /// <summary>
    /// <para>Defines the Canvas Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:canvas.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceFormat" /> <c>&lt;inkml:traceFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class Canvas : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Canvas class.
        /// </summary>
        public Canvas() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Canvas class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Canvas(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Canvas class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Canvas(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Canvas class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Canvas(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>traceFormatRef</para>
        /// <para>Represents the following attribute in the schema: traceFormatRef</para>
        /// </summary>
        public StringValue? TraceFormatRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:canvas");
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceFormat>();
            builder.AddElement<Canvas>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("traceFormatRef", a => a.TraceFormatRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceFormat), 0, 1)
            };
        }

        /// <summary>
        /// <para>TraceFormat.</para>
        /// <para>Represents the following element tag in the schema: inkml:traceFormat.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.TraceFormat? TraceFormat
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.TraceFormat>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Canvas>(deep);
    }

    /// <summary>
    /// <para>Defines the CanvasTransform Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:canvasTransform.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Mapping" /> <c>&lt;inkml:mapping></c></description></item>
    /// </list>
    /// </remark>
    public partial class CanvasTransform : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CanvasTransform class.
        /// </summary>
        public CanvasTransform() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CanvasTransform class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CanvasTransform(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CanvasTransform class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CanvasTransform(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CanvasTransform class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CanvasTransform(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>invertible</para>
        /// <para>Represents the following attribute in the schema: invertible</para>
        /// </summary>
        public BooleanValue? Invertible
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:canvasTransform");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Mapping>();
            builder.AddElement<CanvasTransform>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("invertible", a => a.Invertible);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Mapping), 1, 2)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CanvasTransform>(deep);
    }

    /// <summary>
    /// <para>Defines the InkSource Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:inkSource.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.ActiveArea" /> <c>&lt;inkml:activeArea></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.ChannelProperties" /> <c>&lt;inkml:channelProperties></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Latency" /> <c>&lt;inkml:latency></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.SampleRate" /> <c>&lt;inkml:sampleRate></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.SourceProperty" /> <c>&lt;inkml:srcProperty></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceFormat" /> <c>&lt;inkml:traceFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class InkSource : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the InkSource class.
        /// </summary>
        public InkSource() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the InkSource class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public InkSource(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the InkSource class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public InkSource(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the InkSource class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public InkSource(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>manufacturer</para>
        /// <para>Represents the following attribute in the schema: manufacturer</para>
        /// </summary>
        public StringValue? Manufacturer
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>model</para>
        /// <para>Represents the following attribute in the schema: model</para>
        /// </summary>
        public StringValue? Model
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>serialNo</para>
        /// <para>Represents the following attribute in the schema: serialNo</para>
        /// </summary>
        public StringValue? SerialNo
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>specificationRef</para>
        /// <para>Represents the following attribute in the schema: specificationRef</para>
        /// </summary>
        public StringValue? SpecificationRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>description</para>
        /// <para>Represents the following attribute in the schema: description</para>
        /// </summary>
        public StringValue? Description
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:inkSource");
            builder.AddChild<DocumentFormat.OpenXml.InkML.ActiveArea>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.ChannelProperties>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Latency>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.SampleRate>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.SourceProperty>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceFormat>();
            builder.AddElement<InkSource>()
                .AddAttribute("xml:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("manufacturer", a => a.Manufacturer)
                .AddAttribute("model", a => a.Model)
                .AddAttribute("serialNo", a => a.SerialNo)
                .AddAttribute("specificationRef", a => a.SpecificationRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("description", a => a.Description);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceFormat), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.SampleRate), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Latency), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.ActiveArea), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.SourceProperty), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.ChannelProperties), 0, 1)
            };
        }

        /// <summary>
        /// <para>TraceFormat.</para>
        /// <para>Represents the following element tag in the schema: inkml:traceFormat.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.TraceFormat? TraceFormat
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.TraceFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>SampleRate.</para>
        /// <para>Represents the following element tag in the schema: inkml:sampleRate.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.SampleRate? SampleRate
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.SampleRate>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Latency.</para>
        /// <para>Represents the following element tag in the schema: inkml:latency.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.Latency? Latency
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.Latency>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ActiveArea.</para>
        /// <para>Represents the following element tag in the schema: inkml:activeArea.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.ActiveArea? ActiveArea
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.ActiveArea>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<InkSource>(deep);
    }

    /// <summary>
    /// <para>Defines the Brush Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:brush.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Annotation" /> <c>&lt;inkml:annotation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.AnnotationXml" /> <c>&lt;inkml:annotationXML></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.BrushProperty" /> <c>&lt;inkml:brushProperty></c></description></item>
    /// </list>
    /// </remark>
    public partial class Brush : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Brush class.
        /// </summary>
        public Brush() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Brush class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Brush(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Brush class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Brush(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Brush class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Brush(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>brushRef</para>
        /// <para>Represents the following attribute in the schema: brushRef</para>
        /// </summary>
        public StringValue? BrushRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:brush");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Annotation>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.AnnotationXml>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.BrushProperty>();
            builder.AddElement<Brush>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("brushRef", a => a.BrushRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Annotation), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.AnnotationXml), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.BrushProperty), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Brush>(deep);
    }

    /// <summary>
    /// <para>Defines the Timestamp Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:timestamp.</para>
    /// </summary>
    public partial class Timestamp : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Timestamp class.
        /// </summary>
        public Timestamp() : base()
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>time</para>
        /// <para>Represents the following attribute in the schema: time</para>
        /// </summary>
        public DecimalValue? Time
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>timestampRef</para>
        /// <para>Represents the following attribute in the schema: timestampRef</para>
        /// </summary>
        public StringValue? TimestampRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>timeString</para>
        /// <para>Represents the following attribute in the schema: timeString</para>
        /// </summary>
        public DateTimeValue? TimeString
        {
            get => GetAttribute<DateTimeValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>timeOffset</para>
        /// <para>Represents the following attribute in the schema: timeOffset</para>
        /// </summary>
        public DecimalValue? TimeOffset
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:timestamp");
            builder.AddElement<Timestamp>()
                .AddAttribute("xml:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("time", a => a.Time)
                .AddAttribute("timestampRef", a => a.TimestampRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("timeString", a => a.TimeString)
                .AddAttribute("timeOffset", a => a.TimeOffset);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Timestamp>(deep);
    }

    /// <summary>
    /// <para>Defines the Trace Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:trace.</para>
    /// </summary>
    public partial class Trace : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the Trace class.
        /// </summary>
        public Trace() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Trace class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Trace(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.TraceTypeValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.TraceTypeValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>continuation</para>
        /// <para>Represents the following attribute in the schema: continuation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.InkML.TraceContinuationValues>? Continuation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.InkML.TraceContinuationValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>priorRef</para>
        /// <para>Represents the following attribute in the schema: priorRef</para>
        /// </summary>
        public StringValue? PriorRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>contextRef</para>
        /// <para>Represents the following attribute in the schema: contextRef</para>
        /// </summary>
        public StringValue? ContextRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>brushRef</para>
        /// <para>Represents the following attribute in the schema: brushRef</para>
        /// </summary>
        public StringValue? BrushRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>duration</para>
        /// <para>Represents the following attribute in the schema: duration</para>
        /// </summary>
        public DecimalValue? Duration
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>timeOffset</para>
        /// <para>Represents the following attribute in the schema: timeOffset</para>
        /// </summary>
        public DecimalValue? TimeOffset
        {
            get => GetAttribute<DecimalValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:trace");
            builder.AddElement<Trace>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("type", a => a.Type)
                .AddAttribute("continuation", a => a.Continuation)
                .AddAttribute("priorRef", a => a.PriorRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("contextRef", a => a.ContextRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("brushRef", a => a.BrushRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("duration", a => a.Duration)
                .AddAttribute("timeOffset", a => a.TimeOffset);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Trace>(deep);
    }

    /// <summary>
    /// <para>Defines the TraceGroup Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:traceGroup.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Annotation" /> <c>&lt;inkml:annotation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.AnnotationXml" /> <c>&lt;inkml:annotationXML></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Trace" /> <c>&lt;inkml:trace></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceGroup" /> <c>&lt;inkml:traceGroup></c></description></item>
    /// </list>
    /// </remark>
    public partial class TraceGroup : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TraceGroup class.
        /// </summary>
        public TraceGroup() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceGroup class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceGroup(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceGroup class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceGroup(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceGroup class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TraceGroup(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>contextRef</para>
        /// <para>Represents the following attribute in the schema: contextRef</para>
        /// </summary>
        public StringValue? ContextRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>brushRef</para>
        /// <para>Represents the following attribute in the schema: brushRef</para>
        /// </summary>
        public StringValue? BrushRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:traceGroup");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Annotation>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.AnnotationXml>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Trace>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceGroup>();
            builder.AddElement<TraceGroup>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("contextRef", a => a.ContextRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("brushRef", a => a.BrushRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Annotation), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.AnnotationXml), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Trace), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceGroup), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TraceGroup>(deep);
    }

    /// <summary>
    /// <para>Defines the TraceView Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:traceView.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Annotation" /> <c>&lt;inkml:annotation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.AnnotationXml" /> <c>&lt;inkml:annotationXML></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceView" /> <c>&lt;inkml:traceView></c></description></item>
    /// </list>
    /// </remark>
    public partial class TraceView : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TraceView class.
        /// </summary>
        public TraceView() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceView(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceView class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TraceView(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TraceView class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TraceView(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>contextRef</para>
        /// <para>Represents the following attribute in the schema: contextRef</para>
        /// </summary>
        public StringValue? ContextRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>traceDataRef</para>
        /// <para>Represents the following attribute in the schema: traceDataRef</para>
        /// </summary>
        public StringValue? TraceDataRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>from</para>
        /// <para>Represents the following attribute in the schema: from</para>
        /// </summary>
        public StringValue? From
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>to</para>
        /// <para>Represents the following attribute in the schema: to</para>
        /// </summary>
        public StringValue? To
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:traceView");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Annotation>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.AnnotationXml>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceView>();
            builder.AddElement<TraceView>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("contextRef", a => a.ContextRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("traceDataRef", a => a.TraceDataRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("from", a => a.From)
                .AddAttribute("to", a => a.To);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Annotation), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.AnnotationXml), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceView), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TraceView>(deep);
    }

    /// <summary>
    /// <para>Defines the Context Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:context.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Brush" /> <c>&lt;inkml:brush></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Canvas" /> <c>&lt;inkml:canvas></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.CanvasTransform" /> <c>&lt;inkml:canvasTransform></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.InkSource" /> <c>&lt;inkml:inkSource></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Timestamp" /> <c>&lt;inkml:timestamp></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceFormat" /> <c>&lt;inkml:traceFormat></c></description></item>
    /// </list>
    /// </remark>
    public partial class Context : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Context class.
        /// </summary>
        public Context() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Context class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Context(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Context class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Context(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Context class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Context(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: xml:id</para>
        /// </summary>
        /// <remark>
        /// xmlns:xml=http://www.w3.org/XML/1998/namespace
        /// </remark>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>contextRef</para>
        /// <para>Represents the following attribute in the schema: contextRef</para>
        /// </summary>
        public StringValue? ContextRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>canvasRef</para>
        /// <para>Represents the following attribute in the schema: canvasRef</para>
        /// </summary>
        public StringValue? CanvasRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>canvasTransformRef</para>
        /// <para>Represents the following attribute in the schema: canvasTransformRef</para>
        /// </summary>
        public StringValue? CanvasTransformRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>traceFormatRef</para>
        /// <para>Represents the following attribute in the schema: traceFormatRef</para>
        /// </summary>
        public StringValue? TraceFromatRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>inkSourceRef</para>
        /// <para>Represents the following attribute in the schema: inkSourceRef</para>
        /// </summary>
        public StringValue? InkSourceRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>brushRef</para>
        /// <para>Represents the following attribute in the schema: brushRef</para>
        /// </summary>
        public StringValue? BrushRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>timestampRef</para>
        /// <para>Represents the following attribute in the schema: timestampRef</para>
        /// </summary>
        public StringValue? TimestampRef
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:context");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Brush>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Canvas>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.CanvasTransform>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.InkSource>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Timestamp>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceFormat>();
            builder.AddElement<Context>()
                .AddAttribute("xml:id", a => a.Id)
                .AddAttribute("contextRef", a => a.ContextRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("canvasRef", a => a.CanvasRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("canvasTransformRef", a => a.CanvasTransformRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("traceFormatRef", a => a.TraceFromatRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("inkSourceRef", a => a.InkSourceRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("brushRef", a => a.BrushRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("timestampRef", a => a.TimestampRef, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Canvas), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.CanvasTransform), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.InkSource), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Brush), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Timestamp), 0, 1)
            };
        }

        /// <summary>
        /// <para>Canvas.</para>
        /// <para>Represents the following element tag in the schema: inkml:canvas.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.Canvas? Canvas
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.Canvas>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>CanvasTransform.</para>
        /// <para>Represents the following element tag in the schema: inkml:canvasTransform.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.CanvasTransform? CanvasTransform
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.CanvasTransform>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>TraceFormat.</para>
        /// <para>Represents the following element tag in the schema: inkml:traceFormat.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.TraceFormat? TraceFormat
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.TraceFormat>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>InkSource.</para>
        /// <para>Represents the following element tag in the schema: inkml:inkSource.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.InkSource? InkSource
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.InkSource>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Brush.</para>
        /// <para>Represents the following element tag in the schema: inkml:brush.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.Brush? Brush
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.Brush>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Timestamp.</para>
        /// <para>Represents the following element tag in the schema: inkml:timestamp.</para>
        /// </summary>
        /// <remark>
        /// xmlns:inkml = http://www.w3.org/2003/InkML
        /// </remark>
        public DocumentFormat.OpenXml.InkML.Timestamp? Timestamp
        {
            get => GetElement<DocumentFormat.OpenXml.InkML.Timestamp>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Context>(deep);
    }

    /// <summary>
    /// <para>Defines the Definitions Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is inkml:definitions.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Brush" /> <c>&lt;inkml:brush></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Canvas" /> <c>&lt;inkml:canvas></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.CanvasTransform" /> <c>&lt;inkml:canvasTransform></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Context" /> <c>&lt;inkml:context></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.InkSource" /> <c>&lt;inkml:inkSource></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Mapping" /> <c>&lt;inkml:mapping></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Timestamp" /> <c>&lt;inkml:timestamp></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.Trace" /> <c>&lt;inkml:trace></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceFormat" /> <c>&lt;inkml:traceFormat></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceGroup" /> <c>&lt;inkml:traceGroup></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.InkML.TraceView" /> <c>&lt;inkml:traceView></c></description></item>
    /// </list>
    /// </remark>
    public partial class Definitions : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Definitions class.
        /// </summary>
        public Definitions() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Definitions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Definitions(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Definitions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Definitions(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Definitions class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Definitions(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("inkml:definitions");
            builder.AddChild<DocumentFormat.OpenXml.InkML.Brush>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Canvas>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.CanvasTransform>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Context>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.InkSource>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Mapping>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Timestamp>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.Trace>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceFormat>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceGroup>();
            builder.AddChild<DocumentFormat.OpenXml.InkML.TraceView>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Brush), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Canvas), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.CanvasTransform), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Context), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.InkSource), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Mapping), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Timestamp), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.Trace), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceFormat), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceGroup), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.InkML.TraceView), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Definitions>(deep);
    }

    /// <summary>
    /// Defines the ChannelDataTypeValues enumeration.
    /// </summary>
    public readonly record struct ChannelDataTypeValues : IEnumValue, IEnumValueFactory<ChannelDataTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ChannelDataTypeValues enum instance
        /// </summary>
        public ChannelDataTypeValues(string value) => _value = value;
        ChannelDataTypeValues IEnumValueFactory<ChannelDataTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "integer" => true,
            "decimal" => true,
            "boolean" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "integer";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// integer.
        /// <para>When the item is serialized out as xml, its value is "integer".</para>
        /// </summary>
        public static ChannelDataTypeValues Integer => new("integer");
        /// <summary>
        /// decimal.
        /// <para>When the item is serialized out as xml, its value is "decimal".</para>
        /// </summary>
        public static ChannelDataTypeValues Decimal => new("decimal");
        /// <summary>
        /// boolean.
        /// <para>When the item is serialized out as xml, its value is "boolean".</para>
        /// </summary>
        public static ChannelDataTypeValues Boolean => new("boolean");
    
    }

    /// <summary>
    /// Defines the ChannelValueOrientationValues enumeration.
    /// </summary>
    public readonly record struct ChannelValueOrientationValues : IEnumValue, IEnumValueFactory<ChannelValueOrientationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ChannelValueOrientationValues enum instance
        /// </summary>
        public ChannelValueOrientationValues(string value) => _value = value;
        ChannelValueOrientationValues IEnumValueFactory<ChannelValueOrientationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "+ve" => true,
            "-ve" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "+ve";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// +ve.
        /// <para>When the item is serialized out as xml, its value is "+ve".</para>
        /// </summary>
        public static ChannelValueOrientationValues PlusVe => new("+ve");
        /// <summary>
        /// -ve.
        /// <para>When the item is serialized out as xml, its value is "-ve".</para>
        /// </summary>
        public static ChannelValueOrientationValues MinusVe => new("-ve");
    
    }

    /// <summary>
    /// Defines the StandardChannelPropertyNameValues enumeration.
    /// </summary>
    public readonly record struct StandardChannelPropertyNameValues : IEnumValue, IEnumValueFactory<StandardChannelPropertyNameValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardChannelPropertyNameValues enum instance
        /// </summary>
        public StandardChannelPropertyNameValues(string value) => _value = value;
        StandardChannelPropertyNameValues IEnumValueFactory<StandardChannelPropertyNameValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "threshold" => true,
            "resolution" => true,
            "quantization" => true,
            "noise" => true,
            "accuracy" => true,
            "crossCoupling" => true,
            "skew" => true,
            "minBandwidth" => true,
            "peakRate" => true,
            "distortion" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "threshold";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// threshold.
        /// <para>When the item is serialized out as xml, its value is "threshold".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Threshold => new("threshold");
        /// <summary>
        /// resolution.
        /// <para>When the item is serialized out as xml, its value is "resolution".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Resolution => new("resolution");
        /// <summary>
        /// quantization.
        /// <para>When the item is serialized out as xml, its value is "quantization".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Quantization => new("quantization");
        /// <summary>
        /// noise.
        /// <para>When the item is serialized out as xml, its value is "noise".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Noise => new("noise");
        /// <summary>
        /// accuracy.
        /// <para>When the item is serialized out as xml, its value is "accuracy".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Accuracy => new("accuracy");
        /// <summary>
        /// crossCoupling.
        /// <para>When the item is serialized out as xml, its value is "crossCoupling".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues CrossCoupling => new("crossCoupling");
        /// <summary>
        /// skew.
        /// <para>When the item is serialized out as xml, its value is "skew".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Skew => new("skew");
        /// <summary>
        /// minBandwidth.
        /// <para>When the item is serialized out as xml, its value is "minBandwidth".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues MinBandwidth => new("minBandwidth");
        /// <summary>
        /// peakRate.
        /// <para>When the item is serialized out as xml, its value is "peakRate".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues PeakRate => new("peakRate");
        /// <summary>
        /// distortion.
        /// <para>When the item is serialized out as xml, its value is "distortion".</para>
        /// </summary>
        public static StandardChannelPropertyNameValues Distortion => new("distortion");
    
    }

    /// <summary>
    /// Defines the StandardBrushPropertyNameValues enumeration.
    /// </summary>
    public readonly record struct StandardBrushPropertyNameValues : IEnumValue, IEnumValueFactory<StandardBrushPropertyNameValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardBrushPropertyNameValues enum instance
        /// </summary>
        public StandardBrushPropertyNameValues(string value) => _value = value;
        StandardBrushPropertyNameValues IEnumValueFactory<StandardBrushPropertyNameValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "width" => true,
            "height" => true,
            "color" => true,
            "transparency" => true,
            "tip" => true,
            "rasterOp" => true,
            "antiAliased" => true,
            "fitToCurve" => true,
            "ignorePressure" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "width";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// width.
        /// <para>When the item is serialized out as xml, its value is "width".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues Width => new("width");
        /// <summary>
        /// height.
        /// <para>When the item is serialized out as xml, its value is "height".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues Height => new("height");
        /// <summary>
        /// color.
        /// <para>When the item is serialized out as xml, its value is "color".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues Color => new("color");
        /// <summary>
        /// transparency.
        /// <para>When the item is serialized out as xml, its value is "transparency".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues Transparency => new("transparency");
        /// <summary>
        /// tip.
        /// <para>When the item is serialized out as xml, its value is "tip".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues Tip => new("tip");
        /// <summary>
        /// rasterOp.
        /// <para>When the item is serialized out as xml, its value is "rasterOp".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues RasterOp => new("rasterOp");
        /// <summary>
        /// antiAliased.
        /// <para>When the item is serialized out as xml, its value is "antiAliased".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues AntiAliased => new("antiAliased");
        /// <summary>
        /// fitToCurve.
        /// <para>When the item is serialized out as xml, its value is "fitToCurve".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues FitToCurve => new("fitToCurve");
        /// <summary>
        /// ignorePressure.
        /// <para>When the item is serialized out as xml, its value is "ignorePressure".</para>
        /// </summary>
        public static StandardBrushPropertyNameValues IgnorePressure => new("ignorePressure");
    
    }

    /// <summary>
    /// Defines the StandardChannelNameValues enumeration.
    /// </summary>
    public readonly record struct StandardChannelNameValues : IEnumValue, IEnumValueFactory<StandardChannelNameValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardChannelNameValues enum instance
        /// </summary>
        public StandardChannelNameValues(string value) => _value = value;
        StandardChannelNameValues IEnumValueFactory<StandardChannelNameValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "X" => true,
            "Y" => true,
            "Z" => true,
            "F" => true,
            "TP" => true,
            "BP" => true,
            "S" => true,
            "B1" => true,
            "B2" => true,
            "B3" => true,
            "B4" => true,
            "E" => true,
            "OTx" => true,
            "OTy" => true,
            "OA" => true,
            "OE" => true,
            "OR" => true,
            "RP" => true,
            "RR" => true,
            "RY" => true,
            "C" => true,
            "CR" => true,
            "CG" => true,
            "CB" => true,
            "CC" => true,
            "CM" => true,
            "CY" => true,
            "CK" => true,
            "W" => true,
            "T" => true,
            "SN" => true,
            "TW" => true,
            "TH" => true,
            "TC" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "X";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// X.
        /// <para>When the item is serialized out as xml, its value is "X".</para>
        /// </summary>
        public static StandardChannelNameValues XCoordinate => new("X");
        /// <summary>
        /// Y.
        /// <para>When the item is serialized out as xml, its value is "Y".</para>
        /// </summary>
        public static StandardChannelNameValues YCoordinate => new("Y");
        /// <summary>
        /// Z.
        /// <para>When the item is serialized out as xml, its value is "Z".</para>
        /// </summary>
        public static StandardChannelNameValues ZCoordinate => new("Z");
        /// <summary>
        /// F.
        /// <para>When the item is serialized out as xml, its value is "F".</para>
        /// </summary>
        public static StandardChannelNameValues PenTipForce => new("F");
        /// <summary>
        /// TP.
        /// <para>When the item is serialized out as xml, its value is "TP".</para>
        /// </summary>
        public static StandardChannelNameValues TangentPressure => new("TP");
        /// <summary>
        /// BP.
        /// <para>When the item is serialized out as xml, its value is "BP".</para>
        /// </summary>
        public static StandardChannelNameValues ButtonPressure => new("BP");
        /// <summary>
        /// S.
        /// <para>When the item is serialized out as xml, its value is "S".</para>
        /// </summary>
        public static StandardChannelNameValues TipSwitchState => new("S");
        /// <summary>
        /// B1.
        /// <para>When the item is serialized out as xml, its value is "B1".</para>
        /// </summary>
        public static StandardChannelNameValues SideButton1State => new("B1");
        /// <summary>
        /// B2.
        /// <para>When the item is serialized out as xml, its value is "B2".</para>
        /// </summary>
        public static StandardChannelNameValues SideButton2State => new("B2");
        /// <summary>
        /// B3.
        /// <para>When the item is serialized out as xml, its value is "B3".</para>
        /// </summary>
        public static StandardChannelNameValues SideButton3State => new("B3");
        /// <summary>
        /// B4.
        /// <para>When the item is serialized out as xml, its value is "B4".</para>
        /// </summary>
        public static StandardChannelNameValues SideButton4State => new("B4");
        /// <summary>
        /// E.
        /// <para>When the item is serialized out as xml, its value is "E".</para>
        /// </summary>
        public static StandardChannelNameValues PenInverted => new("E");
        /// <summary>
        /// OTx.
        /// <para>When the item is serialized out as xml, its value is "OTx".</para>
        /// </summary>
        public static StandardChannelNameValues TiltAlongXAxis => new("OTx");
        /// <summary>
        /// OTy.
        /// <para>When the item is serialized out as xml, its value is "OTy".</para>
        /// </summary>
        public static StandardChannelNameValues TiltAlongYAxis => new("OTy");
        /// <summary>
        /// OA.
        /// <para>When the item is serialized out as xml, its value is "OA".</para>
        /// </summary>
        public static StandardChannelNameValues PenAzimuthAngle => new("OA");
        /// <summary>
        /// OE.
        /// <para>When the item is serialized out as xml, its value is "OE".</para>
        /// </summary>
        public static StandardChannelNameValues PenElevationAngle => new("OE");
        /// <summary>
        /// OR.
        /// <para>When the item is serialized out as xml, its value is "OR".</para>
        /// </summary>
        public static StandardChannelNameValues PexAxisRotation => new("OR");
        /// <summary>
        /// RP.
        /// <para>When the item is serialized out as xml, its value is "RP".</para>
        /// </summary>
        public static StandardChannelNameValues PitchRotation => new("RP");
        /// <summary>
        /// RR.
        /// <para>When the item is serialized out as xml, its value is "RR".</para>
        /// </summary>
        public static StandardChannelNameValues RollRotation => new("RR");
        /// <summary>
        /// RY.
        /// <para>When the item is serialized out as xml, its value is "RY".</para>
        /// </summary>
        public static StandardChannelNameValues YawRotation => new("RY");
        /// <summary>
        /// C.
        /// <para>When the item is serialized out as xml, its value is "C".</para>
        /// </summary>
        public static StandardChannelNameValues ColorValue => new("C");
        /// <summary>
        /// CR.
        /// <para>When the item is serialized out as xml, its value is "CR".</para>
        /// </summary>
        public static StandardChannelNameValues RedColorValue => new("CR");
        /// <summary>
        /// CG.
        /// <para>When the item is serialized out as xml, its value is "CG".</para>
        /// </summary>
        public static StandardChannelNameValues GreenColorValue => new("CG");
        /// <summary>
        /// CB.
        /// <para>When the item is serialized out as xml, its value is "CB".</para>
        /// </summary>
        public static StandardChannelNameValues BlueColorValue => new("CB");
        /// <summary>
        /// CC.
        /// <para>When the item is serialized out as xml, its value is "CC".</para>
        /// </summary>
        public static StandardChannelNameValues CyanColorValue => new("CC");
        /// <summary>
        /// CM.
        /// <para>When the item is serialized out as xml, its value is "CM".</para>
        /// </summary>
        public static StandardChannelNameValues MegentaColorValue => new("CM");
        /// <summary>
        /// CY.
        /// <para>When the item is serialized out as xml, its value is "CY".</para>
        /// </summary>
        public static StandardChannelNameValues YellowColorValue => new("CY");
        /// <summary>
        /// CK.
        /// <para>When the item is serialized out as xml, its value is "CK".</para>
        /// </summary>
        public static StandardChannelNameValues BlackColorValue => new("CK");
        /// <summary>
        /// W.
        /// <para>When the item is serialized out as xml, its value is "W".</para>
        /// </summary>
        public static StandardChannelNameValues StrokesWidth => new("W");
        /// <summary>
        /// T.
        /// <para>When the item is serialized out as xml, its value is "T".</para>
        /// </summary>
        public static StandardChannelNameValues Time => new("T");
        /// <summary>
        /// SN.
        /// <para>When the item is serialized out as xml, its value is "SN".</para>
        /// </summary>
        public static StandardChannelNameValues SerialNumber => new("SN");
        /// <summary>
        /// TW.
        /// <para>When the item is serialized out as xml, its value is "TW".</para>
        /// </summary>
        public static StandardChannelNameValues TouchWidth => new("TW");
        /// <summary>
        /// TH.
        /// <para>When the item is serialized out as xml, its value is "TH".</para>
        /// </summary>
        public static StandardChannelNameValues TouchHeight => new("TH");
        /// <summary>
        /// TC.
        /// <para>When the item is serialized out as xml, its value is "TC".</para>
        /// </summary>
        public static StandardChannelNameValues FingerTouch => new("TC");
    
    }

    /// <summary>
    /// Defines the StandardLengthUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardLengthUnitsValues : IEnumValue, IEnumValueFactory<StandardLengthUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardLengthUnitsValues enum instance
        /// </summary>
        public StandardLengthUnitsValues(string value) => _value = value;
        StandardLengthUnitsValues IEnumValueFactory<StandardLengthUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "m" => true,
            "cm" => true,
            "mm" => true,
            "in" => true,
            "pt" => true,
            "pc" => true,
            "em" => true,
            "ex" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "m";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// m.
        /// <para>When the item is serialized out as xml, its value is "m".</para>
        /// </summary>
        public static StandardLengthUnitsValues Meter => new("m");
        /// <summary>
        /// cm.
        /// <para>When the item is serialized out as xml, its value is "cm".</para>
        /// </summary>
        public static StandardLengthUnitsValues Centimeter => new("cm");
        /// <summary>
        /// mm.
        /// <para>When the item is serialized out as xml, its value is "mm".</para>
        /// </summary>
        public static StandardLengthUnitsValues Millimeter => new("mm");
        /// <summary>
        /// in.
        /// <para>When the item is serialized out as xml, its value is "in".</para>
        /// </summary>
        public static StandardLengthUnitsValues Inche => new("in");
        /// <summary>
        /// pt.
        /// <para>When the item is serialized out as xml, its value is "pt".</para>
        /// </summary>
        public static StandardLengthUnitsValues Point => new("pt");
        /// <summary>
        /// pc.
        /// <para>When the item is serialized out as xml, its value is "pc".</para>
        /// </summary>
        public static StandardLengthUnitsValues Pica => new("pc");
        /// <summary>
        /// em.
        /// <para>When the item is serialized out as xml, its value is "em".</para>
        /// </summary>
        public static StandardLengthUnitsValues Em => new("em");
        /// <summary>
        /// ex.
        /// <para>When the item is serialized out as xml, its value is "ex".</para>
        /// </summary>
        public static StandardLengthUnitsValues Ex => new("ex");
    
    }

    /// <summary>
    /// Defines the StandardPerLengthUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardPerLengthUnitsValues : IEnumValue, IEnumValueFactory<StandardPerLengthUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardPerLengthUnitsValues enum instance
        /// </summary>
        public StandardPerLengthUnitsValues(string value) => _value = value;
        StandardPerLengthUnitsValues IEnumValueFactory<StandardPerLengthUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1/m" => true,
            "1/cm" => true,
            "1/mm" => true,
            "1/in" => true,
            "1/pt" => true,
            "1/pc" => true,
            "1/em" => true,
            "1/ex" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1/m";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1/m.
        /// <para>When the item is serialized out as xml, its value is "1/m".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerMeter => new("1/m");
        /// <summary>
        /// 1/cm.
        /// <para>When the item is serialized out as xml, its value is "1/cm".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerCentimeter => new("1/cm");
        /// <summary>
        /// 1/mm.
        /// <para>When the item is serialized out as xml, its value is "1/mm".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerMillimeter => new("1/mm");
        /// <summary>
        /// 1/in.
        /// <para>When the item is serialized out as xml, its value is "1/in".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerInche => new("1/in");
        /// <summary>
        /// 1/pt.
        /// <para>When the item is serialized out as xml, its value is "1/pt".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerPoint => new("1/pt");
        /// <summary>
        /// 1/pc.
        /// <para>When the item is serialized out as xml, its value is "1/pc".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerPica => new("1/pc");
        /// <summary>
        /// 1/em.
        /// <para>When the item is serialized out as xml, its value is "1/em".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerEm => new("1/em");
        /// <summary>
        /// 1/ex.
        /// <para>When the item is serialized out as xml, its value is "1/ex".</para>
        /// </summary>
        public static StandardPerLengthUnitsValues PerEx => new("1/ex");
    
    }

    /// <summary>
    /// Defines the StandardTimeUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardTimeUnitsValues : IEnumValue, IEnumValueFactory<StandardTimeUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardTimeUnitsValues enum instance
        /// </summary>
        public StandardTimeUnitsValues(string value) => _value = value;
        StandardTimeUnitsValues IEnumValueFactory<StandardTimeUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "s" => true,
            "ms" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "s";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// s.
        /// <para>When the item is serialized out as xml, its value is "s".</para>
        /// </summary>
        public static StandardTimeUnitsValues Second => new("s");
        /// <summary>
        /// ms.
        /// <para>When the item is serialized out as xml, its value is "ms".</para>
        /// </summary>
        public static StandardTimeUnitsValues Millisecond => new("ms");
    
    }

    /// <summary>
    /// Defines the StandardPerTimeUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardPerTimeUnitsValues : IEnumValue, IEnumValueFactory<StandardPerTimeUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardPerTimeUnitsValues enum instance
        /// </summary>
        public StandardPerTimeUnitsValues(string value) => _value = value;
        StandardPerTimeUnitsValues IEnumValueFactory<StandardPerTimeUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1/s" => true,
            "1/ms" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1/s";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1/s.
        /// <para>When the item is serialized out as xml, its value is "1/s".</para>
        /// </summary>
        public static StandardPerTimeUnitsValues PerSecond => new("1/s");
        /// <summary>
        /// 1/ms.
        /// <para>When the item is serialized out as xml, its value is "1/ms".</para>
        /// </summary>
        public static StandardPerTimeUnitsValues PerMillisecond => new("1/ms");
    
    }

    /// <summary>
    /// Defines the StandardMassForceUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardMassForceUnitsValues : IEnumValue, IEnumValueFactory<StandardMassForceUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardMassForceUnitsValues enum instance
        /// </summary>
        public StandardMassForceUnitsValues(string value) => _value = value;
        StandardMassForceUnitsValues IEnumValueFactory<StandardMassForceUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "Kg" => true,
            "g" => true,
            "mg" => true,
            "N" => true,
            "lb" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "Kg";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Kg.
        /// <para>When the item is serialized out as xml, its value is "Kg".</para>
        /// </summary>
        public static StandardMassForceUnitsValues Kilogram => new("Kg");
        /// <summary>
        /// g.
        /// <para>When the item is serialized out as xml, its value is "g".</para>
        /// </summary>
        public static StandardMassForceUnitsValues Gram => new("g");
        /// <summary>
        /// mg.
        /// <para>When the item is serialized out as xml, its value is "mg".</para>
        /// </summary>
        public static StandardMassForceUnitsValues Milligram => new("mg");
        /// <summary>
        /// N.
        /// <para>When the item is serialized out as xml, its value is "N".</para>
        /// </summary>
        public static StandardMassForceUnitsValues Newton => new("N");
        /// <summary>
        /// lb.
        /// <para>When the item is serialized out as xml, its value is "lb".</para>
        /// </summary>
        public static StandardMassForceUnitsValues Pond => new("lb");
    
    }

    /// <summary>
    /// Defines the StandardPerMassForceUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardPerMassForceUnitsValues : IEnumValue, IEnumValueFactory<StandardPerMassForceUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardPerMassForceUnitsValues enum instance
        /// </summary>
        public StandardPerMassForceUnitsValues(string value) => _value = value;
        StandardPerMassForceUnitsValues IEnumValueFactory<StandardPerMassForceUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1/Kg" => true,
            "1/g" => true,
            "1/mg" => true,
            "1/N" => true,
            "1/lb" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1/Kg";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1/Kg.
        /// <para>When the item is serialized out as xml, its value is "1/Kg".</para>
        /// </summary>
        public static StandardPerMassForceUnitsValues PerKilogram => new("1/Kg");
        /// <summary>
        /// 1/g.
        /// <para>When the item is serialized out as xml, its value is "1/g".</para>
        /// </summary>
        public static StandardPerMassForceUnitsValues PerGram => new("1/g");
        /// <summary>
        /// 1/mg.
        /// <para>When the item is serialized out as xml, its value is "1/mg".</para>
        /// </summary>
        public static StandardPerMassForceUnitsValues PerMilligram => new("1/mg");
        /// <summary>
        /// 1/N.
        /// <para>When the item is serialized out as xml, its value is "1/N".</para>
        /// </summary>
        public static StandardPerMassForceUnitsValues PerNewton => new("1/N");
        /// <summary>
        /// 1/lb.
        /// <para>When the item is serialized out as xml, its value is "1/lb".</para>
        /// </summary>
        public static StandardPerMassForceUnitsValues PerPond => new("1/lb");
    
    }

    /// <summary>
    /// Defines the StandardAngleUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardAngleUnitsValues : IEnumValue, IEnumValueFactory<StandardAngleUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardAngleUnitsValues enum instance
        /// </summary>
        public StandardAngleUnitsValues(string value) => _value = value;
        StandardAngleUnitsValues IEnumValueFactory<StandardAngleUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "deg" => true,
            "rad" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "deg";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// deg.
        /// <para>When the item is serialized out as xml, its value is "deg".</para>
        /// </summary>
        public static StandardAngleUnitsValues Degree => new("deg");
        /// <summary>
        /// rad.
        /// <para>When the item is serialized out as xml, its value is "rad".</para>
        /// </summary>
        public static StandardAngleUnitsValues Radian => new("rad");
    
    }

    /// <summary>
    /// Defines the StandardPerAngleUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardPerAngleUnitsValues : IEnumValue, IEnumValueFactory<StandardPerAngleUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardPerAngleUnitsValues enum instance
        /// </summary>
        public StandardPerAngleUnitsValues(string value) => _value = value;
        StandardPerAngleUnitsValues IEnumValueFactory<StandardPerAngleUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1/deg" => true,
            "1/rad" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1/deg";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1/deg.
        /// <para>When the item is serialized out as xml, its value is "1/deg".</para>
        /// </summary>
        public static StandardPerAngleUnitsValues PerDegree => new("1/deg");
        /// <summary>
        /// 1/rad.
        /// <para>When the item is serialized out as xml, its value is "1/rad".</para>
        /// </summary>
        public static StandardPerAngleUnitsValues PerRadian => new("1/rad");
    
    }

    /// <summary>
    /// Defines the StandardOtherUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardOtherUnitsValues : IEnumValue, IEnumValueFactory<StandardOtherUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardOtherUnitsValues enum instance
        /// </summary>
        public StandardOtherUnitsValues(string value) => _value = value;
        StandardOtherUnitsValues IEnumValueFactory<StandardOtherUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "%" => true,
            "dev" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "%";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// %.
        /// <para>When the item is serialized out as xml, its value is "%".</para>
        /// </summary>
        public static StandardOtherUnitsValues Percentage => new("%");
        /// <summary>
        /// dev.
        /// <para>When the item is serialized out as xml, its value is "dev".</para>
        /// </summary>
        public static StandardOtherUnitsValues DeviceResolution => new("dev");
        /// <summary>
        /// none.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static StandardOtherUnitsValues None => new("none");
    
    }

    /// <summary>
    /// Defines the StandardPerOtherUnitsValues enumeration.
    /// </summary>
    public readonly record struct StandardPerOtherUnitsValues : IEnumValue, IEnumValueFactory<StandardPerOtherUnitsValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StandardPerOtherUnitsValues enum instance
        /// </summary>
        public StandardPerOtherUnitsValues(string value) => _value = value;
        StandardPerOtherUnitsValues IEnumValueFactory<StandardPerOtherUnitsValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1/%" => true,
            "1/dev" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1/%";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1/%.
        /// <para>When the item is serialized out as xml, its value is "1/%".</para>
        /// </summary>
        public static StandardPerOtherUnitsValues PerPercentage => new("1/%");
        /// <summary>
        /// 1/dev.
        /// <para>When the item is serialized out as xml, its value is "1/dev".</para>
        /// </summary>
        public static StandardPerOtherUnitsValues PerDeviceResolution => new("1/dev");
    
    }

    /// <summary>
    /// Defines the TraceTypeValues enumeration.
    /// </summary>
    public readonly record struct TraceTypeValues : IEnumValue, IEnumValueFactory<TraceTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TraceTypeValues enum instance
        /// </summary>
        public TraceTypeValues(string value) => _value = value;
        TraceTypeValues IEnumValueFactory<TraceTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "penDown" => true,
            "penUp" => true,
            "indeterminate" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "penDown";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// penDown.
        /// <para>When the item is serialized out as xml, its value is "penDown".</para>
        /// </summary>
        public static TraceTypeValues PenDown => new("penDown");
        /// <summary>
        /// penUp.
        /// <para>When the item is serialized out as xml, its value is "penUp".</para>
        /// </summary>
        public static TraceTypeValues PenUp => new("penUp");
        /// <summary>
        /// indeterminate.
        /// <para>When the item is serialized out as xml, its value is "indeterminate".</para>
        /// </summary>
        public static TraceTypeValues Indeterminate => new("indeterminate");
    
    }

    /// <summary>
    /// Defines the TraceContinuationValues enumeration.
    /// </summary>
    public readonly record struct TraceContinuationValues : IEnumValue, IEnumValueFactory<TraceContinuationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TraceContinuationValues enum instance
        /// </summary>
        public TraceContinuationValues(string value) => _value = value;
        TraceContinuationValues IEnumValueFactory<TraceContinuationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "begin" => true,
            "end" => true,
            "middle" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "begin";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// begin.
        /// <para>When the item is serialized out as xml, its value is "begin".</para>
        /// </summary>
        public static TraceContinuationValues Begin => new("begin");
        /// <summary>
        /// end.
        /// <para>When the item is serialized out as xml, its value is "end".</para>
        /// </summary>
        public static TraceContinuationValues End => new("end");
        /// <summary>
        /// middle.
        /// <para>When the item is serialized out as xml, its value is "middle".</para>
        /// </summary>
        public static TraceContinuationValues Middle => new("middle");
    
    }

    /// <summary>
    /// Defines the RasterOperationValues enumeration.
    /// </summary>
    public readonly record struct RasterOperationValues : IEnumValue, IEnumValueFactory<RasterOperationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RasterOperationValues enum instance
        /// </summary>
        public RasterOperationValues(string value) => _value = value;
        RasterOperationValues IEnumValueFactory<RasterOperationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "black" => true,
            "notMergePen" => true,
            "maskNotPen" => true,
            "notCopyPen" => true,
            "maskPenNot" => true,
            "not" => true,
            "xOrPen" => true,
            "notMaskPen" => true,
            "maskPen" => true,
            "notXOrPen" => true,
            "noOperation" => true,
            "mergeNotPen" => true,
            "copyPen" => true,
            "mergePenNot" => true,
            "mergePen" => true,
            "white" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "black";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// black.
        /// <para>When the item is serialized out as xml, its value is "black".</para>
        /// </summary>
        public static RasterOperationValues Black => new("black");
        /// <summary>
        /// notMergePen.
        /// <para>When the item is serialized out as xml, its value is "notMergePen".</para>
        /// </summary>
        public static RasterOperationValues NotMergePen => new("notMergePen");
        /// <summary>
        /// maskNotPen.
        /// <para>When the item is serialized out as xml, its value is "maskNotPen".</para>
        /// </summary>
        public static RasterOperationValues MaskNotPen => new("maskNotPen");
        /// <summary>
        /// notCopyPen.
        /// <para>When the item is serialized out as xml, its value is "notCopyPen".</para>
        /// </summary>
        public static RasterOperationValues NotCopyPen => new("notCopyPen");
        /// <summary>
        /// maskPenNot.
        /// <para>When the item is serialized out as xml, its value is "maskPenNot".</para>
        /// </summary>
        public static RasterOperationValues MaskPenNot => new("maskPenNot");
        /// <summary>
        /// not.
        /// <para>When the item is serialized out as xml, its value is "not".</para>
        /// </summary>
        public static RasterOperationValues Not => new("not");
        /// <summary>
        /// xOrPen.
        /// <para>When the item is serialized out as xml, its value is "xOrPen".</para>
        /// </summary>
        public static RasterOperationValues XOrPen => new("xOrPen");
        /// <summary>
        /// notMaskPen.
        /// <para>When the item is serialized out as xml, its value is "notMaskPen".</para>
        /// </summary>
        public static RasterOperationValues NotMaskPen => new("notMaskPen");
        /// <summary>
        /// maskPen.
        /// <para>When the item is serialized out as xml, its value is "maskPen".</para>
        /// </summary>
        public static RasterOperationValues MaskPen => new("maskPen");
        /// <summary>
        /// notXOrPen.
        /// <para>When the item is serialized out as xml, its value is "notXOrPen".</para>
        /// </summary>
        public static RasterOperationValues NotXOrPen => new("notXOrPen");
        /// <summary>
        /// noOperation.
        /// <para>When the item is serialized out as xml, its value is "noOperation".</para>
        /// </summary>
        public static RasterOperationValues NoOperation => new("noOperation");
        /// <summary>
        /// mergeNotPen.
        /// <para>When the item is serialized out as xml, its value is "mergeNotPen".</para>
        /// </summary>
        public static RasterOperationValues MergeNotPen => new("mergeNotPen");
        /// <summary>
        /// copyPen.
        /// <para>When the item is serialized out as xml, its value is "copyPen".</para>
        /// </summary>
        public static RasterOperationValues CopyPen => new("copyPen");
        /// <summary>
        /// mergePenNot.
        /// <para>When the item is serialized out as xml, its value is "mergePenNot".</para>
        /// </summary>
        public static RasterOperationValues MergePenNot => new("mergePenNot");
        /// <summary>
        /// mergePen.
        /// <para>When the item is serialized out as xml, its value is "mergePen".</para>
        /// </summary>
        public static RasterOperationValues MergePen => new("mergePen");
        /// <summary>
        /// white.
        /// <para>When the item is serialized out as xml, its value is "white".</para>
        /// </summary>
        public static RasterOperationValues White => new("white");
    
    }

    /// <summary>
    /// Defines the PenTipShapeValues enumeration.
    /// </summary>
    public readonly record struct PenTipShapeValues : IEnumValue, IEnumValueFactory<PenTipShapeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PenTipShapeValues enum instance
        /// </summary>
        public PenTipShapeValues(string value) => _value = value;
        PenTipShapeValues IEnumValueFactory<PenTipShapeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "ellipse" => true,
            "rectangle" => true,
            "drop" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "ellipse";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// ellipse.
        /// <para>When the item is serialized out as xml, its value is "ellipse".</para>
        /// </summary>
        public static PenTipShapeValues Ellipse => new("ellipse");
        /// <summary>
        /// rectangle.
        /// <para>When the item is serialized out as xml, its value is "rectangle".</para>
        /// </summary>
        public static PenTipShapeValues Rectangle => new("rectangle");
        /// <summary>
        /// drop.
        /// <para>When the item is serialized out as xml, its value is "drop".</para>
        /// </summary>
        public static PenTipShapeValues Drop => new("drop");
    
    }

    /// <summary>
    /// Defines the MappingTypeValues enumeration.
    /// </summary>
    public readonly record struct MappingTypeValues : IEnumValue, IEnumValueFactory<MappingTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new MappingTypeValues enum instance
        /// </summary>
        public MappingTypeValues(string value) => _value = value;
        MappingTypeValues IEnumValueFactory<MappingTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "identity" => true,
            "lookup" => true,
            "affine" => true,
            "mathml" => true,
            "product" => true,
            "unknown" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "identity";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// identity.
        /// <para>When the item is serialized out as xml, its value is "identity".</para>
        /// </summary>
        public static MappingTypeValues Identity => new("identity");
        /// <summary>
        /// lookup.
        /// <para>When the item is serialized out as xml, its value is "lookup".</para>
        /// </summary>
        public static MappingTypeValues Lookup => new("lookup");
        /// <summary>
        /// affine.
        /// <para>When the item is serialized out as xml, its value is "affine".</para>
        /// </summary>
        public static MappingTypeValues Affine => new("affine");
        /// <summary>
        /// mathml.
        /// <para>When the item is serialized out as xml, its value is "mathml".</para>
        /// </summary>
        public static MappingTypeValues MathML => new("mathml");
        /// <summary>
        /// product.
        /// <para>When the item is serialized out as xml, its value is "product".</para>
        /// </summary>
        public static MappingTypeValues Product => new("product");
        /// <summary>
        /// unknown.
        /// <para>When the item is serialized out as xml, its value is "unknown".</para>
        /// </summary>
        public static MappingTypeValues Unknown => new("unknown");
    
    }

    /// <summary>
    /// Defines the TableApplyValues enumeration.
    /// </summary>
    public readonly record struct TableApplyValues : IEnumValue, IEnumValueFactory<TableApplyValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TableApplyValues enum instance
        /// </summary>
        public TableApplyValues(string value) => _value = value;
        TableApplyValues IEnumValueFactory<TableApplyValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "absolute" => true,
            "relative" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "absolute";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// absolute.
        /// <para>When the item is serialized out as xml, its value is "absolute".</para>
        /// </summary>
        public static TableApplyValues Absolute => new("absolute");
        /// <summary>
        /// relative.
        /// <para>When the item is serialized out as xml, its value is "relative".</para>
        /// </summary>
        public static TableApplyValues Relative => new("relative");
    
    }

    /// <summary>
    /// Defines the TableInterpolationValues enumeration.
    /// </summary>
    public readonly record struct TableInterpolationValues : IEnumValue, IEnumValueFactory<TableInterpolationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TableInterpolationValues enum instance
        /// </summary>
        public TableInterpolationValues(string value) => _value = value;
        TableInterpolationValues IEnumValueFactory<TableInterpolationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "floor" => true,
            "middle" => true,
            "ceiling" => true,
            "linear" => true,
            "cubic" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "floor";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// floor.
        /// <para>When the item is serialized out as xml, its value is "floor".</para>
        /// </summary>
        public static TableInterpolationValues Floor => new("floor");
        /// <summary>
        /// middle.
        /// <para>When the item is serialized out as xml, its value is "middle".</para>
        /// </summary>
        public static TableInterpolationValues Middle => new("middle");
        /// <summary>
        /// ceiling.
        /// <para>When the item is serialized out as xml, its value is "ceiling".</para>
        /// </summary>
        public static TableInterpolationValues Ceiling => new("ceiling");
        /// <summary>
        /// linear.
        /// <para>When the item is serialized out as xml, its value is "linear".</para>
        /// </summary>
        public static TableInterpolationValues Linear => new("linear");
        /// <summary>
        /// cubic.
        /// <para>When the item is serialized out as xml, its value is "cubic".</para>
        /// </summary>
        public static TableInterpolationValues Cubic => new("cubic");
    
    }
}