// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.Office2010.Ink
{
    /// <summary>
    /// <para>Defines the ContextNode Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is msink:context.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Ink.SourceLink" /> <c>&lt;msink:sourceLink></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Ink.DestinationLink" /> <c>&lt;msink:destinationLink></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2010.Ink.ContextNodeProperty" /> <c>&lt;msink:property></c></description></item>
    /// </list>
    /// </remark>
    public partial class ContextNode : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ContextNode class.
        /// </summary>
        public ContextNode() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ContextNode class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ContextNode(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ContextNode class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ContextNode(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ContextNode class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ContextNode(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rotatedBoundingBox</para>
        /// <para>Represents the following attribute in the schema: rotatedBoundingBox</para>
        /// </summary>
        public ListValue<StringValue>? RotatedBoundingBox
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>alignmentLevel</para>
        /// <para>Represents the following attribute in the schema: alignmentLevel</para>
        /// </summary>
        public Int32Value? AlignmentLevel
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>contentType</para>
        /// <para>Represents the following attribute in the schema: contentType</para>
        /// </summary>
        public Int32Value? ContentType
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>ascender</para>
        /// <para>Represents the following attribute in the schema: ascender</para>
        /// </summary>
        public StringValue? Ascender
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>descender</para>
        /// <para>Represents the following attribute in the schema: descender</para>
        /// </summary>
        public StringValue? Descender
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>baseline</para>
        /// <para>Represents the following attribute in the schema: baseline</para>
        /// </summary>
        public StringValue? Baseline
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>midline</para>
        /// <para>Represents the following attribute in the schema: midline</para>
        /// </summary>
        public StringValue? Midline
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>customRecognizerId</para>
        /// <para>Represents the following attribute in the schema: customRecognizerId</para>
        /// </summary>
        public StringValue? CustomRecognizerId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mathML</para>
        /// <para>Represents the following attribute in the schema: mathML</para>
        /// </summary>
        public StringValue? MathML
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mathStruct</para>
        /// <para>Represents the following attribute in the schema: mathStruct</para>
        /// </summary>
        public StringValue? MathStruct
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>mathSymbol</para>
        /// <para>Represents the following attribute in the schema: mathSymbol</para>
        /// </summary>
        public StringValue? MathSymbol
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>beginModifierType</para>
        /// <para>Represents the following attribute in the schema: beginModifierType</para>
        /// </summary>
        public StringValue? BeginModifierType
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>endModifierType</para>
        /// <para>Represents the following attribute in the schema: endModifierType</para>
        /// </summary>
        public StringValue? EndModifierType
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>rotationAngle</para>
        /// <para>Represents the following attribute in the schema: rotationAngle</para>
        /// </summary>
        public Int32Value? RotationAngle
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hotPoints</para>
        /// <para>Represents the following attribute in the schema: hotPoints</para>
        /// </summary>
        public ListValue<StringValue>? HotPoints
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>centroid</para>
        /// <para>Represents the following attribute in the schema: centroid</para>
        /// </summary>
        public StringValue? Centroid
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>semanticType</para>
        /// <para>Represents the following attribute in the schema: semanticType</para>
        /// </summary>
        public StringValue? SemanticType
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>shapeName</para>
        /// <para>Represents the following attribute in the schema: shapeName</para>
        /// </summary>
        public StringValue? ShapeName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>shapeGeometry</para>
        /// <para>Represents the following attribute in the schema: shapeGeometry</para>
        /// </summary>
        public ListValue<StringValue>? ShapeGeometry
        {
            get => GetAttribute<ListValue<StringValue>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("msink:context");
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Ink.SourceLink>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Ink.DestinationLink>();
            builder.AddChild<DocumentFormat.OpenXml.Office2010.Ink.ContextNodeProperty>();
            builder.AddElement<ContextNode>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Office2010.Ink.KnownContextNodeTypeValues>>(EnumValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("rotatedBoundingBox", a => a.RotatedBoundingBox, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Pattern = ("-?[0-9]+,-?[0-9]+") });
                })
                .AddAttribute("alignmentLevel", a => a.AlignmentLevel)
                .AddAttribute("contentType", a => a.ContentType)
                .AddAttribute("ascender", a => a.Ascender, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<ListValue<StringValue>>(NumberValidator.Instance);
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("descender", a => a.Descender, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<ListValue<StringValue>>(NumberValidator.Instance);
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("baseline", a => a.Baseline, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<ListValue<StringValue>>(NumberValidator.Instance);
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("midline", a => a.Midline, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<ListValue<StringValue>>(NumberValidator.Instance);
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("customRecognizerId", a => a.CustomRecognizerId, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                })
                .AddAttribute("mathML", a => a.MathML)
                .AddAttribute("mathStruct", a => a.MathStruct)
                .AddAttribute("mathSymbol", a => a.MathSymbol)
                .AddAttribute("beginModifierType", a => a.BeginModifierType)
                .AddAttribute("endModifierType", a => a.EndModifierType)
                .AddAttribute("rotationAngle", a => a.RotationAngle)
                .AddAttribute("hotPoints", a => a.HotPoints, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Pattern = ("-?[0-9]+,-?[0-9]+") });
                })
                .AddAttribute("centroid", a => a.Centroid, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Pattern = ("-?[0-9]+,-?[0-9]+") });
                })
                .AddAttribute("semanticType", a => a.SemanticType, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Office2010.Ink.KnownSemanticTypeValues>>(EnumValidator.Instance);
                        union.AddValidator<UInt32Value>(NumberValidator.Instance);
                    });
                })
                .AddAttribute("shapeName", a => a.ShapeName)
                .AddAttribute("shapeGeometry", a => a.ShapeGeometry, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { Pattern = ("-?[0-9]+,-?[0-9]+") });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Ink.ContextNodeProperty), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Ink.SourceLink), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2010.Ink.DestinationLink), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ContextNode>(deep);
    }

    /// <summary>
    /// <para>Defines the ContextNodeProperty Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is msink:property.</para>
    /// </summary>
    public partial class ContextNodeProperty : OpenXmlLeafTextElement
    {
        /// <summary>
        /// Initializes a new instance of the ContextNodeProperty class.
        /// </summary>
        public ContextNodeProperty() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ContextNodeProperty class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public ContextNodeProperty(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new HexBinaryValue { InnerText = text };
        }

        /// <summary>
        /// <para>type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("msink:property");
            builder.AddElement<ContextNodeProperty>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true), Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ContextNodeProperty>(deep);
    }

    /// <summary>
    /// <para>Defines the SourceLink Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is msink:sourceLink.</para>
    /// </summary>
    public partial class SourceLink : ContextLinkType
    {
        /// <summary>
        /// Initializes a new instance of the SourceLink class.
        /// </summary>
        public SourceLink() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("msink:sourceLink");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SourceLink>(deep);
    }

    /// <summary>
    /// <para>Defines the DestinationLink Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is msink:destinationLink.</para>
    /// </summary>
    public partial class DestinationLink : ContextLinkType
    {
        /// <summary>
        /// Initializes a new instance of the DestinationLink class.
        /// </summary>
        public DestinationLink() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("msink:destinationLink");
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DestinationLink>(deep);
    }

    /// <summary>
    /// <para>Defines the ContextLinkType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class ContextLinkType : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ContextLinkType class.
        /// </summary>
        protected ContextLinkType() : base()
        {
        }

        /// <summary>
        /// <para>direction</para>
        /// <para>Represents the following attribute in the schema: direction</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2010.Ink.LinkDirectionValues>? Direction
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2010.Ink.LinkDirectionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>ref</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<ContextLinkType>()
                .AddAttribute("direction", a => a.Direction)
                .AddAttribute("ref", a => a.Reference, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                        union.AddValidator<UInt32Value>(NumberValidator.Instance);
                    });
                });
        }
    }

    /// <summary>
    /// Defines the KnownContextNodeTypeValues enumeration.
    /// </summary>
    public readonly record struct KnownContextNodeTypeValues : IEnumValue, IEnumValueFactory<KnownContextNodeTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new KnownContextNodeTypeValues enum instance
        /// </summary>
        public KnownContextNodeTypeValues(string value) => _value = value;
        KnownContextNodeTypeValues IEnumValueFactory<KnownContextNodeTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "root" => true,
            "unclassifiedInk" => true,
            "writingRegion" => true,
            "analysisHint" => true,
            "object" => true,
            "inkDrawing" => true,
            "image" => true,
            "paragraph" => true,
            "line" => true,
            "inkBullet" => true,
            "inkWord" => true,
            "textWord" => true,
            "customRecognizer" => true,
            "mathRegion" => true,
            "mathEquation" => true,
            "mathStruct" => true,
            "mathSymbol" => true,
            "mathIdentifier" => true,
            "mathOperator" => true,
            "mathNumber" => true,
            "nonInkDrawing" => true,
            "groupNode" => true,
            "mixedDrawing" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "root";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// root.
        /// <para>When the item is serialized out as xml, its value is "root".</para>
        /// </summary>
        public static KnownContextNodeTypeValues Root => new("root");
        /// <summary>
        /// unclassifiedInk.
        /// <para>When the item is serialized out as xml, its value is "unclassifiedInk".</para>
        /// </summary>
        public static KnownContextNodeTypeValues UnclassifiedInk => new("unclassifiedInk");
        /// <summary>
        /// writingRegion.
        /// <para>When the item is serialized out as xml, its value is "writingRegion".</para>
        /// </summary>
        public static KnownContextNodeTypeValues WritingRegion => new("writingRegion");
        /// <summary>
        /// analysisHint.
        /// <para>When the item is serialized out as xml, its value is "analysisHint".</para>
        /// </summary>
        public static KnownContextNodeTypeValues AnalysisHint => new("analysisHint");
        /// <summary>
        /// object.
        /// <para>When the item is serialized out as xml, its value is "object".</para>
        /// </summary>
        public static KnownContextNodeTypeValues Object => new("object");
        /// <summary>
        /// inkDrawing.
        /// <para>When the item is serialized out as xml, its value is "inkDrawing".</para>
        /// </summary>
        public static KnownContextNodeTypeValues InkDrawing => new("inkDrawing");
        /// <summary>
        /// image.
        /// <para>When the item is serialized out as xml, its value is "image".</para>
        /// </summary>
        public static KnownContextNodeTypeValues Image => new("image");
        /// <summary>
        /// paragraph.
        /// <para>When the item is serialized out as xml, its value is "paragraph".</para>
        /// </summary>
        public static KnownContextNodeTypeValues Paragraph => new("paragraph");
        /// <summary>
        /// line.
        /// <para>When the item is serialized out as xml, its value is "line".</para>
        /// </summary>
        public static KnownContextNodeTypeValues Line => new("line");
        /// <summary>
        /// inkBullet.
        /// <para>When the item is serialized out as xml, its value is "inkBullet".</para>
        /// </summary>
        public static KnownContextNodeTypeValues InkBullet => new("inkBullet");
        /// <summary>
        /// inkWord.
        /// <para>When the item is serialized out as xml, its value is "inkWord".</para>
        /// </summary>
        public static KnownContextNodeTypeValues InkWord => new("inkWord");
        /// <summary>
        /// textWord.
        /// <para>When the item is serialized out as xml, its value is "textWord".</para>
        /// </summary>
        public static KnownContextNodeTypeValues TextWord => new("textWord");
        /// <summary>
        /// customRecognizer.
        /// <para>When the item is serialized out as xml, its value is "customRecognizer".</para>
        /// </summary>
        public static KnownContextNodeTypeValues CustomRecognizer => new("customRecognizer");
        /// <summary>
        /// mathRegion.
        /// <para>When the item is serialized out as xml, its value is "mathRegion".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathRegion => new("mathRegion");
        /// <summary>
        /// mathEquation.
        /// <para>When the item is serialized out as xml, its value is "mathEquation".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathEquation => new("mathEquation");
        /// <summary>
        /// mathStruct.
        /// <para>When the item is serialized out as xml, its value is "mathStruct".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathStruct => new("mathStruct");
        /// <summary>
        /// mathSymbol.
        /// <para>When the item is serialized out as xml, its value is "mathSymbol".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathSymbol => new("mathSymbol");
        /// <summary>
        /// mathIdentifier.
        /// <para>When the item is serialized out as xml, its value is "mathIdentifier".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathIdentifier => new("mathIdentifier");
        /// <summary>
        /// mathOperator.
        /// <para>When the item is serialized out as xml, its value is "mathOperator".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathOperator => new("mathOperator");
        /// <summary>
        /// mathNumber.
        /// <para>When the item is serialized out as xml, its value is "mathNumber".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MathNumber => new("mathNumber");
        /// <summary>
        /// nonInkDrawing.
        /// <para>When the item is serialized out as xml, its value is "nonInkDrawing".</para>
        /// </summary>
        public static KnownContextNodeTypeValues NonInkDrawing => new("nonInkDrawing");
        /// <summary>
        /// groupNode.
        /// <para>When the item is serialized out as xml, its value is "groupNode".</para>
        /// </summary>
        public static KnownContextNodeTypeValues GroupNode => new("groupNode");
        /// <summary>
        /// mixedDrawing.
        /// <para>When the item is serialized out as xml, its value is "mixedDrawing".</para>
        /// </summary>
        public static KnownContextNodeTypeValues MixedDrawing => new("mixedDrawing");
    
    }

    /// <summary>
    /// Defines the LinkDirectionValues enumeration.
    /// </summary>
    public readonly record struct LinkDirectionValues : IEnumValue, IEnumValueFactory<LinkDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new LinkDirectionValues enum instance
        /// </summary>
        public LinkDirectionValues(string value) => _value = value;
        LinkDirectionValues IEnumValueFactory<LinkDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "to" => true,
            "from" => true,
            "with" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "to";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// to.
        /// <para>When the item is serialized out as xml, its value is "to".</para>
        /// </summary>
        public static LinkDirectionValues To => new("to");
        /// <summary>
        /// from.
        /// <para>When the item is serialized out as xml, its value is "from".</para>
        /// </summary>
        public static LinkDirectionValues From => new("from");
        /// <summary>
        /// with.
        /// <para>When the item is serialized out as xml, its value is "with".</para>
        /// </summary>
        public static LinkDirectionValues With => new("with");
    
    }

    /// <summary>
    /// Defines the KnownSemanticTypeValues enumeration.
    /// </summary>
    public readonly record struct KnownSemanticTypeValues : IEnumValue, IEnumValueFactory<KnownSemanticTypeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new KnownSemanticTypeValues enum instance
        /// </summary>
        public KnownSemanticTypeValues(string value) => _value = value;
        KnownSemanticTypeValues IEnumValueFactory<KnownSemanticTypeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "underline" => true,
            "strikethrough" => true,
            "highlight" => true,
            "scratchOut" => true,
            "verticalRange" => true,
            "callout" => true,
            "enclosure" => true,
            "comment" => true,
            "container" => true,
            "connector" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// none.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static KnownSemanticTypeValues None => new("none");
        /// <summary>
        /// underline.
        /// <para>When the item is serialized out as xml, its value is "underline".</para>
        /// </summary>
        public static KnownSemanticTypeValues Underline => new("underline");
        /// <summary>
        /// strikethrough.
        /// <para>When the item is serialized out as xml, its value is "strikethrough".</para>
        /// </summary>
        public static KnownSemanticTypeValues Strikethrough => new("strikethrough");
        /// <summary>
        /// highlight.
        /// <para>When the item is serialized out as xml, its value is "highlight".</para>
        /// </summary>
        public static KnownSemanticTypeValues Highlight => new("highlight");
        /// <summary>
        /// scratchOut.
        /// <para>When the item is serialized out as xml, its value is "scratchOut".</para>
        /// </summary>
        public static KnownSemanticTypeValues ScratchOut => new("scratchOut");
        /// <summary>
        /// verticalRange.
        /// <para>When the item is serialized out as xml, its value is "verticalRange".</para>
        /// </summary>
        public static KnownSemanticTypeValues VerticalRange => new("verticalRange");
        /// <summary>
        /// callout.
        /// <para>When the item is serialized out as xml, its value is "callout".</para>
        /// </summary>
        public static KnownSemanticTypeValues Callout => new("callout");
        /// <summary>
        /// enclosure.
        /// <para>When the item is serialized out as xml, its value is "enclosure".</para>
        /// </summary>
        public static KnownSemanticTypeValues Enclosure => new("enclosure");
        /// <summary>
        /// comment.
        /// <para>When the item is serialized out as xml, its value is "comment".</para>
        /// </summary>
        public static KnownSemanticTypeValues Comment => new("comment");
        /// <summary>
        /// container.
        /// <para>When the item is serialized out as xml, its value is "container".</para>
        /// </summary>
        public static KnownSemanticTypeValues Container => new("container");
        /// <summary>
        /// connector.
        /// <para>When the item is serialized out as xml, its value is "connector".</para>
        /// </summary>
        public static KnownSemanticTypeValues Connector => new("connector");
    
    }
}