// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using DocumentFormat.OpenXml.Validation.Semantic;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.VariantTypes
{
    /// <summary>
    /// <para>Variant.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:variant.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTArray" /> <c>&lt;vt:array></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTClipboardData" /> <c>&lt;vt:cf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTEmpty" /> <c>&lt;vt:empty></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTNull" /> <c>&lt;vt:null></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.Variant" /> <c>&lt;vt:variant></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTVector" /> <c>&lt;vt:vector></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTVStreamData" /> <c>&lt;vt:vstream></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTClassId" /> <c>&lt;vt:clsid></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTCurrency" /> <c>&lt;vt:cy></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTError" /> <c>&lt;vt:error></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBlob" /> <c>&lt;vt:blob></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTOBlob" /> <c>&lt;vt:oblob></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTStreamData" /> <c>&lt;vt:stream></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTOStreamData" /> <c>&lt;vt:ostream></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTStorage" /> <c>&lt;vt:storage></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTOStorage" /> <c>&lt;vt:ostorage></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBool" /> <c>&lt;vt:bool></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTByte" /> <c>&lt;vt:i1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDate" /> <c>&lt;vt:date></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTFileTime" /> <c>&lt;vt:filetime></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDecimal" /> <c>&lt;vt:decimal></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDouble" /> <c>&lt;vt:r8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTFloat" /> <c>&lt;vt:r4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInt32" /> <c>&lt;vt:i4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInteger" /> <c>&lt;vt:int></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInt64" /> <c>&lt;vt:i8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTShort" /> <c>&lt;vt:i2></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTLPSTR" /> <c>&lt;vt:lpstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTLPWSTR" /> <c>&lt;vt:lpwstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBString" /> <c>&lt;vt:bstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte" /> <c>&lt;vt:ui1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32" /> <c>&lt;vt:ui4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger" /> <c>&lt;vt:uint></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64" /> <c>&lt;vt:ui8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort" /> <c>&lt;vt:ui2></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Variant : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "variant");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Variant");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Variant class.
        /// </summary>
        public Variant() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Variant class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Variant(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Variant class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Variant(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Variant class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Variant(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTArray>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTClipboardData>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTEmpty>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTNull>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.Variant>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTVector>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTVStreamData>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTClassId>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTCurrency>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTError>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBlob>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTOBlob>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTStreamData>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTOStreamData>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTStorage>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTOStorage>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBool>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDate>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTFileTime>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDecimal>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDouble>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTFloat>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInteger>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInt64>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTShort>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTLPSTR>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTLPWSTR>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBString>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.Variant.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTVector.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTArray.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBlob.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTOBlob.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTEmpty.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTNull.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInt64.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInteger.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTFloat.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDouble.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDecimal.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTLPSTR.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTLPWSTR.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBString.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDate.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTFileTime.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBool.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTCurrency.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTError.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTStreamData.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTOStreamData.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTStorage.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTOStorage.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTVStreamData.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTClassId.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTClipboardData.ElementType, 1, 1)
            };
        }

        /// <summary>
        /// <para>Variant.</para>
        /// <para>Represents the following element tag in the schema: vt:variant.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.Variant? InnerVariant
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.Variant.ElementType) as DocumentFormat.OpenXml.VariantTypes.Variant;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.Variant.ElementType);
        }

        /// <summary>
        /// <para>Vector.</para>
        /// <para>Represents the following element tag in the schema: vt:vector.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTVector? VTVector
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTVector.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTVector;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTVector.ElementType);
        }

        /// <summary>
        /// <para>Array.</para>
        /// <para>Represents the following element tag in the schema: vt:array.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTArray? VTArray
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTArray.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTArray;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTArray.ElementType);
        }

        /// <summary>
        /// <para>Binary Blob.</para>
        /// <para>Represents the following element tag in the schema: vt:blob.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTBlob? VTBlob
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTBlob.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTBlob;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTBlob.ElementType);
        }

        /// <summary>
        /// <para>Binary Blob Object.</para>
        /// <para>Represents the following element tag in the schema: vt:oblob.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTOBlob? VTOBlob
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTOBlob.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTOBlob;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTOBlob.ElementType);
        }

        /// <summary>
        /// <para>Empty.</para>
        /// <para>Represents the following element tag in the schema: vt:empty.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTEmpty? VTEmpty
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTEmpty.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTEmpty;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTEmpty.ElementType);
        }

        /// <summary>
        /// <para>Null.</para>
        /// <para>Represents the following element tag in the schema: vt:null.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTNull? VTNull
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTNull.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTNull;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTNull.ElementType);
        }

        /// <summary>
        /// <para>1-Byte Signed Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:i1.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTByte? VTByte
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTByte.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTByte;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTByte.ElementType);
        }

        /// <summary>
        /// <para>2-Byte Signed Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:i2.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTShort? VTShort
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTShort.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTShort;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTShort.ElementType);
        }

        /// <summary>
        /// <para>4-Byte Signed Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:i4.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTInt32? VTInt32
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTInt32.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTInt32;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTInt32.ElementType);
        }

        /// <summary>
        /// <para>8-Byte Signed Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:i8.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTInt64? VTInt64
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTInt64.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTInt64;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTInt64.ElementType);
        }

        /// <summary>
        /// <para>Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:int.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTInteger? VTInteger
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTInteger.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTInteger;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTInteger.ElementType);
        }

        /// <summary>
        /// <para>1-Byte Unsigned Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:ui1.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte? VTUnsignedByte
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte.ElementType);
        }

        /// <summary>
        /// <para>2-Byte Unsigned Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:ui2.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort? VTUnsignedShort
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort.ElementType);
        }

        /// <summary>
        /// <para>4-Byte Unsigned Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:ui4.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32? VTUnsignedInt32
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32.ElementType);
        }

        /// <summary>
        /// <para>8-Byte Unsigned Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:ui8.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64? VTUnsignedInt64
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64.ElementType);
        }

        /// <summary>
        /// <para>Unsigned Integer.</para>
        /// <para>Represents the following element tag in the schema: vt:uint.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger? VTUnsignedInteger
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger.ElementType);
        }

        /// <summary>
        /// <para>4-Byte Real Number.</para>
        /// <para>Represents the following element tag in the schema: vt:r4.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTFloat? VTFloat
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTFloat.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTFloat;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTFloat.ElementType);
        }

        /// <summary>
        /// <para>8-Byte Real Number.</para>
        /// <para>Represents the following element tag in the schema: vt:r8.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTDouble? VTDouble
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTDouble.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTDouble;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTDouble.ElementType);
        }

        /// <summary>
        /// <para>Decimal.</para>
        /// <para>Represents the following element tag in the schema: vt:decimal.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTDecimal? VTDecimal
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTDecimal.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTDecimal;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTDecimal.ElementType);
        }

        /// <summary>
        /// <para>LPSTR.</para>
        /// <para>Represents the following element tag in the schema: vt:lpstr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTLPSTR? VTLPSTR
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTLPSTR.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTLPSTR;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTLPSTR.ElementType);
        }

        /// <summary>
        /// <para>LPWSTR.</para>
        /// <para>Represents the following element tag in the schema: vt:lpwstr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTLPWSTR? VTLPWSTR
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTLPWSTR.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTLPWSTR;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTLPWSTR.ElementType);
        }

        /// <summary>
        /// <para>Basic String.</para>
        /// <para>Represents the following element tag in the schema: vt:bstr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTBString? VTBString
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTBString.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTBString;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTBString.ElementType);
        }

        /// <summary>
        /// <para>Date and Time.</para>
        /// <para>Represents the following element tag in the schema: vt:date.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTDate? VTDate
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTDate.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTDate;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTDate.ElementType);
        }

        /// <summary>
        /// <para>File Time.</para>
        /// <para>Represents the following element tag in the schema: vt:filetime.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTFileTime? VTFileTime
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTFileTime.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTFileTime;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTFileTime.ElementType);
        }

        /// <summary>
        /// <para>Boolean.</para>
        /// <para>Represents the following element tag in the schema: vt:bool.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTBool? VTBool
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTBool.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTBool;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTBool.ElementType);
        }

        /// <summary>
        /// <para>Currency.</para>
        /// <para>Represents the following element tag in the schema: vt:cy.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTCurrency? VTCurrency
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTCurrency.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTCurrency;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTCurrency.ElementType);
        }

        /// <summary>
        /// <para>Error Status Code.</para>
        /// <para>Represents the following element tag in the schema: vt:error.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTError? VTError
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTError.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTError;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTError.ElementType);
        }

        /// <summary>
        /// <para>Binary Stream.</para>
        /// <para>Represents the following element tag in the schema: vt:stream.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTStreamData? VTStreamData
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTStreamData.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTStreamData;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTStreamData.ElementType);
        }

        /// <summary>
        /// <para>Binary Stream Object.</para>
        /// <para>Represents the following element tag in the schema: vt:ostream.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTOStreamData? VTOStreamData
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTOStreamData.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTOStreamData;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTOStreamData.ElementType);
        }

        /// <summary>
        /// <para>Binary Storage.</para>
        /// <para>Represents the following element tag in the schema: vt:storage.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTStorage? VTStorage
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTStorage.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTStorage;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTStorage.ElementType);
        }

        /// <summary>
        /// <para>Binary Storage Object.</para>
        /// <para>Represents the following element tag in the schema: vt:ostorage.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTOStorage? VTOStorage
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTOStorage.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTOStorage;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTOStorage.ElementType);
        }

        /// <summary>
        /// <para>Binary Versioned Stream.</para>
        /// <para>Represents the following element tag in the schema: vt:vstream.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTVStreamData? VTVStreamData
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTVStreamData.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTVStreamData;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTVStreamData.ElementType);
        }

        /// <summary>
        /// <para>Class ID.</para>
        /// <para>Represents the following element tag in the schema: vt:clsid.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTClassId? VTClassId
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTClassId.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTClassId;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTClassId.ElementType);
        }

        /// <summary>
        /// <para>Clipboard Data.</para>
        /// <para>Represents the following element tag in the schema: vt:cf.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:vt = http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes
        /// </remarks>
        public DocumentFormat.OpenXml.VariantTypes.VTClipboardData? VTClipboardData
        {
            get => GetElement(DocumentFormat.OpenXml.VariantTypes.VTClipboardData.ElementType) as DocumentFormat.OpenXml.VariantTypes.VTClipboardData;
            set => SetElement(value, DocumentFormat.OpenXml.VariantTypes.VTClipboardData.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Variant>(deep);
    }

    /// <summary>
    /// <para>Vector.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:vector.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTClipboardData" /> <c>&lt;vt:cf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.Variant" /> <c>&lt;vt:variant></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTClassId" /> <c>&lt;vt:clsid></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTCurrency" /> <c>&lt;vt:cy></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTError" /> <c>&lt;vt:error></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBool" /> <c>&lt;vt:bool></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTByte" /> <c>&lt;vt:i1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDate" /> <c>&lt;vt:date></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTFileTime" /> <c>&lt;vt:filetime></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDouble" /> <c>&lt;vt:r8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTFloat" /> <c>&lt;vt:r4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInt32" /> <c>&lt;vt:i4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInt64" /> <c>&lt;vt:i8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTShort" /> <c>&lt;vt:i2></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTLPSTR" /> <c>&lt;vt:lpstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTLPWSTR" /> <c>&lt;vt:lpwstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBString" /> <c>&lt;vt:bstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte" /> <c>&lt;vt:ui1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32" /> <c>&lt;vt:ui4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64" /> <c>&lt;vt:ui8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort" /> <c>&lt;vt:ui2></c></description></item>
    /// </list>
    /// </remarks>
    public partial class VTVector : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "vector");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Vector");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTVector class.
        /// </summary>
        public VTVector() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTVector class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VTVector(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTVector class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VTVector(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTVector class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VTVector(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Vector Base Type</para>
        /// <para>Represents the following attribute in the schema: baseType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.VariantTypes.VectorBaseValues>? BaseType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.VariantTypes.VectorBaseValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vector Size</para>
        /// <para>Represents the following attribute in the schema: size</para>
        /// </summary>
        public UInt32Value? Size
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTClipboardData>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.Variant>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTClassId>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTCurrency>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTError>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBool>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDate>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTFileTime>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDouble>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTFloat>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInt64>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTShort>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTLPSTR>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTLPWSTR>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBString>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort>();
            builder.AddElement<VTVector>()
                .AddAttribute("baseType", a => a.BaseType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("size", a => a.Size, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.Variant.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInt64.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt64.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTFloat.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDouble.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTLPSTR.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTLPWSTR.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBString.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDate.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTFileTime.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBool.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTCurrency.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTError.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTClassId.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTClipboardData.ElementType, 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTVector>(deep);
    }

    /// <summary>
    /// <para>Array.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:array.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.Variant" /> <c>&lt;vt:variant></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTCurrency" /> <c>&lt;vt:cy></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTError" /> <c>&lt;vt:error></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBool" /> <c>&lt;vt:bool></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTByte" /> <c>&lt;vt:i1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDate" /> <c>&lt;vt:date></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDecimal" /> <c>&lt;vt:decimal></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTDouble" /> <c>&lt;vt:r8></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTFloat" /> <c>&lt;vt:r4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInt32" /> <c>&lt;vt:i4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTInteger" /> <c>&lt;vt:int></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTShort" /> <c>&lt;vt:i2></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTBString" /> <c>&lt;vt:bstr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte" /> <c>&lt;vt:ui1></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32" /> <c>&lt;vt:ui4></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger" /> <c>&lt;vt:uint></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort" /> <c>&lt;vt:ui2></c></description></item>
    /// </list>
    /// </remarks>
    public partial class VTArray : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "array");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Array");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTArray class.
        /// </summary>
        public VTArray() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTArray class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VTArray(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTArray class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VTArray(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTArray class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VTArray(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Array Lower Bounds Attribute</para>
        /// <para>Represents the following attribute in the schema: lBound</para>
        /// </summary>
        public Int32Value? LowerBounds
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Array Upper Bounds Attribute</para>
        /// <para>Represents the following attribute in the schema: uBound</para>
        /// </summary>
        public Int32Value? UpperBounds
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Array Base Type</para>
        /// <para>Represents the following attribute in the schema: baseType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.VariantTypes.ArrayBaseValues>? BaseType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.VariantTypes.ArrayBaseValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.Variant>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTCurrency>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTError>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBool>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDate>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDecimal>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTDouble>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTFloat>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTInteger>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTShort>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTBString>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger>();
            builder.AddChild<DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort>();
            builder.AddElement<VTArray>()
                .AddAttribute("lBound", a => a.LowerBounds, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("uBound", a => a.UpperBounds, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("baseType", a => a.BaseType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.Variant.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTInteger.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedByte.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedShort.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInt32.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTUnsignedInteger.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTFloat.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDouble.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDecimal.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBString.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTDate.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTBool.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTError.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.VariantTypes.VTCurrency.ElementType, 1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTArray>(deep);
    }

    /// <summary>
    /// <para>Binary Blob.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:blob.</para>
    /// </summary>
    public partial class VTBlob : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "blob");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTBlob class.
        /// </summary>
        public VTBlob() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTBlob class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTBlob(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTBlob>(deep);
    }

    /// <summary>
    /// <para>Binary Blob Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:oblob.</para>
    /// </summary>
    public partial class VTOBlob : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "oblob");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTOBlob class.
        /// </summary>
        public VTOBlob() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTOBlob class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTOBlob(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTOBlob>(deep);
    }

    /// <summary>
    /// <para>Binary Stream.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:stream.</para>
    /// </summary>
    public partial class VTStreamData : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "stream");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTStreamData class.
        /// </summary>
        public VTStreamData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTStreamData class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTStreamData(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTStreamData>(deep);
    }

    /// <summary>
    /// <para>Binary Stream Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ostream.</para>
    /// </summary>
    public partial class VTOStreamData : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ostream");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTOStreamData class.
        /// </summary>
        public VTOStreamData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTOStreamData class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTOStreamData(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTOStreamData>(deep);
    }

    /// <summary>
    /// <para>Binary Storage.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:storage.</para>
    /// </summary>
    public partial class VTStorage : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "storage");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTStorage class.
        /// </summary>
        public VTStorage() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTStorage class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTStorage(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTStorage>(deep);
    }

    /// <summary>
    /// <para>Binary Storage Object.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ostorage.</para>
    /// </summary>
    public partial class VTOStorage : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ostorage");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTOStorage class.
        /// </summary>
        public VTOStorage() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTOStorage class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTOStorage(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTOStorage>(deep);
    }

    /// <summary>
    /// <para>Empty.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:empty.</para>
    /// </summary>
    public partial class VTEmpty : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "empty");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Empty");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTEmpty class.
        /// </summary>
        public VTEmpty() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTEmpty>(deep);
    }

    /// <summary>
    /// <para>Null.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:null.</para>
    /// </summary>
    public partial class VTNull : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "null");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Null");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTNull class.
        /// </summary>
        public VTNull() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTNull>(deep);
    }

    /// <summary>
    /// <para>1-Byte Signed Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:i1.</para>
    /// </summary>
    public partial class VTByte : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "i1");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "byte");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTByte class.
        /// </summary>
        public VTByte() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTByte class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTByte(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new SByteValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<SByteValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTByte>(deep);
    }

    /// <summary>
    /// <para>2-Byte Signed Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:i2.</para>
    /// </summary>
    public partial class VTShort : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "i2");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "short");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTShort class.
        /// </summary>
        public VTShort() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTShort class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTShort(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Int16Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Int16Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTShort>(deep);
    }

    /// <summary>
    /// <para>4-Byte Signed Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:i4.</para>
    /// </summary>
    public partial class VTInt32 : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "i4");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "int");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTInt32 class.
        /// </summary>
        public VTInt32() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTInt32 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTInt32(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Int32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Int32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTInt32>(deep);
    }

    /// <summary>
    /// <para>Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:int.</para>
    /// </summary>
    public partial class VTInteger : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "int");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "int");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTInteger class.
        /// </summary>
        public VTInteger() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTInteger class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTInteger(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Int32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Int32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTInteger>(deep);
    }

    /// <summary>
    /// <para>8-Byte Signed Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:i8.</para>
    /// </summary>
    public partial class VTInt64 : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "i8");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "long");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTInt64 class.
        /// </summary>
        public VTInt64() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTInt64 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTInt64(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Int64Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Int64Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTInt64>(deep);
    }

    /// <summary>
    /// <para>1-Byte Unsigned Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ui1.</para>
    /// </summary>
    public partial class VTUnsignedByte : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ui1");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedByte");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTUnsignedByte class.
        /// </summary>
        public VTUnsignedByte() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTUnsignedByte class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTUnsignedByte(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new ByteValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<ByteValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTUnsignedByte>(deep);
    }

    /// <summary>
    /// <para>2-Byte Unsigned Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ui2.</para>
    /// </summary>
    public partial class VTUnsignedShort : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ui2");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedShort");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTUnsignedShort class.
        /// </summary>
        public VTUnsignedShort() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTUnsignedShort class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTUnsignedShort(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt16Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt16Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTUnsignedShort>(deep);
    }

    /// <summary>
    /// <para>4-Byte Unsigned Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ui4.</para>
    /// </summary>
    public partial class VTUnsignedInt32 : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ui4");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedInt");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInt32 class.
        /// </summary>
        public VTUnsignedInt32() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInt32 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTUnsignedInt32(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTUnsignedInt32>(deep);
    }

    /// <summary>
    /// <para>Unsigned Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:uint.</para>
    /// </summary>
    public partial class VTUnsignedInteger : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "uint");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedInt");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInteger class.
        /// </summary>
        public VTUnsignedInteger() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInteger class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTUnsignedInteger(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTUnsignedInteger>(deep);
    }

    /// <summary>
    /// <para>8-Byte Unsigned Integer.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:ui8.</para>
    /// </summary>
    public partial class VTUnsignedInt64 : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ui8");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedLong");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInt64 class.
        /// </summary>
        public VTUnsignedInt64() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTUnsignedInt64 class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTUnsignedInt64(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt64Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt64Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTUnsignedInt64>(deep);
    }

    /// <summary>
    /// <para>4-Byte Real Number.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:r4.</para>
    /// </summary>
    public partial class VTFloat : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "r4");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "float");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTFloat class.
        /// </summary>
        public VTFloat() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTFloat class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTFloat(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new SingleValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<SingleValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTFloat>(deep);
    }

    /// <summary>
    /// <para>8-Byte Real Number.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:r8.</para>
    /// </summary>
    public partial class VTDouble : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "r8");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "double");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTDouble class.
        /// </summary>
        public VTDouble() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTDouble class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTDouble(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DoubleValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<DoubleValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTDouble>(deep);
    }

    /// <summary>
    /// <para>Decimal.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:decimal.</para>
    /// </summary>
    public partial class VTDecimal : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "decimal");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "decimal");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTDecimal class.
        /// </summary>
        public VTDecimal() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTDecimal class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTDecimal(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DecimalValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<DecimalValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTDecimal>(deep);
    }

    /// <summary>
    /// <para>LPSTR.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:lpstr.</para>
    /// </summary>
    public partial class VTLPSTR : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "lpstr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTLPSTR class.
        /// </summary>
        public VTLPSTR() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTLPSTR class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTLPSTR(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTLPSTR>(deep);
    }

    /// <summary>
    /// <para>LPWSTR.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:lpwstr.</para>
    /// </summary>
    public partial class VTLPWSTR : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "lpwstr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTLPWSTR class.
        /// </summary>
        public VTLPWSTR() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTLPWSTR class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTLPWSTR(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTLPWSTR>(deep);
    }

    /// <summary>
    /// <para>Basic String.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:bstr.</para>
    /// </summary>
    public partial class VTBString : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "bstr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTBString class.
        /// </summary>
        public VTBString() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTBString class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTBString(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTBString>(deep);
    }

    /// <summary>
    /// <para>Date and Time.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:date.</para>
    /// </summary>
    public partial class VTDate : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "date");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "dateTime");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTDate class.
        /// </summary>
        public VTDate() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTDate class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTDate(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DateTimeValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<DateTimeValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTDate>(deep);
    }

    /// <summary>
    /// <para>File Time.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:filetime.</para>
    /// </summary>
    public partial class VTFileTime : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "filetime");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "dateTime");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTFileTime class.
        /// </summary>
        public VTFileTime() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTFileTime class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTFileTime(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DateTimeValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<DateTimeValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTFileTime>(deep);
    }

    /// <summary>
    /// <para>Boolean.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:bool.</para>
    /// </summary>
    public partial class VTBool : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "bool");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "boolean");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTBool class.
        /// </summary>
        public VTBool() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTBool class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTBool(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new BooleanValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<BooleanValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTBool>(deep);
    }

    /// <summary>
    /// <para>Currency.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:cy.</para>
    /// </summary>
    public partial class VTCurrency : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "cy");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ST_Cy");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTCurrency class.
        /// </summary>
        public VTCurrency() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTCurrency class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTCurrency(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator(new StringValidator() { Pattern = ("\\s*[0-9]*\\.[0-9]{4}\\s*") });
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTCurrency>(deep);
    }

    /// <summary>
    /// <para>Error Status Code.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:error.</para>
    /// </summary>
    public partial class VTError : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "error");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ST_Error");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTError class.
        /// </summary>
        public VTError() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTError class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTError(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator(new StringValidator() { Pattern = ("0x[0-9A-Fa-f]{8}") });
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTError>(deep);
    }

    /// <summary>
    /// <para>Binary Versioned Stream.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:vstream.</para>
    /// </summary>
    public partial class VTVStreamData : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "vstream");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Vstream");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTVStreamData class.
        /// </summary>
        public VTVStreamData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTVStreamData class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTVStreamData(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        /// <summary>
        /// <para>VSTREAM Version Attribute</para>
        /// <para>Represents the following attribute in the schema: version</para>
        /// </summary>
        public StringValue? Version
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddElement<VTVStreamData>()
                .AddAttribute("version", a => a.Version, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { Pattern = ("\\s*\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}\\s*") });
                });
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("vt:version"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTVStreamData>(deep);
    }

    /// <summary>
    /// <para>Class ID.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:clsid.</para>
    /// </summary>
    public partial class VTClassId : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "clsid");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "ST_Clsid");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTClassId class.
        /// </summary>
        public VTClassId() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTClassId class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTClassId(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator(new StringValidator() { Pattern = ("\\s*\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}\\s*") });
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTClassId>(deep);
    }

    /// <summary>
    /// <para>Clipboard Data.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is vt:cf.</para>
    /// </summary>
    public partial class VTClipboardData : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "cf");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes", "CT_Cf");
        internal static readonly new OpenXmlSchemaType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VTClipboardData class.
        /// </summary>
        public VTClipboardData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VTClipboardData class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VTClipboardData(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        /// <summary>
        /// <para>Format Attribute</para>
        /// <para>Represents the following attribute in the schema: format</para>
        /// </summary>
        public Int32Value? Format
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>size</para>
        /// <para>Represents the following attribute in the schema: size</para>
        /// </summary>
        public UInt32Value? Size
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddElement<VTClipboardData>()
                .AddAttribute("format", a => a.Format, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (-3L) });
                })
                .AddAttribute("size", a => a.Size, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VTClipboardData>(deep);
    }

    /// <summary>
    /// Vector Base Type Simple Type
    /// </summary>
    public readonly record struct VectorBaseValues : IEnumValue, IEnumValueFactory<VectorBaseValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VectorBaseValues enum instance
        /// </summary>
        public VectorBaseValues(string value) => _value = value;
        VectorBaseValues IEnumValueFactory<VectorBaseValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "variant" => true,
            "i1" => true,
            "i2" => true,
            "i4" => true,
            "i8" => true,
            "ui1" => true,
            "ui2" => true,
            "ui4" => true,
            "ui8" => true,
            "r4" => true,
            "r8" => true,
            "lpstr" => true,
            "lpwstr" => true,
            "bstr" => true,
            "date" => true,
            "filetime" => true,
            "bool" => true,
            "cy" => true,
            "error" => true,
            "clsid" => true,
            "cf" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "variant";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Variant Base Type.
        /// <para>When the item is serialized out as xml, its value is "variant".</para>
        /// </summary>
        public static VectorBaseValues Variant => new("variant");
        /// <summary>
        /// Vector Base Type Enumeration Value.
        /// <para>When the item is serialized out as xml, its value is "i1".</para>
        /// </summary>
        public static VectorBaseValues OneByteSignedInteger => new("i1");
        /// <summary>
        /// 2-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i2".</para>
        /// </summary>
        public static VectorBaseValues TwoBytesSignedInteger => new("i2");
        /// <summary>
        /// 4-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i4".</para>
        /// </summary>
        public static VectorBaseValues FourBytesSignedInteger => new("i4");
        /// <summary>
        /// 8-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i8".</para>
        /// </summary>
        public static VectorBaseValues EightBytesSignedInteger => new("i8");
        /// <summary>
        /// 1-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui1".</para>
        /// </summary>
        public static VectorBaseValues OneByteUnsignedInteger => new("ui1");
        /// <summary>
        /// 2-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui2".</para>
        /// </summary>
        public static VectorBaseValues TwoBytesUnsignedInteger => new("ui2");
        /// <summary>
        /// 4-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui4".</para>
        /// </summary>
        public static VectorBaseValues FourBytesUnsignedInteger => new("ui4");
        /// <summary>
        /// 8-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui8".</para>
        /// </summary>
        public static VectorBaseValues EightBytesUnsignedInteger => new("ui8");
        /// <summary>
        /// 4-Byte Real Number Base Type.
        /// <para>When the item is serialized out as xml, its value is "r4".</para>
        /// </summary>
        public static VectorBaseValues FourBytesReal => new("r4");
        /// <summary>
        /// 8-Byte Real Number Base Type.
        /// <para>When the item is serialized out as xml, its value is "r8".</para>
        /// </summary>
        public static VectorBaseValues EightBytesReal => new("r8");
        /// <summary>
        /// LPSTR Base Type.
        /// <para>When the item is serialized out as xml, its value is "lpstr".</para>
        /// </summary>
        public static VectorBaseValues Lpstr => new("lpstr");
        /// <summary>
        /// LPWSTR Base Type.
        /// <para>When the item is serialized out as xml, its value is "lpwstr".</para>
        /// </summary>
        public static VectorBaseValues Lpwstr => new("lpwstr");
        /// <summary>
        /// Basic String Base Type.
        /// <para>When the item is serialized out as xml, its value is "bstr".</para>
        /// </summary>
        public static VectorBaseValues Bstr => new("bstr");
        /// <summary>
        /// Date and Time Base Type.
        /// <para>When the item is serialized out as xml, its value is "date".</para>
        /// </summary>
        public static VectorBaseValues Date => new("date");
        /// <summary>
        /// File Time Base Type.
        /// <para>When the item is serialized out as xml, its value is "filetime".</para>
        /// </summary>
        public static VectorBaseValues Filetime => new("filetime");
        /// <summary>
        /// Boolean Base Type.
        /// <para>When the item is serialized out as xml, its value is "bool".</para>
        /// </summary>
        public static VectorBaseValues Bool => new("bool");
        /// <summary>
        /// Currency Base Type.
        /// <para>When the item is serialized out as xml, its value is "cy".</para>
        /// </summary>
        public static VectorBaseValues Currency => new("cy");
        /// <summary>
        /// Error Status Code Base Type.
        /// <para>When the item is serialized out as xml, its value is "error".</para>
        /// </summary>
        public static VectorBaseValues Error => new("error");
        /// <summary>
        /// Class ID Base Type.
        /// <para>When the item is serialized out as xml, its value is "clsid".</para>
        /// </summary>
        public static VectorBaseValues ClassId => new("clsid");
        /// <summary>
        /// Clipboard Data Base Type.
        /// <para>When the item is serialized out as xml, its value is "cf".</para>
        /// </summary>
        public static VectorBaseValues ClipboardData => new("cf");
    
    }

    /// <summary>
    /// Array Base Type Simple Type
    /// </summary>
    public readonly record struct ArrayBaseValues : IEnumValue, IEnumValueFactory<ArrayBaseValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ArrayBaseValues enum instance
        /// </summary>
        public ArrayBaseValues(string value) => _value = value;
        ArrayBaseValues IEnumValueFactory<ArrayBaseValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "variant" => true,
            "i1" => true,
            "i2" => true,
            "i4" => true,
            "int" => true,
            "ui1" => true,
            "ui2" => true,
            "ui4" => true,
            "uint" => true,
            "r4" => true,
            "r8" => true,
            "decimal" => true,
            "bstr" => true,
            "date" => true,
            "bool" => true,
            "cy" => true,
            "error" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "variant";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Variant Base Type.
        /// <para>When the item is serialized out as xml, its value is "variant".</para>
        /// </summary>
        public static ArrayBaseValues Variant => new("variant");
        /// <summary>
        /// 1-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i1".</para>
        /// </summary>
        public static ArrayBaseValues OneByteSignedInteger => new("i1");
        /// <summary>
        /// 2-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i2".</para>
        /// </summary>
        public static ArrayBaseValues TwoBytesSignedInteger => new("i2");
        /// <summary>
        /// 4-Byte Signed Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "i4".</para>
        /// </summary>
        public static ArrayBaseValues FourBytesSignedInteger => new("i4");
        /// <summary>
        /// Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "int".</para>
        /// </summary>
        public static ArrayBaseValues Integer => new("int");
        /// <summary>
        /// 1-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui1".</para>
        /// </summary>
        public static ArrayBaseValues OneByteUnsignedInteger => new("ui1");
        /// <summary>
        /// 2-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui2".</para>
        /// </summary>
        public static ArrayBaseValues TwoBytesUnsignedInteger => new("ui2");
        /// <summary>
        /// 4-Byte Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "ui4".</para>
        /// </summary>
        public static ArrayBaseValues FourBytesUnsignedInteger => new("ui4");
        /// <summary>
        /// Unsigned Integer Base Type.
        /// <para>When the item is serialized out as xml, its value is "uint".</para>
        /// </summary>
        public static ArrayBaseValues UnsignedInteger => new("uint");
        /// <summary>
        /// 4-Byte Real Number Base Type.
        /// <para>When the item is serialized out as xml, its value is "r4".</para>
        /// </summary>
        public static ArrayBaseValues FourBytesReal => new("r4");
        /// <summary>
        /// 8-Byte Real Number Base Type.
        /// <para>When the item is serialized out as xml, its value is "r8".</para>
        /// </summary>
        public static ArrayBaseValues EightBytesReal => new("r8");
        /// <summary>
        /// Decimal Base Type.
        /// <para>When the item is serialized out as xml, its value is "decimal".</para>
        /// </summary>
        public static ArrayBaseValues Decimal => new("decimal");
        /// <summary>
        /// Basic String Base Type.
        /// <para>When the item is serialized out as xml, its value is "bstr".</para>
        /// </summary>
        public static ArrayBaseValues Bstr => new("bstr");
        /// <summary>
        /// Date and Time Base Type.
        /// <para>When the item is serialized out as xml, its value is "date".</para>
        /// </summary>
        public static ArrayBaseValues Date => new("date");
        /// <summary>
        /// Boolean Base Type.
        /// <para>When the item is serialized out as xml, its value is "bool".</para>
        /// </summary>
        public static ArrayBaseValues Bool => new("bool");
        /// <summary>
        /// Currency Base Type.
        /// <para>When the item is serialized out as xml, its value is "cy".</para>
        /// </summary>
        public static ArrayBaseValues Currency => new("cy");
        /// <summary>
        /// Error Status Code Base Type.
        /// <para>When the item is serialized out as xml, its value is "error".</para>
        /// </summary>
        public static ArrayBaseValues Error => new("error");
    
    }
}