// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.Vml.Wordprocessing
{
    /// <summary>
    /// <para>Top Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:bordertop.</para>
    /// </summary>
    public partial class TopBorder : BorderType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "bordertop");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Border");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TopBorder class.
        /// </summary>
        public TopBorder() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TopBorder>(deep);
    }

    /// <summary>
    /// <para>Left Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:borderleft.</para>
    /// </summary>
    public partial class LeftBorder : BorderType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "borderleft");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Border");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the LeftBorder class.
        /// </summary>
        public LeftBorder() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LeftBorder>(deep);
    }

    /// <summary>
    /// <para>Right Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:borderright.</para>
    /// </summary>
    public partial class RightBorder : BorderType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "borderright");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Border");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the RightBorder class.
        /// </summary>
        public RightBorder() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RightBorder>(deep);
    }

    /// <summary>
    /// <para>Bottom Border.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:borderbottom.</para>
    /// </summary>
    public partial class BottomBorder : BorderType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "borderbottom");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Border");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the BottomBorder class.
        /// </summary>
        public BottomBorder() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BottomBorder>(deep);
    }

    /// <summary>
    /// <para>Defines the BorderType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class BorderType : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Border");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the BorderType class.
        /// </summary>
        protected BorderType() : base()
        {
        }

        /// <summary>
        /// <para>Border Style</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.BorderValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.BorderValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Border Width</para>
        /// <para>Represents the following attribute in the schema: width</para>
        /// </summary>
        public IntegerValue? Width
        {
            get => GetAttribute<IntegerValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Border shadow</para>
        /// <para>Represents the following attribute in the schema: shadow</para>
        /// </summary>
        public TrueFalseValue? Shadow
        {
            get => GetAttribute<TrueFalseValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<BorderType>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("width", a => a.Width, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { IsPositive = (true) });
                })
                .AddAttribute("shadow", a => a.Shadow);
        }
    }

    /// <summary>
    /// <para>Text Wrapping.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:wrap.</para>
    /// </summary>
    public partial class TextWrap : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "wrap");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_Wrap");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TextWrap class.
        /// </summary>
        public TextWrap() : base()
        {
        }

        /// <summary>
        /// <para>Wrapping type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.WrapValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.WrapValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Wrapping side</para>
        /// <para>Represents the following attribute in the schema: side</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.WrapSideValues>? Side
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.WrapSideValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Horizontal Positioning Base</para>
        /// <para>Represents the following attribute in the schema: anchorx</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.HorizontalAnchorValues>? AnchorX
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.HorizontalAnchorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Vertical Positioning Base</para>
        /// <para>Represents the following attribute in the schema: anchory</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.VerticalAnchorValues>? AnchorY
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Vml.Wordprocessing.VerticalAnchorValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.AddElement<TextWrap>()
                .AddAttribute("type", a => a.Type)
                .AddAttribute("side", a => a.Side)
                .AddAttribute("anchorx", a => a.AnchorX)
                .AddAttribute("anchory", a => a.AnchorY);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextWrap>(deep);
    }

    /// <summary>
    /// <para>Anchor Location Is Locked.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is w10:anchorlock.</para>
    /// </summary>
    public partial class AnchorLock : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("urn:schemas-microsoft-com:office:word", "anchorlock");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("urn:schemas-microsoft-com:office:word", "CT_AnchorLock");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the AnchorLock class.
        /// </summary>
        public AnchorLock() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AnchorLock>(deep);
    }

    /// <summary>
    /// Border Type
    /// </summary>
    public readonly record struct BorderValues : IEnumValue, IEnumValueFactory<BorderValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new BorderValues enum instance
        /// </summary>
        public BorderValues(string value) => _value = value;
        BorderValues IEnumValueFactory<BorderValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "single" => true,
            "thick" => true,
            "double" => true,
            "hairline" => true,
            "dot" => true,
            "dash" => true,
            "dotDash" => true,
            "dashDotDot" => true,
            "triple" => true,
            "thinThickSmall" => true,
            "thickThinSmall" => true,
            "thickBetweenThinSmall" => true,
            "thinThick" => true,
            "thickThin" => true,
            "thickBetweenThin" => true,
            "thinThickLarge" => true,
            "thickThinLarge" => true,
            "thickBetweenThinLarge" => true,
            "wave" => true,
            "doubleWave" => true,
            "dashedSmall" => true,
            "dashDotStroked" => true,
            "threeDEmboss" => true,
            "threeDEngrave" => true,
            "HTMLOutset" => true,
            "HTMLInset" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// No Border.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static BorderValues None => new("none");
        /// <summary>
        /// Single Line Border.
        /// <para>When the item is serialized out as xml, its value is "single".</para>
        /// </summary>
        public static BorderValues Single => new("single");
        /// <summary>
        /// Thick Line Border.
        /// <para>When the item is serialized out as xml, its value is "thick".</para>
        /// </summary>
        public static BorderValues Thick => new("thick");
        /// <summary>
        /// Double Line Border.
        /// <para>When the item is serialized out as xml, its value is "double".</para>
        /// </summary>
        public static BorderValues Double => new("double");
        /// <summary>
        /// Hairline Border.
        /// <para>When the item is serialized out as xml, its value is "hairline".</para>
        /// </summary>
        public static BorderValues Hairline => new("hairline");
        /// <summary>
        /// Dotted Border.
        /// <para>When the item is serialized out as xml, its value is "dot".</para>
        /// </summary>
        public static BorderValues Dot => new("dot");
        /// <summary>
        /// pecifies a line border consisting of a dashed line around the parent object..
        /// <para>When the item is serialized out as xml, its value is "dash".</para>
        /// </summary>
        public static BorderValues Dash => new("dash");
        /// <summary>
        /// Dot Dash Border.
        /// <para>When the item is serialized out as xml, its value is "dotDash".</para>
        /// </summary>
        public static BorderValues DotDash => new("dotDash");
        /// <summary>
        /// Dash Dot Dot Border.
        /// <para>When the item is serialized out as xml, its value is "dashDotDot".</para>
        /// </summary>
        public static BorderValues DashDotDot => new("dashDotDot");
        /// <summary>
        /// Triple Line Border.
        /// <para>When the item is serialized out as xml, its value is "triple".</para>
        /// </summary>
        public static BorderValues Triple => new("triple");
        /// <summary>
        /// Thin Thick Small Gap Border.
        /// <para>When the item is serialized out as xml, its value is "thinThickSmall".</para>
        /// </summary>
        public static BorderValues ThinThickSmall => new("thinThickSmall");
        /// <summary>
        /// Small thick-thin lines border.
        /// <para>When the item is serialized out as xml, its value is "thickThinSmall".</para>
        /// </summary>
        public static BorderValues ThickThinSmall => new("thickThinSmall");
        /// <summary>
        /// Small thin-thick-thin Lines Border.
        /// <para>When the item is serialized out as xml, its value is "thickBetweenThinSmall".</para>
        /// </summary>
        public static BorderValues ThickBetweenThinSmall => new("thickBetweenThinSmall");
        /// <summary>
        /// Thin Thick Line Border.
        /// <para>When the item is serialized out as xml, its value is "thinThick".</para>
        /// </summary>
        public static BorderValues ThinThick => new("thinThick");
        /// <summary>
        /// Thick Thin Line Border.
        /// <para>When the item is serialized out as xml, its value is "thickThin".</para>
        /// </summary>
        public static BorderValues ThickThin => new("thickThin");
        /// <summary>
        /// Thin-thick-thin Border.
        /// <para>When the item is serialized out as xml, its value is "thickBetweenThin".</para>
        /// </summary>
        public static BorderValues ThickBetweenThin => new("thickBetweenThin");
        /// <summary>
        /// Thin Thick Large Gap Border.
        /// <para>When the item is serialized out as xml, its value is "thinThickLarge".</para>
        /// </summary>
        public static BorderValues ThinThickLarge => new("thinThickLarge");
        /// <summary>
        /// Thick Thin Large Gap Border.
        /// <para>When the item is serialized out as xml, its value is "thickThinLarge".</para>
        /// </summary>
        public static BorderValues ThickThinLarge => new("thickThinLarge");
        /// <summary>
        /// Large thin-thick-thin Border.
        /// <para>When the item is serialized out as xml, its value is "thickBetweenThinLarge".</para>
        /// </summary>
        public static BorderValues ThickBetweenThinLarge => new("thickBetweenThinLarge");
        /// <summary>
        /// Wavy Border.
        /// <para>When the item is serialized out as xml, its value is "wave".</para>
        /// </summary>
        public static BorderValues Wave => new("wave");
        /// <summary>
        /// Double Wavy Lines Border.
        /// <para>When the item is serialized out as xml, its value is "doubleWave".</para>
        /// </summary>
        public static BorderValues DoubleWave => new("doubleWave");
        /// <summary>
        /// Small Dash Border.
        /// <para>When the item is serialized out as xml, its value is "dashedSmall".</para>
        /// </summary>
        public static BorderValues DashedSmall => new("dashedSmall");
        /// <summary>
        /// Stroked Dash Dot Border.
        /// <para>When the item is serialized out as xml, its value is "dashDotStroked".</para>
        /// </summary>
        public static BorderValues DashDotStroked => new("dashDotStroked");
        /// <summary>
        /// 3D Embossed Border.
        /// <para>When the item is serialized out as xml, its value is "threeDEmboss".</para>
        /// </summary>
        public static BorderValues ThreeDEmboss => new("threeDEmboss");
        /// <summary>
        /// 3D Engraved Border.
        /// <para>When the item is serialized out as xml, its value is "threeDEngrave".</para>
        /// </summary>
        public static BorderValues ThreeDEngrave => new("threeDEngrave");
        /// <summary>
        /// Outset Border.
        /// <para>When the item is serialized out as xml, its value is "HTMLOutset".</para>
        /// </summary>
        public static BorderValues HTMLOutset => new("HTMLOutset");
        /// <summary>
        /// Inset Border.
        /// <para>When the item is serialized out as xml, its value is "HTMLInset".</para>
        /// </summary>
        public static BorderValues HTMLInset => new("HTMLInset");
    
    }

    /// <summary>
    /// Text Wrapping Type
    /// </summary>
    public readonly record struct WrapValues : IEnumValue, IEnumValueFactory<WrapValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new WrapValues enum instance
        /// </summary>
        public WrapValues(string value) => _value = value;
        WrapValues IEnumValueFactory<WrapValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "topAndBottom" => true,
            "square" => true,
            "none" => true,
            "tight" => true,
            "through" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "topAndBottom";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top and bottom wrapping.
        /// <para>When the item is serialized out as xml, its value is "topAndBottom".</para>
        /// </summary>
        public static WrapValues TopAndBottom => new("topAndBottom");
        /// <summary>
        /// Square wrapping.
        /// <para>When the item is serialized out as xml, its value is "square".</para>
        /// </summary>
        public static WrapValues Square => new("square");
        /// <summary>
        /// No wrapping.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static WrapValues None => new("none");
        /// <summary>
        /// Tight wrapping.
        /// <para>When the item is serialized out as xml, its value is "tight".</para>
        /// </summary>
        public static WrapValues Tight => new("tight");
        /// <summary>
        /// Through wrapping.
        /// <para>When the item is serialized out as xml, its value is "through".</para>
        /// </summary>
        public static WrapValues Through => new("through");
    
    }

    /// <summary>
    /// Text Wrapping Side
    /// </summary>
    public readonly record struct WrapSideValues : IEnumValue, IEnumValueFactory<WrapSideValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new WrapSideValues enum instance
        /// </summary>
        public WrapSideValues(string value) => _value = value;
        WrapSideValues IEnumValueFactory<WrapSideValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "both" => true,
            "left" => true,
            "right" => true,
            "largest" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "both";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Both sides.
        /// <para>When the item is serialized out as xml, its value is "both".</para>
        /// </summary>
        public static WrapSideValues Both => new("both");
        /// <summary>
        /// Left side.
        /// <para>When the item is serialized out as xml, its value is "left".</para>
        /// </summary>
        public static WrapSideValues Left => new("left");
        /// <summary>
        /// Right side.
        /// <para>When the item is serialized out as xml, its value is "right".</para>
        /// </summary>
        public static WrapSideValues Right => new("right");
        /// <summary>
        /// Largest side.
        /// <para>When the item is serialized out as xml, its value is "largest".</para>
        /// </summary>
        public static WrapSideValues Largest => new("largest");
    
    }

    /// <summary>
    /// Horizontal Anchor Type
    /// </summary>
    public readonly record struct HorizontalAnchorValues : IEnumValue, IEnumValueFactory<HorizontalAnchorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HorizontalAnchorValues enum instance
        /// </summary>
        public HorizontalAnchorValues(string value) => _value = value;
        HorizontalAnchorValues IEnumValueFactory<HorizontalAnchorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "margin" => true,
            "page" => true,
            "text" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "margin";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Margin.
        /// <para>When the item is serialized out as xml, its value is "margin".</para>
        /// </summary>
        public static HorizontalAnchorValues Margin => new("margin");
        /// <summary>
        /// Page.
        /// <para>When the item is serialized out as xml, its value is "page".</para>
        /// </summary>
        public static HorizontalAnchorValues Page => new("page");
        /// <summary>
        /// Text.
        /// <para>When the item is serialized out as xml, its value is "text".</para>
        /// </summary>
        public static HorizontalAnchorValues Text => new("text");
    
    }

    /// <summary>
    /// Vertical Anchor Type
    /// </summary>
    public readonly record struct VerticalAnchorValues : IEnumValue, IEnumValueFactory<VerticalAnchorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VerticalAnchorValues enum instance
        /// </summary>
        public VerticalAnchorValues(string value) => _value = value;
        VerticalAnchorValues IEnumValueFactory<VerticalAnchorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "margin" => true,
            "page" => true,
            "text" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "margin";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Margin.
        /// <para>When the item is serialized out as xml, its value is "margin".</para>
        /// </summary>
        public static VerticalAnchorValues Margin => new("margin");
        /// <summary>
        /// Page.
        /// <para>When the item is serialized out as xml, its value is "page".</para>
        /// </summary>
        public static VerticalAnchorValues Page => new("page");
        /// <summary>
        /// Text.
        /// <para>When the item is serialized out as xml, its value is "text".</para>
        /// </summary>
        public static VerticalAnchorValues Text => new("text");
    
    }
}