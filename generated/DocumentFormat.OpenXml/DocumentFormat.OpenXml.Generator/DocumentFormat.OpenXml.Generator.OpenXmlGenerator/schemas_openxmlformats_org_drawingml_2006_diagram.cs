// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Drawing;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Office2019.Drawing.Diagram11;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using DocumentFormat.OpenXml.Validation.Semantic;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.Drawing.Diagrams
{
    /// <summary>
    /// <para>Color Transform Definitions.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:colorsDef.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle" /> <c>&lt;dgm:title></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformStyleLabel" /> <c>&lt;dgm:styleLbl></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorsDefinition : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorsDefinition class.
        /// </summary>
        public ColorsDefinition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorsDefinition(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique ID</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Version</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:colorsDef");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformStyleLabel>();
            builder.AddElement<ColorsDefinition>()
                .AddAttribute("uniqueId", a => a.UniqueId)
                .AddAttribute("minVer", a => a.MinVersion);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformStyleLabel), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new AttributeValueSetConstraint(builder.CreateQName("dgm:minVer"), true, new string[] { "12.0" }));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorsDefinition>(deep);

        internal ColorsDefinition(DiagramColorsPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the DiagramColorsPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(DiagramColorsPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the DiagramColorsPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(DiagramColorsPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the DiagramColorsPart associated with this element.
        /// </summary>
        public DiagramColorsPart? DiagramColorsPart
        {
            get => OpenXmlPart as DiagramColorsPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Color Transform Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:colorsDefHdr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle" /> <c>&lt;dgm:title></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorsDefinitionHeader : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeader class.
        /// </summary>
        public ColorsDefinitionHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinitionHeader(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinitionHeader(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeader class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorsDefinitionHeader(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique ID</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Version</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Resource ID</para>
        /// <para>Represents the following attribute in the schema: resId</para>
        /// </summary>
        public Int32Value? ResourceId
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:colorsDefHdr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle>();
            builder.AddElement<ColorsDefinitionHeader>()
                .AddAttribute("uniqueId", a => a.UniqueId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minVer", a => a.MinVersion)
                .AddAttribute("resId", a => a.ResourceId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorDefinitionTitle), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformDescription), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategories), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorsDefinitionHeader>(deep);
    }

    /// <summary>
    /// <para>Color Transform Header List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:colorsDefHdrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader" /> <c>&lt;dgm:colorsDefHdr></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorsDefinitionHeaderList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeaderList class.
        /// </summary>
        public ColorsDefinitionHeaderList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinitionHeaderList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorsDefinitionHeaderList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsDefinitionHeaderList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorsDefinitionHeaderList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:colorsDefHdrLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorsDefinitionHeaderList>(deep);
    }

    /// <summary>
    /// <para>Data Model.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:dataModel.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Background" /> <c>&lt;dgm:bg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Whole" /> <c>&lt;dgm:whole></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList" /> <c>&lt;dgm:cxnLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PointList" /> <c>&lt;dgm:ptLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataModelRoot : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the DataModelRoot class.
        /// </summary>
        public DataModelRoot() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelRoot class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModelRoot(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelRoot class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModelRoot(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelRoot class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataModelRoot(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:dataModel");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Background>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Whole>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PointList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PointList), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Background), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Whole), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Point List.</para>
        /// <para>Represents the following element tag in the schema: dgm:ptLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PointList? PointList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PointList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Connection List.</para>
        /// <para>Represents the following element tag in the schema: dgm:cxnLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList? ConnectionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Background Formatting.</para>
        /// <para>Represents the following element tag in the schema: dgm:bg.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Background? Background
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Background>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Whole E2O Formatting.</para>
        /// <para>Represents the following element tag in the schema: dgm:whole.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Whole? Whole
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Whole>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DataModelExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList? DataModelExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataModelRoot>(deep);

        internal DataModelRoot(DiagramDataPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the DiagramDataPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(DiagramDataPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the DiagramDataPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(DiagramDataPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the DiagramDataPart associated with this element.
        /// </summary>
        public DiagramDataPart? DiagramDataPart
        {
            get => OpenXmlPart as DiagramDataPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Layout Definition.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:layoutDef.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Description" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode" /> <c>&lt;dgm:layoutNode></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Title" /> <c>&lt;dgm:title></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.SampleData" /> <c>&lt;dgm:sampData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleData" /> <c>&lt;dgm:styleData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorData" /> <c>&lt;dgm:clrData></c></description></item>
    /// </list>
    /// </remark>
    public partial class LayoutDefinition : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the LayoutDefinition class.
        /// </summary>
        public LayoutDefinition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LayoutDefinition(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>uniqueId</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>minVer</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>defStyle</para>
        /// <para>Represents the following attribute in the schema: defStyle</para>
        /// </summary>
        public StringValue? DefaultStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:layoutDef");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Description>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Title>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.SampleData>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleData>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorData>();
            builder.AddElement<LayoutDefinition>()
                .AddAttribute("uniqueId", a => a.UniqueId)
                .AddAttribute("minVer", a => a.MinVersion)
                .AddAttribute("defStyle", a => a.DefaultStyle);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Title), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Description), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.SampleData), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleData), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorData), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LayoutDefinition>(deep);

        internal LayoutDefinition(DiagramLayoutDefinitionPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the DiagramLayoutDefinitionPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(DiagramLayoutDefinitionPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the DiagramLayoutDefinitionPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(DiagramLayoutDefinitionPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the DiagramLayoutDefinitionPart associated with this element.
        /// </summary>
        public DiagramLayoutDefinitionPart? DiagramLayoutDefinitionPart
        {
            get => OpenXmlPart as DiagramLayoutDefinitionPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Layout Definition Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:layoutDefHdr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Description" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Title" /> <c>&lt;dgm:title></c></description></item>
    /// </list>
    /// </remark>
    public partial class LayoutDefinitionHeader : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeader class.
        /// </summary>
        public LayoutDefinitionHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinitionHeader(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinitionHeader(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeader class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LayoutDefinitionHeader(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique Identifier</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Version</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Default Style</para>
        /// <para>Represents the following attribute in the schema: defStyle</para>
        /// </summary>
        public StringValue? DefaultStyle
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Resource Identifier</para>
        /// <para>Represents the following attribute in the schema: resId</para>
        /// </summary>
        public Int32Value? ResourceId
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:layoutDefHdr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Description>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Title>();
            builder.AddElement<LayoutDefinitionHeader>()
                .AddAttribute("uniqueId", a => a.UniqueId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minVer", a => a.MinVersion)
                .AddAttribute("defStyle", a => a.DefaultStyle)
                .AddAttribute("resId", a => a.ResourceId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Title), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Description), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.CategoryList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LayoutDefinitionHeader>(deep);
    }

    /// <summary>
    /// <para>Diagram Layout Header List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:layoutDefHdrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader" /> <c>&lt;dgm:layoutDefHdr></c></description></item>
    /// </list>
    /// </remark>
    public partial class LayoutDefinitionHeaderList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeaderList class.
        /// </summary>
        public LayoutDefinitionHeaderList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinitionHeaderList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutDefinitionHeaderList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutDefinitionHeaderList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LayoutDefinitionHeaderList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:layoutDefHdrLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LayoutDefinitionHeaderList>(deep);
    }

    /// <summary>
    /// <para>Explicit Relationships to Diagram Parts.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:relIds.</para>
    /// </summary>
    public partial class RelationshipIds : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the RelationshipIds class.
        /// </summary>
        public RelationshipIds() : base()
        {
        }

        /// <summary>
        /// <para>Explicit Relationship to Diagram Data Part</para>
        /// <para>Represents the following attribute in the schema: r:dm</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? DataPart
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Explicit Relationship to Diagram Layout Definition Part</para>
        /// <para>Represents the following attribute in the schema: r:lo</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? LayoutPart
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Explicit Relationship to Style Definition Part</para>
        /// <para>Represents the following attribute in the schema: r:qs</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? StylePart
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Explicit Relationship to Diagram Colors Part</para>
        /// <para>Represents the following attribute in the schema: r:cs</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? ColorPart
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:relIds");
            builder.AddElement<RelationshipIds>()
                .AddAttribute("r:dm", a => a.DataPart, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:lo", a => a.LayoutPart, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:qs", a => a.StylePart, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r:cs", a => a.ColorPart, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.AddConstraint(new RelationshipTypeConstraint(builder.CreateQName("dgm:cs"), "http://schemas.openxmlformats.org/officeDocument/2006/relationships/diagramColors"));
            builder.AddConstraint(new RelationshipTypeConstraint(builder.CreateQName("dgm:dm"), "http://schemas.openxmlformats.org/officeDocument/2006/relationships/diagramData"));
            builder.AddConstraint(new RelationshipTypeConstraint(builder.CreateQName("dgm:lo"), "http://schemas.openxmlformats.org/officeDocument/2006/relationships/diagramLayout"));
            builder.AddConstraint(new RelationshipTypeConstraint(builder.CreateQName("dgm:qs"), "http://schemas.openxmlformats.org/officeDocument/2006/relationships/diagramQuickStyle"));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:dm")));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RelationshipIds>(deep);
    }

    /// <summary>
    /// <para>Style Definition.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleDef.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D" /> <c>&lt;dgm:scene3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle" /> <c>&lt;dgm:title></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabel" /> <c>&lt;dgm:styleLbl></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleDefinition : OpenXmlPartRootElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDefinition class.
        /// </summary>
        public StyleDefinition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleDefinition(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique Style ID</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Version</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleDef");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabel>();
            builder.AddElement<StyleDefinition>()
                .AddAttribute("uniqueId", a => a.UniqueId)
                .AddAttribute("minVer", a => a.MinVersion);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabel), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDefinition>(deep);

        internal StyleDefinition(DiagramStylePart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the DiagramStylePart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(DiagramStylePart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the DiagramStylePart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(DiagramStylePart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the DiagramStylePart associated with this element.
        /// </summary>
        public DiagramStylePart? DiagramStylePart
        {
            get => OpenXmlPart as DiagramStylePart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Style Definition Header.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleDefHdr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories" /> <c>&lt;dgm:catLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription" /> <c>&lt;dgm:desc></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle" /> <c>&lt;dgm:title></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleDefinitionHeader : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeader class.
        /// </summary>
        public StyleDefinitionHeader() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinitionHeader(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeader class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinitionHeader(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeader class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleDefinitionHeader(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Unique Style ID</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Minimum Version</para>
        /// <para>Represents the following attribute in the schema: minVer</para>
        /// </summary>
        public StringValue? MinVersion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Resource ID</para>
        /// <para>Represents the following attribute in the schema: resId</para>
        /// </summary>
        public Int32Value? ResourceId
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleDefHdr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle>();
            builder.AddElement<StyleDefinitionHeader>()
                .AddAttribute("uniqueId", a => a.UniqueId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("minVer", a => a.MinVersion)
                .AddAttribute("resId", a => a.ResourceId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionTitle), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleLabelDescription), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategories), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDefinitionHeader>(deep);
    }

    /// <summary>
    /// <para>List of Style Definition Headers.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleDefHdrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader" /> <c>&lt;dgm:styleDefHdr></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleDefinitionHeaderList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeaderList class.
        /// </summary>
        public StyleDefinitionHeaderList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinitionHeaderList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeaderList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDefinitionHeaderList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDefinitionHeaderList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleDefinitionHeaderList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleDefHdrLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDefinitionHeaderList>(deep);
    }

    /// <summary>
    /// <para>Color Transform Category.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:cat.</para>
    /// </summary>
    public partial class ColorTransformCategory : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorTransformCategory class.
        /// </summary>
        public ColorTransformCategory() : base()
        {
        }

        /// <summary>
        /// <para>Category Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Priority</para>
        /// <para>Represents the following attribute in the schema: pri</para>
        /// </summary>
        public UInt32Value? Priority
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:cat");
            builder.AddElement<ColorTransformCategory>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("pri", a => a.Priority, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorTransformCategory>(deep);
    }

    /// <summary>
    /// <para>Fill Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:fillClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class FillColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the FillColorList class.
        /// </summary>
        public FillColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FillColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FillColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FillColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FillColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FillColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FillColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:fillClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FillColorList>(deep);
    }

    /// <summary>
    /// <para>Line Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:linClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class LineColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the LineColorList class.
        /// </summary>
        public LineColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LineColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LineColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LineColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LineColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LineColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LineColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:linClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LineColorList>(deep);
    }

    /// <summary>
    /// <para>Effect Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:effectClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class EffectColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the EffectColorList class.
        /// </summary>
        public EffectColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EffectColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EffectColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EffectColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public EffectColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the EffectColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public EffectColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:effectClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EffectColorList>(deep);
    }

    /// <summary>
    /// <para>Text Line Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:txLinClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextLineColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the TextLineColorList class.
        /// </summary>
        public TextLineColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextLineColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextLineColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextLineColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextLineColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextLineColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextLineColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:txLinClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextLineColorList>(deep);
    }

    /// <summary>
    /// <para>Text Fill Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:txFillClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextFillColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the TextFillColorList class.
        /// </summary>
        public TextFillColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFillColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextFillColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFillColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextFillColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextFillColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextFillColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:txFillClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextFillColorList>(deep);
    }

    /// <summary>
    /// <para>Text Effect Color List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:txEffectClrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextEffectColorList : ColorsType
    {
        /// <summary>
        /// Initializes a new instance of the TextEffectColorList class.
        /// </summary>
        public TextEffectColorList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextEffectColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextEffectColorList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextEffectColorList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextEffectColorList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextEffectColorList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextEffectColorList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:txEffectClrLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 0)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.RgbColorModelHex), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.HslColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SystemColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SchemeColor), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetColor), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextEffectColorList>(deep);
    }

    /// <summary>
    /// <para>Defines the ColorsType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class ColorsType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorsType class.
        /// </summary>
        protected ColorsType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected ColorsType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected ColorsType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorsType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected ColorsType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Color Application Method Type</para>
        /// <para>Represents the following attribute in the schema: meth</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ColorApplicationMethodValues>? Method
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ColorApplicationMethodValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hue Direction</para>
        /// <para>Represents the following attribute in the schema: hueDir</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HueDirectionValues>? HueDirection
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HueDirectionValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.HslColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PresetColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SchemeColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.RgbColorModelHex>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SystemColor>();
            builder.AddElement<ColorsType>()
                .AddAttribute("meth", a => a.Method, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("hueDir", a => a.HueDirection, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }
    }

    /// <summary>
    /// <para>Defines the ExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Extension" /> <c>&lt;a:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class ExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ExtensionList class.
        /// </summary>
        public ExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Extension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 1, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Extension), 0, 0)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExtensionList>(deep);
    }

    /// <summary>
    /// <para>Title.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:title.</para>
    /// </summary>
    public partial class ColorDefinitionTitle : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorDefinitionTitle class.
        /// </summary>
        public ColorDefinitionTitle() : base()
        {
        }

        /// <summary>
        /// <para>Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:title");
            builder.AddElement<ColorDefinitionTitle>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorDefinitionTitle>(deep);
    }

    /// <summary>
    /// <para>Description.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:desc.</para>
    /// </summary>
    public partial class ColorTransformDescription : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorTransformDescription class.
        /// </summary>
        public ColorTransformDescription() : base()
        {
        }

        /// <summary>
        /// <para>Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:desc");
            builder.AddElement<ColorTransformDescription>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorTransformDescription>(deep);
    }

    /// <summary>
    /// <para>Color Transform Category List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:catLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategory" /> <c>&lt;dgm:cat></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorTransformCategories : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorTransformCategories class.
        /// </summary>
        public ColorTransformCategories() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformCategories class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorTransformCategories(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformCategories class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorTransformCategories(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformCategories class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorTransformCategories(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:catLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategory>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorTransformCategory), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorTransformCategories>(deep);
    }

    /// <summary>
    /// <para>Style Label.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleLbl.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.FillColorList" /> <c>&lt;dgm:fillClrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LineColorList" /> <c>&lt;dgm:linClrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.EffectColorList" /> <c>&lt;dgm:effectClrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.TextLineColorList" /> <c>&lt;dgm:txLinClrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.TextFillColorList" /> <c>&lt;dgm:txFillClrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.TextEffectColorList" /> <c>&lt;dgm:txEffectClrLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorTransformStyleLabel : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ColorTransformStyleLabel class.
        /// </summary>
        public ColorTransformStyleLabel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformStyleLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorTransformStyleLabel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformStyleLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorTransformStyleLabel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorTransformStyleLabel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorTransformStyleLabel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleLbl");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.FillColorList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LineColorList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.EffectColorList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.TextLineColorList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.TextFillColorList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.TextEffectColorList>();
            builder.AddElement<ColorTransformStyleLabel>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.FillColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LineColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.EffectColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.TextLineColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.TextFillColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.TextEffectColorList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Fill Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:fillClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.FillColorList? FillColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.FillColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Line Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:linClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.LineColorList? LineColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.LineColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Effect Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:effectClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.EffectColorList? EffectColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.EffectColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Line Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:txLinClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.TextLineColorList? TextLineColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.TextLineColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Fill Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:txFillClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.TextFillColorList? TextFillColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.TextFillColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Effect Color List.</para>
        /// <para>Represents the following element tag in the schema: dgm:txEffectClrLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.TextEffectColorList? TextEffectColorList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.TextEffectColorList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorTransformStyleLabel>(deep);
    }

    /// <summary>
    /// <para>Point.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:pt.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PtExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ShapeProperties" /> <c>&lt;dgm:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.TextBody" /> <c>&lt;dgm:t></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PropertySet" /> <c>&lt;dgm:prSet></c></description></item>
    /// </list>
    /// </remark>
    public partial class Point : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Point class.
        /// </summary>
        public Point() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Point class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Point(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Point class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Point(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Point class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Point(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Model Identifier</para>
        /// <para>Represents the following attribute in the schema: modelId</para>
        /// </summary>
        public StringValue? ModelId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Point Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.PointValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.PointValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Connection Identifier</para>
        /// <para>Represents the following attribute in the schema: cxnId</para>
        /// </summary>
        public StringValue? ConnectionId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:pt");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PtExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.TextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PropertySet>();
            builder.AddElement<Point>()
                .AddAttribute("modelId", a => a.ModelId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("cxnId", a => a.ConnectionId, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PropertySet), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ShapeProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.TextBody), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PtExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Property Set.</para>
        /// <para>Represents the following element tag in the schema: dgm:prSet.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PropertySet? PropertySet
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PropertySet>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Shape Properties.</para>
        /// <para>Represents the following element tag in the schema: dgm:spPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ShapeProperties? ShapeProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ShapeProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Body.</para>
        /// <para>Represents the following element tag in the schema: dgm:t.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.TextBody? TextBody
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.TextBody>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>PtExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PtExtensionList? PtExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PtExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Point>(deep);
    }

    /// <summary>
    /// <para>Connection.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:cxn.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Connection : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Connection class.
        /// </summary>
        public Connection() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connection(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Connection(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Connection class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Connection(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Model Identifier</para>
        /// <para>Represents the following attribute in the schema: modelId</para>
        /// </summary>
        public StringValue? ModelId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Point Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Identifier</para>
        /// <para>Represents the following attribute in the schema: srcId</para>
        /// </summary>
        public StringValue? SourceId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination Identifier</para>
        /// <para>Represents the following attribute in the schema: destId</para>
        /// </summary>
        public StringValue? DestinationId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Source Position</para>
        /// <para>Represents the following attribute in the schema: srcOrd</para>
        /// </summary>
        public UInt32Value? SourcePosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Destination Position</para>
        /// <para>Represents the following attribute in the schema: destOrd</para>
        /// </summary>
        public UInt32Value? DestinationPosition
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Parent Transition Identifier</para>
        /// <para>Represents the following attribute in the schema: parTransId</para>
        /// </summary>
        public StringValue? ParentTransitionId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Sibling Transition Identifier</para>
        /// <para>Represents the following attribute in the schema: sibTransId</para>
        /// </summary>
        public StringValue? SiblingTransitionId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Presentation Identifier</para>
        /// <para>Represents the following attribute in the schema: presId</para>
        /// </summary>
        public StringValue? PresentationId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:cxn");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddElement<Connection>()
                .AddAttribute("modelId", a => a.ModelId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("srcId", a => a.SourceId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("destId", a => a.DestinationId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("srcOrd", a => a.SourcePosition, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("destOrd", a => a.DestinationPosition, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("parTransId", a => a.ParentTransitionId, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("sibTransId", a => a.SiblingTransitionId, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("presId", a => a.PresentationId);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:modelId"), true, builder.CreateQName("dgm:cxnLst")));
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:parTransId"), true, null));
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Connection>(deep);
    }

    /// <summary>
    /// <para>Constraint.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:constr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Constraint : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Constraint class.
        /// </summary>
        public Constraint() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraint class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Constraint(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraint class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Constraint(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraint class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Constraint(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Constraint Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>For</para>
        /// <para>Represents the following attribute in the schema: for</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>? For
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>For Name</para>
        /// <para>Represents the following attribute in the schema: forName</para>
        /// </summary>
        public StringValue? ForName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Point Type</para>
        /// <para>Represents the following attribute in the schema: ptType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>? PointType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference Type</para>
        /// <para>Represents the following attribute in the schema: refType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>? ReferenceType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference For</para>
        /// <para>Represents the following attribute in the schema: refFor</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>? ReferenceFor
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference For Name</para>
        /// <para>Represents the following attribute in the schema: refForName</para>
        /// </summary>
        public StringValue? ReferenceForName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference Point Type</para>
        /// <para>Represents the following attribute in the schema: refPtType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>? ReferencePointType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Operator</para>
        /// <para>Represents the following attribute in the schema: op</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.BoolOperatorValues>? Operator
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.BoolOperatorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Factor</para>
        /// <para>Represents the following attribute in the schema: fact</para>
        /// </summary>
        public DoubleValue? Fact
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:constr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddElement<Constraint>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("for", a => a.For, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("forName", a => a.ForName)
                .AddAttribute("ptType", a => a.PointType, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("refType", a => a.ReferenceType, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("refFor", a => a.ReferenceFor, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("refForName", a => a.ReferenceForName)
                .AddAttribute("refPtType", a => a.ReferencePointType, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("op", a => a.Operator, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("val", a => a.Val)
                .AddAttribute("fact", a => a.Fact);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Constraint>(deep);
    }

    /// <summary>
    /// <para>Rule.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:rule.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Rule : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Rule class.
        /// </summary>
        public Rule() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Rule class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Rule(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Rule class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Rule(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Rule class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Rule(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Constraint Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>For</para>
        /// <para>Represents the following attribute in the schema: for</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>? For
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConstraintRelationshipValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>For Name</para>
        /// <para>Represents the following attribute in the schema: forName</para>
        /// </summary>
        public StringValue? ForName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Point Type</para>
        /// <para>Represents the following attribute in the schema: ptType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>? PointType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Factor</para>
        /// <para>Represents the following attribute in the schema: fact</para>
        /// </summary>
        public DoubleValue? Fact
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Max Value</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public DoubleValue? Max
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:rule");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddElement<Rule>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("for", a => a.For, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("forName", a => a.ForName)
                .AddAttribute("ptType", a => a.PointType, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("val", a => a.Val)
                .AddAttribute("fact", a => a.Fact)
                .AddAttribute("max", a => a.Max);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Rule>(deep);
    }

    /// <summary>
    /// <para>Shape Adjust.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:adj.</para>
    /// </summary>
    public partial class Adjust : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Adjust class.
        /// </summary>
        public Adjust() : base()
        {
        }

        /// <summary>
        /// <para>Adjust Handle Index</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:adj");
            builder.AddElement<Adjust>()
                .AddAttribute("idx", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (1L) });
                })
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Adjust>(deep);
    }

    /// <summary>
    /// <para>Shape Adjust List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:adjLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Adjust" /> <c>&lt;dgm:adj></c></description></item>
    /// </list>
    /// </remark>
    public partial class AdjustList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the AdjustList class.
        /// </summary>
        public AdjustList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AdjustList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AdjustList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AdjustList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AdjustList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AdjustList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AdjustList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:adjLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Adjust>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Adjust), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AdjustList>(deep);
    }

    /// <summary>
    /// <para>Parameter.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:param.</para>
    /// </summary>
    public partial class Parameter : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Parameter class.
        /// </summary>
        public Parameter() : base()
        {
        }

        /// <summary>
        /// <para>Parameter Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ParameterIdValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ParameterIdValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:param");
            builder.AddElement<Parameter>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HorizontalAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.VerticalAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ChildDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ChildAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.SecondaryChildAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.LinearDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.SecondaryLinearDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.StartingElementValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.BendPointValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectorRoutingValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ArrowheadStyleValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectorDimensionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.RotationPathValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.CenterShapeMappingValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.NodeHorizontalAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.NodeVerticalAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FallbackDimensionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.TextDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.PyramidAccentPositionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.PyramidAccentTextMarginValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.TextBlockDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.TextAnchorHorizontalValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.TextAnchorVerticalValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.TextAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AutoTextRotationValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.GrowDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FlowDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ContinueDirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.BreakpointValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.OffsetValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyAlignmentValues>>(EnumValidator.Instance);
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator<DoubleValue>(NumberValidator.Instance);
                        union.AddValidator<BooleanValue>(NumberValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectorPointValues>>(EnumValidator.Instance);
                    });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Parameter>(deep);
    }

    /// <summary>
    /// <para>Algorithm.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:alg.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Parameter" /> <c>&lt;dgm:param></c></description></item>
    /// </list>
    /// </remark>
    public partial class Algorithm : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Algorithm class.
        /// </summary>
        public Algorithm() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Algorithm class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Algorithm(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Algorithm class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Algorithm(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Algorithm class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Algorithm(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Algorithm Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AlgorithmValues>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AlgorithmValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Revision Number</para>
        /// <para>Represents the following attribute in the schema: rev</para>
        /// </summary>
        public UInt32Value? Revision
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:alg");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Parameter>();
            builder.AddElement<Algorithm>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("rev", a => a.Revision);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Parameter), 0, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Algorithm>(deep);
    }

    /// <summary>
    /// <para>Shape.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:shape.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AdjustList" /> <c>&lt;dgm:adjLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Shape : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Shape class.
        /// </summary>
        public Shape() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Shape(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Shape(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Shape(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Rotation</para>
        /// <para>Represents the following attribute in the schema: rot</para>
        /// </summary>
        public DoubleValue? Rotation
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Shape Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Relationship to Image Part</para>
        /// <para>Represents the following attribute in the schema: r:blip</para>
        /// </summary>
        /// <remark>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remark>
        public StringValue? Blip
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Z-Order Offset</para>
        /// <para>Represents the following attribute in the schema: zOrderOff</para>
        /// </summary>
        public Int32Value? ZOrderOffset
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Geometry</para>
        /// <para>Represents the following attribute in the schema: hideGeom</para>
        /// </summary>
        public BooleanValue? HideGeometry
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Prevent Text Editing</para>
        /// <para>Represents the following attribute in the schema: lkTxEntry</para>
        /// </summary>
        public BooleanValue? LockedText
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Image Placeholder</para>
        /// <para>Represents the following attribute in the schema: blipPhldr</para>
        /// </summary>
        public BooleanValue? BlipPlaceholder
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:shape");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.AdjustList>();
            builder.AddElement<Shape>()
                .AddAttribute("rot", a => a.Rotation)
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.ShapeTypeValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.OutputShapeValues>>(EnumValidator.Instance);
                    });
                })
                .AddAttribute("r:blip", a => a.Blip)
                .AddAttribute("zOrderOff", a => a.ZOrderOffset)
                .AddAttribute("hideGeom", a => a.HideGeometry)
                .AddAttribute("lkTxEntry", a => a.LockedText)
                .AddAttribute("blipPhldr", a => a.BlipPlaceholder);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.AdjustList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new RelationshipTypeConstraint(builder.CreateQName("dgm:blip"), "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"));
            builder.AddConstraint(new RelationshipExistConstraint(builder.CreateQName("r:blip")));
        }

        /// <summary>
        /// <para>Shape Adjust List.</para>
        /// <para>Represents the following element tag in the schema: dgm:adjLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.AdjustList? AdjustList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.AdjustList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Shape>(deep);
    }

    /// <summary>
    /// <para>Presentation Of.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:presOf.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class PresentationOf : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PresentationOf class.
        /// </summary>
        public PresentationOf() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationOf class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PresentationOf(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationOf class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PresentationOf(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationOf class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PresentationOf(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>? Axis
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Point Type</para>
        /// <para>Represents the following attribute in the schema: ptType</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>? PointType
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Last Transition</para>
        /// <para>Represents the following attribute in the schema: hideLastTrans</para>
        /// </summary>
        public ListValue<BooleanValue>? HideLastTrans
        {
            get => GetAttribute<ListValue<BooleanValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Start</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public ListValue<Int32Value>? Start
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: cnt</para>
        /// </summary>
        public ListValue<UInt32Value>? Count
        {
            get => GetAttribute<ListValue<UInt32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Step</para>
        /// <para>Represents the following attribute in the schema: step</para>
        /// </summary>
        public ListValue<Int32Value>? Step
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:presOf");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddElement<PresentationOf>()
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("ptType", a => a.PointType)
                .AddAttribute("hideLastTrans", a => a.HideLastTrans)
                .AddAttribute("st", a => a.Start)
                .AddAttribute("cnt", a => a.Count)
                .AddAttribute("step", a => a.Step);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PresentationOf>(deep);
    }

    /// <summary>
    /// <para>Constraint List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:constrLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Constraint" /> <c>&lt;dgm:constr></c></description></item>
    /// </list>
    /// </remark>
    public partial class Constraints : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Constraints class.
        /// </summary>
        public Constraints() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraints class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Constraints(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraints class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Constraints(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Constraints class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Constraints(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:constrLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Constraint>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Constraint), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Constraints>(deep);
    }

    /// <summary>
    /// <para>Rule List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:ruleLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Rule" /> <c>&lt;dgm:rule></c></description></item>
    /// </list>
    /// </remark>
    public partial class RuleList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the RuleList class.
        /// </summary>
        public RuleList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RuleList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RuleList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RuleList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RuleList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RuleList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RuleList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:ruleLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Rule>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Rule), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RuleList>(deep);
    }

    /// <summary>
    /// <para>Variable List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:varLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel" /> <c>&lt;dgm:animLvl></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne" /> <c>&lt;dgm:animOne></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled" /> <c>&lt;dgm:bulletEnabled></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren" /> <c>&lt;dgm:chMax></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren" /> <c>&lt;dgm:chPref></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Direction" /> <c>&lt;dgm:dir></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch" /> <c>&lt;dgm:hierBranch></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart" /> <c>&lt;dgm:orgChart></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles" /> <c>&lt;dgm:resizeHandles></c></description></item>
    /// </list>
    /// </remark>
    public partial class VariableList : LayoutVariablePropertySetType
    {
        /// <summary>
        /// Initializes a new instance of the VariableList class.
        /// </summary>
        public VariableList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VariableList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VariableList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VariableList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public VariableList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the VariableList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public VariableList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:varLst");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Direction), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VariableList>(deep);
    }

    /// <summary>
    /// <para>Presentation Layout Variables.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:presLayoutVars.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel" /> <c>&lt;dgm:animLvl></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne" /> <c>&lt;dgm:animOne></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled" /> <c>&lt;dgm:bulletEnabled></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren" /> <c>&lt;dgm:chMax></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren" /> <c>&lt;dgm:chPref></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Direction" /> <c>&lt;dgm:dir></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch" /> <c>&lt;dgm:hierBranch></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart" /> <c>&lt;dgm:orgChart></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles" /> <c>&lt;dgm:resizeHandles></c></description></item>
    /// </list>
    /// </remark>
    public partial class PresentationLayoutVariables : LayoutVariablePropertySetType
    {
        /// <summary>
        /// Initializes a new instance of the PresentationLayoutVariables class.
        /// </summary>
        public PresentationLayoutVariables() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationLayoutVariables class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PresentationLayoutVariables(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationLayoutVariables class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PresentationLayoutVariables(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PresentationLayoutVariables class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PresentationLayoutVariables(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:presLayoutVars");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Direction), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PresentationLayoutVariables>(deep);
    }

    /// <summary>
    /// <para>Defines the LayoutVariablePropertySetType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel" /> <c>&lt;dgm:animLvl></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne" /> <c>&lt;dgm:animOne></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled" /> <c>&lt;dgm:bulletEnabled></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren" /> <c>&lt;dgm:chMax></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren" /> <c>&lt;dgm:chPref></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Direction" /> <c>&lt;dgm:dir></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch" /> <c>&lt;dgm:hierBranch></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart" /> <c>&lt;dgm:orgChart></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles" /> <c>&lt;dgm:resizeHandles></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class LayoutVariablePropertySetType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the LayoutVariablePropertySetType class.
        /// </summary>
        protected LayoutVariablePropertySetType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutVariablePropertySetType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected LayoutVariablePropertySetType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutVariablePropertySetType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected LayoutVariablePropertySetType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutVariablePropertySetType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected LayoutVariablePropertySetType(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Direction>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles>();
        }

        /// <summary>
        /// <para>Show Organization Chart User Interface.</para>
        /// <para>Represents the following element tag in the schema: dgm:orgChart.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart? OrganizationChart
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.OrganizationChart>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Maximum Children.</para>
        /// <para>Represents the following element tag in the schema: dgm:chMax.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren? MaxNumberOfChildren
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.MaxNumberOfChildren>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Preferred Number of Children.</para>
        /// <para>Represents the following element tag in the schema: dgm:chPref.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren? PreferredNumberOfChildren
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PreferredNumberOfChildren>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Show Insert Bullet.</para>
        /// <para>Represents the following element tag in the schema: dgm:bulletEnabled.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled? BulletEnabled
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.BulletEnabled>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Diagram Direction.</para>
        /// <para>Represents the following element tag in the schema: dgm:dir.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Direction? Direction
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Direction>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Organization Chart Branch Style.</para>
        /// <para>Represents the following element tag in the schema: dgm:hierBranch.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch? HierarchyBranch
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranch>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>One by One Animation String.</para>
        /// <para>Represents the following element tag in the schema: dgm:animOne.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne? AnimateOneByOne
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOne>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Level Animation.</para>
        /// <para>Represents the following element tag in the schema: dgm:animLvl.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel? AnimationLevel
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevel>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Shape Resize Style.</para>
        /// <para>Represents the following element tag in the schema: dgm:resizeHandles.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles? ResizeHandles
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandles>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>For Each.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:forEach.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm" /> <c>&lt;dgm:alg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Choose" /> <c>&lt;dgm:choose></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Constraints" /> <c>&lt;dgm:constrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ForEach" /> <c>&lt;dgm:forEach></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode" /> <c>&lt;dgm:layoutNode></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf" /> <c>&lt;dgm:presOf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.RuleList" /> <c>&lt;dgm:ruleLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Shape" /> <c>&lt;dgm:shape></c></description></item>
    /// </list>
    /// </remark>
    public partial class ForEach : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ForEach class.
        /// </summary>
        public ForEach() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ForEach class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ForEach(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ForEach class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ForEach(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ForEach class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ForEach(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Reference</para>
        /// <para>Represents the following attribute in the schema: ref</para>
        /// </summary>
        public StringValue? Reference
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>? Axis
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Point Type</para>
        /// <para>Represents the following attribute in the schema: ptType</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>? PointType
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Last Transition</para>
        /// <para>Represents the following attribute in the schema: hideLastTrans</para>
        /// </summary>
        public ListValue<BooleanValue>? HideLastTrans
        {
            get => GetAttribute<ListValue<BooleanValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Start</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public ListValue<Int32Value>? Start
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: cnt</para>
        /// </summary>
        public ListValue<UInt32Value>? Count
        {
            get => GetAttribute<ListValue<UInt32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Step</para>
        /// <para>Represents the following attribute in the schema: step</para>
        /// </summary>
        public ListValue<Int32Value>? Step
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:forEach");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Choose>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Constraints>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ForEach>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.RuleList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Shape>();
            builder.AddElement<ForEach>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("ref", a => a.Reference)
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("ptType", a => a.PointType)
                .AddAttribute("hideLastTrans", a => a.HideLastTrans)
                .AddAttribute("st", a => a.Start)
                .AddAttribute("cnt", a => a.Count)
                .AddAttribute("step", a => a.Step);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Shape), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Constraints), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.RuleList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ForEach), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Choose), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:name"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ForEach>(deep);
    }

    /// <summary>
    /// <para>Layout Node.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:layoutNode.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm" /> <c>&lt;dgm:alg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Choose" /> <c>&lt;dgm:choose></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Constraints" /> <c>&lt;dgm:constrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ForEach" /> <c>&lt;dgm:forEach></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode" /> <c>&lt;dgm:layoutNode></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.VariableList" /> <c>&lt;dgm:varLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf" /> <c>&lt;dgm:presOf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.RuleList" /> <c>&lt;dgm:ruleLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Shape" /> <c>&lt;dgm:shape></c></description></item>
    /// </list>
    /// </remark>
    public partial class LayoutNode : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the LayoutNode class.
        /// </summary>
        public LayoutNode() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutNode class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutNode(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutNode class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public LayoutNode(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LayoutNode class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public LayoutNode(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Style Label</para>
        /// <para>Represents the following attribute in the schema: styleLbl</para>
        /// </summary>
        public StringValue? StyleLabel
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Child Order</para>
        /// <para>Represents the following attribute in the schema: chOrder</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ChildOrderValues>? ChildOrder
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ChildOrderValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Move With</para>
        /// <para>Represents the following attribute in the schema: moveWith</para>
        /// </summary>
        public StringValue? MoveWith
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:layoutNode");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Choose>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Constraints>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ForEach>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.VariableList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.RuleList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Shape>();
            builder.AddElement<LayoutNode>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("styleLbl", a => a.StyleLabel)
                .AddAttribute("chOrder", a => a.ChildOrder, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("moveWith", a => a.MoveWith);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Shape), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Constraints), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.RuleList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.VariableList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ForEach), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Choose), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:name"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<LayoutNode>(deep);
    }

    /// <summary>
    /// <para>Choose Element.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:choose.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseElse" /> <c>&lt;dgm:else></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseIf" /> <c>&lt;dgm:if></c></description></item>
    /// </list>
    /// </remark>
    public partial class Choose : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Choose class.
        /// </summary>
        public Choose() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Choose class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Choose(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Choose class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Choose(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Choose class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Choose(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:choose");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseElse>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseIf>();
            builder.AddElement<Choose>()
                .AddAttribute("name", a => a.Name);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseIf), 1, 0),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DiagramChooseElse), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:name"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Choose>(deep);
    }

    /// <summary>
    /// <para>If.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:if.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm" /> <c>&lt;dgm:alg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Choose" /> <c>&lt;dgm:choose></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Constraints" /> <c>&lt;dgm:constrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ForEach" /> <c>&lt;dgm:forEach></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode" /> <c>&lt;dgm:layoutNode></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf" /> <c>&lt;dgm:presOf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.RuleList" /> <c>&lt;dgm:ruleLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Shape" /> <c>&lt;dgm:shape></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiagramChooseIf : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DiagramChooseIf class.
        /// </summary>
        public DiagramChooseIf() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseIf class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramChooseIf(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseIf class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramChooseIf(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseIf class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiagramChooseIf(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Axis</para>
        /// <para>Represents the following attribute in the schema: axis</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>? Axis
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AxisValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Data Point Type</para>
        /// <para>Represents the following attribute in the schema: ptType</para>
        /// </summary>
        public ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>? PointType
        {
            get => GetAttribute<ListValue<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ElementValues>>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hide Last Transition</para>
        /// <para>Represents the following attribute in the schema: hideLastTrans</para>
        /// </summary>
        public ListValue<BooleanValue>? HideLastTrans
        {
            get => GetAttribute<ListValue<BooleanValue>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Start</para>
        /// <para>Represents the following attribute in the schema: st</para>
        /// </summary>
        public ListValue<Int32Value>? Start
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Count</para>
        /// <para>Represents the following attribute in the schema: cnt</para>
        /// </summary>
        public ListValue<UInt32Value>? Count
        {
            get => GetAttribute<ListValue<UInt32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Step</para>
        /// <para>Represents the following attribute in the schema: step</para>
        /// </summary>
        public ListValue<Int32Value>? Step
        {
            get => GetAttribute<ListValue<Int32Value>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Function</para>
        /// <para>Represents the following attribute in the schema: func</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FunctionValues>? Function
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FunctionValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Argument</para>
        /// <para>Represents the following attribute in the schema: arg</para>
        /// </summary>
        public StringValue? Argument
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Operator</para>
        /// <para>Represents the following attribute in the schema: op</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FunctionOperatorValues>? Operator
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.FunctionOperatorValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:if");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Choose>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Constraints>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ForEach>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.RuleList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Shape>();
            builder.AddElement<DiagramChooseIf>()
                .AddAttribute("name", a => a.Name)
                .AddAttribute("axis", a => a.Axis)
                .AddAttribute("ptType", a => a.PointType)
                .AddAttribute("hideLastTrans", a => a.HideLastTrans)
                .AddAttribute("st", a => a.Start)
                .AddAttribute("cnt", a => a.Count)
                .AddAttribute("step", a => a.Step)
                .AddAttribute("func", a => a.Function, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("arg", a => a.Argument, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.VariableValues>>(EnumValidator.Instance);
                    });
                })
                .AddAttribute("op", a => a.Operator, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator<BooleanValue>(NumberValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.DirectionValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranchStyleValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOneValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevelStringValues>>(EnumValidator.Instance);
                        union.AddValidator<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandlesStringValues>>(EnumValidator.Instance);
                    });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Shape), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Constraints), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.RuleList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ForEach), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Choose), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:name"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiagramChooseIf>(deep);
    }

    /// <summary>
    /// <para>Else.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:else.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm" /> <c>&lt;dgm:alg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Choose" /> <c>&lt;dgm:choose></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Constraints" /> <c>&lt;dgm:constrLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ForEach" /> <c>&lt;dgm:forEach></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode" /> <c>&lt;dgm:layoutNode></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf" /> <c>&lt;dgm:presOf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.RuleList" /> <c>&lt;dgm:ruleLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Shape" /> <c>&lt;dgm:shape></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiagramChooseElse : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DiagramChooseElse class.
        /// </summary>
        public DiagramChooseElse() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseElse class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramChooseElse(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseElse class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramChooseElse(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramChooseElse class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiagramChooseElse(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:else");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Choose>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Constraints>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ForEach>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.RuleList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Shape>();
            builder.AddElement<DiagramChooseElse>()
                .AddAttribute("name", a => a.Name);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Algorithm), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Shape), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PresentationOf), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Constraints), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.RuleList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ForEach), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutNode), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Choose), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
            builder.AddConstraint(new UniqueAttributeValueConstraint(builder.CreateQName("dgm:name"), true, null));
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiagramChooseElse>(deep);
    }

    /// <summary>
    /// <para>Data Model.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:dataModel.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Background" /> <c>&lt;dgm:bg></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Whole" /> <c>&lt;dgm:whole></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList" /> <c>&lt;dgm:cxnLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PointList" /> <c>&lt;dgm:ptLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataModel : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataModel class.
        /// </summary>
        public DataModel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataModel(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:dataModel");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Background>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Whole>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PointList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PointList), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Background), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Whole), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Point List.</para>
        /// <para>Represents the following element tag in the schema: dgm:ptLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PointList? PointList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PointList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Connection List.</para>
        /// <para>Represents the following element tag in the schema: dgm:cxnLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList? ConnectionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ConnectionList>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Background Formatting.</para>
        /// <para>Represents the following element tag in the schema: dgm:bg.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Background? Background
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Background>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Whole E2O Formatting.</para>
        /// <para>Represents the following element tag in the schema: dgm:whole.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Whole? Whole
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Whole>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>DataModelExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList? DataModelExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.DataModelExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataModel>(deep);
    }

    /// <summary>
    /// <para>Category.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:cat.</para>
    /// </summary>
    public partial class Category : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Category class.
        /// </summary>
        public Category() : base()
        {
        }

        /// <summary>
        /// <para>Category Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Priority</para>
        /// <para>Represents the following attribute in the schema: pri</para>
        /// </summary>
        public UInt32Value? Priority
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:cat");
            builder.AddElement<Category>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("pri", a => a.Priority, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Category>(deep);
    }

    /// <summary>
    /// <para>Title.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:title.</para>
    /// </summary>
    public partial class Title : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Title class.
        /// </summary>
        public Title() : base()
        {
        }

        /// <summary>
        /// <para>Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:title");
            builder.AddElement<Title>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Title>(deep);
    }

    /// <summary>
    /// <para>Description.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:desc.</para>
    /// </summary>
    public partial class Description : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Description class.
        /// </summary>
        public Description() : base()
        {
        }

        /// <summary>
        /// <para>Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:desc");
            builder.AddElement<Description>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Description>(deep);
    }

    /// <summary>
    /// <para>Category List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:catLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Category" /> <c>&lt;dgm:cat></c></description></item>
    /// </list>
    /// </remark>
    public partial class CategoryList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the CategoryList class.
        /// </summary>
        public CategoryList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CategoryList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CategoryList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CategoryList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public CategoryList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the CategoryList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public CategoryList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:catLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Category>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Category), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CategoryList>(deep);
    }

    /// <summary>
    /// <para>Shape Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:style.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.FontReference" /> <c>&lt;a:fontRef></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.LineReference" /> <c>&lt;a:lnRef></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.FillReference" /> <c>&lt;a:fillRef></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectReference" /> <c>&lt;a:effectRef></c></description></item>
    /// </list>
    /// </remark>
    public partial class Style : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Style class.
        /// </summary>
        public Style() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Style class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Style(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Style class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Style(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Style class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Style(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:style");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.FontReference>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.LineReference>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.FillReference>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectReference>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.LineReference), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.FillReference), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectReference), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.FontReference), 1, 1)
            };
        }

        /// <summary>
        /// <para>LineReference.</para>
        /// <para>Represents the following element tag in the schema: a:lnRef.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.LineReference? LineReference
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.LineReference>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>FillReference.</para>
        /// <para>Represents the following element tag in the schema: a:fillRef.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.FillReference? FillReference
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.FillReference>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>EffectReference.</para>
        /// <para>Represents the following element tag in the schema: a:effectRef.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.EffectReference? EffectReference
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.EffectReference>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Font Reference.</para>
        /// <para>Represents the following element tag in the schema: a:fontRef.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.FontReference? FontReference
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.FontReference>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Style>(deep);
    }

    /// <summary>
    /// <para>Show Organization Chart User Interface.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:orgChart.</para>
    /// </summary>
    public partial class OrganizationChart : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the OrganizationChart class.
        /// </summary>
        public OrganizationChart() : base()
        {
        }

        /// <summary>
        /// <para>Show Organization Chart User Interface Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public BooleanValue? Val
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:orgChart");
            builder.AddElement<OrganizationChart>()
                .AddAttribute("val", a => a.Val);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OrganizationChart>(deep);
    }

    /// <summary>
    /// <para>Maximum Children.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:chMax.</para>
    /// </summary>
    public partial class MaxNumberOfChildren : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the MaxNumberOfChildren class.
        /// </summary>
        public MaxNumberOfChildren() : base()
        {
        }

        /// <summary>
        /// <para>Maximum Children Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:chMax");
            builder.AddElement<MaxNumberOfChildren>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (-1L) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MaxNumberOfChildren>(deep);
    }

    /// <summary>
    /// <para>Preferred Number of Children.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:chPref.</para>
    /// </summary>
    public partial class PreferredNumberOfChildren : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the PreferredNumberOfChildren class.
        /// </summary>
        public PreferredNumberOfChildren() : base()
        {
        }

        /// <summary>
        /// <para>Preferred Number of CHildren Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public Int32Value? Val
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:chPref");
            builder.AddElement<PreferredNumberOfChildren>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (-1L) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PreferredNumberOfChildren>(deep);
    }

    /// <summary>
    /// <para>Show Insert Bullet.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:bulletEnabled.</para>
    /// </summary>
    public partial class BulletEnabled : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the BulletEnabled class.
        /// </summary>
        public BulletEnabled() : base()
        {
        }

        /// <summary>
        /// <para>Show Insert Bullet Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public BooleanValue? Val
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:bulletEnabled");
            builder.AddElement<BulletEnabled>()
                .AddAttribute("val", a => a.Val);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BulletEnabled>(deep);
    }

    /// <summary>
    /// <para>Diagram Direction.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:dir.</para>
    /// </summary>
    public partial class Direction : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the Direction class.
        /// </summary>
        public Direction() : base()
        {
        }

        /// <summary>
        /// <para>Diagram Direction Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.DirectionValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.DirectionValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:dir");
            builder.AddElement<Direction>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Direction>(deep);
    }

    /// <summary>
    /// <para>Organization Chart Branch Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:hierBranch.</para>
    /// </summary>
    public partial class HierarchyBranch : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the HierarchyBranch class.
        /// </summary>
        public HierarchyBranch() : base()
        {
        }

        /// <summary>
        /// <para>Organization Chart Branch Style Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranchStyleValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.HierarchyBranchStyleValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:hierBranch");
            builder.AddElement<HierarchyBranch>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<HierarchyBranch>(deep);
    }

    /// <summary>
    /// <para>One by One Animation String.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:animOne.</para>
    /// </summary>
    public partial class AnimateOneByOne : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the AnimateOneByOne class.
        /// </summary>
        public AnimateOneByOne() : base()
        {
        }

        /// <summary>
        /// <para>One By One Animation Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOneValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimateOneByOneValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:animOne");
            builder.AddElement<AnimateOneByOne>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AnimateOneByOne>(deep);
    }

    /// <summary>
    /// <para>Level Animation.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:animLvl.</para>
    /// </summary>
    public partial class AnimationLevel : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the AnimationLevel class.
        /// </summary>
        public AnimationLevel() : base()
        {
        }

        /// <summary>
        /// <para>Level Animation Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevelStringValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.AnimationLevelStringValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:animLvl");
            builder.AddElement<AnimationLevel>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AnimationLevel>(deep);
    }

    /// <summary>
    /// <para>Shape Resize Style.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:resizeHandles.</para>
    /// </summary>
    public partial class ResizeHandles : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the ResizeHandles class.
        /// </summary>
        public ResizeHandles() : base()
        {
        }

        /// <summary>
        /// <para>Shape Resize Style Type</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandlesStringValues>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.Diagrams.ResizeHandlesStringValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:resizeHandles");
            builder.AddElement<ResizeHandles>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ResizeHandles>(deep);
    }

    /// <summary>
    /// <para>Category.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:cat.</para>
    /// </summary>
    public partial class StyleDisplayCategory : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDisplayCategory class.
        /// </summary>
        public StyleDisplayCategory() : base()
        {
        }

        /// <summary>
        /// <para>Category Type</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public StringValue? Type
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Priority</para>
        /// <para>Represents the following attribute in the schema: pri</para>
        /// </summary>
        public UInt32Value? Priority
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:cat");
            builder.AddElement<StyleDisplayCategory>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsUri = (true) });
                })
                .AddAttribute("pri", a => a.Priority, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDisplayCategory>(deep);
    }

    /// <summary>
    /// <para>3-D Scene.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:scene3d.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Backdrop" /> <c>&lt;a:backdrop></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Camera" /> <c>&lt;a:camera></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.LightRig" /> <c>&lt;a:lightRig></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ExtensionList" /> <c>&lt;a:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Scene3D : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Scene3D class.
        /// </summary>
        public Scene3D() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scene3D class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scene3D(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scene3D class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Scene3D(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Scene3D class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Scene3D(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:scene3d");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Backdrop>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Camera>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.LightRig>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Camera), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.LightRig), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Backdrop), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Camera.</para>
        /// <para>Represents the following element tag in the schema: a:camera.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Camera? Camera
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Camera>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Light Rig.</para>
        /// <para>Represents the following element tag in the schema: a:lightRig.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.LightRig? LightRig
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.LightRig>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Backdrop Plane.</para>
        /// <para>Represents the following element tag in the schema: a:backdrop.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Backdrop? Backdrop
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Backdrop>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: a:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Scene3D>(deep);
    }

    /// <summary>
    /// <para>3-D Shape Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:sp3d.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BevelTop" /> <c>&lt;a:bevelT></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BevelBottom" /> <c>&lt;a:bevelB></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ExtrusionColor" /> <c>&lt;a:extrusionClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ContourColor" /> <c>&lt;a:contourClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ExtensionList" /> <c>&lt;a:extLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class Shape3D : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Shape3D class.
        /// </summary>
        public Shape3D() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape3D class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Shape3D(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape3D class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Shape3D(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Shape3D class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Shape3D(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Shape Depth</para>
        /// <para>Represents the following attribute in the schema: z</para>
        /// </summary>
        public Int64Value? Z
        {
            get => GetAttribute<Int64Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Extrusion Height</para>
        /// <para>Represents the following attribute in the schema: extrusionH</para>
        /// </summary>
        public Int64Value? ExtrusionHeight
        {
            get => GetAttribute<Int64Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Contour Width</para>
        /// <para>Represents the following attribute in the schema: contourW</para>
        /// </summary>
        public Int64Value? ContourWidth
        {
            get => GetAttribute<Int64Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Preset Material Type</para>
        /// <para>Represents the following attribute in the schema: prstMaterial</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>? PresetMaterial
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:sp3d");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BevelTop>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BevelBottom>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ExtrusionColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ContourColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ExtensionList>();
            builder.AddElement<Shape3D>()
                .AddAttribute("z", a => a.Z, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (-27273042329600L), MaxInclusive = (27273042316900L) });
                })
                .AddAttribute("extrusionH", a => a.ExtrusionHeight, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (0L), MaxInclusive = (2147483647L) });
                })
                .AddAttribute("contourW", a => a.ContourWidth, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (0L), MaxInclusive = (2147483647L) });
                })
                .AddAttribute("prstMaterial", a => a.PresetMaterial, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.BevelTop), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.BevelBottom), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ExtrusionColor), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ContourColor), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>Top Bevel.</para>
        /// <para>Represents the following element tag in the schema: a:bevelT.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.BevelTop? BevelTop
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.BevelTop>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Bottom Bevel.</para>
        /// <para>Represents the following element tag in the schema: a:bevelB.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.BevelBottom? BevelBottom
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.BevelBottom>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Extrusion Color.</para>
        /// <para>Represents the following element tag in the schema: a:extrusionClr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.ExtrusionColor? ExtrusionColor
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.ExtrusionColor>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Contour Color.</para>
        /// <para>Represents the following element tag in the schema: a:contourClr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.ContourColor? ContourColor
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.ContourColor>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: a:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Shape3D>(deep);
    }

    /// <summary>
    /// <para>Text Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:txPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.FlatText" /> <c>&lt;a:flatTx></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Shape3DType" /> <c>&lt;a:sp3d></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TextProperties class.
        /// </summary>
        public TextProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:txPr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.FlatText>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Shape3DType>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Shape3DType), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.FlatText), 1, 1)
                    }
                }
            };
        }

        /// <summary>
        /// <para>Apply 3D shape properties.</para>
        /// <para>Represents the following element tag in the schema: a:sp3d.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Shape3DType? Shape3DType
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Shape3DType>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>No text in 3D scene.</para>
        /// <para>Represents the following element tag in the schema: a:flatTx.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.FlatText? FlatText
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.FlatText>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextProperties>(deep);
    }

    /// <summary>
    /// <para>Title.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:title.</para>
    /// </summary>
    public partial class StyleDefinitionTitle : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDefinitionTitle class.
        /// </summary>
        public StyleDefinitionTitle() : base()
        {
        }

        /// <summary>
        /// <para>Natural Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:title");
            builder.AddElement<StyleDefinitionTitle>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDefinitionTitle>(deep);
    }

    /// <summary>
    /// <para>Style Label Description.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:desc.</para>
    /// </summary>
    public partial class StyleLabelDescription : OpenXmlLeafElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleLabelDescription class.
        /// </summary>
        public StyleLabelDescription() : base()
        {
        }

        /// <summary>
        /// <para>Natural Language</para>
        /// <para>Represents the following attribute in the schema: lang</para>
        /// </summary>
        public StringValue? Language
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Description Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public StringValue? Val
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:desc");
            builder.AddElement<StyleLabelDescription>()
                .AddAttribute("lang", a => a.Language)
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleLabelDescription>(deep);
    }

    /// <summary>
    /// <para>Category List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:catLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategory" /> <c>&lt;dgm:cat></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleDisplayCategories : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleDisplayCategories class.
        /// </summary>
        public StyleDisplayCategories() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDisplayCategories class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDisplayCategories(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDisplayCategories class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleDisplayCategories(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleDisplayCategories class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleDisplayCategories(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:catLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategory>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 0, 0)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDisplayCategory), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleDisplayCategories>(deep);
    }

    /// <summary>
    /// <para>Style Label.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleLbl.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList" /> <c>&lt;dgm:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D" /> <c>&lt;dgm:scene3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Shape3D" /> <c>&lt;dgm:sp3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Style" /> <c>&lt;dgm:style></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.TextProperties" /> <c>&lt;dgm:txPr></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleLabel : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the StyleLabel class.
        /// </summary>
        public StyleLabel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleLabel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleLabel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleLabel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleLabel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Style Name</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleLbl");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Shape3D>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Style>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.TextProperties>();
            builder.AddElement<StyleLabel>()
                .AddAttribute("name", a => a.Name, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Shape3D), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.TextProperties), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Style), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>3-D Scene.</para>
        /// <para>Represents the following element tag in the schema: dgm:scene3d.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D? Scene3D
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Scene3D>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>3-D Shape Properties.</para>
        /// <para>Represents the following element tag in the schema: dgm:sp3d.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Shape3D? Shape3D
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Shape3D>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text Properties.</para>
        /// <para>Represents the following element tag in the schema: dgm:txPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.TextProperties? TextProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.TextProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Shape Style.</para>
        /// <para>Represents the following element tag in the schema: dgm:style.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Style? Style
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Style>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: dgm:extLst.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList? ExtensionList
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.ExtensionList>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleLabel>(deep);
    }

    /// <summary>
    /// <para>Point List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:ptLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Point" /> <c>&lt;dgm:pt></c></description></item>
    /// </list>
    /// </remark>
    public partial class PointList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PointList class.
        /// </summary>
        public PointList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PointList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PointList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PointList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PointList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PointList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PointList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:ptLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Point>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Point), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PointList>(deep);
    }

    /// <summary>
    /// <para>Connection List.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:cxnLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Connection" /> <c>&lt;dgm:cxn></c></description></item>
    /// </list>
    /// </remark>
    public partial class ConnectionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ConnectionList class.
        /// </summary>
        public ConnectionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ConnectionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ConnectionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ConnectionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:cxnLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Connection>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Connection), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ConnectionList>(deep);
    }

    /// <summary>
    /// <para>Background Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:bg.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BlipFill" /> <c>&lt;a:blipFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectDag" /> <c>&lt;a:effectDag></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectList" /> <c>&lt;a:effectLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GradientFill" /> <c>&lt;a:gradFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GroupFill" /> <c>&lt;a:grpFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.NoFill" /> <c>&lt;a:noFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PatternFill" /> <c>&lt;a:pattFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SolidFill" /> <c>&lt;a:solidFill></c></description></item>
    /// </list>
    /// </remark>
    public partial class Background : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Background class.
        /// </summary>
        public Background() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Background class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Background(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Background class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Background(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Background class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Background(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:bg");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BlipFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectDag>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GradientFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GroupFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.NoFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PatternFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SolidFill>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.NoFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SolidFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.GradientFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.BlipFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PatternFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.GroupFill), 1, 1)
                    }
                },
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectList), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectDag), 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Background>(deep);
    }

    /// <summary>
    /// <para>Whole E2O Formatting.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:whole.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectDag" /> <c>&lt;a:effectDag></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectList" /> <c>&lt;a:effectLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Outline" /> <c>&lt;a:ln></c></description></item>
    /// </list>
    /// </remark>
    public partial class Whole : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the Whole class.
        /// </summary>
        public Whole() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Whole class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Whole(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Whole class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Whole(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Whole class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Whole(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:whole");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectDag>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Outline>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Outline), 0, 1),
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectList), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectDag), 1, 1)
                    }
                }
            };
        }

        /// <summary>
        /// <para>Outline.</para>
        /// <para>Represents the following element tag in the schema: a:ln.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Outline? Outline
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Outline>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Whole>(deep);
    }

    /// <summary>
    /// <para>Defines the DataModelExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.DataModelExtension" /> <c>&lt;a:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class DataModelExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DataModelExtensionList class.
        /// </summary>
        public DataModelExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModelExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataModelExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataModelExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataModelExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.DataModelExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.DataModelExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataModelExtensionList>(deep);
    }

    /// <summary>
    /// <para>Property Set.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:prSet.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.Style" /> <c>&lt;dgm:style></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.PresentationLayoutVariables" /> <c>&lt;dgm:presLayoutVars></c></description></item>
    /// </list>
    /// </remark>
    public partial class PropertySet : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PropertySet class.
        /// </summary>
        public PropertySet() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PropertySet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PropertySet(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PropertySet class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PropertySet(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PropertySet class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PropertySet(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Presentation Element Identifier</para>
        /// <para>Represents the following attribute in the schema: presAssocID</para>
        /// </summary>
        public StringValue? PresentationElementId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Presentation Name</para>
        /// <para>Represents the following attribute in the schema: presName</para>
        /// </summary>
        public StringValue? PresentationName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Presentation Style Label</para>
        /// <para>Represents the following attribute in the schema: presStyleLbl</para>
        /// </summary>
        public StringValue? PresentationStyleLabel
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Presentation Style Index</para>
        /// <para>Represents the following attribute in the schema: presStyleIdx</para>
        /// </summary>
        public Int32Value? PresentationStyleIndex
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Presentation Style Count</para>
        /// <para>Represents the following attribute in the schema: presStyleCnt</para>
        /// </summary>
        public Int32Value? PresentationStyleCount
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Current Diagram Type</para>
        /// <para>Represents the following attribute in the schema: loTypeId</para>
        /// </summary>
        public StringValue? LayoutTypeId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Current Diagram Category</para>
        /// <para>Represents the following attribute in the schema: loCatId</para>
        /// </summary>
        public StringValue? LayoutCategoryId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Current Style Type</para>
        /// <para>Represents the following attribute in the schema: qsTypeId</para>
        /// </summary>
        public StringValue? QuickStyleTypeId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Current Style Category</para>
        /// <para>Represents the following attribute in the schema: qsCatId</para>
        /// </summary>
        public StringValue? QuickStyleCategoryId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Color Transform Type Identifier</para>
        /// <para>Represents the following attribute in the schema: csTypeId</para>
        /// </summary>
        public StringValue? ColorType
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Color Transform Category</para>
        /// <para>Represents the following attribute in the schema: csCatId</para>
        /// </summary>
        public StringValue? ColorCategoryId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Coherent 3D Behavior</para>
        /// <para>Represents the following attribute in the schema: coherent3DOff</para>
        /// </summary>
        public BooleanValue? Coherent3D
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Placeholder Text</para>
        /// <para>Represents the following attribute in the schema: phldrT</para>
        /// </summary>
        public StringValue? PlaceholderText
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Placeholder</para>
        /// <para>Represents the following attribute in the schema: phldr</para>
        /// </summary>
        public BooleanValue? Placeholder
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Rotation</para>
        /// <para>Represents the following attribute in the schema: custAng</para>
        /// </summary>
        public Int32Value? Rotation
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Vertical Flip</para>
        /// <para>Represents the following attribute in the schema: custFlipVert</para>
        /// </summary>
        public BooleanValue? VerticalFlip
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Horizontal Flip</para>
        /// <para>Represents the following attribute in the schema: custFlipHor</para>
        /// </summary>
        public BooleanValue? HorizontalFlip
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fixed Width Override</para>
        /// <para>Represents the following attribute in the schema: custSzX</para>
        /// </summary>
        public Int32Value? FixedWidthOverride
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Fixed Height Override</para>
        /// <para>Represents the following attribute in the schema: custSzY</para>
        /// </summary>
        public Int32Value? FixedHeightOverride
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Width Scale</para>
        /// <para>Represents the following attribute in the schema: custScaleX</para>
        /// </summary>
        public Int32Value? WidthScale
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Height Scale</para>
        /// <para>Represents the following attribute in the schema: custScaleY</para>
        /// </summary>
        public Int32Value? HightScale
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Text Changed</para>
        /// <para>Represents the following attribute in the schema: custT</para>
        /// </summary>
        public BooleanValue? TextChanged
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Factor Width</para>
        /// <para>Represents the following attribute in the schema: custLinFactX</para>
        /// </summary>
        public Int32Value? FactorWidth
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Custom Factor Height</para>
        /// <para>Represents the following attribute in the schema: custLinFactY</para>
        /// </summary>
        public Int32Value? FactorHeight
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Neighbor Offset Width</para>
        /// <para>Represents the following attribute in the schema: custLinFactNeighborX</para>
        /// </summary>
        public Int32Value? NeighborOffsetWidth
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Neighbor Offset Height</para>
        /// <para>Represents the following attribute in the schema: custLinFactNeighborY</para>
        /// </summary>
        public Int32Value? NeighborOffsetHeight
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Radius Scale</para>
        /// <para>Represents the following attribute in the schema: custRadScaleRad</para>
        /// </summary>
        public Int32Value? RadiusScale
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Include Angle Scale</para>
        /// <para>Represents the following attribute in the schema: custRadScaleInc</para>
        /// </summary>
        public Int32Value? IncludeAngleScale
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:prSet");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.Style>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationLayoutVariables>();
            builder.AddElement<PropertySet>()
                .AddAttribute("presAssocID", a => a.PresentationElementId, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<Int32Value>(NumberValidator.Instance);
                        union.AddValidator(new StringValidator() { Pattern = ("\\{[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}\\}") });
                    });
                })
                .AddAttribute("presName", a => a.PresentationName)
                .AddAttribute("presStyleLbl", a => a.PresentationStyleLabel)
                .AddAttribute("presStyleIdx", a => a.PresentationStyleIndex)
                .AddAttribute("presStyleCnt", a => a.PresentationStyleCount)
                .AddAttribute("loTypeId", a => a.LayoutTypeId)
                .AddAttribute("loCatId", a => a.LayoutCategoryId)
                .AddAttribute("qsTypeId", a => a.QuickStyleTypeId)
                .AddAttribute("qsCatId", a => a.QuickStyleCategoryId)
                .AddAttribute("csTypeId", a => a.ColorType)
                .AddAttribute("csCatId", a => a.ColorCategoryId)
                .AddAttribute("coherent3DOff", a => a.Coherent3D)
                .AddAttribute("phldrT", a => a.PlaceholderText)
                .AddAttribute("phldr", a => a.Placeholder)
                .AddAttribute("custAng", a => a.Rotation)
                .AddAttribute("custFlipVert", a => a.VerticalFlip)
                .AddAttribute("custFlipHor", a => a.HorizontalFlip)
                .AddAttribute("custSzX", a => a.FixedWidthOverride)
                .AddAttribute("custSzY", a => a.FixedHeightOverride)
                .AddAttribute("custScaleX", a => a.WidthScale)
                .AddAttribute("custScaleY", a => a.HightScale)
                .AddAttribute("custT", a => a.TextChanged)
                .AddAttribute("custLinFactX", a => a.FactorWidth)
                .AddAttribute("custLinFactY", a => a.FactorHeight)
                .AddAttribute("custLinFactNeighborX", a => a.NeighborOffsetWidth)
                .AddAttribute("custLinFactNeighborY", a => a.NeighborOffsetHeight)
                .AddAttribute("custRadScaleRad", a => a.RadiusScale)
                .AddAttribute("custRadScaleInc", a => a.IncludeAngleScale);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.PresentationLayoutVariables), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.Style), 0, 1)
            };
        }

        /// <summary>
        /// <para>Presentation Layout Variables.</para>
        /// <para>Represents the following element tag in the schema: dgm:presLayoutVars.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.PresentationLayoutVariables? PresentationLayoutVariables
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.PresentationLayoutVariables>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Shape Style.</para>
        /// <para>Represents the following element tag in the schema: dgm:style.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.Style? Style
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.Style>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PropertySet>(deep);
    }

    /// <summary>
    /// <para>Shape Properties.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:spPr.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BlipFill" /> <c>&lt;a:blipFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.CustomGeometry" /> <c>&lt;a:custGeom></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectDag" /> <c>&lt;a:effectDag></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectList" /> <c>&lt;a:effectLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GradientFill" /> <c>&lt;a:gradFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GroupFill" /> <c>&lt;a:grpFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Outline" /> <c>&lt;a:ln></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.NoFill" /> <c>&lt;a:noFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PatternFill" /> <c>&lt;a:pattFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetGeometry" /> <c>&lt;a:prstGeom></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Scene3DType" /> <c>&lt;a:scene3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Shape3DType" /> <c>&lt;a:sp3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList" /> <c>&lt;a:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SolidFill" /> <c>&lt;a:solidFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Transform2D" /> <c>&lt;a:xfrm></c></description></item>
    /// </list>
    /// </remark>
    public partial class ShapeProperties : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the ShapeProperties class.
        /// </summary>
        public ShapeProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ShapeProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ShapeProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Black and White Mode</para>
        /// <para>Represents the following attribute in the schema: bwMode</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>? BlackWhiteMode
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:spPr");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BlipFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.CustomGeometry>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectDag>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GradientFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GroupFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Outline>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.NoFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PatternFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PresetGeometry>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Scene3DType>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Shape3DType>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SolidFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Transform2D>();
            builder.AddElement<ShapeProperties>()
                .AddAttribute("bwMode", a => a.BlackWhiteMode, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Transform2D), 0, 1),
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.CustomGeometry), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PresetGeometry), 1, 1)
                    }
                },
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.NoFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.SolidFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.GradientFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.BlipFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PatternFill), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.GroupFill), 1, 1)
                    }
                },
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Outline), 0, 1),
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectList), 1, 1),
                        new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.EffectDag), 1, 1)
                    }
                },
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Scene3DType), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Shape3DType), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList), 0, 1)
            };
        }

        /// <summary>
        /// <para>2D Transform for Individual Objects.</para>
        /// <para>Represents the following element tag in the schema: a:xfrm.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Transform2D? Transform2D
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Transform2D>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ShapeProperties>(deep);
    }

    /// <summary>
    /// <para>Text Body.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:t.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BodyProperties" /> <c>&lt;a:bodyPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ListStyle" /> <c>&lt;a:lstStyle></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Paragraph" /> <c>&lt;a:p></c></description></item>
    /// </list>
    /// </remark>
    public partial class TextBody : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the TextBody class.
        /// </summary>
        public TextBody() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextBody(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextBody(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBody class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextBody(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:t");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BodyProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ListStyle>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Paragraph>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.BodyProperties), 1, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.ListStyle), 0, 1),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Paragraph), 1, 0)
            };
        }

        /// <summary>
        /// <para>Body Properties.</para>
        /// <para>Represents the following element tag in the schema: a:bodyPr.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.BodyProperties? BodyProperties
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.BodyProperties>();
            set => SetElement(value);
        }

        /// <summary>
        /// <para>Text List Styles.</para>
        /// <para>Represents the following element tag in the schema: a:lstStyle.</para>
        /// </summary>
        /// <remark>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.ListStyle? ListStyle
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.ListStyle>();
            set => SetElement(value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextBody>(deep);
    }

    /// <summary>
    /// <para>Defines the PtExtensionList Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PtExtension" /> <c>&lt;a:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class PtExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the PtExtensionList class.
        /// </summary>
        public PtExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PtExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PtExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PtExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PtExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PtExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PtExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PtExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.PtExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PtExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the DiagramDefinitionExtension Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:ext.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2019.Drawing.Diagram12.TextListStyleType" /> <c>&lt;dgm1612:lstStyle></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2019.Drawing.Diagram11.NumberDiagramInfoList" /> <c>&lt;dgm1611:autoBuNodeInfoLst></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiagramDefinitionExtension : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtension class.
        /// </summary>
        public DiagramDefinitionExtension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramDefinitionExtension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiagramDefinitionExtension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>URI</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:ext");
            builder.AddChild<DocumentFormat.OpenXml.Office2019.Drawing.Diagram12.TextListStyleType>();
            builder.AddChild<DocumentFormat.OpenXml.Office2019.Drawing.Diagram11.NumberDiagramInfoList>();
            builder.AddElement<DiagramDefinitionExtension>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2019.Drawing.Diagram11.NumberDiagramInfoList), 1, 1, version: FileFormatVersions.Office2019),
                new ElementParticle(typeof(DocumentFormat.OpenXml.Office2019.Drawing.Diagram12.TextListStyleType), 1, 1, version: FileFormatVersions.Office2019),
                new AnyParticle(0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiagramDefinitionExtension>(deep);
    }

    /// <summary>
    /// <para>Defines the SampleData Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:sampData.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModel" /> <c>&lt;dgm:dataModel></c></description></item>
    /// </list>
    /// </remark>
    public partial class SampleData : SampleDataType
    {
        /// <summary>
        /// Initializes a new instance of the SampleData class.
        /// </summary>
        public SampleData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SampleData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SampleData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SampleData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:sampData");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModel), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SampleData>(deep);
    }

    /// <summary>
    /// <para>Defines the StyleData Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:styleData.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModel" /> <c>&lt;dgm:dataModel></c></description></item>
    /// </list>
    /// </remark>
    public partial class StyleData : SampleDataType
    {
        /// <summary>
        /// Initializes a new instance of the StyleData class.
        /// </summary>
        public StyleData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StyleData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StyleData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StyleData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:styleData");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModel), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StyleData>(deep);
    }

    /// <summary>
    /// <para>Defines the ColorData Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:clrData.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModel" /> <c>&lt;dgm:dataModel></c></description></item>
    /// </list>
    /// </remark>
    public partial class ColorData : SampleDataType
    {
        /// <summary>
        /// Initializes a new instance of the ColorData class.
        /// </summary>
        public ColorData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:clrData");
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModel), 0, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorData>(deep);
    }

    /// <summary>
    /// <para>Defines the SampleDataType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DataModel" /> <c>&lt;dgm:dataModel></c></description></item>
    /// </list>
    /// </remark>
    public abstract partial class SampleDataType : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the SampleDataType class.
        /// </summary>
        protected SampleDataType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleDataType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected SampleDataType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleDataType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected SampleDataType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SampleDataType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected SampleDataType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Use Default</para>
        /// <para>Represents the following attribute in the schema: useDef</para>
        /// </summary>
        public BooleanValue? UseDefault
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DataModel>();
            builder.AddElement<SampleDataType>()
                .AddAttribute("useDef", a => a.UseDefault);
        }

        /// <summary>
        /// <para>Data Model.</para>
        /// <para>Represents the following element tag in the schema: dgm:dataModel.</para>
        /// </summary>
        /// <remark>
        /// xmlns:dgm = http://schemas.openxmlformats.org/drawingml/2006/diagram
        /// </remark>
        public DocumentFormat.OpenXml.Drawing.Diagrams.DataModel? DataModel
        {
            get => GetElement<DocumentFormat.OpenXml.Drawing.Diagrams.DataModel>();
            set => SetElement(value);
        }
    }

    /// <summary>
    /// <para>List of extensions to the CT_DiagramDefintions type..</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is dgm:extLst.</para>
    /// </summary>
    /// <remark>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtension" /> <c>&lt;dgm:ext></c></description></item>
    /// </list>
    /// </remark>
    public partial class DiagramDefinitionExtensionList : OpenXmlCompositeElement
    {
        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtensionList class.
        /// </summary>
        public DiagramDefinitionExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramDefinitionExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DiagramDefinitionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DiagramDefinitionExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DiagramDefinitionExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema("dgm:extLst");
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtension>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DiagramDefinitionExtension), 0, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DiagramDefinitionExtensionList>(deep);
    }

    /// <summary>
    /// Color Application Method Type
    /// </summary>
    public readonly record struct ColorApplicationMethodValues : IEnumValue, IEnumValueFactory<ColorApplicationMethodValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ColorApplicationMethodValues enum instance
        /// </summary>
        public ColorApplicationMethodValues(string value) => _value = value;
        ColorApplicationMethodValues IEnumValueFactory<ColorApplicationMethodValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "span" => true,
            "cycle" => true,
            "repeat" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "span";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Span.
        /// <para>When the item is serialized out as xml, its value is "span".</para>
        /// </summary>
        public static ColorApplicationMethodValues Span => new("span");
        /// <summary>
        /// Cycle.
        /// <para>When the item is serialized out as xml, its value is "cycle".</para>
        /// </summary>
        public static ColorApplicationMethodValues Cycle => new("cycle");
        /// <summary>
        /// Repeat.
        /// <para>When the item is serialized out as xml, its value is "repeat".</para>
        /// </summary>
        public static ColorApplicationMethodValues Repeat => new("repeat");
    
    }

    /// <summary>
    /// Hue Direction
    /// </summary>
    public readonly record struct HueDirectionValues : IEnumValue, IEnumValueFactory<HueDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HueDirectionValues enum instance
        /// </summary>
        public HueDirectionValues(string value) => _value = value;
        HueDirectionValues IEnumValueFactory<HueDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "cw" => true,
            "ccw" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "cw";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Clockwise Hue Direction.
        /// <para>When the item is serialized out as xml, its value is "cw".</para>
        /// </summary>
        public static HueDirectionValues Clockwise => new("cw");
        /// <summary>
        /// Counterclockwise Hue Direction.
        /// <para>When the item is serialized out as xml, its value is "ccw".</para>
        /// </summary>
        public static HueDirectionValues Counterclockwise => new("ccw");
    
    }

    /// <summary>
    /// Point Type
    /// </summary>
    public readonly record struct PointValues : IEnumValue, IEnumValueFactory<PointValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PointValues enum instance
        /// </summary>
        public PointValues(string value) => _value = value;
        PointValues IEnumValueFactory<PointValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "node" => true,
            "asst" => true,
            "doc" => true,
            "pres" => true,
            "parTrans" => true,
            "sibTrans" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "node";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Node.
        /// <para>When the item is serialized out as xml, its value is "node".</para>
        /// </summary>
        public static PointValues Node => new("node");
        /// <summary>
        /// Assistant Element.
        /// <para>When the item is serialized out as xml, its value is "asst".</para>
        /// </summary>
        public static PointValues Assistant => new("asst");
        /// <summary>
        /// Document.
        /// <para>When the item is serialized out as xml, its value is "doc".</para>
        /// </summary>
        public static PointValues Document => new("doc");
        /// <summary>
        /// Presentation.
        /// <para>When the item is serialized out as xml, its value is "pres".</para>
        /// </summary>
        public static PointValues Presentation => new("pres");
        /// <summary>
        /// Parent Transition.
        /// <para>When the item is serialized out as xml, its value is "parTrans".</para>
        /// </summary>
        public static PointValues ParentTransition => new("parTrans");
        /// <summary>
        /// Sibling Transition.
        /// <para>When the item is serialized out as xml, its value is "sibTrans".</para>
        /// </summary>
        public static PointValues SiblingTransition => new("sibTrans");
    
    }

    /// <summary>
    /// Connection Type
    /// </summary>
    public readonly record struct ConnectionValues : IEnumValue, IEnumValueFactory<ConnectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConnectionValues enum instance
        /// </summary>
        public ConnectionValues(string value) => _value = value;
        ConnectionValues IEnumValueFactory<ConnectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "parOf" => true,
            "presOf" => true,
            "presParOf" => true,
            "unknownRelationship" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "parOf";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Parent Of.
        /// <para>When the item is serialized out as xml, its value is "parOf".</para>
        /// </summary>
        public static ConnectionValues ParentOf => new("parOf");
        /// <summary>
        /// Presentation Of.
        /// <para>When the item is serialized out as xml, its value is "presOf".</para>
        /// </summary>
        public static ConnectionValues PresentationOf => new("presOf");
        /// <summary>
        /// Presentation Parent Of.
        /// <para>When the item is serialized out as xml, its value is "presParOf".</para>
        /// </summary>
        public static ConnectionValues PresentationParentOf => new("presParOf");
        /// <summary>
        /// Unknown Relationship.
        /// <para>When the item is serialized out as xml, its value is "unknownRelationship".</para>
        /// </summary>
        public static ConnectionValues UnknownRelationship => new("unknownRelationship");
    
    }

    /// <summary>
    /// Diagram Direction Definition
    /// </summary>
    public readonly record struct DirectionValues : IEnumValue, IEnumValueFactory<DirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DirectionValues enum instance
        /// </summary>
        public DirectionValues(string value) => _value = value;
        DirectionValues IEnumValueFactory<DirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "norm" => true,
            "rev" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "norm";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Normal Direction.
        /// <para>When the item is serialized out as xml, its value is "norm".</para>
        /// </summary>
        public static DirectionValues Normal => new("norm");
        /// <summary>
        /// Reversed Direction.
        /// <para>When the item is serialized out as xml, its value is "rev".</para>
        /// </summary>
        public static DirectionValues Reversed => new("rev");
    
    }

    /// <summary>
    /// Hierarchy Branch Style Definition
    /// </summary>
    public readonly record struct HierarchyBranchStyleValues : IEnumValue, IEnumValueFactory<HierarchyBranchStyleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HierarchyBranchStyleValues enum instance
        /// </summary>
        public HierarchyBranchStyleValues(string value) => _value = value;
        HierarchyBranchStyleValues IEnumValueFactory<HierarchyBranchStyleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "r" => true,
            "hang" => true,
            "std" => true,
            "init" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static HierarchyBranchStyleValues Left => new("l");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static HierarchyBranchStyleValues Right => new("r");
        /// <summary>
        /// Hanging.
        /// <para>When the item is serialized out as xml, its value is "hang".</para>
        /// </summary>
        public static HierarchyBranchStyleValues Hanging => new("hang");
        /// <summary>
        /// Standard.
        /// <para>When the item is serialized out as xml, its value is "std".</para>
        /// </summary>
        public static HierarchyBranchStyleValues Standard => new("std");
        /// <summary>
        /// Initial.
        /// <para>When the item is serialized out as xml, its value is "init".</para>
        /// </summary>
        public static HierarchyBranchStyleValues Initial => new("init");
    
    }

    /// <summary>
    /// One by One Animation Value Definition
    /// </summary>
    public readonly record struct AnimateOneByOneValues : IEnumValue, IEnumValueFactory<AnimateOneByOneValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AnimateOneByOneValues enum instance
        /// </summary>
        public AnimateOneByOneValues(string value) => _value = value;
        AnimateOneByOneValues IEnumValueFactory<AnimateOneByOneValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "one" => true,
            "branch" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Disable One-by-One.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static AnimateOneByOneValues None => new("none");
        /// <summary>
        /// One By One.
        /// <para>When the item is serialized out as xml, its value is "one".</para>
        /// </summary>
        public static AnimateOneByOneValues One => new("one");
        /// <summary>
        /// By Branch One By One.
        /// <para>When the item is serialized out as xml, its value is "branch".</para>
        /// </summary>
        public static AnimateOneByOneValues Branch => new("branch");
    
    }

    /// <summary>
    /// Animation Level String Definition
    /// </summary>
    public readonly record struct AnimationLevelStringValues : IEnumValue, IEnumValueFactory<AnimationLevelStringValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AnimationLevelStringValues enum instance
        /// </summary>
        public AnimationLevelStringValues(string value) => _value = value;
        AnimationLevelStringValues IEnumValueFactory<AnimationLevelStringValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "lvl" => true,
            "ctr" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Disable Level At Once.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static AnimationLevelStringValues None => new("none");
        /// <summary>
        /// By Level Animation.
        /// <para>When the item is serialized out as xml, its value is "lvl".</para>
        /// </summary>
        public static AnimationLevelStringValues Level => new("lvl");
        /// <summary>
        /// From Center Animation.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static AnimationLevelStringValues Center => new("ctr");
    
    }

    /// <summary>
    /// Resize Handle
    /// </summary>
    public readonly record struct ResizeHandlesStringValues : IEnumValue, IEnumValueFactory<ResizeHandlesStringValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ResizeHandlesStringValues enum instance
        /// </summary>
        public ResizeHandlesStringValues(string value) => _value = value;
        ResizeHandlesStringValues IEnumValueFactory<ResizeHandlesStringValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "exact" => true,
            "rel" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "exact";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Exact.
        /// <para>When the item is serialized out as xml, its value is "exact".</para>
        /// </summary>
        public static ResizeHandlesStringValues Exact => new("exact");
        /// <summary>
        /// Relative.
        /// <para>When the item is serialized out as xml, its value is "rel".</para>
        /// </summary>
        public static ResizeHandlesStringValues Relative => new("rel");
    
    }

    /// <summary>
    /// Algorithm Types
    /// </summary>
    public readonly record struct AlgorithmValues : IEnumValue, IEnumValueFactory<AlgorithmValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AlgorithmValues enum instance
        /// </summary>
        public AlgorithmValues(string value) => _value = value;
        AlgorithmValues IEnumValueFactory<AlgorithmValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "composite" => true,
            "conn" => true,
            "cycle" => true,
            "hierChild" => true,
            "hierRoot" => true,
            "pyra" => true,
            "lin" => true,
            "sp" => true,
            "tx" => true,
            "snake" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "composite";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Composite.
        /// <para>When the item is serialized out as xml, its value is "composite".</para>
        /// </summary>
        public static AlgorithmValues Composite => new("composite");
        /// <summary>
        /// Connector Algorithm.
        /// <para>When the item is serialized out as xml, its value is "conn".</para>
        /// </summary>
        public static AlgorithmValues Connector => new("conn");
        /// <summary>
        /// Cycle Algorithm.
        /// <para>When the item is serialized out as xml, its value is "cycle".</para>
        /// </summary>
        public static AlgorithmValues Cycle => new("cycle");
        /// <summary>
        /// Hierarchy Child Algorithm.
        /// <para>When the item is serialized out as xml, its value is "hierChild".</para>
        /// </summary>
        public static AlgorithmValues HierarchyChild => new("hierChild");
        /// <summary>
        /// Hierarchy Root Algorithm.
        /// <para>When the item is serialized out as xml, its value is "hierRoot".</para>
        /// </summary>
        public static AlgorithmValues HierarchyRoot => new("hierRoot");
        /// <summary>
        /// Pyramid Algorithm.
        /// <para>When the item is serialized out as xml, its value is "pyra".</para>
        /// </summary>
        public static AlgorithmValues Pyramid => new("pyra");
        /// <summary>
        /// Linear Algorithm.
        /// <para>When the item is serialized out as xml, its value is "lin".</para>
        /// </summary>
        public static AlgorithmValues Linear => new("lin");
        /// <summary>
        /// Space Algorithm.
        /// <para>When the item is serialized out as xml, its value is "sp".</para>
        /// </summary>
        public static AlgorithmValues Space => new("sp");
        /// <summary>
        /// Text Algorithm.
        /// <para>When the item is serialized out as xml, its value is "tx".</para>
        /// </summary>
        public static AlgorithmValues Text => new("tx");
        /// <summary>
        /// Snake Algorithm.
        /// <para>When the item is serialized out as xml, its value is "snake".</para>
        /// </summary>
        public static AlgorithmValues Snake => new("snake");
    
    }

    /// <summary>
    /// Axis Type
    /// </summary>
    public readonly record struct AxisValues : IEnumValue, IEnumValueFactory<AxisValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AxisValues enum instance
        /// </summary>
        public AxisValues(string value) => _value = value;
        AxisValues IEnumValueFactory<AxisValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "self" => true,
            "ch" => true,
            "des" => true,
            "desOrSelf" => true,
            "par" => true,
            "ancst" => true,
            "ancstOrSelf" => true,
            "followSib" => true,
            "precedSib" => true,
            "follow" => true,
            "preced" => true,
            "root" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "self";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Self.
        /// <para>When the item is serialized out as xml, its value is "self".</para>
        /// </summary>
        public static AxisValues Self => new("self");
        /// <summary>
        /// Child.
        /// <para>When the item is serialized out as xml, its value is "ch".</para>
        /// </summary>
        public static AxisValues Child => new("ch");
        /// <summary>
        /// Descendant.
        /// <para>When the item is serialized out as xml, its value is "des".</para>
        /// </summary>
        public static AxisValues Descendant => new("des");
        /// <summary>
        /// Descendant or Self.
        /// <para>When the item is serialized out as xml, its value is "desOrSelf".</para>
        /// </summary>
        public static AxisValues DescendantOrSelf => new("desOrSelf");
        /// <summary>
        /// Parent.
        /// <para>When the item is serialized out as xml, its value is "par".</para>
        /// </summary>
        public static AxisValues Parent => new("par");
        /// <summary>
        /// Ancestor.
        /// <para>When the item is serialized out as xml, its value is "ancst".</para>
        /// </summary>
        public static AxisValues Ancestor => new("ancst");
        /// <summary>
        /// Ancestor or Self.
        /// <para>When the item is serialized out as xml, its value is "ancstOrSelf".</para>
        /// </summary>
        public static AxisValues AncestorOrSelf => new("ancstOrSelf");
        /// <summary>
        /// Follow Sibling.
        /// <para>When the item is serialized out as xml, its value is "followSib".</para>
        /// </summary>
        public static AxisValues FollowSibling => new("followSib");
        /// <summary>
        /// Preceding Sibling.
        /// <para>When the item is serialized out as xml, its value is "precedSib".</para>
        /// </summary>
        public static AxisValues PrecedingSibling => new("precedSib");
        /// <summary>
        /// Follow.
        /// <para>When the item is serialized out as xml, its value is "follow".</para>
        /// </summary>
        public static AxisValues Follow => new("follow");
        /// <summary>
        /// Preceding.
        /// <para>When the item is serialized out as xml, its value is "preced".</para>
        /// </summary>
        public static AxisValues Preceding => new("preced");
        /// <summary>
        /// Root.
        /// <para>When the item is serialized out as xml, its value is "root".</para>
        /// </summary>
        public static AxisValues Root => new("root");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static AxisValues None => new("none");
    
    }

    /// <summary>
    /// Boolean Constraint
    /// </summary>
    public readonly record struct BoolOperatorValues : IEnumValue, IEnumValueFactory<BoolOperatorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new BoolOperatorValues enum instance
        /// </summary>
        public BoolOperatorValues(string value) => _value = value;
        BoolOperatorValues IEnumValueFactory<BoolOperatorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "equ" => true,
            "gte" => true,
            "lte" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static BoolOperatorValues None => new("none");
        /// <summary>
        /// Equal.
        /// <para>When the item is serialized out as xml, its value is "equ".</para>
        /// </summary>
        public static BoolOperatorValues Equal => new("equ");
        /// <summary>
        /// Greater Than or Equal to.
        /// <para>When the item is serialized out as xml, its value is "gte".</para>
        /// </summary>
        public static BoolOperatorValues GreaterThanOrEqualTo => new("gte");
        /// <summary>
        /// Less Than or Equal to.
        /// <para>When the item is serialized out as xml, its value is "lte".</para>
        /// </summary>
        public static BoolOperatorValues LessThanOrEqualTo => new("lte");
    
    }

    /// <summary>
    /// Child Order
    /// </summary>
    public readonly record struct ChildOrderValues : IEnumValue, IEnumValueFactory<ChildOrderValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ChildOrderValues enum instance
        /// </summary>
        public ChildOrderValues(string value) => _value = value;
        ChildOrderValues IEnumValueFactory<ChildOrderValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "b" => true,
            "t" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "b";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static ChildOrderValues Bottom => new("b");
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static ChildOrderValues Top => new("t");
    
    }

    /// <summary>
    /// Constraint Type
    /// </summary>
    public readonly record struct ConstraintValues : IEnumValue, IEnumValueFactory<ConstraintValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConstraintValues enum instance
        /// </summary>
        public ConstraintValues(string value) => _value = value;
        ConstraintValues IEnumValueFactory<ConstraintValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "alignOff" => true,
            "begMarg" => true,
            "bendDist" => true,
            "begPad" => true,
            "b" => true,
            "bMarg" => true,
            "bOff" => true,
            "ctrX" => true,
            "ctrXOff" => true,
            "ctrY" => true,
            "ctrYOff" => true,
            "connDist" => true,
            "diam" => true,
            "endMarg" => true,
            "endPad" => true,
            "h" => true,
            "hArH" => true,
            "hOff" => true,
            "l" => true,
            "lMarg" => true,
            "lOff" => true,
            "r" => true,
            "rMarg" => true,
            "rOff" => true,
            "primFontSz" => true,
            "pyraAcctRatio" => true,
            "secFontSz" => true,
            "sibSp" => true,
            "secSibSp" => true,
            "sp" => true,
            "stemThick" => true,
            "t" => true,
            "tMarg" => true,
            "tOff" => true,
            "userA" => true,
            "userB" => true,
            "userC" => true,
            "userD" => true,
            "userE" => true,
            "userF" => true,
            "userG" => true,
            "userH" => true,
            "userI" => true,
            "userJ" => true,
            "userK" => true,
            "userL" => true,
            "userM" => true,
            "userN" => true,
            "userO" => true,
            "userP" => true,
            "userQ" => true,
            "userR" => true,
            "userS" => true,
            "userT" => true,
            "userU" => true,
            "userV" => true,
            "userW" => true,
            "userX" => true,
            "userY" => true,
            "userZ" => true,
            "w" => true,
            "wArH" => true,
            "wOff" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Unknown.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static ConstraintValues None => new("none");
        /// <summary>
        /// Alignment Offset.
        /// <para>When the item is serialized out as xml, its value is "alignOff".</para>
        /// </summary>
        public static ConstraintValues AlignmentOffset => new("alignOff");
        /// <summary>
        /// Beginning Margin.
        /// <para>When the item is serialized out as xml, its value is "begMarg".</para>
        /// </summary>
        public static ConstraintValues BeginningMargin => new("begMarg");
        /// <summary>
        /// Bending Distance.
        /// <para>When the item is serialized out as xml, its value is "bendDist".</para>
        /// </summary>
        public static ConstraintValues BendingDistance => new("bendDist");
        /// <summary>
        /// Beginning Padding.
        /// <para>When the item is serialized out as xml, its value is "begPad".</para>
        /// </summary>
        public static ConstraintValues BeginningPadding => new("begPad");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static ConstraintValues Bottom => new("b");
        /// <summary>
        /// Bottom Margin.
        /// <para>When the item is serialized out as xml, its value is "bMarg".</para>
        /// </summary>
        public static ConstraintValues BottomMargin => new("bMarg");
        /// <summary>
        /// Bottom Offset.
        /// <para>When the item is serialized out as xml, its value is "bOff".</para>
        /// </summary>
        public static ConstraintValues BottomOffset => new("bOff");
        /// <summary>
        /// Center Height.
        /// <para>When the item is serialized out as xml, its value is "ctrX".</para>
        /// </summary>
        public static ConstraintValues CenterHeight => new("ctrX");
        /// <summary>
        /// Center X Offset.
        /// <para>When the item is serialized out as xml, its value is "ctrXOff".</para>
        /// </summary>
        public static ConstraintValues CenterXOffset => new("ctrXOff");
        /// <summary>
        /// Center Width.
        /// <para>When the item is serialized out as xml, its value is "ctrY".</para>
        /// </summary>
        public static ConstraintValues CenterWidth => new("ctrY");
        /// <summary>
        /// Center Y Offset.
        /// <para>When the item is serialized out as xml, its value is "ctrYOff".</para>
        /// </summary>
        public static ConstraintValues CenterYOffset => new("ctrYOff");
        /// <summary>
        /// Connection Distance.
        /// <para>When the item is serialized out as xml, its value is "connDist".</para>
        /// </summary>
        public static ConstraintValues ConnectionDistance => new("connDist");
        /// <summary>
        /// Diameter.
        /// <para>When the item is serialized out as xml, its value is "diam".</para>
        /// </summary>
        public static ConstraintValues Diameter => new("diam");
        /// <summary>
        /// End Margin.
        /// <para>When the item is serialized out as xml, its value is "endMarg".</para>
        /// </summary>
        public static ConstraintValues EndMargin => new("endMarg");
        /// <summary>
        /// End Padding.
        /// <para>When the item is serialized out as xml, its value is "endPad".</para>
        /// </summary>
        public static ConstraintValues EndPadding => new("endPad");
        /// <summary>
        /// Height.
        /// <para>When the item is serialized out as xml, its value is "h".</para>
        /// </summary>
        public static ConstraintValues Height => new("h");
        /// <summary>
        /// Arrowhead Height.
        /// <para>When the item is serialized out as xml, its value is "hArH".</para>
        /// </summary>
        public static ConstraintValues ArrowheadHeight => new("hArH");
        /// <summary>
        /// Height Offset.
        /// <para>When the item is serialized out as xml, its value is "hOff".</para>
        /// </summary>
        public static ConstraintValues HeightOffset => new("hOff");
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static ConstraintValues Left => new("l");
        /// <summary>
        /// Left Margin.
        /// <para>When the item is serialized out as xml, its value is "lMarg".</para>
        /// </summary>
        public static ConstraintValues LeftMargin => new("lMarg");
        /// <summary>
        /// Left Offset.
        /// <para>When the item is serialized out as xml, its value is "lOff".</para>
        /// </summary>
        public static ConstraintValues LeftOffset => new("lOff");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static ConstraintValues Right => new("r");
        /// <summary>
        /// Right Margin.
        /// <para>When the item is serialized out as xml, its value is "rMarg".</para>
        /// </summary>
        public static ConstraintValues RightMargin => new("rMarg");
        /// <summary>
        /// Right Offset.
        /// <para>When the item is serialized out as xml, its value is "rOff".</para>
        /// </summary>
        public static ConstraintValues RightOffset => new("rOff");
        /// <summary>
        /// Primary Font Size.
        /// <para>When the item is serialized out as xml, its value is "primFontSz".</para>
        /// </summary>
        public static ConstraintValues PrimaryFontSize => new("primFontSz");
        /// <summary>
        /// Pyramid Accent Ratio.
        /// <para>When the item is serialized out as xml, its value is "pyraAcctRatio".</para>
        /// </summary>
        public static ConstraintValues PyramidAccentRatio => new("pyraAcctRatio");
        /// <summary>
        /// Secondary Font Size.
        /// <para>When the item is serialized out as xml, its value is "secFontSz".</para>
        /// </summary>
        public static ConstraintValues SecondaryFontSize => new("secFontSz");
        /// <summary>
        /// Sibling Spacing.
        /// <para>When the item is serialized out as xml, its value is "sibSp".</para>
        /// </summary>
        public static ConstraintValues SiblingSpacing => new("sibSp");
        /// <summary>
        /// Secondary Sibling Spacing.
        /// <para>When the item is serialized out as xml, its value is "secSibSp".</para>
        /// </summary>
        public static ConstraintValues SecondarySiblingSpacing => new("secSibSp");
        /// <summary>
        /// Spacing.
        /// <para>When the item is serialized out as xml, its value is "sp".</para>
        /// </summary>
        public static ConstraintValues Spacing => new("sp");
        /// <summary>
        /// Stem Thickness.
        /// <para>When the item is serialized out as xml, its value is "stemThick".</para>
        /// </summary>
        public static ConstraintValues StemThickness => new("stemThick");
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static ConstraintValues Top => new("t");
        /// <summary>
        /// Top Margin.
        /// <para>When the item is serialized out as xml, its value is "tMarg".</para>
        /// </summary>
        public static ConstraintValues TopMargin => new("tMarg");
        /// <summary>
        /// Top Offset.
        /// <para>When the item is serialized out as xml, its value is "tOff".</para>
        /// </summary>
        public static ConstraintValues TopOffset => new("tOff");
        /// <summary>
        /// User Defined A.
        /// <para>When the item is serialized out as xml, its value is "userA".</para>
        /// </summary>
        public static ConstraintValues UserDefinedA => new("userA");
        /// <summary>
        /// User Defined B.
        /// <para>When the item is serialized out as xml, its value is "userB".</para>
        /// </summary>
        public static ConstraintValues UserDefinedB => new("userB");
        /// <summary>
        /// User Defined C.
        /// <para>When the item is serialized out as xml, its value is "userC".</para>
        /// </summary>
        public static ConstraintValues UserDefinedC => new("userC");
        /// <summary>
        /// User Defined D.
        /// <para>When the item is serialized out as xml, its value is "userD".</para>
        /// </summary>
        public static ConstraintValues UserDefinedD => new("userD");
        /// <summary>
        /// User Defined E.
        /// <para>When the item is serialized out as xml, its value is "userE".</para>
        /// </summary>
        public static ConstraintValues UserDefinedE => new("userE");
        /// <summary>
        /// User Defined F.
        /// <para>When the item is serialized out as xml, its value is "userF".</para>
        /// </summary>
        public static ConstraintValues UserDefinedF => new("userF");
        /// <summary>
        /// User Defined G.
        /// <para>When the item is serialized out as xml, its value is "userG".</para>
        /// </summary>
        public static ConstraintValues UserDefinedG => new("userG");
        /// <summary>
        /// User Defined H.
        /// <para>When the item is serialized out as xml, its value is "userH".</para>
        /// </summary>
        public static ConstraintValues UserDefinedH => new("userH");
        /// <summary>
        /// User Defined I.
        /// <para>When the item is serialized out as xml, its value is "userI".</para>
        /// </summary>
        public static ConstraintValues UserDefinedI => new("userI");
        /// <summary>
        /// User Defined J.
        /// <para>When the item is serialized out as xml, its value is "userJ".</para>
        /// </summary>
        public static ConstraintValues UserDefinedJ => new("userJ");
        /// <summary>
        /// User Defined K.
        /// <para>When the item is serialized out as xml, its value is "userK".</para>
        /// </summary>
        public static ConstraintValues UserDefinedK => new("userK");
        /// <summary>
        /// User Defined L.
        /// <para>When the item is serialized out as xml, its value is "userL".</para>
        /// </summary>
        public static ConstraintValues UserDefinedL => new("userL");
        /// <summary>
        /// User Defined M.
        /// <para>When the item is serialized out as xml, its value is "userM".</para>
        /// </summary>
        public static ConstraintValues UserDefinedM => new("userM");
        /// <summary>
        /// User Defined N.
        /// <para>When the item is serialized out as xml, its value is "userN".</para>
        /// </summary>
        public static ConstraintValues UserDefinedN => new("userN");
        /// <summary>
        /// User Defined O.
        /// <para>When the item is serialized out as xml, its value is "userO".</para>
        /// </summary>
        public static ConstraintValues UserDefinedO => new("userO");
        /// <summary>
        /// User Defined P.
        /// <para>When the item is serialized out as xml, its value is "userP".</para>
        /// </summary>
        public static ConstraintValues UserDefinedP => new("userP");
        /// <summary>
        /// User Defined Q.
        /// <para>When the item is serialized out as xml, its value is "userQ".</para>
        /// </summary>
        public static ConstraintValues UserDefinedQ => new("userQ");
        /// <summary>
        /// User Defined R.
        /// <para>When the item is serialized out as xml, its value is "userR".</para>
        /// </summary>
        public static ConstraintValues UserDefinedR => new("userR");
        /// <summary>
        /// User Defined S.
        /// <para>When the item is serialized out as xml, its value is "userS".</para>
        /// </summary>
        public static ConstraintValues UserDefinedS => new("userS");
        /// <summary>
        /// User Defined T.
        /// <para>When the item is serialized out as xml, its value is "userT".</para>
        /// </summary>
        public static ConstraintValues UserDefinedT => new("userT");
        /// <summary>
        /// User Defined U.
        /// <para>When the item is serialized out as xml, its value is "userU".</para>
        /// </summary>
        public static ConstraintValues UserDefinedU => new("userU");
        /// <summary>
        /// User Defined V.
        /// <para>When the item is serialized out as xml, its value is "userV".</para>
        /// </summary>
        public static ConstraintValues UserDefinedV => new("userV");
        /// <summary>
        /// User Defined W.
        /// <para>When the item is serialized out as xml, its value is "userW".</para>
        /// </summary>
        public static ConstraintValues UserDefinedW => new("userW");
        /// <summary>
        /// User Defined X.
        /// <para>When the item is serialized out as xml, its value is "userX".</para>
        /// </summary>
        public static ConstraintValues UserDefinedX => new("userX");
        /// <summary>
        /// User Defined Y.
        /// <para>When the item is serialized out as xml, its value is "userY".</para>
        /// </summary>
        public static ConstraintValues UserDefinedY => new("userY");
        /// <summary>
        /// User Defined Z.
        /// <para>When the item is serialized out as xml, its value is "userZ".</para>
        /// </summary>
        public static ConstraintValues UserDefinedZ => new("userZ");
        /// <summary>
        /// Width.
        /// <para>When the item is serialized out as xml, its value is "w".</para>
        /// </summary>
        public static ConstraintValues Width => new("w");
        /// <summary>
        /// Arrowhead Width.
        /// <para>When the item is serialized out as xml, its value is "wArH".</para>
        /// </summary>
        public static ConstraintValues ArrowheadWidth => new("wArH");
        /// <summary>
        /// Width Offset.
        /// <para>When the item is serialized out as xml, its value is "wOff".</para>
        /// </summary>
        public static ConstraintValues WidthOffset => new("wOff");
    
    }

    /// <summary>
    /// Constraint Relationship
    /// </summary>
    public readonly record struct ConstraintRelationshipValues : IEnumValue, IEnumValueFactory<ConstraintRelationshipValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConstraintRelationshipValues enum instance
        /// </summary>
        public ConstraintRelationshipValues(string value) => _value = value;
        ConstraintRelationshipValues IEnumValueFactory<ConstraintRelationshipValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "self" => true,
            "ch" => true,
            "des" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "self";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Self.
        /// <para>When the item is serialized out as xml, its value is "self".</para>
        /// </summary>
        public static ConstraintRelationshipValues Self => new("self");
        /// <summary>
        /// Child.
        /// <para>When the item is serialized out as xml, its value is "ch".</para>
        /// </summary>
        public static ConstraintRelationshipValues Child => new("ch");
        /// <summary>
        /// Descendant.
        /// <para>When the item is serialized out as xml, its value is "des".</para>
        /// </summary>
        public static ConstraintRelationshipValues Descendant => new("des");
    
    }

    /// <summary>
    /// Element Type
    /// </summary>
    public readonly record struct ElementValues : IEnumValue, IEnumValueFactory<ElementValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ElementValues enum instance
        /// </summary>
        public ElementValues(string value) => _value = value;
        ElementValues IEnumValueFactory<ElementValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "all" => true,
            "doc" => true,
            "node" => true,
            "norm" => true,
            "nonNorm" => true,
            "asst" => true,
            "nonAsst" => true,
            "parTrans" => true,
            "pres" => true,
            "sibTrans" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "all";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// All.
        /// <para>When the item is serialized out as xml, its value is "all".</para>
        /// </summary>
        public static ElementValues All => new("all");
        /// <summary>
        /// Document.
        /// <para>When the item is serialized out as xml, its value is "doc".</para>
        /// </summary>
        public static ElementValues Document => new("doc");
        /// <summary>
        /// Node.
        /// <para>When the item is serialized out as xml, its value is "node".</para>
        /// </summary>
        public static ElementValues Node => new("node");
        /// <summary>
        /// Normal.
        /// <para>When the item is serialized out as xml, its value is "norm".</para>
        /// </summary>
        public static ElementValues Normal => new("norm");
        /// <summary>
        /// Non Normal.
        /// <para>When the item is serialized out as xml, its value is "nonNorm".</para>
        /// </summary>
        public static ElementValues NonNormal => new("nonNorm");
        /// <summary>
        /// Assistant.
        /// <para>When the item is serialized out as xml, its value is "asst".</para>
        /// </summary>
        public static ElementValues Assistant => new("asst");
        /// <summary>
        /// Non Assistant.
        /// <para>When the item is serialized out as xml, its value is "nonAsst".</para>
        /// </summary>
        public static ElementValues NonAssistant => new("nonAsst");
        /// <summary>
        /// Parent Transition.
        /// <para>When the item is serialized out as xml, its value is "parTrans".</para>
        /// </summary>
        public static ElementValues ParentTransition => new("parTrans");
        /// <summary>
        /// Presentation.
        /// <para>When the item is serialized out as xml, its value is "pres".</para>
        /// </summary>
        public static ElementValues Presentation => new("pres");
        /// <summary>
        /// Sibling Transition.
        /// <para>When the item is serialized out as xml, its value is "sibTrans".</para>
        /// </summary>
        public static ElementValues SiblingTransition => new("sibTrans");
    
    }

    /// <summary>
    /// Parameter Identifier
    /// </summary>
    public readonly record struct ParameterIdValues : IEnumValue, IEnumValueFactory<ParameterIdValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ParameterIdValues enum instance
        /// </summary>
        public ParameterIdValues(string value) => _value = value;
        ParameterIdValues IEnumValueFactory<ParameterIdValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "horzAlign" => true,
            "vertAlign" => true,
            "chDir" => true,
            "chAlign" => true,
            "secChAlign" => true,
            "linDir" => true,
            "secLinDir" => true,
            "stElem" => true,
            "bendPt" => true,
            "connRout" => true,
            "begSty" => true,
            "endSty" => true,
            "dim" => true,
            "rotPath" => true,
            "ctrShpMap" => true,
            "nodeHorzAlign" => true,
            "nodeVertAlign" => true,
            "fallback" => true,
            "txDir" => true,
            "pyraAcctPos" => true,
            "pyraAcctTxMar" => true,
            "txBlDir" => true,
            "txAnchorHorz" => true,
            "txAnchorVert" => true,
            "txAnchorHorzCh" => true,
            "txAnchorVertCh" => true,
            "parTxLTRAlign" => true,
            "parTxRTLAlign" => true,
            "shpTxLTRAlignCh" => true,
            "shpTxRTLAlignCh" => true,
            "autoTxRot" => true,
            "grDir" => true,
            "flowDir" => true,
            "contDir" => true,
            "bkpt" => true,
            "off" => true,
            "hierAlign" => true,
            "bkPtFixedVal" => true,
            "stBulletLvl" => true,
            "stAng" => true,
            "spanAng" => true,
            "ar" => true,
            "lnSpPar" => true,
            "lnSpAfParP" => true,
            "lnSpCh" => true,
            "lnSpAfChP" => true,
            "rtShortDist" => true,
            "alignTx" => true,
            "pyraLvlNode" => true,
            "pyraAcctBkgdNode" => true,
            "pyraAcctTxNode" => true,
            "srcNode" => true,
            "dstNode" => true,
            "begPts" => true,
            "endPts" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "horzAlign";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "horzAlign".</para>
        /// </summary>
        public static ParameterIdValues HorizontalAlignment => new("horzAlign");
        /// <summary>
        /// Vertical Alignment.
        /// <para>When the item is serialized out as xml, its value is "vertAlign".</para>
        /// </summary>
        public static ParameterIdValues VerticalAlignment => new("vertAlign");
        /// <summary>
        /// Child Direction.
        /// <para>When the item is serialized out as xml, its value is "chDir".</para>
        /// </summary>
        public static ParameterIdValues ChildDirection => new("chDir");
        /// <summary>
        /// Child Alignment.
        /// <para>When the item is serialized out as xml, its value is "chAlign".</para>
        /// </summary>
        public static ParameterIdValues ChildAlignment => new("chAlign");
        /// <summary>
        /// Secondary Child Alignment.
        /// <para>When the item is serialized out as xml, its value is "secChAlign".</para>
        /// </summary>
        public static ParameterIdValues SecondaryChildAlignment => new("secChAlign");
        /// <summary>
        /// Linear Direction.
        /// <para>When the item is serialized out as xml, its value is "linDir".</para>
        /// </summary>
        public static ParameterIdValues LinearDirection => new("linDir");
        /// <summary>
        /// Secondary Linear Direction.
        /// <para>When the item is serialized out as xml, its value is "secLinDir".</para>
        /// </summary>
        public static ParameterIdValues SecondaryLinearDirection => new("secLinDir");
        /// <summary>
        /// Start Element.
        /// <para>When the item is serialized out as xml, its value is "stElem".</para>
        /// </summary>
        public static ParameterIdValues StartElement => new("stElem");
        /// <summary>
        /// Bend Point.
        /// <para>When the item is serialized out as xml, its value is "bendPt".</para>
        /// </summary>
        public static ParameterIdValues BendPoint => new("bendPt");
        /// <summary>
        /// Connection Route.
        /// <para>When the item is serialized out as xml, its value is "connRout".</para>
        /// </summary>
        public static ParameterIdValues ConnectionRoute => new("connRout");
        /// <summary>
        /// Beginning Arrowhead Style.
        /// <para>When the item is serialized out as xml, its value is "begSty".</para>
        /// </summary>
        public static ParameterIdValues BeginningArrowheadStyle => new("begSty");
        /// <summary>
        /// End Style.
        /// <para>When the item is serialized out as xml, its value is "endSty".</para>
        /// </summary>
        public static ParameterIdValues EndStyle => new("endSty");
        /// <summary>
        /// Connector Dimension.
        /// <para>When the item is serialized out as xml, its value is "dim".</para>
        /// </summary>
        public static ParameterIdValues ConnectorDimension => new("dim");
        /// <summary>
        /// Rotation Path.
        /// <para>When the item is serialized out as xml, its value is "rotPath".</para>
        /// </summary>
        public static ParameterIdValues RotationPath => new("rotPath");
        /// <summary>
        /// Center Shape Mapping.
        /// <para>When the item is serialized out as xml, its value is "ctrShpMap".</para>
        /// </summary>
        public static ParameterIdValues CenterShapeMapping => new("ctrShpMap");
        /// <summary>
        /// Node Horizontal Alignment.
        /// <para>When the item is serialized out as xml, its value is "nodeHorzAlign".</para>
        /// </summary>
        public static ParameterIdValues NodeHorizontalAlignment => new("nodeHorzAlign");
        /// <summary>
        /// Node Vertical Alignment.
        /// <para>When the item is serialized out as xml, its value is "nodeVertAlign".</para>
        /// </summary>
        public static ParameterIdValues NodeVerticalAlignment => new("nodeVertAlign");
        /// <summary>
        /// Fallback Scale.
        /// <para>When the item is serialized out as xml, its value is "fallback".</para>
        /// </summary>
        public static ParameterIdValues FallbackScale => new("fallback");
        /// <summary>
        /// Text Direction.
        /// <para>When the item is serialized out as xml, its value is "txDir".</para>
        /// </summary>
        public static ParameterIdValues TextDirection => new("txDir");
        /// <summary>
        /// Pyramid Accent Position.
        /// <para>When the item is serialized out as xml, its value is "pyraAcctPos".</para>
        /// </summary>
        public static ParameterIdValues PyramidAccentPosition => new("pyraAcctPos");
        /// <summary>
        /// Pyramid Accent Text Margin.
        /// <para>When the item is serialized out as xml, its value is "pyraAcctTxMar".</para>
        /// </summary>
        public static ParameterIdValues PyramidAccentTextMargin => new("pyraAcctTxMar");
        /// <summary>
        /// Text Block Direction.
        /// <para>When the item is serialized out as xml, its value is "txBlDir".</para>
        /// </summary>
        public static ParameterIdValues TextBlockDirection => new("txBlDir");
        /// <summary>
        /// Text Anchor Horizontal.
        /// <para>When the item is serialized out as xml, its value is "txAnchorHorz".</para>
        /// </summary>
        public static ParameterIdValues TextAnchorHorizontal => new("txAnchorHorz");
        /// <summary>
        /// Text Anchor Vertical.
        /// <para>When the item is serialized out as xml, its value is "txAnchorVert".</para>
        /// </summary>
        public static ParameterIdValues TextAnchorVertical => new("txAnchorVert");
        /// <summary>
        /// Text Anchor Horizontal With Children.
        /// <para>When the item is serialized out as xml, its value is "txAnchorHorzCh".</para>
        /// </summary>
        public static ParameterIdValues TextAnchorHorizontalWithChildren => new("txAnchorHorzCh");
        /// <summary>
        /// Text Anchor Vertical With Children.
        /// <para>When the item is serialized out as xml, its value is "txAnchorVertCh".</para>
        /// </summary>
        public static ParameterIdValues TextAnchorVerticalWithChildren => new("txAnchorVertCh");
        /// <summary>
        /// Parent Text Left-to-Right Alignment.
        /// <para>When the item is serialized out as xml, its value is "parTxLTRAlign".</para>
        /// </summary>
        public static ParameterIdValues ParentTextLeftToRightAlignment => new("parTxLTRAlign");
        /// <summary>
        /// Parent Text Right-to-Left Alignment.
        /// <para>When the item is serialized out as xml, its value is "parTxRTLAlign".</para>
        /// </summary>
        public static ParameterIdValues ParentTextRightToLeftAlignment => new("parTxRTLAlign");
        /// <summary>
        /// Shape Text Left-to-Right Alignment.
        /// <para>When the item is serialized out as xml, its value is "shpTxLTRAlignCh".</para>
        /// </summary>
        public static ParameterIdValues ShapeTextLeftToRightAlignment => new("shpTxLTRAlignCh");
        /// <summary>
        /// Shape Text Right-to-Left Alignment.
        /// <para>When the item is serialized out as xml, its value is "shpTxRTLAlignCh".</para>
        /// </summary>
        public static ParameterIdValues ShapeTextRightToLeftAlignment => new("shpTxRTLAlignCh");
        /// <summary>
        /// Auto Text Rotation.
        /// <para>When the item is serialized out as xml, its value is "autoTxRot".</para>
        /// </summary>
        public static ParameterIdValues AutoTextRotation => new("autoTxRot");
        /// <summary>
        /// Grow Direction.
        /// <para>When the item is serialized out as xml, its value is "grDir".</para>
        /// </summary>
        public static ParameterIdValues GrowDirection => new("grDir");
        /// <summary>
        /// Flow Direction.
        /// <para>When the item is serialized out as xml, its value is "flowDir".</para>
        /// </summary>
        public static ParameterIdValues FlowDirection => new("flowDir");
        /// <summary>
        /// Continue Direction.
        /// <para>When the item is serialized out as xml, its value is "contDir".</para>
        /// </summary>
        public static ParameterIdValues ContinueDirection => new("contDir");
        /// <summary>
        /// Breakpoint.
        /// <para>When the item is serialized out as xml, its value is "bkpt".</para>
        /// </summary>
        public static ParameterIdValues Breakpoint => new("bkpt");
        /// <summary>
        /// Offset.
        /// <para>When the item is serialized out as xml, its value is "off".</para>
        /// </summary>
        public static ParameterIdValues Offset => new("off");
        /// <summary>
        /// Hierarchy Alignment.
        /// <para>When the item is serialized out as xml, its value is "hierAlign".</para>
        /// </summary>
        public static ParameterIdValues HierarchyAlignment => new("hierAlign");
        /// <summary>
        /// Breakpoint Fixed Value.
        /// <para>When the item is serialized out as xml, its value is "bkPtFixedVal".</para>
        /// </summary>
        public static ParameterIdValues BreakpointFixedValue => new("bkPtFixedVal");
        /// <summary>
        /// Start Bullets At Level.
        /// <para>When the item is serialized out as xml, its value is "stBulletLvl".</para>
        /// </summary>
        public static ParameterIdValues StartBulletsAtLevel => new("stBulletLvl");
        /// <summary>
        /// Start Angle.
        /// <para>When the item is serialized out as xml, its value is "stAng".</para>
        /// </summary>
        public static ParameterIdValues StartAngle => new("stAng");
        /// <summary>
        /// Span Angle.
        /// <para>When the item is serialized out as xml, its value is "spanAng".</para>
        /// </summary>
        public static ParameterIdValues SpanAngle => new("spanAng");
        /// <summary>
        /// Aspect Ratio.
        /// <para>When the item is serialized out as xml, its value is "ar".</para>
        /// </summary>
        public static ParameterIdValues AspectRatio => new("ar");
        /// <summary>
        /// Line Spacing Parent.
        /// <para>When the item is serialized out as xml, its value is "lnSpPar".</para>
        /// </summary>
        public static ParameterIdValues LineSpacingParent => new("lnSpPar");
        /// <summary>
        /// Line Spacing After Parent Paragraph.
        /// <para>When the item is serialized out as xml, its value is "lnSpAfParP".</para>
        /// </summary>
        public static ParameterIdValues LineSpacingAfterParentParagraph => new("lnSpAfParP");
        /// <summary>
        /// Line Spacing Children.
        /// <para>When the item is serialized out as xml, its value is "lnSpCh".</para>
        /// </summary>
        public static ParameterIdValues LineSpacingChildren => new("lnSpCh");
        /// <summary>
        /// Line Spacing After Children Paragraph.
        /// <para>When the item is serialized out as xml, its value is "lnSpAfChP".</para>
        /// </summary>
        public static ParameterIdValues LineSpacingAfterChildrenParagraph => new("lnSpAfChP");
        /// <summary>
        /// Route Shortest Distance.
        /// <para>When the item is serialized out as xml, its value is "rtShortDist".</para>
        /// </summary>
        public static ParameterIdValues RouteShortestDistance => new("rtShortDist");
        /// <summary>
        /// Text Alignment.
        /// <para>When the item is serialized out as xml, its value is "alignTx".</para>
        /// </summary>
        public static ParameterIdValues TextAlignment => new("alignTx");
        /// <summary>
        /// Pyramid Level Node.
        /// <para>When the item is serialized out as xml, its value is "pyraLvlNode".</para>
        /// </summary>
        public static ParameterIdValues PyramidLevelNode => new("pyraLvlNode");
        /// <summary>
        /// Pyramid Accent Background Node.
        /// <para>When the item is serialized out as xml, its value is "pyraAcctBkgdNode".</para>
        /// </summary>
        public static ParameterIdValues PyramidAccentBackgroundNode => new("pyraAcctBkgdNode");
        /// <summary>
        /// Pyramid Accent Text Node.
        /// <para>When the item is serialized out as xml, its value is "pyraAcctTxNode".</para>
        /// </summary>
        public static ParameterIdValues PyramidAccentTextNode => new("pyraAcctTxNode");
        /// <summary>
        /// Source Node.
        /// <para>When the item is serialized out as xml, its value is "srcNode".</para>
        /// </summary>
        public static ParameterIdValues SourceNode => new("srcNode");
        /// <summary>
        /// Destination Node.
        /// <para>When the item is serialized out as xml, its value is "dstNode".</para>
        /// </summary>
        public static ParameterIdValues DestinationNode => new("dstNode");
        /// <summary>
        /// Beginning Points.
        /// <para>When the item is serialized out as xml, its value is "begPts".</para>
        /// </summary>
        public static ParameterIdValues BeginningPoints => new("begPts");
        /// <summary>
        /// End Points.
        /// <para>When the item is serialized out as xml, its value is "endPts".</para>
        /// </summary>
        public static ParameterIdValues EndPoints => new("endPts");
    
    }

    /// <summary>
    /// Function Type
    /// </summary>
    public readonly record struct FunctionValues : IEnumValue, IEnumValueFactory<FunctionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FunctionValues enum instance
        /// </summary>
        public FunctionValues(string value) => _value = value;
        FunctionValues IEnumValueFactory<FunctionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "cnt" => true,
            "pos" => true,
            "revPos" => true,
            "posEven" => true,
            "posOdd" => true,
            "var" => true,
            "depth" => true,
            "maxDepth" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "cnt";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Count.
        /// <para>When the item is serialized out as xml, its value is "cnt".</para>
        /// </summary>
        public static FunctionValues Count => new("cnt");
        /// <summary>
        /// Position.
        /// <para>When the item is serialized out as xml, its value is "pos".</para>
        /// </summary>
        public static FunctionValues Position => new("pos");
        /// <summary>
        /// Reverse Position.
        /// <para>When the item is serialized out as xml, its value is "revPos".</para>
        /// </summary>
        public static FunctionValues ReversePosition => new("revPos");
        /// <summary>
        /// Position Even.
        /// <para>When the item is serialized out as xml, its value is "posEven".</para>
        /// </summary>
        public static FunctionValues PositionEven => new("posEven");
        /// <summary>
        /// Position Odd.
        /// <para>When the item is serialized out as xml, its value is "posOdd".</para>
        /// </summary>
        public static FunctionValues PositionOdd => new("posOdd");
        /// <summary>
        /// Variable.
        /// <para>When the item is serialized out as xml, its value is "var".</para>
        /// </summary>
        public static FunctionValues Variable => new("var");
        /// <summary>
        /// Depth.
        /// <para>When the item is serialized out as xml, its value is "depth".</para>
        /// </summary>
        public static FunctionValues Depth => new("depth");
        /// <summary>
        /// Max Depth.
        /// <para>When the item is serialized out as xml, its value is "maxDepth".</para>
        /// </summary>
        public static FunctionValues MaxDepth => new("maxDepth");
    
    }

    /// <summary>
    /// Function Operator
    /// </summary>
    public readonly record struct FunctionOperatorValues : IEnumValue, IEnumValueFactory<FunctionOperatorValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FunctionOperatorValues enum instance
        /// </summary>
        public FunctionOperatorValues(string value) => _value = value;
        FunctionOperatorValues IEnumValueFactory<FunctionOperatorValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "equ" => true,
            "neq" => true,
            "gt" => true,
            "lt" => true,
            "gte" => true,
            "lte" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "equ";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Equal.
        /// <para>When the item is serialized out as xml, its value is "equ".</para>
        /// </summary>
        public static FunctionOperatorValues Equal => new("equ");
        /// <summary>
        /// Not Equal To.
        /// <para>When the item is serialized out as xml, its value is "neq".</para>
        /// </summary>
        public static FunctionOperatorValues NotEqualTo => new("neq");
        /// <summary>
        /// Greater Than.
        /// <para>When the item is serialized out as xml, its value is "gt".</para>
        /// </summary>
        public static FunctionOperatorValues GreaterThan => new("gt");
        /// <summary>
        /// Less Than.
        /// <para>When the item is serialized out as xml, its value is "lt".</para>
        /// </summary>
        public static FunctionOperatorValues LessThan => new("lt");
        /// <summary>
        /// Greater Than or Equal to.
        /// <para>When the item is serialized out as xml, its value is "gte".</para>
        /// </summary>
        public static FunctionOperatorValues GreaterThanOrEqualTo => new("gte");
        /// <summary>
        /// Less Than or Equal to.
        /// <para>When the item is serialized out as xml, its value is "lte".</para>
        /// </summary>
        public static FunctionOperatorValues LessThanOrEqualTo => new("lte");
    
    }

    /// <summary>
    /// Horizontal Alignment
    /// </summary>
    public readonly record struct HorizontalAlignmentValues : IEnumValue, IEnumValueFactory<HorizontalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HorizontalAlignmentValues enum instance
        /// </summary>
        public HorizontalAlignmentValues(string value) => _value = value;
        HorizontalAlignmentValues IEnumValueFactory<HorizontalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "ctr" => true,
            "r" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static HorizontalAlignmentValues Left => new("l");
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static HorizontalAlignmentValues Center => new("ctr");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static HorizontalAlignmentValues Right => new("r");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static HorizontalAlignmentValues None => new("none");
    
    }

    /// <summary>
    /// Child Direction
    /// </summary>
    public readonly record struct ChildDirectionValues : IEnumValue, IEnumValueFactory<ChildDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ChildDirectionValues enum instance
        /// </summary>
        public ChildDirectionValues(string value) => _value = value;
        ChildDirectionValues IEnumValueFactory<ChildDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "horz" => true,
            "vert" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "horz";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Horizontal.
        /// <para>When the item is serialized out as xml, its value is "horz".</para>
        /// </summary>
        public static ChildDirectionValues Horizontal => new("horz");
        /// <summary>
        /// Vertical.
        /// <para>When the item is serialized out as xml, its value is "vert".</para>
        /// </summary>
        public static ChildDirectionValues Vertical => new("vert");
    
    }

    /// <summary>
    /// Child Alignment
    /// </summary>
    public readonly record struct ChildAlignmentValues : IEnumValue, IEnumValueFactory<ChildAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ChildAlignmentValues enum instance
        /// </summary>
        public ChildAlignmentValues(string value) => _value = value;
        ChildAlignmentValues IEnumValueFactory<ChildAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "t" => true,
            "b" => true,
            "l" => true,
            "r" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "t";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static ChildAlignmentValues Top => new("t");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static ChildAlignmentValues Bottom => new("b");
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static ChildAlignmentValues Left => new("l");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static ChildAlignmentValues Right => new("r");
    
    }

    /// <summary>
    /// Secondary Child Alignment
    /// </summary>
    public readonly record struct SecondaryChildAlignmentValues : IEnumValue, IEnumValueFactory<SecondaryChildAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SecondaryChildAlignmentValues enum instance
        /// </summary>
        public SecondaryChildAlignmentValues(string value) => _value = value;
        SecondaryChildAlignmentValues IEnumValueFactory<SecondaryChildAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "t" => true,
            "b" => true,
            "l" => true,
            "r" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static SecondaryChildAlignmentValues None => new("none");
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static SecondaryChildAlignmentValues Top => new("t");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static SecondaryChildAlignmentValues Bottom => new("b");
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static SecondaryChildAlignmentValues Left => new("l");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static SecondaryChildAlignmentValues Right => new("r");
    
    }

    /// <summary>
    /// Linear Direction
    /// </summary>
    public readonly record struct LinearDirectionValues : IEnumValue, IEnumValueFactory<LinearDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new LinearDirectionValues enum instance
        /// </summary>
        public LinearDirectionValues(string value) => _value = value;
        LinearDirectionValues IEnumValueFactory<LinearDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "fromL" => true,
            "fromR" => true,
            "fromT" => true,
            "fromB" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "fromL";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// From Left.
        /// <para>When the item is serialized out as xml, its value is "fromL".</para>
        /// </summary>
        public static LinearDirectionValues FromLeft => new("fromL");
        /// <summary>
        /// From Right.
        /// <para>When the item is serialized out as xml, its value is "fromR".</para>
        /// </summary>
        public static LinearDirectionValues FromRight => new("fromR");
        /// <summary>
        /// From Top.
        /// <para>When the item is serialized out as xml, its value is "fromT".</para>
        /// </summary>
        public static LinearDirectionValues FromTop => new("fromT");
        /// <summary>
        /// From Bottom.
        /// <para>When the item is serialized out as xml, its value is "fromB".</para>
        /// </summary>
        public static LinearDirectionValues FromBottom => new("fromB");
    
    }

    /// <summary>
    /// Secondary Linear Direction
    /// </summary>
    public readonly record struct SecondaryLinearDirectionValues : IEnumValue, IEnumValueFactory<SecondaryLinearDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SecondaryLinearDirectionValues enum instance
        /// </summary>
        public SecondaryLinearDirectionValues(string value) => _value = value;
        SecondaryLinearDirectionValues IEnumValueFactory<SecondaryLinearDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "fromL" => true,
            "fromR" => true,
            "fromT" => true,
            "fromB" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static SecondaryLinearDirectionValues None => new("none");
        /// <summary>
        /// From Left.
        /// <para>When the item is serialized out as xml, its value is "fromL".</para>
        /// </summary>
        public static SecondaryLinearDirectionValues FromLeft => new("fromL");
        /// <summary>
        /// From Right.
        /// <para>When the item is serialized out as xml, its value is "fromR".</para>
        /// </summary>
        public static SecondaryLinearDirectionValues FromRight => new("fromR");
        /// <summary>
        /// From Top.
        /// <para>When the item is serialized out as xml, its value is "fromT".</para>
        /// </summary>
        public static SecondaryLinearDirectionValues FromTop => new("fromT");
        /// <summary>
        /// From Bottom.
        /// <para>When the item is serialized out as xml, its value is "fromB".</para>
        /// </summary>
        public static SecondaryLinearDirectionValues FromBottom => new("fromB");
    
    }

    /// <summary>
    /// Starting Element
    /// </summary>
    public readonly record struct StartingElementValues : IEnumValue, IEnumValueFactory<StartingElementValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StartingElementValues enum instance
        /// </summary>
        public StartingElementValues(string value) => _value = value;
        StartingElementValues IEnumValueFactory<StartingElementValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "node" => true,
            "trans" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "node";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Node.
        /// <para>When the item is serialized out as xml, its value is "node".</para>
        /// </summary>
        public static StartingElementValues Node => new("node");
        /// <summary>
        /// Transition.
        /// <para>When the item is serialized out as xml, its value is "trans".</para>
        /// </summary>
        public static StartingElementValues Transition => new("trans");
    
    }

    /// <summary>
    /// Rotation Path
    /// </summary>
    public readonly record struct RotationPathValues : IEnumValue, IEnumValueFactory<RotationPathValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RotationPathValues enum instance
        /// </summary>
        public RotationPathValues(string value) => _value = value;
        RotationPathValues IEnumValueFactory<RotationPathValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "alongPath" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static RotationPathValues None => new("none");
        /// <summary>
        /// Along Path.
        /// <para>When the item is serialized out as xml, its value is "alongPath".</para>
        /// </summary>
        public static RotationPathValues AlongPath => new("alongPath");
    
    }

    /// <summary>
    /// Center Shape Mapping
    /// </summary>
    public readonly record struct CenterShapeMappingValues : IEnumValue, IEnumValueFactory<CenterShapeMappingValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new CenterShapeMappingValues enum instance
        /// </summary>
        public CenterShapeMappingValues(string value) => _value = value;
        CenterShapeMappingValues IEnumValueFactory<CenterShapeMappingValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "fNode" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static CenterShapeMappingValues None => new("none");
        /// <summary>
        /// First Node.
        /// <para>When the item is serialized out as xml, its value is "fNode".</para>
        /// </summary>
        public static CenterShapeMappingValues FirstNode => new("fNode");
    
    }

    /// <summary>
    /// Bend Point
    /// </summary>
    public readonly record struct BendPointValues : IEnumValue, IEnumValueFactory<BendPointValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new BendPointValues enum instance
        /// </summary>
        public BendPointValues(string value) => _value = value;
        BendPointValues IEnumValueFactory<BendPointValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "beg" => true,
            "def" => true,
            "end" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "beg";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Beginning.
        /// <para>When the item is serialized out as xml, its value is "beg".</para>
        /// </summary>
        public static BendPointValues Beginning => new("beg");
        /// <summary>
        /// Default.
        /// <para>When the item is serialized out as xml, its value is "def".</para>
        /// </summary>
        public static BendPointValues Default => new("def");
        /// <summary>
        /// End.
        /// <para>When the item is serialized out as xml, its value is "end".</para>
        /// </summary>
        public static BendPointValues End => new("end");
    
    }

    /// <summary>
    /// Connector Routing
    /// </summary>
    public readonly record struct ConnectorRoutingValues : IEnumValue, IEnumValueFactory<ConnectorRoutingValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConnectorRoutingValues enum instance
        /// </summary>
        public ConnectorRoutingValues(string value) => _value = value;
        ConnectorRoutingValues IEnumValueFactory<ConnectorRoutingValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "stra" => true,
            "bend" => true,
            "curve" => true,
            "longCurve" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "stra";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Straight.
        /// <para>When the item is serialized out as xml, its value is "stra".</para>
        /// </summary>
        public static ConnectorRoutingValues Straight => new("stra");
        /// <summary>
        /// Bending.
        /// <para>When the item is serialized out as xml, its value is "bend".</para>
        /// </summary>
        public static ConnectorRoutingValues Bending => new("bend");
        /// <summary>
        /// Curve.
        /// <para>When the item is serialized out as xml, its value is "curve".</para>
        /// </summary>
        public static ConnectorRoutingValues Curve => new("curve");
        /// <summary>
        /// Long Curve.
        /// <para>When the item is serialized out as xml, its value is "longCurve".</para>
        /// </summary>
        public static ConnectorRoutingValues LongCurve => new("longCurve");
    
    }

    /// <summary>
    /// Arrowhead Styles
    /// </summary>
    public readonly record struct ArrowheadStyleValues : IEnumValue, IEnumValueFactory<ArrowheadStyleValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ArrowheadStyleValues enum instance
        /// </summary>
        public ArrowheadStyleValues(string value) => _value = value;
        ArrowheadStyleValues IEnumValueFactory<ArrowheadStyleValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "auto" => true,
            "arr" => true,
            "noArr" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "auto";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Auto.
        /// <para>When the item is serialized out as xml, its value is "auto".</para>
        /// </summary>
        public static ArrowheadStyleValues Auto => new("auto");
        /// <summary>
        /// Arrowhead Present.
        /// <para>When the item is serialized out as xml, its value is "arr".</para>
        /// </summary>
        public static ArrowheadStyleValues Arrow => new("arr");
        /// <summary>
        /// No Arrowhead.
        /// <para>When the item is serialized out as xml, its value is "noArr".</para>
        /// </summary>
        public static ArrowheadStyleValues NoArrow => new("noArr");
    
    }

    /// <summary>
    /// Connector Dimension
    /// </summary>
    public readonly record struct ConnectorDimensionValues : IEnumValue, IEnumValueFactory<ConnectorDimensionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConnectorDimensionValues enum instance
        /// </summary>
        public ConnectorDimensionValues(string value) => _value = value;
        ConnectorDimensionValues IEnumValueFactory<ConnectorDimensionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1D" => true,
            "2D" => true,
            "cust" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1D";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1 Dimension.
        /// <para>When the item is serialized out as xml, its value is "1D".</para>
        /// </summary>
        public static ConnectorDimensionValues OneDimension => new("1D");
        /// <summary>
        /// 2 Dimensions.
        /// <para>When the item is serialized out as xml, its value is "2D".</para>
        /// </summary>
        public static ConnectorDimensionValues TwoDimension => new("2D");
        /// <summary>
        /// Custom.
        /// <para>When the item is serialized out as xml, its value is "cust".</para>
        /// </summary>
        public static ConnectorDimensionValues Custom => new("cust");
    
    }

    /// <summary>
    /// Connector Point
    /// </summary>
    public readonly record struct ConnectorPointValues : IEnumValue, IEnumValueFactory<ConnectorPointValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ConnectorPointValues enum instance
        /// </summary>
        public ConnectorPointValues(string value) => _value = value;
        ConnectorPointValues IEnumValueFactory<ConnectorPointValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "auto" => true,
            "bCtr" => true,
            "ctr" => true,
            "midL" => true,
            "midR" => true,
            "tCtr" => true,
            "bL" => true,
            "bR" => true,
            "tL" => true,
            "tR" => true,
            "radial" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "auto";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Auto.
        /// <para>When the item is serialized out as xml, its value is "auto".</para>
        /// </summary>
        public static ConnectorPointValues Auto => new("auto");
        /// <summary>
        /// Bottom Center.
        /// <para>When the item is serialized out as xml, its value is "bCtr".</para>
        /// </summary>
        public static ConnectorPointValues BottomCenter => new("bCtr");
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static ConnectorPointValues Center => new("ctr");
        /// <summary>
        /// Middle Left.
        /// <para>When the item is serialized out as xml, its value is "midL".</para>
        /// </summary>
        public static ConnectorPointValues MiddleLeft => new("midL");
        /// <summary>
        /// Middle Right.
        /// <para>When the item is serialized out as xml, its value is "midR".</para>
        /// </summary>
        public static ConnectorPointValues MiddleRight => new("midR");
        /// <summary>
        /// Top Center.
        /// <para>When the item is serialized out as xml, its value is "tCtr".</para>
        /// </summary>
        public static ConnectorPointValues TopCenter => new("tCtr");
        /// <summary>
        /// Bottom Left.
        /// <para>When the item is serialized out as xml, its value is "bL".</para>
        /// </summary>
        public static ConnectorPointValues BottomLeft => new("bL");
        /// <summary>
        /// Bottom Right.
        /// <para>When the item is serialized out as xml, its value is "bR".</para>
        /// </summary>
        public static ConnectorPointValues BottomRight => new("bR");
        /// <summary>
        /// Top Left.
        /// <para>When the item is serialized out as xml, its value is "tL".</para>
        /// </summary>
        public static ConnectorPointValues TopLeft => new("tL");
        /// <summary>
        /// Top Right.
        /// <para>When the item is serialized out as xml, its value is "tR".</para>
        /// </summary>
        public static ConnectorPointValues TopRight => new("tR");
        /// <summary>
        /// Radial.
        /// <para>When the item is serialized out as xml, its value is "radial".</para>
        /// </summary>
        public static ConnectorPointValues Radial => new("radial");
    
    }

    /// <summary>
    /// Node Horizontal Alignment
    /// </summary>
    public readonly record struct NodeHorizontalAlignmentValues : IEnumValue, IEnumValueFactory<NodeHorizontalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new NodeHorizontalAlignmentValues enum instance
        /// </summary>
        public NodeHorizontalAlignmentValues(string value) => _value = value;
        NodeHorizontalAlignmentValues IEnumValueFactory<NodeHorizontalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "ctr" => true,
            "r" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static NodeHorizontalAlignmentValues Left => new("l");
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static NodeHorizontalAlignmentValues Center => new("ctr");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static NodeHorizontalAlignmentValues Right => new("r");
    
    }

    /// <summary>
    /// Node Vertical Alignment
    /// </summary>
    public readonly record struct NodeVerticalAlignmentValues : IEnumValue, IEnumValueFactory<NodeVerticalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new NodeVerticalAlignmentValues enum instance
        /// </summary>
        public NodeVerticalAlignmentValues(string value) => _value = value;
        NodeVerticalAlignmentValues IEnumValueFactory<NodeVerticalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "t" => true,
            "mid" => true,
            "b" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "t";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static NodeVerticalAlignmentValues Top => new("t");
        /// <summary>
        /// Middle.
        /// <para>When the item is serialized out as xml, its value is "mid".</para>
        /// </summary>
        public static NodeVerticalAlignmentValues Middle => new("mid");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static NodeVerticalAlignmentValues Bottom => new("b");
    
    }

    /// <summary>
    /// Fallback Dimension
    /// </summary>
    public readonly record struct FallbackDimensionValues : IEnumValue, IEnumValueFactory<FallbackDimensionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FallbackDimensionValues enum instance
        /// </summary>
        public FallbackDimensionValues(string value) => _value = value;
        FallbackDimensionValues IEnumValueFactory<FallbackDimensionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "1D" => true,
            "2D" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "1D";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// 1 Dimension.
        /// <para>When the item is serialized out as xml, its value is "1D".</para>
        /// </summary>
        public static FallbackDimensionValues OneDimension => new("1D");
        /// <summary>
        /// 2 Dimensions.
        /// <para>When the item is serialized out as xml, its value is "2D".</para>
        /// </summary>
        public static FallbackDimensionValues TwoDimension => new("2D");
    
    }

    /// <summary>
    /// Text Direction
    /// </summary>
    public readonly record struct TextDirectionValues : IEnumValue, IEnumValueFactory<TextDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextDirectionValues enum instance
        /// </summary>
        public TextDirectionValues(string value) => _value = value;
        TextDirectionValues IEnumValueFactory<TextDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "fromT" => true,
            "fromB" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "fromT";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// From Top.
        /// <para>When the item is serialized out as xml, its value is "fromT".</para>
        /// </summary>
        public static TextDirectionValues FromTop => new("fromT");
        /// <summary>
        /// From Bottom.
        /// <para>When the item is serialized out as xml, its value is "fromB".</para>
        /// </summary>
        public static TextDirectionValues FromBottom => new("fromB");
    
    }

    /// <summary>
    /// Pyramid Accent Position
    /// </summary>
    public readonly record struct PyramidAccentPositionValues : IEnumValue, IEnumValueFactory<PyramidAccentPositionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PyramidAccentPositionValues enum instance
        /// </summary>
        public PyramidAccentPositionValues(string value) => _value = value;
        PyramidAccentPositionValues IEnumValueFactory<PyramidAccentPositionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "bef" => true,
            "aft" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "bef";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Before.
        /// <para>When the item is serialized out as xml, its value is "bef".</para>
        /// </summary>
        public static PyramidAccentPositionValues Before => new("bef");
        /// <summary>
        /// Pyramid Accent After.
        /// <para>When the item is serialized out as xml, its value is "aft".</para>
        /// </summary>
        public static PyramidAccentPositionValues After => new("aft");
    
    }

    /// <summary>
    /// Pyramid Accent Text Margin
    /// </summary>
    public readonly record struct PyramidAccentTextMarginValues : IEnumValue, IEnumValueFactory<PyramidAccentTextMarginValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PyramidAccentTextMarginValues enum instance
        /// </summary>
        public PyramidAccentTextMarginValues(string value) => _value = value;
        PyramidAccentTextMarginValues IEnumValueFactory<PyramidAccentTextMarginValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "step" => true,
            "stack" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "step";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Step.
        /// <para>When the item is serialized out as xml, its value is "step".</para>
        /// </summary>
        public static PyramidAccentTextMarginValues Step => new("step");
        /// <summary>
        /// Stack.
        /// <para>When the item is serialized out as xml, its value is "stack".</para>
        /// </summary>
        public static PyramidAccentTextMarginValues Stack => new("stack");
    
    }

    /// <summary>
    /// Text Block Direction
    /// </summary>
    public readonly record struct TextBlockDirectionValues : IEnumValue, IEnumValueFactory<TextBlockDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextBlockDirectionValues enum instance
        /// </summary>
        public TextBlockDirectionValues(string value) => _value = value;
        TextBlockDirectionValues IEnumValueFactory<TextBlockDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "horz" => true,
            "vert" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "horz";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Horizontal.
        /// <para>When the item is serialized out as xml, its value is "horz".</para>
        /// </summary>
        public static TextBlockDirectionValues Horizontal => new("horz");
        /// <summary>
        /// Vertical Direction.
        /// <para>When the item is serialized out as xml, its value is "vert".</para>
        /// </summary>
        public static TextBlockDirectionValues Vertical => new("vert");
    
    }

    /// <summary>
    /// Text Anchor Horizontal
    /// </summary>
    public readonly record struct TextAnchorHorizontalValues : IEnumValue, IEnumValueFactory<TextAnchorHorizontalValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextAnchorHorizontalValues enum instance
        /// </summary>
        public TextAnchorHorizontalValues(string value) => _value = value;
        TextAnchorHorizontalValues IEnumValueFactory<TextAnchorHorizontalValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "ctr" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static TextAnchorHorizontalValues None => new("none");
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static TextAnchorHorizontalValues Center => new("ctr");
    
    }

    /// <summary>
    /// Text Anchor Vertical
    /// </summary>
    public readonly record struct TextAnchorVerticalValues : IEnumValue, IEnumValueFactory<TextAnchorVerticalValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextAnchorVerticalValues enum instance
        /// </summary>
        public TextAnchorVerticalValues(string value) => _value = value;
        TextAnchorVerticalValues IEnumValueFactory<TextAnchorVerticalValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "t" => true,
            "mid" => true,
            "b" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "t";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static TextAnchorVerticalValues Top => new("t");
        /// <summary>
        /// Middle.
        /// <para>When the item is serialized out as xml, its value is "mid".</para>
        /// </summary>
        public static TextAnchorVerticalValues Middle => new("mid");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static TextAnchorVerticalValues Bottom => new("b");
    
    }

    /// <summary>
    /// Text Alignment
    /// </summary>
    public readonly record struct TextAlignmentValues : IEnumValue, IEnumValueFactory<TextAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TextAlignmentValues enum instance
        /// </summary>
        public TextAlignmentValues(string value) => _value = value;
        TextAlignmentValues IEnumValueFactory<TextAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "ctr" => true,
            "r" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Left.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static TextAlignmentValues Left => new("l");
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static TextAlignmentValues Center => new("ctr");
        /// <summary>
        /// Right.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static TextAlignmentValues Right => new("r");
    
    }

    /// <summary>
    /// Auto Text Rotation
    /// </summary>
    public readonly record struct AutoTextRotationValues : IEnumValue, IEnumValueFactory<AutoTextRotationValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AutoTextRotationValues enum instance
        /// </summary>
        public AutoTextRotationValues(string value) => _value = value;
        AutoTextRotationValues IEnumValueFactory<AutoTextRotationValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "upr" => true,
            "grav" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static AutoTextRotationValues None => new("none");
        /// <summary>
        /// Upright.
        /// <para>When the item is serialized out as xml, its value is "upr".</para>
        /// </summary>
        public static AutoTextRotationValues Upright => new("upr");
        /// <summary>
        /// Gravity.
        /// <para>When the item is serialized out as xml, its value is "grav".</para>
        /// </summary>
        public static AutoTextRotationValues Gravity => new("grav");
    
    }

    /// <summary>
    /// Grow Direction
    /// </summary>
    public readonly record struct GrowDirectionValues : IEnumValue, IEnumValueFactory<GrowDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GrowDirectionValues enum instance
        /// </summary>
        public GrowDirectionValues(string value) => _value = value;
        GrowDirectionValues IEnumValueFactory<GrowDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "tL" => true,
            "tR" => true,
            "bL" => true,
            "bR" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "tL";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top Left.
        /// <para>When the item is serialized out as xml, its value is "tL".</para>
        /// </summary>
        public static GrowDirectionValues TopLeft => new("tL");
        /// <summary>
        /// Top Right.
        /// <para>When the item is serialized out as xml, its value is "tR".</para>
        /// </summary>
        public static GrowDirectionValues TopRight => new("tR");
        /// <summary>
        /// Bottom Left.
        /// <para>When the item is serialized out as xml, its value is "bL".</para>
        /// </summary>
        public static GrowDirectionValues BottomLeft => new("bL");
        /// <summary>
        /// Bottom Right.
        /// <para>When the item is serialized out as xml, its value is "bR".</para>
        /// </summary>
        public static GrowDirectionValues BottomRight => new("bR");
    
    }

    /// <summary>
    /// Flow Direction
    /// </summary>
    public readonly record struct FlowDirectionValues : IEnumValue, IEnumValueFactory<FlowDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FlowDirectionValues enum instance
        /// </summary>
        public FlowDirectionValues(string value) => _value = value;
        FlowDirectionValues IEnumValueFactory<FlowDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "row" => true,
            "col" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "row";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Row.
        /// <para>When the item is serialized out as xml, its value is "row".</para>
        /// </summary>
        public static FlowDirectionValues Row => new("row");
        /// <summary>
        /// Column.
        /// <para>When the item is serialized out as xml, its value is "col".</para>
        /// </summary>
        public static FlowDirectionValues Column => new("col");
    
    }

    /// <summary>
    /// Continue Direction
    /// </summary>
    public readonly record struct ContinueDirectionValues : IEnumValue, IEnumValueFactory<ContinueDirectionValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ContinueDirectionValues enum instance
        /// </summary>
        public ContinueDirectionValues(string value) => _value = value;
        ContinueDirectionValues IEnumValueFactory<ContinueDirectionValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "revDir" => true,
            "sameDir" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "revDir";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Reverse Direction.
        /// <para>When the item is serialized out as xml, its value is "revDir".</para>
        /// </summary>
        public static ContinueDirectionValues ReverseDirection => new("revDir");
        /// <summary>
        /// Same Direction.
        /// <para>When the item is serialized out as xml, its value is "sameDir".</para>
        /// </summary>
        public static ContinueDirectionValues SameDirection => new("sameDir");
    
    }

    /// <summary>
    /// Breakpoint
    /// </summary>
    public readonly record struct BreakpointValues : IEnumValue, IEnumValueFactory<BreakpointValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new BreakpointValues enum instance
        /// </summary>
        public BreakpointValues(string value) => _value = value;
        BreakpointValues IEnumValueFactory<BreakpointValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "endCnv" => true,
            "bal" => true,
            "fixed" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "endCnv";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// End of Canvas.
        /// <para>When the item is serialized out as xml, its value is "endCnv".</para>
        /// </summary>
        public static BreakpointValues EndCanvas => new("endCnv");
        /// <summary>
        /// Balanced.
        /// <para>When the item is serialized out as xml, its value is "bal".</para>
        /// </summary>
        public static BreakpointValues Balanced => new("bal");
        /// <summary>
        /// Fixed.
        /// <para>When the item is serialized out as xml, its value is "fixed".</para>
        /// </summary>
        public static BreakpointValues Fixed => new("fixed");
    
    }

    /// <summary>
    /// Offset
    /// </summary>
    public readonly record struct OffsetValues : IEnumValue, IEnumValueFactory<OffsetValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new OffsetValues enum instance
        /// </summary>
        public OffsetValues(string value) => _value = value;
        OffsetValues IEnumValueFactory<OffsetValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "ctr" => true,
            "off" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "ctr";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Center.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static OffsetValues Center => new("ctr");
        /// <summary>
        /// Offset.
        /// <para>When the item is serialized out as xml, its value is "off".</para>
        /// </summary>
        public static OffsetValues Offset => new("off");
    
    }

    /// <summary>
    /// Hierarchy Alignment
    /// </summary>
    public readonly record struct HierarchyAlignmentValues : IEnumValue, IEnumValueFactory<HierarchyAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new HierarchyAlignmentValues enum instance
        /// </summary>
        public HierarchyAlignmentValues(string value) => _value = value;
        HierarchyAlignmentValues IEnumValueFactory<HierarchyAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "tL" => true,
            "tR" => true,
            "tCtrCh" => true,
            "tCtrDes" => true,
            "bL" => true,
            "bR" => true,
            "bCtrCh" => true,
            "bCtrDes" => true,
            "lT" => true,
            "lB" => true,
            "lCtrCh" => true,
            "lCtrDes" => true,
            "rT" => true,
            "rB" => true,
            "rCtrCh" => true,
            "rCtrDes" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "tL";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Top Left.
        /// <para>When the item is serialized out as xml, its value is "tL".</para>
        /// </summary>
        public static HierarchyAlignmentValues TopLeft => new("tL");
        /// <summary>
        /// Top Right.
        /// <para>When the item is serialized out as xml, its value is "tR".</para>
        /// </summary>
        public static HierarchyAlignmentValues TopRight => new("tR");
        /// <summary>
        /// Top Center Children.
        /// <para>When the item is serialized out as xml, its value is "tCtrCh".</para>
        /// </summary>
        public static HierarchyAlignmentValues TopCenterChildren => new("tCtrCh");
        /// <summary>
        /// Top Center Descendants.
        /// <para>When the item is serialized out as xml, its value is "tCtrDes".</para>
        /// </summary>
        public static HierarchyAlignmentValues TopCenterDescendants => new("tCtrDes");
        /// <summary>
        /// Bottom Left.
        /// <para>When the item is serialized out as xml, its value is "bL".</para>
        /// </summary>
        public static HierarchyAlignmentValues BottomLeft => new("bL");
        /// <summary>
        /// Bottom Right.
        /// <para>When the item is serialized out as xml, its value is "bR".</para>
        /// </summary>
        public static HierarchyAlignmentValues BottomRight => new("bR");
        /// <summary>
        /// Bottom Center Child.
        /// <para>When the item is serialized out as xml, its value is "bCtrCh".</para>
        /// </summary>
        public static HierarchyAlignmentValues BottomCenterChild => new("bCtrCh");
        /// <summary>
        /// Bottom Center Descendant.
        /// <para>When the item is serialized out as xml, its value is "bCtrDes".</para>
        /// </summary>
        public static HierarchyAlignmentValues BottomCenterDescendant => new("bCtrDes");
        /// <summary>
        /// Left Top.
        /// <para>When the item is serialized out as xml, its value is "lT".</para>
        /// </summary>
        public static HierarchyAlignmentValues LeftTop => new("lT");
        /// <summary>
        /// Left Bottom.
        /// <para>When the item is serialized out as xml, its value is "lB".</para>
        /// </summary>
        public static HierarchyAlignmentValues LeftBottom => new("lB");
        /// <summary>
        /// Left Center Child.
        /// <para>When the item is serialized out as xml, its value is "lCtrCh".</para>
        /// </summary>
        public static HierarchyAlignmentValues LeftCenterChild => new("lCtrCh");
        /// <summary>
        /// Left Center Descendant.
        /// <para>When the item is serialized out as xml, its value is "lCtrDes".</para>
        /// </summary>
        public static HierarchyAlignmentValues LeftCenterDescendant => new("lCtrDes");
        /// <summary>
        /// Right Top.
        /// <para>When the item is serialized out as xml, its value is "rT".</para>
        /// </summary>
        public static HierarchyAlignmentValues RightTop => new("rT");
        /// <summary>
        /// Right Bottom.
        /// <para>When the item is serialized out as xml, its value is "rB".</para>
        /// </summary>
        public static HierarchyAlignmentValues RightBottom => new("rB");
        /// <summary>
        /// Right Center Children.
        /// <para>When the item is serialized out as xml, its value is "rCtrCh".</para>
        /// </summary>
        public static HierarchyAlignmentValues RightCenterChildren => new("rCtrCh");
        /// <summary>
        /// Right Center Descendants.
        /// <para>When the item is serialized out as xml, its value is "rCtrDes".</para>
        /// </summary>
        public static HierarchyAlignmentValues RightCenterDescendants => new("rCtrDes");
    
    }

    /// <summary>
    /// Variable Type
    /// </summary>
    public readonly record struct VariableValues : IEnumValue, IEnumValueFactory<VariableValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VariableValues enum instance
        /// </summary>
        public VariableValues(string value) => _value = value;
        VariableValues IEnumValueFactory<VariableValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "orgChart" => true,
            "chMax" => true,
            "chPref" => true,
            "bulEnabled" => true,
            "dir" => true,
            "hierBranch" => true,
            "animOne" => true,
            "animLvl" => true,
            "resizeHandles" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// Unknown.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static VariableValues None => new("none");
        /// <summary>
        /// Organizational Chart Algorithm.
        /// <para>When the item is serialized out as xml, its value is "orgChart".</para>
        /// </summary>
        public static VariableValues OrganizationalChart => new("orgChart");
        /// <summary>
        /// Child Max.
        /// <para>When the item is serialized out as xml, its value is "chMax".</para>
        /// </summary>
        public static VariableValues ChildMax => new("chMax");
        /// <summary>
        /// Child Preference.
        /// <para>When the item is serialized out as xml, its value is "chPref".</para>
        /// </summary>
        public static VariableValues ChildPreference => new("chPref");
        /// <summary>
        /// Bullets Enabled.
        /// <para>When the item is serialized out as xml, its value is "bulEnabled".</para>
        /// </summary>
        public static VariableValues BulletsEnabled => new("bulEnabled");
        /// <summary>
        /// Direction.
        /// <para>When the item is serialized out as xml, its value is "dir".</para>
        /// </summary>
        public static VariableValues Direction => new("dir");
        /// <summary>
        /// Hierarchy Branch.
        /// <para>When the item is serialized out as xml, its value is "hierBranch".</para>
        /// </summary>
        public static VariableValues HierarchyBranch => new("hierBranch");
        /// <summary>
        /// Animate One.
        /// <para>When the item is serialized out as xml, its value is "animOne".</para>
        /// </summary>
        public static VariableValues AnimateOne => new("animOne");
        /// <summary>
        /// Animation Level.
        /// <para>When the item is serialized out as xml, its value is "animLvl".</para>
        /// </summary>
        public static VariableValues AnimationLevel => new("animLvl");
        /// <summary>
        /// Resize Handles.
        /// <para>When the item is serialized out as xml, its value is "resizeHandles".</para>
        /// </summary>
        public static VariableValues ResizeHandles => new("resizeHandles");
    
    }

    /// <summary>
    /// Output Shape Type
    /// </summary>
    public readonly record struct OutputShapeValues : IEnumValue, IEnumValueFactory<OutputShapeValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new OutputShapeValues enum instance
        /// </summary>
        public OutputShapeValues(string value) => _value = value;
        OutputShapeValues IEnumValueFactory<OutputShapeValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "conn" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2007;
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static OutputShapeValues None => new("none");
        /// <summary>
        /// Connection.
        /// <para>When the item is serialized out as xml, its value is "conn".</para>
        /// </summary>
        public static OutputShapeValues Connection => new("conn");
    
    }

    /// <summary>
    /// Vertical Alignment
    /// </summary>
    public readonly record struct VerticalAlignmentValues : IEnumValue, IEnumValueFactory<VerticalAlignmentValues>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new VerticalAlignmentValues enum instance
        /// </summary>
        public VerticalAlignmentValues(string value) => _value = value;
        VerticalAlignmentValues IEnumValueFactory<VerticalAlignmentValues>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "t" => true,
            "mid" => true,
            "b" => true,
            "none" => true,
            "top" => true,
            "center" => true,
            "bottom" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "t";
        FileFormatVersions IEnumValue.Version => InternalValue switch
        {
            "top" => FileFormatVersions.Office2010,
            "center" => FileFormatVersions.Office2010,
            "bottom" => FileFormatVersions.Office2010,
            _ => FileFormatVersions.Office2007,
        };
        /// <summary>
        /// Top.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static VerticalAlignmentValues Top => new("t");
        /// <summary>
        /// Middle.
        /// <para>When the item is serialized out as xml, its value is "mid".</para>
        /// </summary>
        public static VerticalAlignmentValues Middle => new("mid");
        /// <summary>
        /// Bottom.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static VerticalAlignmentValues Bottom => new("b");
        /// <summary>
        /// None.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static VerticalAlignmentValues None => new("none");
        /// <summary>
        /// top.
        /// <para>When the item is serialized out as xml, its value is "top".</para>
        /// <para>This item is only available in Office 2010 and later.</para>
        /// </summary>
        public static VerticalAlignmentValues Top2010 => new("top");
        /// <summary>
        /// center.
        /// <para>When the item is serialized out as xml, its value is "center".</para>
        /// <para>This item is only available in Office 2010 and later.</para>
        /// </summary>
        public static VerticalAlignmentValues Middle2010 => new("center");
        /// <summary>
        /// bottom.
        /// <para>When the item is serialized out as xml, its value is "bottom".</para>
        /// <para>This item is only available in Office 2010 and later.</para>
        /// </summary>
        public static VerticalAlignmentValues Bottom2010 => new("bottom");
    
    }
}