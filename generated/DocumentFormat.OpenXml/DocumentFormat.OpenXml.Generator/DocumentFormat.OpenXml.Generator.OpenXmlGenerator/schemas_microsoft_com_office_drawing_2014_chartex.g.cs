// <auto-generated/>

// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#nullable enable

using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Drawing;
using DocumentFormat.OpenXml.Drawing.Charts;
using DocumentFormat.OpenXml.Framework;
using DocumentFormat.OpenXml.Framework.Metadata;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Validation.Schema;
using System;
using System.Collections.Generic;
using System.IO.Packaging;

namespace DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing
{
    /// <summary>
    /// <para>Defines the ChartSpace Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:chartSpace.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType" /> <c>&lt;cx:clrMapOvr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart" /> <c>&lt;cx:chart></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData" /> <c>&lt;cx:chartData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides" /> <c>&lt;cx:fmtOvrs></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings" /> <c>&lt;cx:printSettings></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ChartSpace : OpenXmlPartRootElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "chartSpace");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ChartSpace");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ChartSpace class.
        /// </summary>
        public ChartSpace() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSpace class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSpace(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSpace class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartSpace(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartSpace class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartSpace(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ChartData.</para>
        /// <para>Represents the following element tag in the schema: cx:chartData.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData? ChartData
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartData.ElementType);
        }

        /// <summary>
        /// <para>Chart.</para>
        /// <para>Represents the following element tag in the schema: cx:chart.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart? Chart
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Chart.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>ColorMappingType.</para>
        /// <para>Represents the following element tag in the schema: cx:clrMapOvr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType? ColorMappingType
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ColorMappingType.ElementType);
        }

        /// <summary>
        /// <para>FormatOverrides.</para>
        /// <para>Represents the following element tag in the schema: cx:fmtOvrs.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides? FormatOverrides
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverrides.ElementType);
        }

        /// <summary>
        /// <para>PrintSettings.</para>
        /// <para>Represents the following element tag in the schema: cx:printSettings.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings? PrintSettings
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PrintSettings.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartSpace>(deep);

        internal ChartSpace(ExtendedChartPart ownerPart) : base(ownerPart)
        {
        }

        /// <summary>
        /// Loads the DOM from the ExtendedChartPart
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to be loaded.</param>
        public void Load(ExtendedChartPart openXmlPart)
        {
            LoadFromPart(openXmlPart);
        }

        /// <summary>
        /// Saves the DOM into the ExtendedChartPart.
        /// </summary>
        /// <param name="openXmlPart">Specifies the part to save to.</param>
        public void Save(ExtendedChartPart openXmlPart)
        {
            base.SaveToPart(openXmlPart);
        }

        /// <summary>
        /// Gets the ExtendedChartPart associated with this element.
        /// </summary>
        public ExtendedChartPart? ExtendedChartPart
        {
            get => OpenXmlPart as ExtendedChartPart;
            internal set => OpenXmlPart = value;
        }
    }

    /// <summary>
    /// <para>Defines the RelId Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:chart.</para>
    /// </summary>
    public partial class RelId : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "chart");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_RelId");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the RelId class.
        /// </summary>
        public RelId() : base()
        {
        }

        /// <summary>
        /// <para>id, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remarks>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remarks>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<RelId>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RelId>(deep);
    }

    /// <summary>
    /// <para>Defines the BinCountXsdunsignedInt Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:binCount.</para>
    /// </summary>
    public partial class BinCountXsdunsignedInt : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "binCount");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "unsignedInt");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the BinCountXsdunsignedInt class.
        /// </summary>
        public BinCountXsdunsignedInt() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the BinCountXsdunsignedInt class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public BinCountXsdunsignedInt(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<BinCountXsdunsignedInt>(deep);
    }

    /// <summary>
    /// <para>Defines the Extension2 Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:ext.</para>
    /// </summary>
    public partial class Extension2 : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "ext");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Extension");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Extension2 class.
        /// </summary>
        public Extension2() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension2 class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Extension2(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension2 class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Extension2(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Extension2 class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Extension2(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>uri, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: uri</para>
        /// </summary>
        public StringValue? Uri
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<Extension2>()
                .AddAttribute("uri", a => a.Uri, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new AnyParticle(1, 1)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Extension2>(deep);
    }

    /// <summary>
    /// <para>Defines the MinColorSolidColorFillProperties Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:minColor.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MinColorSolidColorFillProperties : OpenXmlSolidColorFillPropertiesElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "minColor");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_SolidColorFillProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MinColorSolidColorFillProperties class.
        /// </summary>
        public MinColorSolidColorFillProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinColorSolidColorFillProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinColorSolidColorFillProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinColorSolidColorFillProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MinColorSolidColorFillProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelHex.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.HslColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SystemColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SchemeColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.PresetColor.ElementType, 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MinColorSolidColorFillProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the MidColorSolidColorFillProperties Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:midColor.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MidColorSolidColorFillProperties : OpenXmlSolidColorFillPropertiesElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "midColor");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_SolidColorFillProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MidColorSolidColorFillProperties class.
        /// </summary>
        public MidColorSolidColorFillProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MidColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MidColorSolidColorFillProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MidColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MidColorSolidColorFillProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MidColorSolidColorFillProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MidColorSolidColorFillProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelHex.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.HslColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SystemColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SchemeColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.PresetColor.ElementType, 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MidColorSolidColorFillProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the MaxColorSolidColorFillProperties Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:maxColor.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MaxColorSolidColorFillProperties : OpenXmlSolidColorFillPropertiesElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "maxColor");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_SolidColorFillProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MaxColorSolidColorFillProperties class.
        /// </summary>
        public MaxColorSolidColorFillProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MaxColorSolidColorFillProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxColorSolidColorFillProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MaxColorSolidColorFillProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxColorSolidColorFillProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MaxColorSolidColorFillProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.RgbColorModelHex.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.HslColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SystemColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SchemeColor.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.PresetColor.ElementType, 1, 1)
                    }
                }
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MaxColorSolidColorFillProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the OpenXmlSolidColorFillPropertiesElement Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.HslColor" /> <c>&lt;a:hslClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetColor" /> <c>&lt;a:prstClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SchemeColor" /> <c>&lt;a:schemeClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage" /> <c>&lt;a:scrgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.RgbColorModelHex" /> <c>&lt;a:srgbClr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SystemColor" /> <c>&lt;a:sysClr></c></description></item>
    /// </list>
    /// </remarks>
    public abstract partial class OpenXmlSolidColorFillPropertiesElement : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_SolidColorFillProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OpenXmlSolidColorFillPropertiesElement class.
        /// </summary>
        protected OpenXmlSolidColorFillPropertiesElement() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlSolidColorFillPropertiesElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlSolidColorFillPropertiesElement(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlSolidColorFillPropertiesElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlSolidColorFillPropertiesElement(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlSolidColorFillPropertiesElement class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected OpenXmlSolidColorFillPropertiesElement(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.HslColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PresetColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SchemeColor>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.RgbColorModelHex>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SystemColor>();
        }

        /// <summary>
        /// <para>RGB Color Model - Percentage Variant.</para>
        /// <para>Represents the following element tag in the schema: a:scrgbClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage? RgbColorModelPercentage
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage.ElementType) as DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.RgbColorModelPercentage.ElementType);
        }

        /// <summary>
        /// <para>RGB Color Model - Hex Variant.</para>
        /// <para>Represents the following element tag in the schema: a:srgbClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.RgbColorModelHex? RgbColorModelHex
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.RgbColorModelHex.ElementType) as DocumentFormat.OpenXml.Drawing.RgbColorModelHex;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.RgbColorModelHex.ElementType);
        }

        /// <summary>
        /// <para>Hue, Saturation, Luminance Color Model.</para>
        /// <para>Represents the following element tag in the schema: a:hslClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.HslColor? HslColor
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.HslColor.ElementType) as DocumentFormat.OpenXml.Drawing.HslColor;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.HslColor.ElementType);
        }

        /// <summary>
        /// <para>System Color.</para>
        /// <para>Represents the following element tag in the schema: a:sysClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.SystemColor? SystemColor
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.SystemColor.ElementType) as DocumentFormat.OpenXml.Drawing.SystemColor;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.SystemColor.ElementType);
        }

        /// <summary>
        /// <para>Scheme Color.</para>
        /// <para>Represents the following element tag in the schema: a:schemeClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.SchemeColor? SchemeColor
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.SchemeColor.ElementType) as DocumentFormat.OpenXml.Drawing.SchemeColor;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.SchemeColor.ElementType);
        }

        /// <summary>
        /// <para>Preset Color.</para>
        /// <para>Represents the following element tag in the schema: a:prstClr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.PresetColor? PresetColor
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.PresetColor.ElementType) as DocumentFormat.OpenXml.Drawing.PresetColor;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.PresetColor.ElementType);
        }
    }

    /// <summary>
    /// <para>Defines the ChartStringValue Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:pt.</para>
    /// </summary>
    public partial class ChartStringValue : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "pt");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_StringValue");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ChartStringValue class.
        /// </summary>
        public ChartStringValue() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartStringValue class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public ChartStringValue(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Index
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<ChartStringValue>()
                .AddAttribute("idx", a => a.Index, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartStringValue>(deep);
    }

    /// <summary>
    /// <para>Defines the Formula Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:f.</para>
    /// </summary>
    public partial class Formula : OpenXmlFormulaElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "f");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Formula");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Formula class.
        /// </summary>
        public Formula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Formula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Formula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Formula>(deep);
    }

    /// <summary>
    /// <para>Defines the NfFormula Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:nf.</para>
    /// </summary>
    public partial class NfFormula : OpenXmlFormulaElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "nf");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Formula");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NfFormula class.
        /// </summary>
        public NfFormula() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NfFormula class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public NfFormula(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NfFormula>(deep);
    }

    /// <summary>
    /// <para>Defines the OpenXmlFormulaElement Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    public abstract partial class OpenXmlFormulaElement : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Formula");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OpenXmlFormulaElement class.
        /// </summary>
        protected OpenXmlFormulaElement() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlFormulaElement class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        protected OpenXmlFormulaElement(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        /// <summary>
        /// <para>dir, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: dir</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormulaDirection>? Dir
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormulaDirection>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddElement<OpenXmlFormulaElement>()
                .AddAttribute("dir", a => a.Dir);
        }
    }

    /// <summary>
    /// <para>Defines the StringLevel Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:lvl.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartStringValue" /> <c>&lt;cx:pt></c></description></item>
    /// </list>
    /// </remarks>
    public partial class StringLevel : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "lvl");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_StringLevel");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the StringLevel class.
        /// </summary>
        public StringLevel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringLevel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringLevel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringLevel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StringLevel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>ptCount, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: ptCount</para>
        /// </summary>
        public UInt32Value? PtCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartStringValue>();
            builder.AddElement<StringLevel>()
                .AddAttribute("ptCount", a => a.PtCount, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("name", a => a.Name);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartStringValue.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StringLevel>(deep);
    }

    /// <summary>
    /// <para>Defines the NumericValue Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:pt.</para>
    /// </summary>
    public partial class NumericValue : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "pt");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_NumericValue");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NumericValue class.
        /// </summary>
        public NumericValue() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericValue class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public NumericValue(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DoubleValue { InnerText = text };
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Idx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<NumericValue>()
                .AddAttribute("idx", a => a.Idx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumericValue>(deep);
    }

    /// <summary>
    /// <para>Defines the NumericLevel Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:lvl.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericValue" /> <c>&lt;cx:pt></c></description></item>
    /// </list>
    /// </remarks>
    public partial class NumericLevel : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "lvl");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_NumericLevel");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NumericLevel class.
        /// </summary>
        public NumericLevel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumericLevel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericLevel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumericLevel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericLevel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NumericLevel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>ptCount, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: ptCount</para>
        /// </summary>
        public UInt32Value? PtCount
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>formatCode, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: formatCode</para>
        /// </summary>
        public StringValue? FormatCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>name, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: name</para>
        /// </summary>
        public StringValue? Name
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericValue>();
            builder.AddElement<NumericLevel>()
                .AddAttribute("ptCount", a => a.PtCount, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("formatCode", a => a.FormatCode)
                .AddAttribute("name", a => a.Name);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericValue.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumericLevel>(deep);
    }

    /// <summary>
    /// <para>Defines the NumericDimension Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:numDim.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula" /> <c>&lt;cx:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula" /> <c>&lt;cx:nf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericLevel" /> <c>&lt;cx:lvl></c></description></item>
    /// </list>
    /// </remarks>
    public partial class NumericDimension : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "numDim");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_NumericDimension");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NumericDimension class.
        /// </summary>
        public NumericDimension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericDimension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumericDimension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericDimension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public NumericDimension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the NumericDimension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public NumericDimension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericDimensionType>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericDimensionType>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericLevel>();
            builder.AddElement<NumericDimension>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericLevel.ElementType, 0, 0, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericLevel.ElementType, 1, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumericDimension>(deep);
    }

    /// <summary>
    /// <para>Defines the StringDimension Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:strDim.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula" /> <c>&lt;cx:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula" /> <c>&lt;cx:nf></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringLevel" /> <c>&lt;cx:lvl></c></description></item>
    /// </list>
    /// </remarks>
    public partial class StringDimension : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "strDim");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_StringDimension");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the StringDimension class.
        /// </summary>
        public StringDimension() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringDimension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringDimension(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringDimension class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public StringDimension(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the StringDimension class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public StringDimension(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringDimensionType>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringDimensionType>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringLevel>();
            builder.AddElement<StringDimension>()
                .AddAttribute("type", a => a.Type, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NfFormula.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringLevel.ElementType, 0, 0, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringLevel.ElementType, 1, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<StringDimension>(deep);
    }

    /// <summary>
    /// <para>Defines the ExtensionList Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:extLst.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Extension2" /> <c>&lt;cx:ext></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ExtensionList : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "extLst");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ExtensionList");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ExtensionList class.
        /// </summary>
        public ExtensionList() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ExtensionList(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ExtensionList class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ExtensionList(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Extension2>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Extension2.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExtensionList>(deep);
    }

    /// <summary>
    /// <para>Defines the ExternalData Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:externalData.</para>
    /// </summary>
    public partial class ExternalData : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "externalData");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ExternalData");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ExternalData class.
        /// </summary>
        public ExternalData() : base()
        {
        }

        /// <summary>
        /// <para>RelId of the relationship for the external data, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: r:id</para>
        /// </summary>
        /// <remarks>
        /// xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
        /// </remarks>
        public StringValue? Id
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>True if the external link should automatically update, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: cx:autoUpdate</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx=http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public BooleanValue? AutoUpdate
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<ExternalData>()
                .AddAttribute("r:id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("cx:autoUpdate", a => a.AutoUpdate, aBuilder =>
                {
                    aBuilder.AddValidator(new OfficeVersionValidator(FileFormatVersions.Office2016));
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExternalData>(deep);
    }

    /// <summary>
    /// <para>Defines the Data Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:data.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericDimension" /> <c>&lt;cx:numDim></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringDimension" /> <c>&lt;cx:strDim></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Data : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "data");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Data");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Data class.
        /// </summary>
        public Data() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Data class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Data(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Data class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Data(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Data class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Data(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericDimension>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringDimension>();
            builder.AddElement<Data>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumericDimension.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.StringDimension.ElementType, 1, 1, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Data>(deep);
    }

    /// <summary>
    /// <para>Defines the VXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:v.</para>
    /// </summary>
    public partial class VXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "v");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the VXsdstring class.
        /// </summary>
        public VXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the VXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public VXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<VXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the CopyrightXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:copyright.</para>
    /// </summary>
    public partial class CopyrightXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "copyright");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the CopyrightXsdstring class.
        /// </summary>
        public CopyrightXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the CopyrightXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public CopyrightXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CopyrightXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the SeparatorXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:separator.</para>
    /// </summary>
    public partial class SeparatorXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "separator");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the SeparatorXsdstring class.
        /// </summary>
        public SeparatorXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SeparatorXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public SeparatorXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SeparatorXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the OddHeaderXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:oddHeader.</para>
    /// </summary>
    public partial class OddHeaderXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "oddHeader");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OddHeaderXsdstring class.
        /// </summary>
        public OddHeaderXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OddHeaderXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public OddHeaderXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OddHeaderXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the OddFooterXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:oddFooter.</para>
    /// </summary>
    public partial class OddFooterXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "oddFooter");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OddFooterXsdstring class.
        /// </summary>
        public OddFooterXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OddFooterXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public OddFooterXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<OddFooterXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the EvenHeaderXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:evenHeader.</para>
    /// </summary>
    public partial class EvenHeaderXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "evenHeader");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the EvenHeaderXsdstring class.
        /// </summary>
        public EvenHeaderXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EvenHeaderXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public EvenHeaderXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EvenHeaderXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the EvenFooterXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:evenFooter.</para>
    /// </summary>
    public partial class EvenFooterXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "evenFooter");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the EvenFooterXsdstring class.
        /// </summary>
        public EvenFooterXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EvenFooterXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public EvenFooterXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EvenFooterXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the FirstHeaderXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:firstHeader.</para>
    /// </summary>
    public partial class FirstHeaderXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "firstHeader");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the FirstHeaderXsdstring class.
        /// </summary>
        public FirstHeaderXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FirstHeaderXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public FirstHeaderXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FirstHeaderXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the FirstFooterXsdstring Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:firstFooter.</para>
    /// </summary>
    public partial class FirstFooterXsdstring : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "firstFooter");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "string");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the FirstFooterXsdstring class.
        /// </summary>
        public FirstFooterXsdstring() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FirstFooterXsdstring class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public FirstFooterXsdstring(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new StringValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FirstFooterXsdstring>(deep);
    }

    /// <summary>
    /// <para>Defines the TextData Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:txData.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula" /> <c>&lt;cx:f></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.VXsdstring" /> <c>&lt;cx:v></c></description></item>
    /// </list>
    /// </remarks>
    public partial class TextData : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "txData");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_TextData");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TextData class.
        /// </summary>
        public TextData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TextData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TextData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.VXsdstring>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Formula.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.VXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.VXsdstring.ElementType, 1, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TextData>(deep);
    }

    /// <summary>
    /// <para>Defines the RichTextBody Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:rich.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BodyProperties" /> <c>&lt;a:bodyPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ListStyle" /> <c>&lt;a:lstStyle></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Paragraph" /> <c>&lt;a:p></c></description></item>
    /// </list>
    /// </remarks>
    public partial class RichTextBody : TextBodyType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "rich");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_TextBody");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the RichTextBody class.
        /// </summary>
        public RichTextBody() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the RichTextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RichTextBody(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RichTextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public RichTextBody(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the RichTextBody class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public RichTextBody(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Drawing.BodyProperties.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.ListStyle.ElementType, 0, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Paragraph.ElementType, 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RichTextBody>(deep);
    }

    /// <summary>
    /// <para>Defines the TxPrTextBody Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:txPr.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BodyProperties" /> <c>&lt;a:bodyPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ListStyle" /> <c>&lt;a:lstStyle></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Paragraph" /> <c>&lt;a:p></c></description></item>
    /// </list>
    /// </remarks>
    public partial class TxPrTextBody : TextBodyType
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "txPr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_TextBody");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TxPrTextBody class.
        /// </summary>
        public TxPrTextBody() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TxPrTextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TxPrTextBody(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TxPrTextBody class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TxPrTextBody(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TxPrTextBody class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TxPrTextBody(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Drawing.BodyProperties.ElementType, 1, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.ListStyle.ElementType, 0, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Paragraph.ElementType, 1, 0)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TxPrTextBody>(deep);
    }

    /// <summary>
    /// <para>Defines the TextBodyType Class.</para>
    /// <para>This class is available in Office 2007 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BodyProperties" /> <c>&lt;a:bodyPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ListStyle" /> <c>&lt;a:lstStyle></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Paragraph" /> <c>&lt;a:p></c></description></item>
    /// </list>
    /// </remarks>
    public abstract partial class TextBodyType : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_TextBody");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TextBodyType class.
        /// </summary>
        protected TextBodyType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBodyType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected TextBodyType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBodyType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected TextBodyType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TextBodyType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected TextBodyType(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BodyProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ListStyle>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Paragraph>();
        }

        /// <summary>
        /// <para>Body Properties.</para>
        /// <para>Represents the following element tag in the schema: a:bodyPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.BodyProperties? BodyProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.BodyProperties.ElementType) as DocumentFormat.OpenXml.Drawing.BodyProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.BodyProperties.ElementType);
        }

        /// <summary>
        /// <para>Text List Styles.</para>
        /// <para>Represents the following element tag in the schema: a:lstStyle.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.ListStyle? ListStyle
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.ListStyle.ElementType) as DocumentFormat.OpenXml.Drawing.ListStyle;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.ListStyle.ElementType);
        }
    }

    /// <summary>
    /// <para>Defines the Text Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:tx.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody" /> <c>&lt;cx:rich></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData" /> <c>&lt;cx:txData></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Text : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "tx");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Text");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Text class.
        /// </summary>
        public Text() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Text class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Text(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Text class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Text(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Text class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Text(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody.ElementType, 1, 1, version: FileFormatVersions.Office2016)
                }
            };
        }

        /// <summary>
        /// <para>TextData.</para>
        /// <para>Represents the following element tag in the schema: cx:txData.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData? TextData
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TextData.ElementType);
        }

        /// <summary>
        /// <para>RichTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:rich.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody? RichTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RichTextBody.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Text>(deep);
    }

    /// <summary>
    /// <para>Defines the ShapeProperties Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:spPr.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.BlipFill" /> <c>&lt;a:blipFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.CustomGeometry" /> <c>&lt;a:custGeom></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectDag" /> <c>&lt;a:effectDag></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.EffectList" /> <c>&lt;a:effectLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GradientFill" /> <c>&lt;a:gradFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.GroupFill" /> <c>&lt;a:grpFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Outline" /> <c>&lt;a:ln></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.NoFill" /> <c>&lt;a:noFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PatternFill" /> <c>&lt;a:pattFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.PresetGeometry" /> <c>&lt;a:prstGeom></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Scene3DType" /> <c>&lt;a:scene3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Shape3DType" /> <c>&lt;a:sp3d></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList" /> <c>&lt;a:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.SolidFill" /> <c>&lt;a:solidFill></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.Transform2D" /> <c>&lt;a:xfrm></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ShapeProperties : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "spPr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_ShapeProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class.
        /// </summary>
        public ShapeProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ShapeProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ShapeProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ShapeProperties(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Black and White Mode</para>
        /// <para>Represents the following attribute in the schema: bwMode</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>? BlackWhiteMode
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Drawing.BlipFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.CustomGeometry>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectDag>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.EffectList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GradientFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.GroupFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Outline>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.NoFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PatternFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.PresetGeometry>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Scene3DType>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Shape3DType>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.SolidFill>();
            builder.AddChild<DocumentFormat.OpenXml.Drawing.Transform2D>();
            builder.AddElement<ShapeProperties>()
                .AddAttribute("bwMode", a => a.BlackWhiteMode, aBuilder =>
                {
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Transform2D.ElementType, 0, 1),
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.CustomGeometry.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.PresetGeometry.ElementType, 1, 1)
                    }
                },
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.NoFill.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.SolidFill.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.GradientFill.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.BlipFill.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.PatternFill.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.GroupFill.ElementType, 1, 1)
                    }
                },
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Outline.ElementType, 0, 1),
                new CompositeParticle.Builder(ParticleType.Group, 0, 1)
                {
                    new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                    {
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.EffectList.ElementType, 1, 1),
                        new ElementParticle(DocumentFormat.OpenXml.Drawing.EffectDag.ElementType, 1, 1)
                    }
                },
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Scene3DType.ElementType, 0, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.Shape3DType.ElementType, 0, 1),
                new ElementParticle(DocumentFormat.OpenXml.Drawing.ShapePropertiesExtensionList.ElementType, 0, 1)
            };
        }

        /// <summary>
        /// <para>2D Transform for Individual Objects.</para>
        /// <para>Represents the following element tag in the schema: a:xfrm.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.Transform2D? Transform2D
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.Transform2D.ElementType) as DocumentFormat.OpenXml.Drawing.Transform2D;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.Transform2D.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ShapeProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the AxisUnitsLabel Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:unitsLabel.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text" /> <c>&lt;cx:tx></c></description></item>
    /// </list>
    /// </remarks>
    public partial class AxisUnitsLabel : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "unitsLabel");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_AxisUnitsLabel");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the AxisUnitsLabel class.
        /// </summary>
        public AxisUnitsLabel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnitsLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisUnitsLabel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnitsLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisUnitsLabel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnitsLabel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AxisUnitsLabel(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: cx:tx.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text? Text
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AxisUnitsLabel>(deep);
    }

    /// <summary>
    /// <para>Defines the CategoryAxisScaling Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:catScaling.</para>
    /// </summary>
    public partial class CategoryAxisScaling : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "catScaling");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_CategoryAxisScaling");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the CategoryAxisScaling class.
        /// </summary>
        public CategoryAxisScaling() : base()
        {
        }

        /// <summary>
        /// <para>gapWidth, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: gapWidth</para>
        /// </summary>
        public StringValue? GapWidth
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<CategoryAxisScaling>()
                .AddAttribute("gapWidth", a => a.GapWidth, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(new NumberValidator() { MinInclusive = (0L) });
                        union.AddValidator(StringValidator.Instance);
                    });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<CategoryAxisScaling>(deep);
    }

    /// <summary>
    /// <para>Defines the ValueAxisScaling Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:valScaling.</para>
    /// </summary>
    public partial class ValueAxisScaling : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "valScaling");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueAxisScaling");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ValueAxisScaling class.
        /// </summary>
        public ValueAxisScaling() : base()
        {
        }

        /// <summary>
        /// <para>max, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: max</para>
        /// </summary>
        public StringValue? Max
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>min, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: min</para>
        /// </summary>
        public StringValue? Min
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>majorUnit, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: majorUnit</para>
        /// </summary>
        public StringValue? MajorUnit
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>minorUnit, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: minorUnit</para>
        /// </summary>
        public StringValue? MinorUnit
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<ValueAxisScaling>()
                .AddAttribute("max", a => a.Max, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(NumberValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("min", a => a.Min, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(NumberValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("majorUnit", a => a.MajorUnit, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(new NumberValidator() { MinExclusive = (0L) });
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("minorUnit", a => a.MinorUnit, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(new NumberValidator() { MinExclusive = (0L) });
                        union.AddValidator(StringValidator.Instance);
                    });
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ValueAxisScaling>(deep);
    }

    /// <summary>
    /// <para>Defines the AxisTitle Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:title.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text" /> <c>&lt;cx:tx></c></description></item>
    /// </list>
    /// </remarks>
    public partial class AxisTitle : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "title");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_AxisTitle");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the AxisTitle class.
        /// </summary>
        public AxisTitle() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisTitle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisTitle(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisTitle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisTitle(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisTitle class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AxisTitle(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: cx:tx.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text? Text
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AxisTitle>(deep);
    }

    /// <summary>
    /// <para>Defines the AxisUnits Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:units.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel" /> <c>&lt;cx:unitsLabel></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class AxisUnits : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "units");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_AxisUnits");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the AxisUnits class.
        /// </summary>
        public AxisUnits() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnits class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisUnits(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnits class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public AxisUnits(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisUnits class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public AxisUnits(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>unit, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: unit</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnit>? Unit
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnit>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddElement<AxisUnits>()
                .AddAttribute("unit", a => a.Unit);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>AxisUnitsLabel.</para>
        /// <para>Represents the following element tag in the schema: cx:unitsLabel.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel? AxisUnitsLabel
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnitsLabel.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AxisUnits>(deep);
    }

    /// <summary>
    /// <para>Defines the MajorGridlinesGridlines Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:majorGridlines.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MajorGridlinesGridlines : OpenXmlGridlinesElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "majorGridlines");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Gridlines");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MajorGridlinesGridlines class.
        /// </summary>
        public MajorGridlinesGridlines() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorGridlinesGridlines class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MajorGridlinesGridlines(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorGridlinesGridlines class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MajorGridlinesGridlines(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorGridlinesGridlines class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MajorGridlinesGridlines(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MajorGridlinesGridlines>(deep);
    }

    /// <summary>
    /// <para>Defines the MinorGridlinesGridlines Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:minorGridlines.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MinorGridlinesGridlines : OpenXmlGridlinesElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "minorGridlines");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Gridlines");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MinorGridlinesGridlines class.
        /// </summary>
        public MinorGridlinesGridlines() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorGridlinesGridlines class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinorGridlinesGridlines(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorGridlinesGridlines class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinorGridlinesGridlines(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorGridlinesGridlines class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MinorGridlinesGridlines(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MinorGridlinesGridlines>(deep);
    }

    /// <summary>
    /// <para>Defines the OpenXmlGridlinesElement Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public abstract partial class OpenXmlGridlinesElement : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Gridlines");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OpenXmlGridlinesElement class.
        /// </summary>
        protected OpenXmlGridlinesElement() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlGridlinesElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlGridlinesElement(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlGridlinesElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlGridlinesElement(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlGridlinesElement class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected OpenXmlGridlinesElement(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }
    }

    /// <summary>
    /// <para>Defines the MajorTickMarksTickMarks Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:majorTickMarks.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MajorTickMarksTickMarks : OpenXmlTickMarksElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "majorTickMarks");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_TickMarks");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MajorTickMarksTickMarks class.
        /// </summary>
        public MajorTickMarksTickMarks() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorTickMarksTickMarks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MajorTickMarksTickMarks(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorTickMarksTickMarks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MajorTickMarksTickMarks(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MajorTickMarksTickMarks class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MajorTickMarksTickMarks(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MajorTickMarksTickMarks>(deep);
    }

    /// <summary>
    /// <para>Defines the MinorTickMarksTickMarks Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:minorTickMarks.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MinorTickMarksTickMarks : OpenXmlTickMarksElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "minorTickMarks");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_TickMarks");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MinorTickMarksTickMarks class.
        /// </summary>
        public MinorTickMarksTickMarks() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorTickMarksTickMarks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinorTickMarksTickMarks(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorTickMarksTickMarks class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinorTickMarksTickMarks(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinorTickMarksTickMarks class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MinorTickMarksTickMarks(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MinorTickMarksTickMarks>(deep);
    }

    /// <summary>
    /// <para>Defines the OpenXmlTickMarksElement Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public abstract partial class OpenXmlTickMarksElement : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_TickMarks");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OpenXmlTickMarksElement class.
        /// </summary>
        protected OpenXmlTickMarksElement() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlTickMarksElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlTickMarksElement(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlTickMarksElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlTickMarksElement(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlTickMarksElement class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected OpenXmlTickMarksElement(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>type, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: type</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TickMarksType>? Type
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TickMarksType>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddElement<OpenXmlTickMarksElement>()
                .AddAttribute("type", a => a.Type);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }
    }

    /// <summary>
    /// <para>Defines the TickLabels Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:tickLabels.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class TickLabels : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "tickLabels");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_TickLabels");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the TickLabels class.
        /// </summary>
        public TickLabels() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the TickLabels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TickLabels(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TickLabels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public TickLabels(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the TickLabels class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public TickLabels(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<TickLabels>(deep);
    }

    /// <summary>
    /// <para>Defines the NumberFormat Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:numFmt.</para>
    /// </summary>
    public partial class NumberFormat : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "numFmt");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_NumberFormat");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NumberFormat class.
        /// </summary>
        public NumberFormat() : base()
        {
        }

        /// <summary>
        /// <para>formatCode, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: formatCode</para>
        /// </summary>
        public StringValue? FormatCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>sourceLinked, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: sourceLinked</para>
        /// </summary>
        public BooleanValue? SourceLinked
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<NumberFormat>()
                .AddAttribute("formatCode", a => a.FormatCode, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("sourceLinked", a => a.SourceLinked);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumberFormat>(deep);
    }

    /// <summary>
    /// <para>Defines the Xsddouble Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:binSize.</para>
    /// </summary>
    public partial class Xsddouble : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "binSize");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "double");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Xsddouble class.
        /// </summary>
        public Xsddouble() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Xsddouble class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Xsddouble(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new DoubleValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<DoubleValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Xsddouble>(deep);
    }

    /// <summary>
    /// <para>Defines the Address Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:address.</para>
    /// </summary>
    public partial class Address : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "address");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Address");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Address class.
        /// </summary>
        public Address() : base()
        {
        }

        /// <summary>
        /// <para>address1, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: address1</para>
        /// </summary>
        public StringValue? Address1
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>countryRegion, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: countryRegion</para>
        /// </summary>
        public StringValue? CountryRegion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>adminDistrict1, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: adminDistrict1</para>
        /// </summary>
        public StringValue? AdminDistrict1
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>adminDistrict2, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: adminDistrict2</para>
        /// </summary>
        public StringValue? AdminDistrict2
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>postalCode, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: postalCode</para>
        /// </summary>
        public StringValue? PostalCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>locality, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: locality</para>
        /// </summary>
        public StringValue? Locality
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>isoCountryCode, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: isoCountryCode</para>
        /// </summary>
        public StringValue? IsoCountryCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<Address>()
                .AddAttribute("address1", a => a.Address1)
                .AddAttribute("countryRegion", a => a.CountryRegion)
                .AddAttribute("adminDistrict1", a => a.AdminDistrict1)
                .AddAttribute("adminDistrict2", a => a.AdminDistrict2)
                .AddAttribute("postalCode", a => a.PostalCode)
                .AddAttribute("locality", a => a.Locality)
                .AddAttribute("isoCountryCode", a => a.IsoCountryCode);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Address>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoLocation Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoLocation.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address" /> <c>&lt;cx:address></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoLocation : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoLocation");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoLocation");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoLocation class.
        /// </summary>
        public GeoLocation() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocation(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocation class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocation(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocation class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoLocation(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>latitude, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: latitude</para>
        /// </summary>
        public DoubleValue? Latitude
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>longitude, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: longitude</para>
        /// </summary>
        public DoubleValue? Longitude
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityName</para>
        /// </summary>
        public StringValue? EntityName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address>();
            builder.AddElement<GeoLocation>()
                .AddAttribute("latitude", a => a.Latitude)
                .AddAttribute("longitude", a => a.Longitude)
                .AddAttribute("entityName", a => a.EntityName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Address.</para>
        /// <para>Represents the following element tag in the schema: cx:address.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address? Address
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Address.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoLocation>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoLocationQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoLocationQuery.</para>
    /// </summary>
    public partial class GeoLocationQuery : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoLocationQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoLocationQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoLocationQuery class.
        /// </summary>
        public GeoLocationQuery() : base()
        {
        }

        /// <summary>
        /// <para>countryRegion, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: countryRegion</para>
        /// </summary>
        public StringValue? CountryRegion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>adminDistrict1, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: adminDistrict1</para>
        /// </summary>
        public StringValue? AdminDistrict1
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>adminDistrict2, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: adminDistrict2</para>
        /// </summary>
        public StringValue? AdminDistrict2
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>postalCode, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: postalCode</para>
        /// </summary>
        public StringValue? PostalCode
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoLocationQuery>()
                .AddAttribute("countryRegion", a => a.CountryRegion)
                .AddAttribute("adminDistrict1", a => a.AdminDistrict1)
                .AddAttribute("adminDistrict2", a => a.AdminDistrict2)
                .AddAttribute("postalCode", a => a.PostalCode)
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoLocationQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoLocations Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoLocations.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation" /> <c>&lt;cx:geoLocation></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoLocations : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoLocations");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoLocations");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoLocations class.
        /// </summary>
        public GeoLocations() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocations class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocations(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocations class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocations(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocations class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoLocations(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoLocation.</para>
        /// <para>Represents the following element tag in the schema: cx:geoLocation.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation? GeoLocation
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocation.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoLocations>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoLocationQueryResult Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoLocationQueryResult.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery" /> <c>&lt;cx:geoLocationQuery></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations" /> <c>&lt;cx:geoLocations></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoLocationQueryResult : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoLocationQueryResult");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoLocationQueryResult");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResult class.
        /// </summary>
        public GeoLocationQueryResult() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocationQueryResult(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocationQueryResult(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResult class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoLocationQueryResult(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoLocationQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoLocationQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery? GeoLocationQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQuery.ElementType);
        }

        /// <summary>
        /// <para>GeoLocations.</para>
        /// <para>Represents the following element tag in the schema: cx:geoLocations.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations? GeoLocations
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocations.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoLocationQueryResult>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoPolygon Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoPolygon.</para>
    /// </summary>
    public partial class GeoPolygon : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoPolygon");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoPolygon");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoPolygon class.
        /// </summary>
        public GeoPolygon() : base()
        {
        }

        /// <summary>
        /// <para>polygonId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: polygonId</para>
        /// </summary>
        public StringValue? PolygonId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>numPoints, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: numPoints</para>
        /// </summary>
        public IntegerValue? NumPoints
        {
            get => GetAttribute<IntegerValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pcaRings, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: pcaRings</para>
        /// </summary>
        public StringValue? PcaRings
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoPolygon>()
                .AddAttribute("polygonId", a => a.PolygonId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("numPoints", a => a.NumPoints, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("pcaRings", a => a.PcaRings, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoPolygon>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoPolygons Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoPolygons.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygon" /> <c>&lt;cx:geoPolygon></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoPolygons : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoPolygons");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoPolygons");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoPolygons class.
        /// </summary>
        public GeoPolygons() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoPolygons class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoPolygons(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoPolygons class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoPolygons(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoPolygons class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoPolygons(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygon>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygon.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoPolygons>(deep);
    }

    /// <summary>
    /// <para>Defines the Copyrights Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:copyrights.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CopyrightXsdstring" /> <c>&lt;cx:copyright></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Copyrights : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "copyrights");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Copyrights");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Copyrights class.
        /// </summary>
        public Copyrights() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Copyrights class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Copyrights(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Copyrights class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Copyrights(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Copyrights class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Copyrights(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CopyrightXsdstring>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CopyrightXsdstring.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Copyrights>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataEntityQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataEntityQuery.</para>
    /// </summary>
    public partial class GeoDataEntityQuery : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataEntityQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataEntityQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQuery class.
        /// </summary>
        public GeoDataEntityQuery() : base()
        {
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoDataEntityQuery>()
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataEntityQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoData Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoData.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights" /> <c>&lt;cx:copyrights></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons" /> <c>&lt;cx:geoPolygons></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoData : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoData");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoData");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoData class.
        /// </summary>
        public GeoData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoData(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>entityName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityName</para>
        /// </summary>
        public StringValue? EntityName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>east, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: east</para>
        /// </summary>
        public DoubleValue? East
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>west, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: west</para>
        /// </summary>
        public DoubleValue? West
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>north, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: north</para>
        /// </summary>
        public DoubleValue? North
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>south, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: south</para>
        /// </summary>
        public DoubleValue? South
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons>();
            builder.AddElement<GeoData>()
                .AddAttribute("entityName", a => a.EntityName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("east", a => a.East, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("west", a => a.West, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("north", a => a.North, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("south", a => a.South, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoPolygons.</para>
        /// <para>Represents the following element tag in the schema: cx:geoPolygons.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons? GeoPolygons
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoPolygons.ElementType);
        }

        /// <summary>
        /// <para>Copyrights.</para>
        /// <para>Represents the following element tag in the schema: cx:copyrights.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights? Copyrights
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Copyrights.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoData>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataEntityQueryResult Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataEntityQueryResult.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData" /> <c>&lt;cx:geoData></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery" /> <c>&lt;cx:geoDataEntityQuery></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoDataEntityQueryResult : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataEntityQueryResult");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataEntityQueryResult");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResult class.
        /// </summary>
        public GeoDataEntityQueryResult() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataEntityQueryResult(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataEntityQueryResult(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResult class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoDataEntityQueryResult(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoDataEntityQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoDataEntityQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery? GeoDataEntityQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQuery.ElementType);
        }

        /// <summary>
        /// <para>GeoData.</para>
        /// <para>Represents the following element tag in the schema: cx:geoData.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData? GeoData
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoData.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataEntityQueryResult>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataPointQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataPointQuery.</para>
    /// </summary>
    public partial class GeoDataPointQuery : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataPointQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataPointQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataPointQuery class.
        /// </summary>
        public GeoDataPointQuery() : base()
        {
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>latitude, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: latitude</para>
        /// </summary>
        public DoubleValue? Latitude
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>longitude, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: longitude</para>
        /// </summary>
        public DoubleValue? Longitude
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoDataPointQuery>()
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("latitude", a => a.Latitude, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("longitude", a => a.Longitude, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataPointQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataPointToEntityQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataPointToEntityQuery.</para>
    /// </summary>
    public partial class GeoDataPointToEntityQuery : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataPointToEntityQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataPointToEntityQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQuery class.
        /// </summary>
        public GeoDataPointToEntityQuery() : base()
        {
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoDataPointToEntityQuery>()
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataPointToEntityQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataPointToEntityQueryResult Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataPointToEntityQueryResult.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery" /> <c>&lt;cx:geoDataPointQuery></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery" /> <c>&lt;cx:geoDataPointToEntityQuery></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoDataPointToEntityQueryResult : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataPointToEntityQueryResult");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataPointToEntityQueryResult");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResult class.
        /// </summary>
        public GeoDataPointToEntityQueryResult() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataPointToEntityQueryResult(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataPointToEntityQueryResult(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResult class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoDataPointToEntityQueryResult(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoDataPointQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoDataPointQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery? GeoDataPointQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointQuery.ElementType);
        }

        /// <summary>
        /// <para>GeoDataPointToEntityQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoDataPointToEntityQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery? GeoDataPointToEntityQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQuery.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataPointToEntityQueryResult>(deep);
    }

    /// <summary>
    /// <para>Defines the EntityType Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:entityType.</para>
    /// </summary>
    public partial class EntityType : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "entityType");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "ST_EntityType");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the EntityType class.
        /// </summary>
        public EntityType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the EntityType class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public EntityType(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum> { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>(EnumValidator.Instance);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<EntityType>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoChildTypes Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoChildTypes.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityType" /> <c>&lt;cx:entityType></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoChildTypes : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoChildTypes");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoChildTypes");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoChildTypes class.
        /// </summary>
        public GeoChildTypes() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildTypes(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildTypes class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildTypes(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildTypes class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoChildTypes(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityType>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityType.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoChildTypes>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoHierarchyEntity Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoHierarchyEntity.</para>
    /// </summary>
    public partial class GeoHierarchyEntity : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoHierarchyEntity");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoHierarchyEntity");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoHierarchyEntity class.
        /// </summary>
        public GeoHierarchyEntity() : base()
        {
        }

        /// <summary>
        /// <para>entityName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityName</para>
        /// </summary>
        public StringValue? EntityName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoHierarchyEntity>()
                .AddAttribute("entityName", a => a.EntityName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoHierarchyEntity>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoChildEntitiesQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoChildEntitiesQuery.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes" /> <c>&lt;cx:geoChildTypes></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoChildEntitiesQuery : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoChildEntitiesQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoChildEntitiesQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQuery class.
        /// </summary>
        public GeoChildEntitiesQuery() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQuery class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQuery(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQuery class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQuery(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQuery class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoChildEntitiesQuery(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes>();
            builder.AddElement<GeoChildEntitiesQuery>()
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoChildTypes.</para>
        /// <para>Represents the following element tag in the schema: cx:geoChildTypes.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes? GeoChildTypes
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildTypes.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoChildEntitiesQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoChildEntities Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoChildEntities.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoHierarchyEntity" /> <c>&lt;cx:geoHierarchyEntity></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoChildEntities : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoChildEntities");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoChildEntities");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoChildEntities class.
        /// </summary>
        public GeoChildEntities() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntities class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntities(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntities class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntities(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntities class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoChildEntities(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoHierarchyEntity>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoHierarchyEntity.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoChildEntities>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoChildEntitiesQueryResult Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoChildEntitiesQueryResult.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities" /> <c>&lt;cx:geoChildEntities></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery" /> <c>&lt;cx:geoChildEntitiesQuery></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoChildEntitiesQueryResult : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoChildEntitiesQueryResult");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoChildEntitiesQueryResult");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResult class.
        /// </summary>
        public GeoChildEntitiesQueryResult() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQueryResult(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQueryResult(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResult class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoChildEntitiesQueryResult(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoChildEntitiesQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoChildEntitiesQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery? GeoChildEntitiesQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQuery.ElementType);
        }

        /// <summary>
        /// <para>GeoChildEntities.</para>
        /// <para>Represents the following element tag in the schema: cx:geoChildEntities.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities? GeoChildEntities
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntities.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoChildEntitiesQueryResult>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoParentEntitiesQuery Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoParentEntitiesQuery.</para>
    /// </summary>
    public partial class GeoParentEntitiesQuery : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoParentEntitiesQuery");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoParentEntitiesQuery");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQuery class.
        /// </summary>
        public GeoParentEntitiesQuery() : base()
        {
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoParentEntitiesQuery>()
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoParentEntitiesQuery>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoEntity Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoEntity.</para>
    /// </summary>
    public partial class GeoEntity : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoEntity");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoEntity");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoEntity class.
        /// </summary>
        public GeoEntity() : base()
        {
        }

        /// <summary>
        /// <para>entityName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityName</para>
        /// </summary>
        public StringValue? EntityName
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>entityType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>? EntityType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EntityTypeEnum>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoEntity>()
                .AddAttribute("entityName", a => a.EntityName, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("entityType", a => a.EntityType, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoEntity>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoParentEntity Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoParentEntity.</para>
    /// </summary>
    public partial class GeoParentEntity : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoParentEntity");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoParentEntity");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoParentEntity class.
        /// </summary>
        public GeoParentEntity() : base()
        {
        }

        /// <summary>
        /// <para>entityId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: entityId</para>
        /// </summary>
        public StringValue? EntityId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<GeoParentEntity>()
                .AddAttribute("entityId", a => a.EntityId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoParentEntity>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoParentEntitiesQueryResult Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoParentEntitiesQueryResult.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity" /> <c>&lt;cx:geoEntity></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery" /> <c>&lt;cx:geoParentEntitiesQuery></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity" /> <c>&lt;cx:geoParentEntity></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoParentEntitiesQueryResult : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoParentEntitiesQueryResult");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoParentEntitiesQueryResult");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResult class.
        /// </summary>
        public GeoParentEntitiesQueryResult() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoParentEntitiesQueryResult(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResult class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoParentEntitiesQueryResult(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResult class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoParentEntitiesQueryResult(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoParentEntitiesQuery.</para>
        /// <para>Represents the following element tag in the schema: cx:geoParentEntitiesQuery.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery? GeoParentEntitiesQuery
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQuery.ElementType);
        }

        /// <summary>
        /// <para>GeoEntity.</para>
        /// <para>Represents the following element tag in the schema: cx:geoEntity.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity? GeoEntity
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoEntity.ElementType);
        }

        /// <summary>
        /// <para>GeoParentEntity.</para>
        /// <para>Represents the following element tag in the schema: cx:geoParentEntity.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity? GeoParentEntity
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntity.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoParentEntitiesQueryResult>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoLocationQueryResults Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoLocationQueryResults.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResult" /> <c>&lt;cx:geoLocationQueryResult></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoLocationQueryResults : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoLocationQueryResults");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoLocationQueryResults");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResults class.
        /// </summary>
        public GeoLocationQueryResults() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocationQueryResults(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoLocationQueryResults(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoLocationQueryResults class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoLocationQueryResults(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResult>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResult.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoLocationQueryResults>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataEntityQueryResults Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataEntityQueryResults.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResult" /> <c>&lt;cx:geoDataEntityQueryResult></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoDataEntityQueryResults : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataEntityQueryResults");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataEntityQueryResults");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResults class.
        /// </summary>
        public GeoDataEntityQueryResults() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataEntityQueryResults(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataEntityQueryResults(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataEntityQueryResults class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoDataEntityQueryResults(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResult>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResult.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataEntityQueryResults>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoDataPointToEntityQueryResults Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoDataPointToEntityQueryResults.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResult" /> <c>&lt;cx:geoDataPointToEntityQueryResult></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoDataPointToEntityQueryResults : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoDataPointToEntityQueryResults");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoDataPointToEntityQueryResults");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResults class.
        /// </summary>
        public GeoDataPointToEntityQueryResults() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataPointToEntityQueryResults(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoDataPointToEntityQueryResults(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoDataPointToEntityQueryResults class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoDataPointToEntityQueryResults(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResult>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResult.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoDataPointToEntityQueryResults>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoChildEntitiesQueryResults Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoChildEntitiesQueryResults.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResult" /> <c>&lt;cx:geoChildEntitiesQueryResult></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoChildEntitiesQueryResults : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoChildEntitiesQueryResults");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoChildEntitiesQueryResults");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResults class.
        /// </summary>
        public GeoChildEntitiesQueryResults() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQueryResults(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoChildEntitiesQueryResults(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoChildEntitiesQueryResults class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoChildEntitiesQueryResults(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResult>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResult.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoChildEntitiesQueryResults>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoParentEntitiesQueryResults Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoParentEntitiesQueryResults.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResult" /> <c>&lt;cx:geoParentEntitiesQueryResult></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoParentEntitiesQueryResults : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoParentEntitiesQueryResults");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoParentEntitiesQueryResults");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResults class.
        /// </summary>
        public GeoParentEntitiesQueryResults() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoParentEntitiesQueryResults(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResults class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoParentEntitiesQueryResults(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoParentEntitiesQueryResults class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoParentEntitiesQueryResults(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResult>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResult.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoParentEntitiesQueryResults>(deep);
    }

    /// <summary>
    /// <para>Defines the Xsdbase64Binary Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:binary.</para>
    /// </summary>
    public partial class Xsdbase64Binary : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "binary");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://www.w3.org/2001/XMLSchema", "base64Binary");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Xsdbase64Binary class.
        /// </summary>
        public Xsdbase64Binary() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Xsdbase64Binary class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public Xsdbase64Binary(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new Base64BinaryValue { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<Base64BinaryValue>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Xsdbase64Binary>(deep);
    }

    /// <summary>
    /// <para>Defines the Clear Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:clear.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults" /> <c>&lt;cx:geoChildEntitiesQueryResults></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults" /> <c>&lt;cx:geoDataEntityQueryResults></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults" /> <c>&lt;cx:geoDataPointToEntityQueryResults></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults" /> <c>&lt;cx:geoLocationQueryResults></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults" /> <c>&lt;cx:geoParentEntitiesQueryResults></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Clear : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "clear");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Clear");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Clear class.
        /// </summary>
        public Clear() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Clear class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Clear(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Clear class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Clear(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Clear class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Clear(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoLocationQueryResults.</para>
        /// <para>Represents the following element tag in the schema: cx:geoLocationQueryResults.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults? GeoLocationQueryResults
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoLocationQueryResults.ElementType);
        }

        /// <summary>
        /// <para>GeoDataEntityQueryResults.</para>
        /// <para>Represents the following element tag in the schema: cx:geoDataEntityQueryResults.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults? GeoDataEntityQueryResults
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataEntityQueryResults.ElementType);
        }

        /// <summary>
        /// <para>GeoDataPointToEntityQueryResults.</para>
        /// <para>Represents the following element tag in the schema: cx:geoDataPointToEntityQueryResults.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults? GeoDataPointToEntityQueryResults
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoDataPointToEntityQueryResults.ElementType);
        }

        /// <summary>
        /// <para>GeoChildEntitiesQueryResults.</para>
        /// <para>Represents the following element tag in the schema: cx:geoChildEntitiesQueryResults.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults? GeoChildEntitiesQueryResults
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoChildEntitiesQueryResults.ElementType);
        }

        /// <summary>
        /// <para>GeoParentEntitiesQueryResults.</para>
        /// <para>Represents the following element tag in the schema: cx:geoParentEntitiesQueryResults.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults? GeoParentEntitiesQueryResults
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoParentEntitiesQueryResults.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Clear>(deep);
    }

    /// <summary>
    /// <para>Defines the GeoCache Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geoCache.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Clear" /> <c>&lt;cx:clear></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsdbase64Binary" /> <c>&lt;cx:binary></c></description></item>
    /// </list>
    /// </remarks>
    public partial class GeoCache : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geoCache");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_GeoCache");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the GeoCache class.
        /// </summary>
        public GeoCache() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoCache(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoCache class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public GeoCache(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GeoCache class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public GeoCache(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>provider, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: provider</para>
        /// </summary>
        public StringValue? Provider
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Clear>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsdbase64Binary>();
            builder.AddElement<GeoCache>()
                .AddAttribute("provider", a => a.Provider, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 0)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsdbase64Binary.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Clear.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<GeoCache>(deep);
    }

    /// <summary>
    /// <para>Defines the ParentLabelLayout Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:parentLabelLayout.</para>
    /// </summary>
    public partial class ParentLabelLayout : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "parentLabelLayout");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ParentLabelLayout");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ParentLabelLayout class.
        /// </summary>
        public ParentLabelLayout() : base()
        {
        }

        /// <summary>
        /// <para>val, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayoutVal>? ParentLabelLayoutVal
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayoutVal>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<ParentLabelLayout>()
                .AddAttribute("val", a => a.ParentLabelLayoutVal, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ParentLabelLayout>(deep);
    }

    /// <summary>
    /// <para>Defines the RegionLabelLayout Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:regionLabelLayout.</para>
    /// </summary>
    public partial class RegionLabelLayout : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "regionLabelLayout");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_RegionLabelLayout");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the RegionLabelLayout class.
        /// </summary>
        public RegionLabelLayout() : base()
        {
        }

        /// <summary>
        /// <para>val, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayoutEnum>? Val
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayoutEnum>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<RegionLabelLayout>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<RegionLabelLayout>(deep);
    }

    /// <summary>
    /// <para>Defines the SeriesElementVisibilities Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:visibility.</para>
    /// </summary>
    public partial class SeriesElementVisibilities : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "visibility");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_SeriesElementVisibilities");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the SeriesElementVisibilities class.
        /// </summary>
        public SeriesElementVisibilities() : base()
        {
        }

        /// <summary>
        /// <para>connectorLines, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: connectorLines</para>
        /// </summary>
        public BooleanValue? ConnectorLines
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>meanLine, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: meanLine</para>
        /// </summary>
        public BooleanValue? MeanLine
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>meanMarker, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: meanMarker</para>
        /// </summary>
        public BooleanValue? MeanMarker
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>nonoutliers, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: nonoutliers</para>
        /// </summary>
        public BooleanValue? Nonoutliers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>outliers, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: outliers</para>
        /// </summary>
        public BooleanValue? Outliers
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<SeriesElementVisibilities>()
                .AddAttribute("connectorLines", a => a.ConnectorLines)
                .AddAttribute("meanLine", a => a.MeanLine)
                .AddAttribute("meanMarker", a => a.MeanMarker)
                .AddAttribute("nonoutliers", a => a.Nonoutliers)
                .AddAttribute("outliers", a => a.Outliers);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SeriesElementVisibilities>(deep);
    }

    /// <summary>
    /// <para>Defines the Aggregation Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:aggregation.</para>
    /// </summary>
    public partial class Aggregation : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "aggregation");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Aggregation");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Aggregation class.
        /// </summary>
        public Aggregation() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Aggregation>(deep);
    }

    /// <summary>
    /// <para>Defines the Binning Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:binning.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble" /> <c>&lt;cx:binSize></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt" /> <c>&lt;cx:binCount></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Binning : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "binning");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Binning");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Binning class.
        /// </summary>
        public Binning() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Binning class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Binning(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Binning class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Binning(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Binning class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Binning(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>intervalClosed, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: intervalClosed</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.IntervalClosedSide>? IntervalClosed
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.IntervalClosedSide>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>underflow, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: underflow</para>
        /// </summary>
        public StringValue? Underflow
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>overflow, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: overflow</para>
        /// </summary>
        public StringValue? Overflow
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt>();
            builder.AddElement<Binning>()
                .AddAttribute("intervalClosed", a => a.IntervalClosed)
                .AddAttribute("underflow", a => a.Underflow, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(NumberValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                })
                .AddAttribute("overflow", a => a.Overflow, aBuilder =>
                {
                    aBuilder.AddUnion(union =>
                    {
                        union.AddValidator<DoubleValue>(NumberValidator.Instance);
                        union.AddValidator(StringValidator.Instance);
                    });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 0, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt.ElementType, 1, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Xsddouble.</para>
        /// <para>Represents the following element tag in the schema: cx:binSize.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble? Xsddouble
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Xsddouble.ElementType);
        }

        /// <summary>
        /// <para>BinCountXsdunsignedInt.</para>
        /// <para>Represents the following element tag in the schema: cx:binCount.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt? BinCountXsdunsignedInt
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.BinCountXsdunsignedInt.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Binning>(deep);
    }

    /// <summary>
    /// <para>Defines the Geography Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:geography.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache" /> <c>&lt;cx:geoCache></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Geography : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "geography");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Geography");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Geography class.
        /// </summary>
        public Geography() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Geography class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Geography(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Geography class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Geography(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Geography class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Geography(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>projectionType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: projectionType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoProjectionType>? ProjectionType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoProjectionType>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>viewedRegionType, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: viewedRegionType</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoMappingLevel>? ViewedRegionType
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoMappingLevel>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cultureLanguage, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: cultureLanguage</para>
        /// </summary>
        public StringValue? CultureLanguage
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>cultureRegion, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: cultureRegion</para>
        /// </summary>
        public StringValue? CultureRegion
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>attribution, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: attribution</para>
        /// </summary>
        public StringValue? Attribution
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache>();
            builder.AddElement<Geography>()
                .AddAttribute("projectionType", a => a.ProjectionType)
                .AddAttribute("viewedRegionType", a => a.ViewedRegionType)
                .AddAttribute("cultureLanguage", a => a.CultureLanguage, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("cultureRegion", a => a.CultureRegion, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("attribution", a => a.Attribution, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>GeoCache.</para>
        /// <para>Represents the following element tag in the schema: cx:geoCache.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache? GeoCache
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.GeoCache.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Geography>(deep);
    }

    /// <summary>
    /// <para>Defines the Statistics Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:statistics.</para>
    /// </summary>
    public partial class Statistics : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "statistics");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Statistics");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Statistics class.
        /// </summary>
        public Statistics() : base()
        {
        }

        /// <summary>
        /// <para>quartileMethod, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: quartileMethod</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.QuartileMethod>? QuartileMethod
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.QuartileMethod>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<Statistics>()
                .AddAttribute("quartileMethod", a => a.QuartileMethod);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Statistics>(deep);
    }

    /// <summary>
    /// <para>Defines the Subtotals Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:subtotals.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.UnsignedIntegerType" /> <c>&lt;cx:idx></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Subtotals : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "subtotals");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Subtotals");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Subtotals class.
        /// </summary>
        public Subtotals() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Subtotals class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Subtotals(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Subtotals class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Subtotals(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Subtotals class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Subtotals(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.UnsignedIntegerType>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.UnsignedIntegerType.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Subtotals>(deep);
    }

    /// <summary>
    /// <para>Defines the ExtremeValueColorPosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:extremeValue.</para>
    /// </summary>
    public partial class ExtremeValueColorPosition : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "extremeValue");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ExtremeValueColorPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ExtremeValueColorPosition class.
        /// </summary>
        public ExtremeValueColorPosition() : base()
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ExtremeValueColorPosition>(deep);
    }

    /// <summary>
    /// <para>Defines the NumberColorPosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:number.</para>
    /// </summary>
    public partial class NumberColorPosition : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "number");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_NumberColorPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the NumberColorPosition class.
        /// </summary>
        public NumberColorPosition() : base()
        {
        }

        /// <summary>
        /// <para>val, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<NumberColorPosition>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<NumberColorPosition>(deep);
    }

    /// <summary>
    /// <para>Defines the PercentageColorPosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:percent.</para>
    /// </summary>
    public partial class PercentageColorPosition : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "percent");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PercentageColorPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PercentageColorPosition class.
        /// </summary>
        public PercentageColorPosition() : base()
        {
        }

        /// <summary>
        /// <para>val, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public DoubleValue? Val
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<PercentageColorPosition>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PercentageColorPosition>(deep);
    }

    /// <summary>
    /// <para>Defines the MinValueColorEndPosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:min.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition" /> <c>&lt;cx:extremeValue></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition" /> <c>&lt;cx:number></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition" /> <c>&lt;cx:percent></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MinValueColorEndPosition : OpenXmlValueColorEndPositionElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "min");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColorEndPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MinValueColorEndPosition class.
        /// </summary>
        public MinValueColorEndPosition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinValueColorEndPosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinValueColorEndPosition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinValueColorEndPosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MinValueColorEndPosition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MinValueColorEndPosition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MinValueColorEndPosition(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MinValueColorEndPosition>(deep);
    }

    /// <summary>
    /// <para>Defines the MaxValueColorEndPosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:max.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition" /> <c>&lt;cx:extremeValue></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition" /> <c>&lt;cx:number></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition" /> <c>&lt;cx:percent></c></description></item>
    /// </list>
    /// </remarks>
    public partial class MaxValueColorEndPosition : OpenXmlValueColorEndPositionElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "max");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColorEndPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the MaxValueColorEndPosition class.
        /// </summary>
        public MaxValueColorEndPosition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxValueColorEndPosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MaxValueColorEndPosition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxValueColorEndPosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public MaxValueColorEndPosition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the MaxValueColorEndPosition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public MaxValueColorEndPosition(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<MaxValueColorEndPosition>(deep);
    }

    /// <summary>
    /// <para>Defines the OpenXmlValueColorEndPositionElement Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is :.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition" /> <c>&lt;cx:extremeValue></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition" /> <c>&lt;cx:number></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition" /> <c>&lt;cx:percent></c></description></item>
    /// </list>
    /// </remarks>
    public abstract partial class OpenXmlValueColorEndPositionElement : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new(string.Empty, string.Empty);
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColorEndPosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the OpenXmlValueColorEndPositionElement class.
        /// </summary>
        protected OpenXmlValueColorEndPositionElement() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlValueColorEndPositionElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlValueColorEndPositionElement(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlValueColorEndPositionElement class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        protected OpenXmlValueColorEndPositionElement(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the OpenXmlValueColorEndPositionElement class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        protected OpenXmlValueColorEndPositionElement(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition>();
        }

        /// <summary>
        /// <para>ExtremeValueColorPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:extremeValue.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition? ExtremeValueColorPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtremeValueColorPosition.ElementType);
        }

        /// <summary>
        /// <para>NumberColorPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:number.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition? NumberColorPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType);
        }

        /// <summary>
        /// <para>PercentageColorPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:percent.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition? PercentageColorPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType);
        }
    }

    /// <summary>
    /// <para>Defines the ValueColorMiddlePosition Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:mid.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition" /> <c>&lt;cx:number></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition" /> <c>&lt;cx:percent></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ValueColorMiddlePosition : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "mid");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColorMiddlePosition");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ValueColorMiddlePosition class.
        /// </summary>
        public ValueColorMiddlePosition() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorMiddlePosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColorMiddlePosition(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorMiddlePosition class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColorMiddlePosition(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorMiddlePosition class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ValueColorMiddlePosition(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType, 1, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>NumberColorPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:number.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition? NumberColorPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberColorPosition.ElementType);
        }

        /// <summary>
        /// <para>PercentageColorPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:percent.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition? PercentageColorPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PercentageColorPosition.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ValueColorMiddlePosition>(deep);
    }

    /// <summary>
    /// <para>Defines the DataLabelVisibilities Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:visibility.</para>
    /// </summary>
    public partial class DataLabelVisibilities : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "visibility");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataLabelVisibilities");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataLabelVisibilities class.
        /// </summary>
        public DataLabelVisibilities() : base()
        {
        }

        /// <summary>
        /// <para>seriesName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: seriesName</para>
        /// </summary>
        public BooleanValue? SeriesName
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>categoryName, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: categoryName</para>
        /// </summary>
        public BooleanValue? CategoryName
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>value, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: value</para>
        /// </summary>
        public BooleanValue? Value
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<DataLabelVisibilities>()
                .AddAttribute("seriesName", a => a.SeriesName)
                .AddAttribute("categoryName", a => a.CategoryName)
                .AddAttribute("value", a => a.Value);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataLabelVisibilities>(deep);
    }

    /// <summary>
    /// <para>Defines the DataLabel Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:dataLabel.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities" /> <c>&lt;cx:visibility></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat" /> <c>&lt;cx:numFmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring" /> <c>&lt;cx:separator></c></description></item>
    /// </list>
    /// </remarks>
    public partial class DataLabel : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "dataLabel");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataLabel");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataLabel class.
        /// </summary>
        public DataLabel() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataLabel(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabel class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataLabel(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabel class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataLabel(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Idx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>pos, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: pos</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelPos>? Pos
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelPos>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring>();
            builder.AddElement<DataLabel>()
                .AddAttribute("idx", a => a.Idx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("pos", a => a.Pos);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>NumberFormat.</para>
        /// <para>Represents the following element tag in the schema: cx:numFmt.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat? NumberFormat
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>DataLabelVisibilities.</para>
        /// <para>Represents the following element tag in the schema: cx:visibility.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities? DataLabelVisibilities
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType);
        }

        /// <summary>
        /// <para>SeparatorXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:separator.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring? SeparatorXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataLabel>(deep);
    }

    /// <summary>
    /// <para>Defines the DataLabelHidden Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:dataLabelHidden.</para>
    /// </summary>
    public partial class DataLabelHidden : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "dataLabelHidden");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataLabelHidden");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataLabelHidden class.
        /// </summary>
        public DataLabelHidden() : base()
        {
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Idx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<DataLabelHidden>()
                .AddAttribute("idx", a => a.Idx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataLabelHidden>(deep);
    }

    /// <summary>
    /// <para>Defines the ValueColors Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:valueColors.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties" /> <c>&lt;cx:minColor></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties" /> <c>&lt;cx:midColor></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties" /> <c>&lt;cx:maxColor></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ValueColors : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "valueColors");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColors");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ValueColors class.
        /// </summary>
        public ValueColors() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColors(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColors class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColors(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColors class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ValueColors(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>MinColorSolidColorFillProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:minColor.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties? MinColorSolidColorFillProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinColorSolidColorFillProperties.ElementType);
        }

        /// <summary>
        /// <para>MidColorSolidColorFillProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:midColor.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties? MidColorSolidColorFillProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MidColorSolidColorFillProperties.ElementType);
        }

        /// <summary>
        /// <para>MaxColorSolidColorFillProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:maxColor.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties? MaxColorSolidColorFillProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxColorSolidColorFillProperties.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ValueColors>(deep);
    }

    /// <summary>
    /// <para>Defines the ValueColorPositions Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:valueColorPositions.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition" /> <c>&lt;cx:min></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition" /> <c>&lt;cx:max></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition" /> <c>&lt;cx:mid></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ValueColorPositions : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "valueColorPositions");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ValueColorPositions");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ValueColorPositions class.
        /// </summary>
        public ValueColorPositions() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorPositions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColorPositions(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorPositions class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ValueColorPositions(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ValueColorPositions class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ValueColorPositions(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>count, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: count</para>
        /// </summary>
        public Int32Value? Count
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition>();
            builder.AddElement<ValueColorPositions>()
                .AddAttribute("count", a => a.Count, aBuilder =>
                {
                    aBuilder.AddValidator(new NumberValidator() { MinInclusive = (2L), MaxInclusive = (3L) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>MinValueColorEndPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:min.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition? MinValueColorEndPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinValueColorEndPosition.ElementType);
        }

        /// <summary>
        /// <para>ValueColorMiddlePosition.</para>
        /// <para>Represents the following element tag in the schema: cx:mid.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition? ValueColorMiddlePosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorMiddlePosition.ElementType);
        }

        /// <summary>
        /// <para>MaxValueColorEndPosition.</para>
        /// <para>Represents the following element tag in the schema: cx:max.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition? MaxValueColorEndPosition
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MaxValueColorEndPosition.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ValueColorPositions>(deep);
    }

    /// <summary>
    /// <para>Defines the DataPoint Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:dataPt.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class DataPoint : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "dataPt");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataPoint");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataPoint class.
        /// </summary>
        public DataPoint() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataPoint class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataPoint(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataPoint class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataPoint(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataPoint class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataPoint(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Idx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddElement<DataPoint>()
                .AddAttribute("idx", a => a.Idx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataPoint>(deep);
    }

    /// <summary>
    /// <para>Defines the DataLabels Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:dataLabels.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabel" /> <c>&lt;cx:dataLabel></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelHidden" /> <c>&lt;cx:dataLabelHidden></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities" /> <c>&lt;cx:visibility></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat" /> <c>&lt;cx:numFmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring" /> <c>&lt;cx:separator></c></description></item>
    /// </list>
    /// </remarks>
    public partial class DataLabels : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "dataLabels");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataLabels");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataLabels class.
        /// </summary>
        public DataLabels() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataLabels(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabels class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public DataLabels(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the DataLabels class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public DataLabels(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>pos, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: pos</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelPos>? Pos
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelPos>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabel>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelHidden>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring>();
            builder.AddElement<DataLabels>()
                .AddAttribute("pos", a => a.Pos);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabel.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelHidden.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>NumberFormat.</para>
        /// <para>Represents the following element tag in the schema: cx:numFmt.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat? NumberFormat
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>DataLabelVisibilities.</para>
        /// <para>Represents the following element tag in the schema: cx:visibility.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities? DataLabelVisibilities
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabelVisibilities.ElementType);
        }

        /// <summary>
        /// <para>SeparatorXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:separator.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring? SeparatorXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeparatorXsdstring.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataLabels>(deep);
    }

    /// <summary>
    /// <para>Defines the DataId Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:dataId.</para>
    /// </summary>
    public partial class DataId : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "dataId");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_DataId");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the DataId class.
        /// </summary>
        public DataId() : base()
        {
        }

        /// <summary>
        /// <para>val, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public UInt32Value? Val
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<DataId>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<DataId>(deep);
    }

    /// <summary>
    /// <para>Defines the SeriesLayoutProperties Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:layoutPr.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Aggregation" /> <c>&lt;cx:aggregation></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Binning" /> <c>&lt;cx:binning></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Geography" /> <c>&lt;cx:geography></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout" /> <c>&lt;cx:parentLabelLayout></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout" /> <c>&lt;cx:regionLabelLayout></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities" /> <c>&lt;cx:visibility></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Statistics" /> <c>&lt;cx:statistics></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Subtotals" /> <c>&lt;cx:subtotals></c></description></item>
    /// </list>
    /// </remarks>
    public partial class SeriesLayoutProperties : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "layoutPr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_SeriesLayoutProperties");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the SeriesLayoutProperties class.
        /// </summary>
        public SeriesLayoutProperties() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SeriesLayoutProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SeriesLayoutProperties(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SeriesLayoutProperties class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public SeriesLayoutProperties(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the SeriesLayoutProperties class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public SeriesLayoutProperties(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Aggregation>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Binning>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Geography>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Statistics>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Subtotals>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new CompositeParticle.Builder(ParticleType.Choice, 0, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Aggregation.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Binning.ElementType, 0, 1, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Geography.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Statistics.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Subtotals.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ParentLabelLayout.</para>
        /// <para>Represents the following element tag in the schema: cx:parentLabelLayout.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout? ParentLabelLayout
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ParentLabelLayout.ElementType);
        }

        /// <summary>
        /// <para>RegionLabelLayout.</para>
        /// <para>Represents the following element tag in the schema: cx:regionLabelLayout.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout? RegionLabelLayout
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.RegionLabelLayout.ElementType);
        }

        /// <summary>
        /// <para>SeriesElementVisibilities.</para>
        /// <para>Represents the following element tag in the schema: cx:visibility.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities? SeriesElementVisibilities
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesElementVisibilities.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<SeriesLayoutProperties>(deep);
    }

    /// <summary>
    /// <para>Defines the AxisId Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:axisId.</para>
    /// </summary>
    public partial class AxisId : OpenXmlLeafTextElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "axisId");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "ST_AxisId");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the AxisId class.
        /// </summary>
        public AxisId() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the AxisId class with the specified text content.
        /// </summary>
        /// <param name="text">Specifies the text content of the element.</param>
        public AxisId(string text) : base(text)
        {
        }

        internal override OpenXmlSimpleType InnerTextToValue(string text)
        {
            return new UInt32Value { InnerText = text };
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.AddValidator<UInt32Value>(NumberValidator.Instance);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<AxisId>(deep);
    }

    /// <summary>
    /// <para>Defines the PlotSurface Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:plotSurface.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class PlotSurface : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "plotSurface");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PlotSurface");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PlotSurface class.
        /// </summary>
        public PlotSurface() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotSurface class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotSurface(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotSurface class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotSurface(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotSurface class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PlotSurface(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PlotSurface>(deep);
    }

    /// <summary>
    /// <para>Defines the Series Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:series.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataId" /> <c>&lt;cx:dataId></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabels" /> <c>&lt;cx:dataLabels></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataPoint" /> <c>&lt;cx:dataPt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesLayoutProperties" /> <c>&lt;cx:layoutPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text" /> <c>&lt;cx:tx></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions" /> <c>&lt;cx:valueColorPositions></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors" /> <c>&lt;cx:valueColors></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisId" /> <c>&lt;cx:axisId></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Series : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "series");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Series");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Series class.
        /// </summary>
        public Series() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Series class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Series(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Series class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Series(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Series class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Series(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>layoutId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: layoutId</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesLayout>? LayoutId
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesLayout>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hidden, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>ownerIdx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: ownerIdx</para>
        /// </summary>
        public UInt32Value? OwnerIdx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>uniqueId, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: uniqueId</para>
        /// </summary>
        public StringValue? UniqueId
        {
            get => GetAttribute<StringValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>formatIdx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: formatIdx</para>
        /// </summary>
        public UInt32Value? FormatIdx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataId>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabels>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataPoint>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesLayoutProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisId>();
            builder.AddElement<Series>()
                .AddAttribute("layoutId", a => a.LayoutId, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("hidden", a => a.Hidden)
                .AddAttribute("ownerIdx", a => a.OwnerIdx)
                .AddAttribute("uniqueId", a => a.UniqueId)
                .AddAttribute("formatIdx", a => a.FormatIdx);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataPoint.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataLabels.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.DataId.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SeriesLayoutProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisId.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: cx:tx.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text? Text
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>ValueColors.</para>
        /// <para>Represents the following element tag in the schema: cx:valueColors.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors? ValueColors
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColors.ElementType);
        }

        /// <summary>
        /// <para>ValueColorPositions.</para>
        /// <para>Represents the following element tag in the schema: cx:valueColorPositions.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions? ValueColorPositions
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueColorPositions.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Series>(deep);
    }

    /// <summary>
    /// <para>Defines the PlotAreaRegion Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:plotAreaRegion.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface" /> <c>&lt;cx:plotSurface></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Series" /> <c>&lt;cx:series></c></description></item>
    /// </list>
    /// </remarks>
    public partial class PlotAreaRegion : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "plotAreaRegion");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PlotAreaRegion");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PlotAreaRegion class.
        /// </summary>
        public PlotAreaRegion() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotAreaRegion class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotAreaRegion(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotAreaRegion class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotAreaRegion(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotAreaRegion class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PlotAreaRegion(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Series>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Series.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>PlotSurface.</para>
        /// <para>Represents the following element tag in the schema: cx:plotSurface.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface? PlotSurface
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotSurface.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PlotAreaRegion>(deep);
    }

    /// <summary>
    /// <para>Defines the Axis Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:axis.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisTitle" /> <c>&lt;cx:title></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnits" /> <c>&lt;cx:units></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CategoryAxisScaling" /> <c>&lt;cx:catScaling></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorGridlinesGridlines" /> <c>&lt;cx:majorGridlines></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorGridlinesGridlines" /> <c>&lt;cx:minorGridlines></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat" /> <c>&lt;cx:numFmt></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TickLabels" /> <c>&lt;cx:tickLabels></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorTickMarksTickMarks" /> <c>&lt;cx:majorTickMarks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorTickMarksTickMarks" /> <c>&lt;cx:minorTickMarks></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueAxisScaling" /> <c>&lt;cx:valScaling></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Axis : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "axis");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Axis");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Axis class.
        /// </summary>
        public Axis() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Axis class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Axis(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Axis class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Axis(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Axis class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Axis(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>id, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: id</para>
        /// </summary>
        public UInt32Value? Id
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>hidden, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: hidden</para>
        /// </summary>
        public BooleanValue? Hidden
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisTitle>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnits>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CategoryAxisScaling>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorGridlinesGridlines>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorGridlinesGridlines>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TickLabels>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorTickMarksTickMarks>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorTickMarksTickMarks>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueAxisScaling>();
            builder.AddElement<Axis>()
                .AddAttribute("id", a => a.Id, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("hidden", a => a.Hidden);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new CompositeParticle.Builder(ParticleType.Choice, 1, 1)
                {
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.CategoryAxisScaling.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                    new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ValueAxisScaling.ElementType, 1, 1, version: FileFormatVersions.Office2016)
                },
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisTitle.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.AxisUnits.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorGridlinesGridlines.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorGridlinesGridlines.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MajorTickMarksTickMarks.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.MinorTickMarksTickMarks.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TickLabels.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.NumberFormat.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Axis>(deep);
    }

    /// <summary>
    /// <para>Defines the ChartTitle Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:title.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text" /> <c>&lt;cx:tx></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ChartTitle : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "title");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ChartTitle");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ChartTitle class.
        /// </summary>
        public ChartTitle() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartTitle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartTitle(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartTitle class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartTitle(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartTitle class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartTitle(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>pos, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: pos</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SidePos>? Pos
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SidePos>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>align, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: align</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PosAlign>? Align
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PosAlign>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>overlay, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: overlay</para>
        /// </summary>
        public BooleanValue? Overlay
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text>();
            builder.AddElement<ChartTitle>()
                .AddAttribute("pos", a => a.Pos)
                .AddAttribute("align", a => a.Align)
                .AddAttribute("overlay", a => a.Overlay);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>Text.</para>
        /// <para>Represents the following element tag in the schema: cx:tx.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text? Text
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Text.ElementType);
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartTitle>(deep);
    }

    /// <summary>
    /// <para>Defines the PlotArea Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:plotArea.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Axis" /> <c>&lt;cx:axis></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion" /> <c>&lt;cx:plotAreaRegion></c></description></item>
    /// </list>
    /// </remarks>
    public partial class PlotArea : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "plotArea");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PlotArea");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PlotArea class.
        /// </summary>
        public PlotArea() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotArea class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotArea(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotArea class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PlotArea(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PlotArea class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PlotArea(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Axis>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Axis.ElementType, 0, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>PlotAreaRegion.</para>
        /// <para>Represents the following element tag in the schema: cx:plotAreaRegion.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion? PlotAreaRegion
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotAreaRegion.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PlotArea>(deep);
    }

    /// <summary>
    /// <para>Defines the Legend Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:legend.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody" /> <c>&lt;cx:txPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Legend : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "legend");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Legend");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Legend class.
        /// </summary>
        public Legend() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Legend class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Legend(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Legend class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Legend(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Legend class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Legend(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>pos, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: pos</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SidePos>? Pos
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.SidePos>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>align, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: align</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PosAlign>? Align
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PosAlign>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>overlay, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: overlay</para>
        /// </summary>
        public BooleanValue? Overlay
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddElement<Legend>()
                .AddAttribute("pos", a => a.Pos)
                .AddAttribute("align", a => a.Align)
                .AddAttribute("overlay", a => a.Overlay);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>TxPrTextBody.</para>
        /// <para>Represents the following element tag in the schema: cx:txPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody? TxPrTextBody
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.TxPrTextBody.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Legend>(deep);
    }

    /// <summary>
    /// <para>Defines the FormatOverride Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:fmtOvr.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties" /> <c>&lt;cx:spPr></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class FormatOverride : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "fmtOvr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_FormatOverride");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the FormatOverride class.
        /// </summary>
        public FormatOverride() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverride class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FormatOverride(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverride class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FormatOverride(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverride class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FormatOverride(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>idx, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: idx</para>
        /// </summary>
        public UInt32Value? Idx
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddElement<FormatOverride>()
                .AddAttribute("idx", a => a.Idx, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ShapeProperties.</para>
        /// <para>Represents the following element tag in the schema: cx:spPr.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties? ShapeProperties
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ShapeProperties.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FormatOverride>(deep);
    }

    /// <summary>
    /// <para>Defines the HeaderFooter Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:headerFooter.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring" /> <c>&lt;cx:oddHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring" /> <c>&lt;cx:oddFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring" /> <c>&lt;cx:evenHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring" /> <c>&lt;cx:evenFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring" /> <c>&lt;cx:firstHeader></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring" /> <c>&lt;cx:firstFooter></c></description></item>
    /// </list>
    /// </remarks>
    public partial class HeaderFooter : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "headerFooter");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_HeaderFooter");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class.
        /// </summary>
        public HeaderFooter() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HeaderFooter(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public HeaderFooter(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the HeaderFooter class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public HeaderFooter(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>alignWithMargins, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: alignWithMargins</para>
        /// </summary>
        public BooleanValue? AlignWithMargins
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>differentOddEven, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: differentOddEven</para>
        /// </summary>
        public BooleanValue? DifferentOddEven
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>differentFirst, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: differentFirst</para>
        /// </summary>
        public BooleanValue? DifferentFirst
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring>();
            builder.AddElement<HeaderFooter>()
                .AddAttribute("alignWithMargins", a => a.AlignWithMargins)
                .AddAttribute("differentOddEven", a => a.DifferentOddEven)
                .AddAttribute("differentFirst", a => a.DifferentFirst);
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>OddHeaderXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:oddHeader.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring? OddHeaderXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddHeaderXsdstring.ElementType);
        }

        /// <summary>
        /// <para>OddFooterXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:oddFooter.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring? OddFooterXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.OddFooterXsdstring.ElementType);
        }

        /// <summary>
        /// <para>EvenHeaderXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:evenHeader.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring? EvenHeaderXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenHeaderXsdstring.ElementType);
        }

        /// <summary>
        /// <para>EvenFooterXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:evenFooter.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring? EvenFooterXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.EvenFooterXsdstring.ElementType);
        }

        /// <summary>
        /// <para>FirstHeaderXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:firstHeader.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring? FirstHeaderXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstHeaderXsdstring.ElementType);
        }

        /// <summary>
        /// <para>FirstFooterXsdstring.</para>
        /// <para>Represents the following element tag in the schema: cx:firstFooter.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring? FirstFooterXsdstring
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FirstFooterXsdstring.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<HeaderFooter>(deep);
    }

    /// <summary>
    /// <para>Defines the PageMargins Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:pageMargins.</para>
    /// </summary>
    public partial class PageMargins : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "pageMargins");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PageMargins");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PageMargins class.
        /// </summary>
        public PageMargins() : base()
        {
        }

        /// <summary>
        /// <para>l, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: l</para>
        /// </summary>
        public DoubleValue? L
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>r, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: r</para>
        /// </summary>
        public DoubleValue? R
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>t, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: t</para>
        /// </summary>
        public DoubleValue? T
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>b, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: b</para>
        /// </summary>
        public DoubleValue? B
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>header, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: header</para>
        /// </summary>
        public DoubleValue? Header
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>footer, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: footer</para>
        /// </summary>
        public DoubleValue? Footer
        {
            get => GetAttribute<DoubleValue>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<PageMargins>()
                .AddAttribute("l", a => a.L, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("r", a => a.R, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("t", a => a.T, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("b", a => a.B, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("header", a => a.Header, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                })
                .AddAttribute("footer", a => a.Footer, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageMargins>(deep);
    }

    /// <summary>
    /// <para>Defines the PageSetup Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:pageSetup.</para>
    /// </summary>
    public partial class PageSetup : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "pageSetup");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PageSetup");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PageSetup class.
        /// </summary>
        public PageSetup() : base()
        {
        }

        /// <summary>
        /// <para>paperSize, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: paperSize</para>
        /// </summary>
        public UInt32Value? PaperSize
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>firstPageNumber, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: firstPageNumber</para>
        /// </summary>
        public UInt32Value? FirstPageNumber
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>orientation, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: orientation</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageOrientation>? Orientation
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageOrientation>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>blackAndWhite, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: blackAndWhite</para>
        /// </summary>
        public BooleanValue? BlackAndWhite
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>draft, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: draft</para>
        /// </summary>
        public BooleanValue? Draft
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>useFirstPageNumber, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: useFirstPageNumber</para>
        /// </summary>
        public BooleanValue? UseFirstPageNumber
        {
            get => GetAttribute<BooleanValue>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>horizontalDpi, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: horizontalDpi</para>
        /// </summary>
        public Int32Value? HorizontalDpi
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>verticalDpi, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: verticalDpi</para>
        /// </summary>
        public Int32Value? VerticalDpi
        {
            get => GetAttribute<Int32Value>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>copies, this property is only available in Office 2016 and later.</para>
        /// <para>Represents the following attribute in the schema: copies</para>
        /// </summary>
        public UInt32Value? Copies
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<PageSetup>()
                .AddAttribute("paperSize", a => a.PaperSize)
                .AddAttribute("firstPageNumber", a => a.FirstPageNumber)
                .AddAttribute("orientation", a => a.Orientation)
                .AddAttribute("blackAndWhite", a => a.BlackAndWhite)
                .AddAttribute("draft", a => a.Draft)
                .AddAttribute("useFirstPageNumber", a => a.UseFirstPageNumber)
                .AddAttribute("horizontalDpi", a => a.HorizontalDpi)
                .AddAttribute("verticalDpi", a => a.VerticalDpi)
                .AddAttribute("copies", a => a.Copies);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PageSetup>(deep);
    }

    /// <summary>
    /// <para>Defines the ChartData Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:chartData.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Data" /> <c>&lt;cx:data></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData" /> <c>&lt;cx:externalData></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ChartData : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "chartData");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_ChartData");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ChartData class.
        /// </summary>
        public ChartData() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartData(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartData class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ChartData(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ChartData class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ChartData(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Data>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Data.ElementType, 1, 0, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ExternalData.</para>
        /// <para>Represents the following element tag in the schema: cx:externalData.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData? ExternalData
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExternalData.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ChartData>(deep);
    }

    /// <summary>
    /// <para>Defines the Chart Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:chart.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle" /> <c>&lt;cx:title></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList" /> <c>&lt;cx:extLst></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend" /> <c>&lt;cx:legend></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea" /> <c>&lt;cx:plotArea></c></description></item>
    /// </list>
    /// </remarks>
    public partial class Chart : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "chart");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_Chart");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the Chart class.
        /// </summary>
        public Chart() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chart class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Chart(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chart class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public Chart(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the Chart class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public Chart(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea.ElementType, 1, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>ChartTitle.</para>
        /// <para>Represents the following element tag in the schema: cx:title.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle? ChartTitle
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ChartTitle.ElementType);
        }

        /// <summary>
        /// <para>PlotArea.</para>
        /// <para>Represents the following element tag in the schema: cx:plotArea.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea? PlotArea
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PlotArea.ElementType);
        }

        /// <summary>
        /// <para>Legend.</para>
        /// <para>Represents the following element tag in the schema: cx:legend.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend? Legend
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.Legend.ElementType);
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: cx:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<Chart>(deep);
    }

    /// <summary>
    /// <para>Defines the ColorMappingType Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:clrMapOvr.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Drawing.ExtensionList" /> <c>&lt;a:extLst></c></description></item>
    /// </list>
    /// </remarks>
    public partial class ColorMappingType : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "clrMapOvr");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/main", "CT_ColorMapping");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the ColorMappingType class.
        /// </summary>
        public ColorMappingType() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorMappingType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorMappingType(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorMappingType class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public ColorMappingType(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the ColorMappingType class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public ColorMappingType(string outerXml) : base(outerXml)
        {
        }

        /// <summary>
        /// <para>Background 1</para>
        /// <para>Represents the following attribute in the schema: bg1</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Background1
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Text 1</para>
        /// <para>Represents the following attribute in the schema: tx1</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Text1
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Background 2</para>
        /// <para>Represents the following attribute in the schema: bg2</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Background2
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Text 2</para>
        /// <para>Represents the following attribute in the schema: tx2</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Text2
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 1</para>
        /// <para>Represents the following attribute in the schema: accent1</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent1
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 2</para>
        /// <para>Represents the following attribute in the schema: accent2</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent2
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 3</para>
        /// <para>Represents the following attribute in the schema: accent3</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent3
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 4</para>
        /// <para>Represents the following attribute in the schema: accent4</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent4
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 5</para>
        /// <para>Represents the following attribute in the schema: accent5</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent5
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Accent 6</para>
        /// <para>Represents the following attribute in the schema: accent6</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Accent6
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Hyperlink</para>
        /// <para>Represents the following attribute in the schema: hlink</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? Hyperlink
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        /// <summary>
        /// <para>Followed Hyperlink</para>
        /// <para>Represents the following attribute in the schema: folHlink</para>
        /// </summary>
        public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>? FollowedHyperlink
        {
            get => GetAttribute<EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Drawing.ExtensionList>();
            builder.AddElement<ColorMappingType>()
                .AddAttribute("bg1", a => a.Background1, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("tx1", a => a.Text1, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("bg2", a => a.Background2, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("tx2", a => a.Text2, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent1", a => a.Accent1, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent2", a => a.Accent2, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent3", a => a.Accent3, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent4", a => a.Accent4, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent5", a => a.Accent5, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("accent6", a => a.Accent6, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("hlink", a => a.Hyperlink, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                })
                .AddAttribute("folHlink", a => a.FollowedHyperlink, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                    aBuilder.AddValidator(new StringValidator() { IsToken = (true) });
                });
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Drawing.ExtensionList.ElementType, 0, 1)
            };
        }

        /// <summary>
        /// <para>ExtensionList.</para>
        /// <para>Represents the following element tag in the schema: a:extLst.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
        /// </remarks>
        public DocumentFormat.OpenXml.Drawing.ExtensionList? ExtensionList
        {
            get => GetElement(DocumentFormat.OpenXml.Drawing.ExtensionList.ElementType) as DocumentFormat.OpenXml.Drawing.ExtensionList;
            set => SetElement(value, DocumentFormat.OpenXml.Drawing.ExtensionList.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<ColorMappingType>(deep);
    }

    /// <summary>
    /// <para>Defines the FormatOverrides Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:fmtOvrs.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverride" /> <c>&lt;cx:fmtOvr></c></description></item>
    /// </list>
    /// </remarks>
    public partial class FormatOverrides : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "fmtOvrs");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_FormatOverrides");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the FormatOverrides class.
        /// </summary>
        public FormatOverrides() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverrides class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FormatOverrides(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverrides class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public FormatOverrides(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the FormatOverrides class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public FormatOverrides(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverride>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.FormatOverride.ElementType, 0, 0, version: FileFormatVersions.Office2016)
            };
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<FormatOverrides>(deep);
    }

    /// <summary>
    /// <para>Defines the PrintSettings Class.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:printSettings.</para>
    /// </summary>
    /// <remarks>
    /// <para>The following table lists the possible child types:</para>
    /// <list type="bullet">
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter" /> <c>&lt;cx:headerFooter></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins" /> <c>&lt;cx:pageMargins></c></description></item>
    ///   <item><description><see cref="DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup" /> <c>&lt;cx:pageSetup></c></description></item>
    /// </list>
    /// </remarks>
    public partial class PrintSettings : OpenXmlCompositeElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "printSettings");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "CT_PrintSettings");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the PrintSettings class.
        /// </summary>
        public PrintSettings() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the PrintSettings class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PrintSettings(IEnumerable<OpenXmlElement> childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PrintSettings class with the specified child elements.
        /// </summary>
        /// <param name="childElements">Specifies the child elements.</param>
        public PrintSettings(params OpenXmlElement[] childElements) : base(childElements)
        {
        }

        /// <summary>
        /// Initializes a new instance of the PrintSettings class from outer XML.
        /// </summary>
        /// <param name="outerXml">Specifies the outer XML of the element.</param>
        public PrintSettings(string outerXml) : base(outerXml)
        {
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins>();
            builder.AddChild<DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup>();
            builder.Particle = new CompositeParticle.Builder(ParticleType.Sequence, 1, 1)
            {
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins.ElementType, 0, 1, version: FileFormatVersions.Office2016),
                new ElementParticle(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup.ElementType, 0, 1, version: FileFormatVersions.Office2016)
            };
        }

        /// <summary>
        /// <para>HeaderFooter.</para>
        /// <para>Represents the following element tag in the schema: cx:headerFooter.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter? HeaderFooter
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.HeaderFooter.ElementType);
        }

        /// <summary>
        /// <para>PageMargins.</para>
        /// <para>Represents the following element tag in the schema: cx:pageMargins.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins? PageMargins
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageMargins.ElementType);
        }

        /// <summary>
        /// <para>PageSetup.</para>
        /// <para>Represents the following element tag in the schema: cx:pageSetup.</para>
        /// </summary>
        /// <remarks>
        /// xmlns:cx = http://schemas.microsoft.com/office/drawing/2014/chartex
        /// </remarks>
        public DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup? PageSetup
        {
            get => GetElement(DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup.ElementType) as DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup;
            set => SetElement(value, DocumentFormat.OpenXml.Office2016.Drawing.ChartDrawing.PageSetup.ElementType);
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<PrintSettings>(deep);
    }

    /// <summary>
    /// <para>Index of subtotal data point.</para>
    /// <para>This class is available in Office 2016 and above.</para>
    /// <para>When the object is serialized out as xml, it's qualified name is cx:idx.</para>
    /// </summary>
    public partial class UnsignedIntegerType : OpenXmlLeafElement
    {
        #pragma warning disable CS0109
        internal static readonly new OpenXmlQualifiedName ElementQName = new("http://schemas.microsoft.com/office/drawing/2014/chartex", "idx");
        internal static readonly new OpenXmlQualifiedName ElementTypeName = new("http://schemas.openxmlformats.org/drawingml/2006/chart", "CT_UnsignedInt");
        internal static readonly new OpenXmlType ElementType = new(ElementQName, ElementTypeName);
        #pragma warning restore CS0109

        /// <summary>
        /// Initializes a new instance of the UnsignedIntegerType class.
        /// </summary>
        public UnsignedIntegerType() : base()
        {
        }

        /// <summary>
        /// <para>Integer Value</para>
        /// <para>Represents the following attribute in the schema: val</para>
        /// </summary>
        public UInt32Value? Val
        {
            get => GetAttribute<UInt32Value>();
            set => SetAttribute(value);
        }

        internal override void ConfigureMetadata(ElementMetadata.Builder builder)
        {
            base.ConfigureMetadata(builder);
            builder.SetSchema(ElementType);
            builder.Availability = FileFormatVersions.Office2016;
            builder.AddElement<UnsignedIntegerType>()
                .AddAttribute("val", a => a.Val, aBuilder =>
                {
                    aBuilder.AddValidator(RequiredValidator.Instance);
                });
        }

        /// <inheritdoc/>
        public override OpenXmlElement CloneNode(bool deep) => CloneImp<UnsignedIntegerType>(deep);
    }

    /// <summary>
    /// Defines the FormulaDirection enumeration.
    /// </summary>
    public readonly record struct FormulaDirection : IEnumValue, IEnumValueFactory<FormulaDirection>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new FormulaDirection enum instance
        /// </summary>
        public FormulaDirection(string value) => _value = value;
        FormulaDirection IEnumValueFactory<FormulaDirection>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "col" => true,
            "row" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "col";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// col.
        /// <para>When the item is serialized out as xml, its value is "col".</para>
        /// </summary>
        public static FormulaDirection Col => new("col");
        /// <summary>
        /// row.
        /// <para>When the item is serialized out as xml, its value is "row".</para>
        /// </summary>
        public static FormulaDirection Row => new("row");
    
    }

    /// <summary>
    /// Defines the StringDimensionType enumeration.
    /// </summary>
    public readonly record struct StringDimensionType : IEnumValue, IEnumValueFactory<StringDimensionType>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new StringDimensionType enum instance
        /// </summary>
        public StringDimensionType(string value) => _value = value;
        StringDimensionType IEnumValueFactory<StringDimensionType>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "cat" => true,
            "colorStr" => true,
            "entityId" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "cat";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// cat.
        /// <para>When the item is serialized out as xml, its value is "cat".</para>
        /// </summary>
        public static StringDimensionType Cat => new("cat");
        /// <summary>
        /// colorStr.
        /// <para>When the item is serialized out as xml, its value is "colorStr".</para>
        /// </summary>
        public static StringDimensionType ColorStr => new("colorStr");
        /// <summary>
        /// entityId.
        /// <para>When the item is serialized out as xml, its value is "entityId".</para>
        /// </summary>
        public static StringDimensionType EntityId => new("entityId");
    
    }

    /// <summary>
    /// Defines the NumericDimensionType enumeration.
    /// </summary>
    public readonly record struct NumericDimensionType : IEnumValue, IEnumValueFactory<NumericDimensionType>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new NumericDimensionType enum instance
        /// </summary>
        public NumericDimensionType(string value) => _value = value;
        NumericDimensionType IEnumValueFactory<NumericDimensionType>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "val" => true,
            "x" => true,
            "y" => true,
            "size" => true,
            "colorVal" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "val";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// val.
        /// <para>When the item is serialized out as xml, its value is "val".</para>
        /// </summary>
        public static NumericDimensionType Val => new("val");
        /// <summary>
        /// x.
        /// <para>When the item is serialized out as xml, its value is "x".</para>
        /// </summary>
        public static NumericDimensionType X => new("x");
        /// <summary>
        /// y.
        /// <para>When the item is serialized out as xml, its value is "y".</para>
        /// </summary>
        public static NumericDimensionType Y => new("y");
        /// <summary>
        /// size.
        /// <para>When the item is serialized out as xml, its value is "size".</para>
        /// </summary>
        public static NumericDimensionType Size => new("size");
        /// <summary>
        /// colorVal.
        /// <para>When the item is serialized out as xml, its value is "colorVal".</para>
        /// </summary>
        public static NumericDimensionType ColorVal => new("colorVal");
    
    }

    /// <summary>
    /// Defines the SidePos enumeration.
    /// </summary>
    public readonly record struct SidePos : IEnumValue, IEnumValueFactory<SidePos>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SidePos enum instance
        /// </summary>
        public SidePos(string value) => _value = value;
        SidePos IEnumValueFactory<SidePos>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "t" => true,
            "r" => true,
            "b" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// l.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static SidePos L => new("l");
        /// <summary>
        /// t.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static SidePos T => new("t");
        /// <summary>
        /// r.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static SidePos R => new("r");
        /// <summary>
        /// b.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static SidePos B => new("b");
    
    }

    /// <summary>
    /// Defines the PosAlign enumeration.
    /// </summary>
    public readonly record struct PosAlign : IEnumValue, IEnumValueFactory<PosAlign>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PosAlign enum instance
        /// </summary>
        public PosAlign(string value) => _value = value;
        PosAlign IEnumValueFactory<PosAlign>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "min" => true,
            "ctr" => true,
            "max" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "min";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// min.
        /// <para>When the item is serialized out as xml, its value is "min".</para>
        /// </summary>
        public static PosAlign Min => new("min");
        /// <summary>
        /// ctr.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static PosAlign Ctr => new("ctr");
        /// <summary>
        /// max.
        /// <para>When the item is serialized out as xml, its value is "max".</para>
        /// </summary>
        public static PosAlign Max => new("max");
    
    }

    /// <summary>
    /// Defines the AxisUnit enumeration.
    /// </summary>
    public readonly record struct AxisUnit : IEnumValue, IEnumValueFactory<AxisUnit>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new AxisUnit enum instance
        /// </summary>
        public AxisUnit(string value) => _value = value;
        AxisUnit IEnumValueFactory<AxisUnit>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "hundreds" => true,
            "thousands" => true,
            "tenThousands" => true,
            "hundredThousands" => true,
            "millions" => true,
            "tenMillions" => true,
            "hundredMillions" => true,
            "billions" => true,
            "trillions" => true,
            "percentage" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "hundreds";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// hundreds.
        /// <para>When the item is serialized out as xml, its value is "hundreds".</para>
        /// </summary>
        public static AxisUnit Hundreds => new("hundreds");
        /// <summary>
        /// thousands.
        /// <para>When the item is serialized out as xml, its value is "thousands".</para>
        /// </summary>
        public static AxisUnit Thousands => new("thousands");
        /// <summary>
        /// tenThousands.
        /// <para>When the item is serialized out as xml, its value is "tenThousands".</para>
        /// </summary>
        public static AxisUnit TenThousands => new("tenThousands");
        /// <summary>
        /// hundredThousands.
        /// <para>When the item is serialized out as xml, its value is "hundredThousands".</para>
        /// </summary>
        public static AxisUnit HundredThousands => new("hundredThousands");
        /// <summary>
        /// millions.
        /// <para>When the item is serialized out as xml, its value is "millions".</para>
        /// </summary>
        public static AxisUnit Millions => new("millions");
        /// <summary>
        /// tenMillions.
        /// <para>When the item is serialized out as xml, its value is "tenMillions".</para>
        /// </summary>
        public static AxisUnit TenMillions => new("tenMillions");
        /// <summary>
        /// hundredMillions.
        /// <para>When the item is serialized out as xml, its value is "hundredMillions".</para>
        /// </summary>
        public static AxisUnit HundredMillions => new("hundredMillions");
        /// <summary>
        /// billions.
        /// <para>When the item is serialized out as xml, its value is "billions".</para>
        /// </summary>
        public static AxisUnit Billions => new("billions");
        /// <summary>
        /// trillions.
        /// <para>When the item is serialized out as xml, its value is "trillions".</para>
        /// </summary>
        public static AxisUnit Trillions => new("trillions");
        /// <summary>
        /// percentage.
        /// <para>When the item is serialized out as xml, its value is "percentage".</para>
        /// </summary>
        public static AxisUnit Percentage => new("percentage");
    
    }

    /// <summary>
    /// Defines the TickMarksType enumeration.
    /// </summary>
    public readonly record struct TickMarksType : IEnumValue, IEnumValueFactory<TickMarksType>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new TickMarksType enum instance
        /// </summary>
        public TickMarksType(string value) => _value = value;
        TickMarksType IEnumValueFactory<TickMarksType>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "in" => true,
            "out" => true,
            "cross" => true,
            "none" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "in";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// in.
        /// <para>When the item is serialized out as xml, its value is "in".</para>
        /// </summary>
        public static TickMarksType In => new("in");
        /// <summary>
        /// out.
        /// <para>When the item is serialized out as xml, its value is "out".</para>
        /// </summary>
        public static TickMarksType Out => new("out");
        /// <summary>
        /// cross.
        /// <para>When the item is serialized out as xml, its value is "cross".</para>
        /// </summary>
        public static TickMarksType Cross => new("cross");
        /// <summary>
        /// none.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static TickMarksType None => new("none");
    
    }

    /// <summary>
    /// Defines the SeriesLayout enumeration.
    /// </summary>
    public readonly record struct SeriesLayout : IEnumValue, IEnumValueFactory<SeriesLayout>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new SeriesLayout enum instance
        /// </summary>
        public SeriesLayout(string value) => _value = value;
        SeriesLayout IEnumValueFactory<SeriesLayout>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "boxWhisker" => true,
            "clusteredColumn" => true,
            "funnel" => true,
            "paretoLine" => true,
            "regionMap" => true,
            "sunburst" => true,
            "treemap" => true,
            "waterfall" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "boxWhisker";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// boxWhisker.
        /// <para>When the item is serialized out as xml, its value is "boxWhisker".</para>
        /// </summary>
        public static SeriesLayout BoxWhisker => new("boxWhisker");
        /// <summary>
        /// clusteredColumn.
        /// <para>When the item is serialized out as xml, its value is "clusteredColumn".</para>
        /// </summary>
        public static SeriesLayout ClusteredColumn => new("clusteredColumn");
        /// <summary>
        /// funnel.
        /// <para>When the item is serialized out as xml, its value is "funnel".</para>
        /// </summary>
        public static SeriesLayout Funnel => new("funnel");
        /// <summary>
        /// paretoLine.
        /// <para>When the item is serialized out as xml, its value is "paretoLine".</para>
        /// </summary>
        public static SeriesLayout ParetoLine => new("paretoLine");
        /// <summary>
        /// regionMap.
        /// <para>When the item is serialized out as xml, its value is "regionMap".</para>
        /// </summary>
        public static SeriesLayout RegionMap => new("regionMap");
        /// <summary>
        /// sunburst.
        /// <para>When the item is serialized out as xml, its value is "sunburst".</para>
        /// </summary>
        public static SeriesLayout Sunburst => new("sunburst");
        /// <summary>
        /// treemap.
        /// <para>When the item is serialized out as xml, its value is "treemap".</para>
        /// </summary>
        public static SeriesLayout Treemap => new("treemap");
        /// <summary>
        /// waterfall.
        /// <para>When the item is serialized out as xml, its value is "waterfall".</para>
        /// </summary>
        public static SeriesLayout Waterfall => new("waterfall");
    
    }

    /// <summary>
    /// Defines the ParentLabelLayoutVal enumeration.
    /// </summary>
    public readonly record struct ParentLabelLayoutVal : IEnumValue, IEnumValueFactory<ParentLabelLayoutVal>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new ParentLabelLayoutVal enum instance
        /// </summary>
        public ParentLabelLayoutVal(string value) => _value = value;
        ParentLabelLayoutVal IEnumValueFactory<ParentLabelLayoutVal>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "banner" => true,
            "overlapping" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// none.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static ParentLabelLayoutVal None => new("none");
        /// <summary>
        /// banner.
        /// <para>When the item is serialized out as xml, its value is "banner".</para>
        /// </summary>
        public static ParentLabelLayoutVal Banner => new("banner");
        /// <summary>
        /// overlapping.
        /// <para>When the item is serialized out as xml, its value is "overlapping".</para>
        /// </summary>
        public static ParentLabelLayoutVal Overlapping => new("overlapping");
    
    }

    /// <summary>
    /// Defines the RegionLabelLayoutEnum enumeration.
    /// </summary>
    public readonly record struct RegionLabelLayoutEnum : IEnumValue, IEnumValueFactory<RegionLabelLayoutEnum>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new RegionLabelLayoutEnum enum instance
        /// </summary>
        public RegionLabelLayoutEnum(string value) => _value = value;
        RegionLabelLayoutEnum IEnumValueFactory<RegionLabelLayoutEnum>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "none" => true,
            "bestFitOnly" => true,
            "showAll" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "none";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// none.
        /// <para>When the item is serialized out as xml, its value is "none".</para>
        /// </summary>
        public static RegionLabelLayoutEnum None => new("none");
        /// <summary>
        /// bestFitOnly.
        /// <para>When the item is serialized out as xml, its value is "bestFitOnly".</para>
        /// </summary>
        public static RegionLabelLayoutEnum BestFitOnly => new("bestFitOnly");
        /// <summary>
        /// showAll.
        /// <para>When the item is serialized out as xml, its value is "showAll".</para>
        /// </summary>
        public static RegionLabelLayoutEnum ShowAll => new("showAll");
    
    }

    /// <summary>
    /// Defines the IntervalClosedSide enumeration.
    /// </summary>
    public readonly record struct IntervalClosedSide : IEnumValue, IEnumValueFactory<IntervalClosedSide>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new IntervalClosedSide enum instance
        /// </summary>
        public IntervalClosedSide(string value) => _value = value;
        IntervalClosedSide IEnumValueFactory<IntervalClosedSide>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "l" => true,
            "r" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "l";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// l.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static IntervalClosedSide L => new("l");
        /// <summary>
        /// r.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static IntervalClosedSide R => new("r");
    
    }

    /// <summary>
    /// Defines the EntityTypeEnum enumeration.
    /// </summary>
    public readonly record struct EntityTypeEnum : IEnumValue, IEnumValueFactory<EntityTypeEnum>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new EntityTypeEnum enum instance
        /// </summary>
        public EntityTypeEnum(string value) => _value = value;
        EntityTypeEnum IEnumValueFactory<EntityTypeEnum>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "Address" => true,
            "AdminDistrict" => true,
            "AdminDistrict2" => true,
            "AdminDistrict3" => true,
            "Continent" => true,
            "CountryRegion" => true,
            "Locality" => true,
            "Ocean" => true,
            "Planet" => true,
            "PostalCode" => true,
            "Region" => true,
            "Unsupported" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "Address";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// Address.
        /// <para>When the item is serialized out as xml, its value is "Address".</para>
        /// </summary>
        public static EntityTypeEnum Address => new("Address");
        /// <summary>
        /// AdminDistrict.
        /// <para>When the item is serialized out as xml, its value is "AdminDistrict".</para>
        /// </summary>
        public static EntityTypeEnum AdminDistrict => new("AdminDistrict");
        /// <summary>
        /// AdminDistrict2.
        /// <para>When the item is serialized out as xml, its value is "AdminDistrict2".</para>
        /// </summary>
        public static EntityTypeEnum AdminDistrict2 => new("AdminDistrict2");
        /// <summary>
        /// AdminDistrict3.
        /// <para>When the item is serialized out as xml, its value is "AdminDistrict3".</para>
        /// </summary>
        public static EntityTypeEnum AdminDistrict3 => new("AdminDistrict3");
        /// <summary>
        /// Continent.
        /// <para>When the item is serialized out as xml, its value is "Continent".</para>
        /// </summary>
        public static EntityTypeEnum Continent => new("Continent");
        /// <summary>
        /// CountryRegion.
        /// <para>When the item is serialized out as xml, its value is "CountryRegion".</para>
        /// </summary>
        public static EntityTypeEnum CountryRegion => new("CountryRegion");
        /// <summary>
        /// Locality.
        /// <para>When the item is serialized out as xml, its value is "Locality".</para>
        /// </summary>
        public static EntityTypeEnum Locality => new("Locality");
        /// <summary>
        /// Ocean.
        /// <para>When the item is serialized out as xml, its value is "Ocean".</para>
        /// </summary>
        public static EntityTypeEnum Ocean => new("Ocean");
        /// <summary>
        /// Planet.
        /// <para>When the item is serialized out as xml, its value is "Planet".</para>
        /// </summary>
        public static EntityTypeEnum Planet => new("Planet");
        /// <summary>
        /// PostalCode.
        /// <para>When the item is serialized out as xml, its value is "PostalCode".</para>
        /// </summary>
        public static EntityTypeEnum PostalCode => new("PostalCode");
        /// <summary>
        /// Region.
        /// <para>When the item is serialized out as xml, its value is "Region".</para>
        /// </summary>
        public static EntityTypeEnum Region => new("Region");
        /// <summary>
        /// Unsupported.
        /// <para>When the item is serialized out as xml, its value is "Unsupported".</para>
        /// </summary>
        public static EntityTypeEnum Unsupported => new("Unsupported");
    
    }

    /// <summary>
    /// Defines the GeoProjectionType enumeration.
    /// </summary>
    public readonly record struct GeoProjectionType : IEnumValue, IEnumValueFactory<GeoProjectionType>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GeoProjectionType enum instance
        /// </summary>
        public GeoProjectionType(string value) => _value = value;
        GeoProjectionType IEnumValueFactory<GeoProjectionType>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "mercator" => true,
            "miller" => true,
            "robinson" => true,
            "albers" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "mercator";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// mercator.
        /// <para>When the item is serialized out as xml, its value is "mercator".</para>
        /// </summary>
        public static GeoProjectionType Mercator => new("mercator");
        /// <summary>
        /// miller.
        /// <para>When the item is serialized out as xml, its value is "miller".</para>
        /// </summary>
        public static GeoProjectionType Miller => new("miller");
        /// <summary>
        /// robinson.
        /// <para>When the item is serialized out as xml, its value is "robinson".</para>
        /// </summary>
        public static GeoProjectionType Robinson => new("robinson");
        /// <summary>
        /// albers.
        /// <para>When the item is serialized out as xml, its value is "albers".</para>
        /// </summary>
        public static GeoProjectionType Albers => new("albers");
    
    }

    /// <summary>
    /// Defines the GeoMappingLevel enumeration.
    /// </summary>
    public readonly record struct GeoMappingLevel : IEnumValue, IEnumValueFactory<GeoMappingLevel>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new GeoMappingLevel enum instance
        /// </summary>
        public GeoMappingLevel(string value) => _value = value;
        GeoMappingLevel IEnumValueFactory<GeoMappingLevel>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "dataOnly" => true,
            "postalCode" => true,
            "county" => true,
            "state" => true,
            "countryRegion" => true,
            "countryRegionList" => true,
            "world" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "dataOnly";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// dataOnly.
        /// <para>When the item is serialized out as xml, its value is "dataOnly".</para>
        /// </summary>
        public static GeoMappingLevel DataOnly => new("dataOnly");
        /// <summary>
        /// postalCode.
        /// <para>When the item is serialized out as xml, its value is "postalCode".</para>
        /// </summary>
        public static GeoMappingLevel PostalCode => new("postalCode");
        /// <summary>
        /// county.
        /// <para>When the item is serialized out as xml, its value is "county".</para>
        /// </summary>
        public static GeoMappingLevel County => new("county");
        /// <summary>
        /// state.
        /// <para>When the item is serialized out as xml, its value is "state".</para>
        /// </summary>
        public static GeoMappingLevel State => new("state");
        /// <summary>
        /// countryRegion.
        /// <para>When the item is serialized out as xml, its value is "countryRegion".</para>
        /// </summary>
        public static GeoMappingLevel CountryRegion => new("countryRegion");
        /// <summary>
        /// countryRegionList.
        /// <para>When the item is serialized out as xml, its value is "countryRegionList".</para>
        /// </summary>
        public static GeoMappingLevel CountryRegionList => new("countryRegionList");
        /// <summary>
        /// world.
        /// <para>When the item is serialized out as xml, its value is "world".</para>
        /// </summary>
        public static GeoMappingLevel World => new("world");
    
    }

    /// <summary>
    /// Defines the QuartileMethod enumeration.
    /// </summary>
    public readonly record struct QuartileMethod : IEnumValue, IEnumValueFactory<QuartileMethod>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new QuartileMethod enum instance
        /// </summary>
        public QuartileMethod(string value) => _value = value;
        QuartileMethod IEnumValueFactory<QuartileMethod>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "inclusive" => true,
            "exclusive" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "inclusive";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// inclusive.
        /// <para>When the item is serialized out as xml, its value is "inclusive".</para>
        /// </summary>
        public static QuartileMethod Inclusive => new("inclusive");
        /// <summary>
        /// exclusive.
        /// <para>When the item is serialized out as xml, its value is "exclusive".</para>
        /// </summary>
        public static QuartileMethod Exclusive => new("exclusive");
    
    }

    /// <summary>
    /// Defines the DataLabelPos enumeration.
    /// </summary>
    public readonly record struct DataLabelPos : IEnumValue, IEnumValueFactory<DataLabelPos>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new DataLabelPos enum instance
        /// </summary>
        public DataLabelPos(string value) => _value = value;
        DataLabelPos IEnumValueFactory<DataLabelPos>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "bestFit" => true,
            "b" => true,
            "ctr" => true,
            "inBase" => true,
            "inEnd" => true,
            "l" => true,
            "outEnd" => true,
            "r" => true,
            "t" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "bestFit";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// bestFit.
        /// <para>When the item is serialized out as xml, its value is "bestFit".</para>
        /// </summary>
        public static DataLabelPos BestFit => new("bestFit");
        /// <summary>
        /// b.
        /// <para>When the item is serialized out as xml, its value is "b".</para>
        /// </summary>
        public static DataLabelPos B => new("b");
        /// <summary>
        /// ctr.
        /// <para>When the item is serialized out as xml, its value is "ctr".</para>
        /// </summary>
        public static DataLabelPos Ctr => new("ctr");
        /// <summary>
        /// inBase.
        /// <para>When the item is serialized out as xml, its value is "inBase".</para>
        /// </summary>
        public static DataLabelPos InBase => new("inBase");
        /// <summary>
        /// inEnd.
        /// <para>When the item is serialized out as xml, its value is "inEnd".</para>
        /// </summary>
        public static DataLabelPos InEnd => new("inEnd");
        /// <summary>
        /// l.
        /// <para>When the item is serialized out as xml, its value is "l".</para>
        /// </summary>
        public static DataLabelPos L => new("l");
        /// <summary>
        /// outEnd.
        /// <para>When the item is serialized out as xml, its value is "outEnd".</para>
        /// </summary>
        public static DataLabelPos OutEnd => new("outEnd");
        /// <summary>
        /// r.
        /// <para>When the item is serialized out as xml, its value is "r".</para>
        /// </summary>
        public static DataLabelPos R => new("r");
        /// <summary>
        /// t.
        /// <para>When the item is serialized out as xml, its value is "t".</para>
        /// </summary>
        public static DataLabelPos T => new("t");
    
    }

    /// <summary>
    /// Defines the PageOrientation enumeration.
    /// </summary>
    public readonly record struct PageOrientation : IEnumValue, IEnumValueFactory<PageOrientation>
    {
        private readonly string? _value;
        /// <summary>
        /// Creates a new PageOrientation enum instance
        /// </summary>
        public PageOrientation(string value) => _value = value;
        PageOrientation IEnumValueFactory<PageOrientation>.Create(string name) => new(name);
        bool IEnumValue.IsValid => InternalValue switch
        {
            "default" => true,
            "portrait" => true,
            "landscape" => true,
            _ => false
        };
        string IEnumValue.Value => InternalValue;
        private string InternalValue => _value ?? "default";
        FileFormatVersions IEnumValue.Version => FileFormatVersions.Office2016;
        /// <summary>
        /// default.
        /// <para>When the item is serialized out as xml, its value is "default".</para>
        /// </summary>
        public static PageOrientation Default => new("default");
        /// <summary>
        /// portrait.
        /// <para>When the item is serialized out as xml, its value is "portrait".</para>
        /// </summary>
        public static PageOrientation Portrait => new("portrait");
        /// <summary>
        /// landscape.
        /// <para>When the item is serialized out as xml, its value is "landscape".</para>
        /// </summary>
        public static PageOrientation Landscape => new("landscape");
    
    }
}