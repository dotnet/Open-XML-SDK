// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// This source file is machine generated.  Please do not change the code manually.
using System;
using System.Collections.Generic;
using System.IO.Packaging;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Office2013.Word.Drawing;
using DocumentFormat.OpenXml.Office2013.Theme;
using DocumentFormat.OpenXml.Office2013.Drawing;
using DocumentFormat.OpenXml.Office2010.Drawing;
using DocumentFormat.OpenXml.Office2010.Drawing.Diagram;
using DocumentFormat.OpenXml.Office.Drawing;

namespace DocumentFormat.OpenXml.Drawing
{
/// <summary>
/// <para>Audio from CD.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:audioCd.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StartTime &lt;a:st></description></item>
///<item><description>EndTime &lt;a:end></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StartTime))]
    [ChildElementInfo(typeof(EndTime))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AudioFromCD : OpenXmlCompositeElement
{
    private const string tagName = "audioCd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10001;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AudioFromCD class.
    /// </summary>
    public AudioFromCD():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AudioFromCD class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AudioFromCD(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AudioFromCD class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AudioFromCD(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AudioFromCD class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AudioFromCD(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "st" == name)
    return new StartTime();
    
if( 10 == namespaceId && "end" == name)
    return new EndTime();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "st","end","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Audio Start Time.</para>
    /// <para> Represents the following element tag in the schema: a:st </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public StartTime StartTime
    {
        get 
        {
            return GetElement<StartTime>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Audio End Time.</para>
    /// <para> Represents the following element tag in the schema: a:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EndTime EndTime
    {
        get 
        {
            return GetElement<EndTime>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AudioFromCD>(deep);
    }

   
}
/// <summary>
/// <para>Audio from WAV File.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:wavAudioFile.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WaveAudioFile : EmbeddedWavAudioFileType
{
    private const string tagName = "wavAudioFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10002;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WaveAudioFile class.
    /// </summary>
    public WaveAudioFile():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WaveAudioFile>(deep);
    }

}
/// <summary>
/// <para>Hyperlink Sound.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:snd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyperlinkSound : EmbeddedWavAudioFileType
{
    private const string tagName = "snd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10165;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HyperlinkSound class.
    /// </summary>
    public HyperlinkSound():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyperlinkSound>(deep);
    }

}
/// <summary>
/// Defines the EmbeddedWavAudioFileType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class EmbeddedWavAudioFileType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "embed","name","builtIn" };
    private static byte[] attributeNamespaceIds = { 19,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Embedded Audio File Relationship ID.</para>
    /// <para>Represents the following attribute in the schema: r:embed </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "embed")]
    public StringValue Embed
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sound Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Recognized Built-In Sound.</para>
    /// <para>Represents the following attribute in the schema: builtIn </para>
    /// </summary>
    [SchemaAttr(0, "builtIn")]
    public BooleanValue BuiltIn
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "embed" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "builtIn" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the EmbeddedWavAudioFileType class.
    /// </summary>
    protected EmbeddedWavAudioFileType(){}
    
    
    
}
/// <summary>
/// <para>Audio from File.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:audioFile.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AudioFromFile : OpenXmlCompositeElement
{
    private const string tagName = "audioFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10003;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "link" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Linked Relationship ID.</para>
    /// <para>Represents the following attribute in the schema: r:link </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "link")]
    public StringValue Link
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AudioFromFile class.
    /// </summary>
    public AudioFromFile():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AudioFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AudioFromFile(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AudioFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AudioFromFile(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AudioFromFile class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AudioFromFile(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "link" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AudioFromFile>(deep);
    }

   
}
/// <summary>
/// <para>Video from File.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:videoFile.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VideoFromFile : OpenXmlCompositeElement
{
    private const string tagName = "videoFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10004;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "link" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Linked Relationship ID.</para>
    /// <para>Represents the following attribute in the schema: r:link </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "link")]
    public StringValue Link
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VideoFromFile class.
    /// </summary>
    public VideoFromFile():base(){}
    
            /// <summary>
    ///Initializes a new instance of the VideoFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VideoFromFile(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the VideoFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VideoFromFile(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the VideoFromFile class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public VideoFromFile(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "link" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VideoFromFile>(deep);
    }

   
}
/// <summary>
/// <para>QuickTime from File.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:quickTimeFile.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QuickTimeFromFile : OpenXmlCompositeElement
{
    private const string tagName = "quickTimeFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10005;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "link" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Linked Relationship ID.</para>
    /// <para>Represents the following attribute in the schema: r:link </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "link")]
    public StringValue Link
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QuickTimeFromFile class.
    /// </summary>
    public QuickTimeFromFile():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QuickTimeFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QuickTimeFromFile(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QuickTimeFromFile class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QuickTimeFromFile(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QuickTimeFromFile class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QuickTimeFromFile(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "link" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QuickTimeFromFile>(deep);
    }

   
}
/// <summary>
/// <para>Tint.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tint.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tint : PositiveFixedPercentageType
{
    private const string tagName = "tint";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10006;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Tint class.
    /// </summary>
    public Tint():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tint>(deep);
    }

}
/// <summary>
/// <para>Shade.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:shade.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shade : PositiveFixedPercentageType
{
    private const string tagName = "shade";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10007;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Shade class.
    /// </summary>
    public Shade():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shade>(deep);
    }

}
/// <summary>
/// <para>Alpha.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alpha.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Alpha : PositiveFixedPercentageType
{
    private const string tagName = "alpha";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10011;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Alpha class.
    /// </summary>
    public Alpha():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Alpha>(deep);
    }

}
/// <summary>
/// Defines the PositiveFixedPercentageType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PositiveFixedPercentageType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PositiveFixedPercentageType class.
    /// </summary>
    protected PositiveFixedPercentageType(){}
    
    
    
}
/// <summary>
/// <para>Complement.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:comp.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Complement : OpenXmlLeafElement
{
    private const string tagName = "comp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10008;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Complement class.
    /// </summary>
    public Complement():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Complement>(deep);
    }

   
}
/// <summary>
/// <para>Inverse.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:inv.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Inverse : OpenXmlLeafElement
{
    private const string tagName = "inv";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10009;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Inverse class.
    /// </summary>
    public Inverse():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Inverse>(deep);
    }

   
}
/// <summary>
/// <para>Gray.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gray.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Gray : OpenXmlLeafElement
{
    private const string tagName = "gray";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10010;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Gray class.
    /// </summary>
    public Gray():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Gray>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaOffset : OpenXmlLeafElement
{
    private const string tagName = "alphaOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10012;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaOffset class.
    /// </summary>
    public AlphaOffset():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaOffset>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Modulation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaModulation : PositivePercentageType
{
    private const string tagName = "alphaMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10013;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaModulation class.
    /// </summary>
    public AlphaModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaModulation>(deep);
    }

}
/// <summary>
/// <para>Hue Modulate.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hueMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HueModulation : PositivePercentageType
{
    private const string tagName = "hueMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10016;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HueModulation class.
    /// </summary>
    public HueModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HueModulation>(deep);
    }

}
/// <summary>
/// Defines the PositivePercentageType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PositivePercentageType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PositivePercentageType class.
    /// </summary>
    protected PositivePercentageType(){}
    
    
    
}
/// <summary>
/// <para>Hue.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hue.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hue : OpenXmlLeafElement
{
    private const string tagName = "hue";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10014;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Hue class.
    /// </summary>
    public Hue():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hue>(deep);
    }

   
}
/// <summary>
/// <para>Hue Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hueOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HueOffset : OpenXmlLeafElement
{
    private const string tagName = "hueOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10015;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HueOffset class.
    /// </summary>
    public HueOffset():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HueOffset>(deep);
    }

   
}
/// <summary>
/// <para>Saturation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sat.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Saturation : PercentageType
{
    private const string tagName = "sat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10017;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Saturation class.
    /// </summary>
    public Saturation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Saturation>(deep);
    }

}
/// <summary>
/// <para>Saturation Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:satOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaturationOffset : PercentageType
{
    private const string tagName = "satOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10018;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaturationOffset class.
    /// </summary>
    public SaturationOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaturationOffset>(deep);
    }

}
/// <summary>
/// <para>Saturation Modulation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:satMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaturationModulation : PercentageType
{
    private const string tagName = "satMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10019;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaturationModulation class.
    /// </summary>
    public SaturationModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaturationModulation>(deep);
    }

}
/// <summary>
/// <para>Luminance.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lum.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Luminance : PercentageType
{
    private const string tagName = "lum";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10020;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Luminance class.
    /// </summary>
    public Luminance():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Luminance>(deep);
    }

}
/// <summary>
/// <para>Luminance Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lumOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LuminanceOffset : PercentageType
{
    private const string tagName = "lumOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10021;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LuminanceOffset class.
    /// </summary>
    public LuminanceOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LuminanceOffset>(deep);
    }

}
/// <summary>
/// <para>Luminance Modulation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lumMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LuminanceModulation : PercentageType
{
    private const string tagName = "lumMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10022;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LuminanceModulation class.
    /// </summary>
    public LuminanceModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LuminanceModulation>(deep);
    }

}
/// <summary>
/// <para>Red.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:red.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Red : PercentageType
{
    private const string tagName = "red";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10023;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Red class.
    /// </summary>
    public Red():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Red>(deep);
    }

}
/// <summary>
/// <para>Red Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:redOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RedOffset : PercentageType
{
    private const string tagName = "redOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10024;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RedOffset class.
    /// </summary>
    public RedOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RedOffset>(deep);
    }

}
/// <summary>
/// <para>Red Modulation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:redMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RedModulation : PercentageType
{
    private const string tagName = "redMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10025;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RedModulation class.
    /// </summary>
    public RedModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RedModulation>(deep);
    }

}
/// <summary>
/// <para>Green.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:green.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Green : PercentageType
{
    private const string tagName = "green";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10026;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Green class.
    /// </summary>
    public Green():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Green>(deep);
    }

}
/// <summary>
/// <para>Green Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:greenOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GreenOffset : PercentageType
{
    private const string tagName = "greenOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10027;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GreenOffset class.
    /// </summary>
    public GreenOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GreenOffset>(deep);
    }

}
/// <summary>
/// <para>Green Modification.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:greenMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GreenModulation : PercentageType
{
    private const string tagName = "greenMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10028;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GreenModulation class.
    /// </summary>
    public GreenModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GreenModulation>(deep);
    }

}
/// <summary>
/// <para>Blue.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blue.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Blue : PercentageType
{
    private const string tagName = "blue";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10029;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Blue class.
    /// </summary>
    public Blue():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Blue>(deep);
    }

}
/// <summary>
/// <para>Blue Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blueOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlueOffset : PercentageType
{
    private const string tagName = "blueOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10030;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BlueOffset class.
    /// </summary>
    public BlueOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlueOffset>(deep);
    }

}
/// <summary>
/// <para>Blue Modification.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blueMod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlueModulation : PercentageType
{
    private const string tagName = "blueMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10031;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BlueModulation class.
    /// </summary>
    public BlueModulation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlueModulation>(deep);
    }

}
/// <summary>
/// Defines the PercentageType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PercentageType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PercentageType class.
    /// </summary>
    protected PercentageType(){}
    
    
    
}
/// <summary>
/// <para>Gamma.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gamma.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Gamma : OpenXmlLeafElement
{
    private const string tagName = "gamma";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10032;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Gamma class.
    /// </summary>
    public Gamma():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Gamma>(deep);
    }

   
}
/// <summary>
/// <para>Inverse Gamma.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:invGamma.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InverseGamma : OpenXmlLeafElement
{
    private const string tagName = "invGamma";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10033;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the InverseGamma class.
    /// </summary>
    public InverseGamma():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InverseGamma>(deep);
    }

   
}
/// <summary>
/// <para>Extension.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Extension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10034;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Extension class.
    /// </summary>
    public Extension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Extension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Extension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Extension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Extension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Extension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Extension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    
    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Extension>(deep);
    }

   
}
/// <summary>
/// <para>RGB Color Model - Percentage Variant.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:scrgbClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RgbColorModelPercentage : OpenXmlCompositeElement
{
    private const string tagName = "scrgbClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10035;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","g","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Red.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public Int32Value RedPortion
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Green.</para>
    /// <para>Represents the following attribute in the schema: g </para>
    /// </summary>
    [SchemaAttr(0, "g")]
    public Int32Value GreenPortion
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Blue.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public Int32Value BluePortion
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RgbColorModelPercentage class.
    /// </summary>
    public RgbColorModelPercentage():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RgbColorModelPercentage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RgbColorModelPercentage(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RgbColorModelPercentage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RgbColorModelPercentage(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RgbColorModelPercentage class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RgbColorModelPercentage(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "g" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "b" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RgbColorModelPercentage>(deep);
    }

   
}
/// <summary>
/// <para>RGB Color Model - Hex Variant.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:srgbClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RgbColorModelHex : OpenXmlCompositeElement
{
    private const string tagName = "srgbClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10036;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","legacySpreadsheetColorIndex" };
    private static byte[] attributeNamespaceIds = { 0,48 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public HexBinaryValue Val
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> legacySpreadsheetColorIndex.</para>
    /// <para>Represents the following attribute in the schema: a14:legacySpreadsheetColorIndex </para>
    /// </summary>
///<remark> xmlns:a14=http://schemas.microsoft.com/office/drawing/2010/main
///</remark>
    [SchemaAttr(48, "legacySpreadsheetColorIndex")]
    public Int32Value LegacySpreadsheetColorIndex
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RgbColorModelHex class.
    /// </summary>
    public RgbColorModelHex():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RgbColorModelHex class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RgbColorModelHex(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RgbColorModelHex class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RgbColorModelHex(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RgbColorModelHex class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RgbColorModelHex(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new HexBinaryValue();
    
if( 48 == namespaceId && "legacySpreadsheetColorIndex" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RgbColorModelHex>(deep);
    }

   
}
/// <summary>
/// <para>Hue, Saturation, Luminance Color Model.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hslClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HslColor : OpenXmlCompositeElement
{
    private const string tagName = "hslClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10037;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "hue","sat","lum" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hue.</para>
    /// <para>Represents the following attribute in the schema: hue </para>
    /// </summary>
    [SchemaAttr(0, "hue")]
    public Int32Value HueValue
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Saturation.</para>
    /// <para>Represents the following attribute in the schema: sat </para>
    /// </summary>
    [SchemaAttr(0, "sat")]
    public Int32Value SatValue
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Luminance.</para>
    /// <para>Represents the following attribute in the schema: lum </para>
    /// </summary>
    [SchemaAttr(0, "lum")]
    public Int32Value LumValue
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HslColor class.
    /// </summary>
    public HslColor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the HslColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HslColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HslColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HslColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HslColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HslColor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "hue" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sat" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "lum" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HslColor>(deep);
    }

   
}
/// <summary>
/// <para>System Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sysClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SystemColor : OpenXmlCompositeElement
{
    private const string tagName = "sysClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10038;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","lastClr" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.SystemColorValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.SystemColorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Last Color.</para>
    /// <para>Represents the following attribute in the schema: lastClr </para>
    /// </summary>
    [SchemaAttr(0, "lastClr")]
    public HexBinaryValue LastColor
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SystemColor class.
    /// </summary>
    public SystemColor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SystemColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SystemColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SystemColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SystemColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SystemColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SystemColor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.SystemColorValues>();
    
if( 0 == namespaceId && "lastClr" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SystemColor>(deep);
    }

   
}
/// <summary>
/// <para>Scheme Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:schemeClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SchemeColor : OpenXmlCompositeElement
{
    private const string tagName = "schemeClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10039;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.SchemeColorValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.SchemeColorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SchemeColor class.
    /// </summary>
    public SchemeColor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SchemeColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SchemeColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SchemeColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SchemeColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SchemeColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SchemeColor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.SchemeColorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SchemeColor>(deep);
    }

   
}
/// <summary>
/// <para>Preset Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:prstClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tint &lt;a:tint></description></item>
///<item><description>Shade &lt;a:shade></description></item>
///<item><description>Complement &lt;a:comp></description></item>
///<item><description>Inverse &lt;a:inv></description></item>
///<item><description>Gray &lt;a:gray></description></item>
///<item><description>Alpha &lt;a:alpha></description></item>
///<item><description>AlphaOffset &lt;a:alphaOff></description></item>
///<item><description>AlphaModulation &lt;a:alphaMod></description></item>
///<item><description>Hue &lt;a:hue></description></item>
///<item><description>HueOffset &lt;a:hueOff></description></item>
///<item><description>HueModulation &lt;a:hueMod></description></item>
///<item><description>Saturation &lt;a:sat></description></item>
///<item><description>SaturationOffset &lt;a:satOff></description></item>
///<item><description>SaturationModulation &lt;a:satMod></description></item>
///<item><description>Luminance &lt;a:lum></description></item>
///<item><description>LuminanceOffset &lt;a:lumOff></description></item>
///<item><description>LuminanceModulation &lt;a:lumMod></description></item>
///<item><description>Red &lt;a:red></description></item>
///<item><description>RedOffset &lt;a:redOff></description></item>
///<item><description>RedModulation &lt;a:redMod></description></item>
///<item><description>Green &lt;a:green></description></item>
///<item><description>GreenOffset &lt;a:greenOff></description></item>
///<item><description>GreenModulation &lt;a:greenMod></description></item>
///<item><description>Blue &lt;a:blue></description></item>
///<item><description>BlueOffset &lt;a:blueOff></description></item>
///<item><description>BlueModulation &lt;a:blueMod></description></item>
///<item><description>Gamma &lt;a:gamma></description></item>
///<item><description>InverseGamma &lt;a:invGamma></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tint))]
    [ChildElementInfo(typeof(Shade))]
    [ChildElementInfo(typeof(Complement))]
    [ChildElementInfo(typeof(Inverse))]
    [ChildElementInfo(typeof(Gray))]
    [ChildElementInfo(typeof(Alpha))]
    [ChildElementInfo(typeof(AlphaOffset))]
    [ChildElementInfo(typeof(AlphaModulation))]
    [ChildElementInfo(typeof(Hue))]
    [ChildElementInfo(typeof(HueOffset))]
    [ChildElementInfo(typeof(HueModulation))]
    [ChildElementInfo(typeof(Saturation))]
    [ChildElementInfo(typeof(SaturationOffset))]
    [ChildElementInfo(typeof(SaturationModulation))]
    [ChildElementInfo(typeof(Luminance))]
    [ChildElementInfo(typeof(LuminanceOffset))]
    [ChildElementInfo(typeof(LuminanceModulation))]
    [ChildElementInfo(typeof(Red))]
    [ChildElementInfo(typeof(RedOffset))]
    [ChildElementInfo(typeof(RedModulation))]
    [ChildElementInfo(typeof(Green))]
    [ChildElementInfo(typeof(GreenOffset))]
    [ChildElementInfo(typeof(GreenModulation))]
    [ChildElementInfo(typeof(Blue))]
    [ChildElementInfo(typeof(BlueOffset))]
    [ChildElementInfo(typeof(BlueModulation))]
    [ChildElementInfo(typeof(Gamma))]
    [ChildElementInfo(typeof(InverseGamma))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PresetColor : OpenXmlCompositeElement
{
    private const string tagName = "prstClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10040;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetColorValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetColorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PresetColor class.
    /// </summary>
    public PresetColor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PresetColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PresetColor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tint" == name)
    return new Tint();
    
if( 10 == namespaceId && "shade" == name)
    return new Shade();
    
if( 10 == namespaceId && "comp" == name)
    return new Complement();
    
if( 10 == namespaceId && "inv" == name)
    return new Inverse();
    
if( 10 == namespaceId && "gray" == name)
    return new Gray();
    
if( 10 == namespaceId && "alpha" == name)
    return new Alpha();
    
if( 10 == namespaceId && "alphaOff" == name)
    return new AlphaOffset();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulation();
    
if( 10 == namespaceId && "hue" == name)
    return new Hue();
    
if( 10 == namespaceId && "hueOff" == name)
    return new HueOffset();
    
if( 10 == namespaceId && "hueMod" == name)
    return new HueModulation();
    
if( 10 == namespaceId && "sat" == name)
    return new Saturation();
    
if( 10 == namespaceId && "satOff" == name)
    return new SaturationOffset();
    
if( 10 == namespaceId && "satMod" == name)
    return new SaturationModulation();
    
if( 10 == namespaceId && "lum" == name)
    return new Luminance();
    
if( 10 == namespaceId && "lumOff" == name)
    return new LuminanceOffset();
    
if( 10 == namespaceId && "lumMod" == name)
    return new LuminanceModulation();
    
if( 10 == namespaceId && "red" == name)
    return new Red();
    
if( 10 == namespaceId && "redOff" == name)
    return new RedOffset();
    
if( 10 == namespaceId && "redMod" == name)
    return new RedModulation();
    
if( 10 == namespaceId && "green" == name)
    return new Green();
    
if( 10 == namespaceId && "greenOff" == name)
    return new GreenOffset();
    
if( 10 == namespaceId && "greenMod" == name)
    return new GreenModulation();
    
if( 10 == namespaceId && "blue" == name)
    return new Blue();
    
if( 10 == namespaceId && "blueOff" == name)
    return new BlueOffset();
    
if( 10 == namespaceId && "blueMod" == name)
    return new BlueModulation();
    
if( 10 == namespaceId && "gamma" == name)
    return new Gamma();
    
if( 10 == namespaceId && "invGamma" == name)
    return new InverseGamma();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetColorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PresetColor>(deep);
    }

   
}
/// <summary>
/// <para>Apply 3D shape properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sp3d.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>BevelTop &lt;a:bevelT></description></item>
///<item><description>BevelBottom &lt;a:bevelB></description></item>
///<item><description>ExtrusionColor &lt;a:extrusionClr></description></item>
///<item><description>ContourColor &lt;a:contourClr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(BevelTop))]
    [ChildElementInfo(typeof(BevelBottom))]
    [ChildElementInfo(typeof(ExtrusionColor))]
    [ChildElementInfo(typeof(ContourColor))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shape3DType : OpenXmlCompositeElement
{
    private const string tagName = "sp3d";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10041;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "z","extrusionH","contourW","prstMaterial" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shape Depth.</para>
    /// <para>Represents the following attribute in the schema: z </para>
    /// </summary>
    [SchemaAttr(0, "z")]
    public Int64Value Z
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Extrusion Height.</para>
    /// <para>Represents the following attribute in the schema: extrusionH </para>
    /// </summary>
    [SchemaAttr(0, "extrusionH")]
    public Int64Value ExtrusionHeight
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Contour Width.</para>
    /// <para>Represents the following attribute in the schema: contourW </para>
    /// </summary>
    [SchemaAttr(0, "contourW")]
    public Int64Value ContourWidth
    {
        get { return (Int64Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Preset Material Type.</para>
    /// <para>Represents the following attribute in the schema: prstMaterial </para>
    /// </summary>
    [SchemaAttr(0, "prstMaterial")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues> PresetMaterial
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Shape3DType class.
    /// </summary>
    public Shape3DType():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Shape3DType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Shape3DType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Shape3DType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Shape3DType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Shape3DType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Shape3DType(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "bevelT" == name)
    return new BevelTop();
    
if( 10 == namespaceId && "bevelB" == name)
    return new BevelBottom();
    
if( 10 == namespaceId && "extrusionClr" == name)
    return new ExtrusionColor();
    
if( 10 == namespaceId && "contourClr" == name)
    return new ContourColor();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "bevelT","bevelB","extrusionClr","contourClr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Top Bevel.</para>
    /// <para> Represents the following element tag in the schema: a:bevelT </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BevelTop BevelTop
    {
        get 
        {
            return GetElement<BevelTop>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Bottom Bevel.</para>
    /// <para> Represents the following element tag in the schema: a:bevelB </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BevelBottom BevelBottom
    {
        get 
        {
            return GetElement<BevelBottom>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Extrusion Color.</para>
    /// <para> Represents the following element tag in the schema: a:extrusionClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtrusionColor ExtrusionColor
    {
        get 
        {
            return GetElement<ExtrusionColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Contour Color.</para>
    /// <para> Represents the following element tag in the schema: a:contourClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ContourColor ContourColor
    {
        get 
        {
            return GetElement<ContourColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "z" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "extrusionH" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "contourW" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "prstMaterial" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shape3DType>(deep);
    }

   
}
/// <summary>
/// <para>No text in 3D scene.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:flatTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FlatText : OpenXmlLeafElement
{
    private const string tagName = "flatTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10042;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "z" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Z Coordinate.</para>
    /// <para>Represents the following attribute in the schema: z </para>
    /// </summary>
    [SchemaAttr(0, "z")]
    public Int64Value Z
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FlatText class.
    /// </summary>
    public FlatText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "z" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FlatText>(deep);
    }

   
}
/// <summary>
/// <para>Linear Gradient Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lin.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LinearGradientFill : OpenXmlLeafElement
{
    private const string tagName = "lin";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10043;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ang","scaled" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Angle.</para>
    /// <para>Represents the following attribute in the schema: ang </para>
    /// </summary>
    [SchemaAttr(0, "ang")]
    public Int32Value Angle
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Scaled.</para>
    /// <para>Represents the following attribute in the schema: scaled </para>
    /// </summary>
    [SchemaAttr(0, "scaled")]
    public BooleanValue Scaled
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LinearGradientFill class.
    /// </summary>
    public LinearGradientFill():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ang" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "scaled" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LinearGradientFill>(deep);
    }

   
}
/// <summary>
/// <para>Path Gradient.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:path.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FillToRectangle &lt;a:fillToRect></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FillToRectangle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PathGradientFill : OpenXmlCompositeElement
{
    private const string tagName = "path";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10044;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "path" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Gradient Fill Path.</para>
    /// <para>Represents the following attribute in the schema: path </para>
    /// </summary>
    [SchemaAttr(0, "path")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PathShadeValues> Path
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PathShadeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PathGradientFill class.
    /// </summary>
    public PathGradientFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PathGradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PathGradientFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PathGradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PathGradientFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PathGradientFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PathGradientFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "fillToRect" == name)
    return new FillToRectangle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fillToRect" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Fill To Rectangle.</para>
    /// <para> Represents the following element tag in the schema: a:fillToRect </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FillToRectangle FillToRectangle
    {
        get 
        {
            return GetElement<FillToRectangle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "path" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PathShadeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PathGradientFill>(deep);
    }

   
}
/// <summary>
/// <para>Tile.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tile.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tile : OpenXmlLeafElement
{
    private const string tagName = "tile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10045;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "tx","ty","sx","sy","flip","algn" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Offset.</para>
    /// <para>Represents the following attribute in the schema: tx </para>
    /// </summary>
    [SchemaAttr(0, "tx")]
    public Int64Value HorizontalOffset
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Offset.</para>
    /// <para>Represents the following attribute in the schema: ty </para>
    /// </summary>
    [SchemaAttr(0, "ty")]
    public Int64Value VerticalOffset
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Ratio.</para>
    /// <para>Represents the following attribute in the schema: sx </para>
    /// </summary>
    [SchemaAttr(0, "sx")]
    public Int32Value HorizontalRatio
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Ratio.</para>
    /// <para>Represents the following attribute in the schema: sy </para>
    /// </summary>
    [SchemaAttr(0, "sy")]
    public Int32Value VerticalRatio
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Tile Flipping.</para>
    /// <para>Represents the following attribute in the schema: flip </para>
    /// </summary>
    [SchemaAttr(0, "flip")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues> Flip
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Tile class.
    /// </summary>
    public Tile():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "tx" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "ty" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "sx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sy" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "flip" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues>();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tile>(deep);
    }

   
}
/// <summary>
/// <para>Stretch.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:stretch.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FillRectangle &lt;a:fillRect></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FillRectangle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Stretch : OpenXmlCompositeElement
{
    private const string tagName = "stretch";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10046;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Stretch class.
    /// </summary>
    public Stretch():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Stretch class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Stretch(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Stretch class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Stretch(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Stretch class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Stretch(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "fillRect" == name)
    return new FillRectangle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fillRect" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Fill Rectangle.</para>
    /// <para> Represents the following element tag in the schema: a:fillRect </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FillRectangle FillRectangle
    {
        get 
        {
            return GetElement<FillRectangle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Stretch>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NoFill Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:noFill.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoFill : OpenXmlLeafElement
{
    private const string tagName = "noFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10047;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NoFill class.
    /// </summary>
    public NoFill():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoFill>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SolidFill Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:solidFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SolidFill : OpenXmlCompositeElement
{
    private const string tagName = "solidFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10048;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SolidFill class.
    /// </summary>
    public SolidFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SolidFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SolidFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SolidFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SolidFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SolidFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SolidFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SolidFill>(deep);
    }

   
}
/// <summary>
/// <para>Defines the GradientFill Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gradFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GradientStopList &lt;a:gsLst></description></item>
///<item><description>LinearGradientFill &lt;a:lin></description></item>
///<item><description>PathGradientFill &lt;a:path></description></item>
///<item><description>TileRectangle &lt;a:tileRect></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GradientStopList))]
    [ChildElementInfo(typeof(LinearGradientFill))]
    [ChildElementInfo(typeof(PathGradientFill))]
    [ChildElementInfo(typeof(TileRectangle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GradientFill : OpenXmlCompositeElement
{
    private const string tagName = "gradFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10049;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "flip","rotWithShape" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Tile Flip.</para>
    /// <para>Represents the following attribute in the schema: flip </para>
    /// </summary>
    [SchemaAttr(0, "flip")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues> Flip
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Rotate With Shape.</para>
    /// <para>Represents the following attribute in the schema: rotWithShape </para>
    /// </summary>
    [SchemaAttr(0, "rotWithShape")]
    public BooleanValue RotateWithShape
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GradientFill class.
    /// </summary>
    public GradientFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GradientFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "gsLst" == name)
    return new GradientStopList();
    
if( 10 == namespaceId && "lin" == name)
    return new LinearGradientFill();
    
if( 10 == namespaceId && "path" == name)
    return new PathGradientFill();
    
if( 10 == namespaceId && "tileRect" == name)
    return new TileRectangle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "gsLst","lin","path","tileRect" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Gradient Stop List.</para>
    /// <para> Represents the following element tag in the schema: a:gsLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GradientStopList GradientStopList
    {
        get 
        {
            return GetElement<GradientStopList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "flip" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TileFlipValues>();
    
if( 0 == namespaceId && "rotWithShape" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GradientFill>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BlipFill Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blipFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Blip &lt;a:blip></description></item>
///<item><description>SourceRectangle &lt;a:srcRect></description></item>
///<item><description>Tile &lt;a:tile></description></item>
///<item><description>Stretch &lt;a:stretch></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Blip))]
    [ChildElementInfo(typeof(SourceRectangle))]
    [ChildElementInfo(typeof(Tile))]
    [ChildElementInfo(typeof(Stretch))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlipFill : OpenXmlCompositeElement
{
    private const string tagName = "blipFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10050;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "dpi","rotWithShape" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> DPI Setting.</para>
    /// <para>Represents the following attribute in the schema: dpi </para>
    /// </summary>
    [SchemaAttr(0, "dpi")]
    public UInt32Value Dpi
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Rotate With Shape.</para>
    /// <para>Represents the following attribute in the schema: rotWithShape </para>
    /// </summary>
    [SchemaAttr(0, "rotWithShape")]
    public BooleanValue RotateWithShape
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BlipFill class.
    /// </summary>
    public BlipFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BlipFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BlipFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "blip" == name)
    return new Blip();
    
if( 10 == namespaceId && "srcRect" == name)
    return new SourceRectangle();
    
if( 10 == namespaceId && "tile" == name)
    return new Tile();
    
if( 10 == namespaceId && "stretch" == name)
    return new Stretch();
    

    return null;
}

        private static readonly string[] eleTagNames = { "blip","srcRect","tile","stretch" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Blip.</para>
    /// <para> Represents the following element tag in the schema: a:blip </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Blip Blip
    {
        get 
        {
            return GetElement<Blip>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Source Rectangle.</para>
    /// <para> Represents the following element tag in the schema: a:srcRect </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SourceRectangle SourceRectangle
    {
        get 
        {
            return GetElement<SourceRectangle>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "dpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rotWithShape" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlipFill>(deep);
    }

   
}
/// <summary>
/// <para>Pattern Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pattFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ForegroundColor &lt;a:fgClr></description></item>
///<item><description>BackgroundColor &lt;a:bgClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ForegroundColor))]
    [ChildElementInfo(typeof(BackgroundColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PatternFill : OpenXmlCompositeElement
{
    private const string tagName = "pattFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10051;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prst" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Pattern.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetPatternValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetPatternValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PatternFill class.
    /// </summary>
    public PatternFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PatternFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PatternFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PatternFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PatternFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PatternFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PatternFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "fgClr" == name)
    return new ForegroundColor();
    
if( 10 == namespaceId && "bgClr" == name)
    return new BackgroundColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fgClr","bgClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Foreground color.</para>
    /// <para> Represents the following element tag in the schema: a:fgClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ForegroundColor ForegroundColor
    {
        get 
        {
            return GetElement<ForegroundColor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Background color.</para>
    /// <para> Represents the following element tag in the schema: a:bgClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BackgroundColor BackgroundColor
    {
        get 
        {
            return GetElement<BackgroundColor>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetPatternValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PatternFill>(deep);
    }

   
}
/// <summary>
/// <para>Group Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:grpFill.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupFill : OpenXmlLeafElement
{
    private const string tagName = "grpFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10052;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the GroupFill class.
    /// </summary>
    public GroupFill():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupFill>(deep);
    }

   
}
/// <summary>
/// <para>Effect Container.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cont.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectContainer &lt;a:cont></description></item>
///<item><description>Effect &lt;a:effect></description></item>
///<item><description>AlphaBiLevel &lt;a:alphaBiLevel></description></item>
///<item><description>AlphaCeiling &lt;a:alphaCeiling></description></item>
///<item><description>AlphaFloor &lt;a:alphaFloor></description></item>
///<item><description>AlphaInverse &lt;a:alphaInv></description></item>
///<item><description>AlphaModulationEffect &lt;a:alphaMod></description></item>
///<item><description>AlphaModulationFixed &lt;a:alphaModFix></description></item>
///<item><description>AlphaOutset &lt;a:alphaOutset></description></item>
///<item><description>AlphaReplace &lt;a:alphaRepl></description></item>
///<item><description>BiLevel &lt;a:biLevel></description></item>
///<item><description>Blend &lt;a:blend></description></item>
///<item><description>Blur &lt;a:blur></description></item>
///<item><description>ColorChange &lt;a:clrChange></description></item>
///<item><description>ColorReplacement &lt;a:clrRepl></description></item>
///<item><description>Duotone &lt;a:duotone></description></item>
///<item><description>Fill &lt;a:fill></description></item>
///<item><description>FillOverlay &lt;a:fillOverlay></description></item>
///<item><description>Glow &lt;a:glow></description></item>
///<item><description>Grayscale &lt;a:grayscl></description></item>
///<item><description>Hsl &lt;a:hsl></description></item>
///<item><description>InnerShadow &lt;a:innerShdw></description></item>
///<item><description>LuminanceEffect &lt;a:lum></description></item>
///<item><description>OuterShadow &lt;a:outerShdw></description></item>
///<item><description>PresetShadow &lt;a:prstShdw></description></item>
///<item><description>Reflection &lt;a:reflection></description></item>
///<item><description>RelativeOffset &lt;a:relOff></description></item>
///<item><description>SoftEdge &lt;a:softEdge></description></item>
///<item><description>TintEffect &lt;a:tint></description></item>
///<item><description>TransformEffect &lt;a:xfrm></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectContainer : EffectContainerType
{
    private const string tagName = "cont";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10053;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EffectContainer class.
    /// </summary>
    public EffectContainer():base(){}
            /// <summary>
    ///Initializes a new instance of the EffectContainer class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectContainer(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectContainer class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectContainer(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectContainer class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectContainer(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectContainer>(deep);
    }

}
/// <summary>
/// <para>Effect Container.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effectDag.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectContainer &lt;a:cont></description></item>
///<item><description>Effect &lt;a:effect></description></item>
///<item><description>AlphaBiLevel &lt;a:alphaBiLevel></description></item>
///<item><description>AlphaCeiling &lt;a:alphaCeiling></description></item>
///<item><description>AlphaFloor &lt;a:alphaFloor></description></item>
///<item><description>AlphaInverse &lt;a:alphaInv></description></item>
///<item><description>AlphaModulationEffect &lt;a:alphaMod></description></item>
///<item><description>AlphaModulationFixed &lt;a:alphaModFix></description></item>
///<item><description>AlphaOutset &lt;a:alphaOutset></description></item>
///<item><description>AlphaReplace &lt;a:alphaRepl></description></item>
///<item><description>BiLevel &lt;a:biLevel></description></item>
///<item><description>Blend &lt;a:blend></description></item>
///<item><description>Blur &lt;a:blur></description></item>
///<item><description>ColorChange &lt;a:clrChange></description></item>
///<item><description>ColorReplacement &lt;a:clrRepl></description></item>
///<item><description>Duotone &lt;a:duotone></description></item>
///<item><description>Fill &lt;a:fill></description></item>
///<item><description>FillOverlay &lt;a:fillOverlay></description></item>
///<item><description>Glow &lt;a:glow></description></item>
///<item><description>Grayscale &lt;a:grayscl></description></item>
///<item><description>Hsl &lt;a:hsl></description></item>
///<item><description>InnerShadow &lt;a:innerShdw></description></item>
///<item><description>LuminanceEffect &lt;a:lum></description></item>
///<item><description>OuterShadow &lt;a:outerShdw></description></item>
///<item><description>PresetShadow &lt;a:prstShdw></description></item>
///<item><description>Reflection &lt;a:reflection></description></item>
///<item><description>RelativeOffset &lt;a:relOff></description></item>
///<item><description>SoftEdge &lt;a:softEdge></description></item>
///<item><description>TintEffect &lt;a:tint></description></item>
///<item><description>TransformEffect &lt;a:xfrm></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectDag : EffectContainerType
{
    private const string tagName = "effectDag";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10084;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EffectDag class.
    /// </summary>
    public EffectDag():base(){}
            /// <summary>
    ///Initializes a new instance of the EffectDag class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectDag(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectDag class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectDag(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectDag class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectDag(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectDag>(deep);
    }

}
/// <summary>
/// Defines the EffectContainerType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectContainer &lt;a:cont></description></item>
///<item><description>Effect &lt;a:effect></description></item>
///<item><description>AlphaBiLevel &lt;a:alphaBiLevel></description></item>
///<item><description>AlphaCeiling &lt;a:alphaCeiling></description></item>
///<item><description>AlphaFloor &lt;a:alphaFloor></description></item>
///<item><description>AlphaInverse &lt;a:alphaInv></description></item>
///<item><description>AlphaModulationEffect &lt;a:alphaMod></description></item>
///<item><description>AlphaModulationFixed &lt;a:alphaModFix></description></item>
///<item><description>AlphaOutset &lt;a:alphaOutset></description></item>
///<item><description>AlphaReplace &lt;a:alphaRepl></description></item>
///<item><description>BiLevel &lt;a:biLevel></description></item>
///<item><description>Blend &lt;a:blend></description></item>
///<item><description>Blur &lt;a:blur></description></item>
///<item><description>ColorChange &lt;a:clrChange></description></item>
///<item><description>ColorReplacement &lt;a:clrRepl></description></item>
///<item><description>Duotone &lt;a:duotone></description></item>
///<item><description>Fill &lt;a:fill></description></item>
///<item><description>FillOverlay &lt;a:fillOverlay></description></item>
///<item><description>Glow &lt;a:glow></description></item>
///<item><description>Grayscale &lt;a:grayscl></description></item>
///<item><description>Hsl &lt;a:hsl></description></item>
///<item><description>InnerShadow &lt;a:innerShdw></description></item>
///<item><description>LuminanceEffect &lt;a:lum></description></item>
///<item><description>OuterShadow &lt;a:outerShdw></description></item>
///<item><description>PresetShadow &lt;a:prstShdw></description></item>
///<item><description>Reflection &lt;a:reflection></description></item>
///<item><description>RelativeOffset &lt;a:relOff></description></item>
///<item><description>SoftEdge &lt;a:softEdge></description></item>
///<item><description>TintEffect &lt;a:tint></description></item>
///<item><description>TransformEffect &lt;a:xfrm></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectContainer))]
    [ChildElementInfo(typeof(Effect))]
    [ChildElementInfo(typeof(AlphaBiLevel))]
    [ChildElementInfo(typeof(AlphaCeiling))]
    [ChildElementInfo(typeof(AlphaFloor))]
    [ChildElementInfo(typeof(AlphaInverse))]
    [ChildElementInfo(typeof(AlphaModulationEffect))]
    [ChildElementInfo(typeof(AlphaModulationFixed))]
    [ChildElementInfo(typeof(AlphaOutset))]
    [ChildElementInfo(typeof(AlphaReplace))]
    [ChildElementInfo(typeof(BiLevel))]
    [ChildElementInfo(typeof(Blend))]
    [ChildElementInfo(typeof(Blur))]
    [ChildElementInfo(typeof(ColorChange))]
    [ChildElementInfo(typeof(ColorReplacement))]
    [ChildElementInfo(typeof(Duotone))]
    [ChildElementInfo(typeof(Fill))]
    [ChildElementInfo(typeof(FillOverlay))]
    [ChildElementInfo(typeof(Glow))]
    [ChildElementInfo(typeof(Grayscale))]
    [ChildElementInfo(typeof(Hsl))]
    [ChildElementInfo(typeof(InnerShadow))]
    [ChildElementInfo(typeof(LuminanceEffect))]
    [ChildElementInfo(typeof(OuterShadow))]
    [ChildElementInfo(typeof(PresetShadow))]
    [ChildElementInfo(typeof(Reflection))]
    [ChildElementInfo(typeof(RelativeOffset))]
    [ChildElementInfo(typeof(SoftEdge))]
    [ChildElementInfo(typeof(TintEffect))]
    [ChildElementInfo(typeof(TransformEffect))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class EffectContainerType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "type","name" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Effect Container Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.EffectContainerValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.EffectContainerValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cont" == name)
    return new EffectContainer();
    
if( 10 == namespaceId && "effect" == name)
    return new Effect();
    
if( 10 == namespaceId && "alphaBiLevel" == name)
    return new AlphaBiLevel();
    
if( 10 == namespaceId && "alphaCeiling" == name)
    return new AlphaCeiling();
    
if( 10 == namespaceId && "alphaFloor" == name)
    return new AlphaFloor();
    
if( 10 == namespaceId && "alphaInv" == name)
    return new AlphaInverse();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulationEffect();
    
if( 10 == namespaceId && "alphaModFix" == name)
    return new AlphaModulationFixed();
    
if( 10 == namespaceId && "alphaOutset" == name)
    return new AlphaOutset();
    
if( 10 == namespaceId && "alphaRepl" == name)
    return new AlphaReplace();
    
if( 10 == namespaceId && "biLevel" == name)
    return new BiLevel();
    
if( 10 == namespaceId && "blend" == name)
    return new Blend();
    
if( 10 == namespaceId && "blur" == name)
    return new Blur();
    
if( 10 == namespaceId && "clrChange" == name)
    return new ColorChange();
    
if( 10 == namespaceId && "clrRepl" == name)
    return new ColorReplacement();
    
if( 10 == namespaceId && "duotone" == name)
    return new Duotone();
    
if( 10 == namespaceId && "fill" == name)
    return new Fill();
    
if( 10 == namespaceId && "fillOverlay" == name)
    return new FillOverlay();
    
if( 10 == namespaceId && "glow" == name)
    return new Glow();
    
if( 10 == namespaceId && "grayscl" == name)
    return new Grayscale();
    
if( 10 == namespaceId && "hsl" == name)
    return new Hsl();
    
if( 10 == namespaceId && "innerShdw" == name)
    return new InnerShadow();
    
if( 10 == namespaceId && "lum" == name)
    return new LuminanceEffect();
    
if( 10 == namespaceId && "outerShdw" == name)
    return new OuterShadow();
    
if( 10 == namespaceId && "prstShdw" == name)
    return new PresetShadow();
    
if( 10 == namespaceId && "reflection" == name)
    return new Reflection();
    
if( 10 == namespaceId && "relOff" == name)
    return new RelativeOffset();
    
if( 10 == namespaceId && "softEdge" == name)
    return new SoftEdge();
    
if( 10 == namespaceId && "tint" == name)
    return new TintEffect();
    
if( 10 == namespaceId && "xfrm" == name)
    return new TransformEffect();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.EffectContainerValues>();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the EffectContainerType class.
    /// </summary>
    protected EffectContainerType(){}
    
            /// <summary>
    ///Initializes a new instance of the EffectContainerType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected EffectContainerType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectContainerType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected EffectContainerType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectContainerType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected EffectContainerType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Effect : OpenXmlLeafElement
{
    private const string tagName = "effect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10054;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Effect class.
    /// </summary>
    public Effect():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Effect>(deep);
    }

   
}
/// <summary>
/// <para>Defines the AlphaBiLevel Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaBiLevel.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaBiLevel : OpenXmlLeafElement
{
    private const string tagName = "alphaBiLevel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10055;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "thresh" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Threshold.</para>
    /// <para>Represents the following attribute in the schema: thresh </para>
    /// </summary>
    [SchemaAttr(0, "thresh")]
    public Int32Value Threshold
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaBiLevel class.
    /// </summary>
    public AlphaBiLevel():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "thresh" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaBiLevel>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Ceiling Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaCeiling.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaCeiling : OpenXmlLeafElement
{
    private const string tagName = "alphaCeiling";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10056;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AlphaCeiling class.
    /// </summary>
    public AlphaCeiling():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaCeiling>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Floor Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaFloor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaFloor : OpenXmlLeafElement
{
    private const string tagName = "alphaFloor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10057;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AlphaFloor class.
    /// </summary>
    public AlphaFloor():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaFloor>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Inverse Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaInv.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaInverse : OpenXmlCompositeElement
{
    private const string tagName = "alphaInv";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10058;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AlphaInverse class.
    /// </summary>
    public AlphaInverse():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AlphaInverse class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AlphaInverse(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AlphaInverse class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AlphaInverse(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AlphaInverse class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AlphaInverse(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaInverse>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Modulate Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaMod.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectContainer &lt;a:cont></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectContainer))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaModulationEffect : OpenXmlCompositeElement
{
    private const string tagName = "alphaMod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10059;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AlphaModulationEffect class.
    /// </summary>
    public AlphaModulationEffect():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AlphaModulationEffect class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AlphaModulationEffect(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AlphaModulationEffect class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AlphaModulationEffect(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AlphaModulationEffect class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AlphaModulationEffect(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cont" == name)
    return new EffectContainer();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cont" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> EffectContainer.</para>
    /// <para> Represents the following element tag in the schema: a:cont </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectContainer EffectContainer
    {
        get 
        {
            return GetElement<EffectContainer>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaModulationEffect>(deep);
    }

   
}
/// <summary>
/// <para>Defines the AlphaModulationFixed Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaModFix.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaModulationFixed : OpenXmlLeafElement
{
    private const string tagName = "alphaModFix";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10060;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "amt" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Amount.</para>
    /// <para>Represents the following attribute in the schema: amt </para>
    /// </summary>
    [SchemaAttr(0, "amt")]
    public Int32Value Amount
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaModulationFixed class.
    /// </summary>
    public AlphaModulationFixed():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "amt" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaModulationFixed>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Inset/Outset Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaOutset.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaOutset : OpenXmlLeafElement
{
    private const string tagName = "alphaOutset";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10061;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rad" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Radius.</para>
    /// <para>Represents the following attribute in the schema: rad </para>
    /// </summary>
    [SchemaAttr(0, "rad")]
    public Int64Value Radius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaOutset class.
    /// </summary>
    public AlphaOutset():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rad" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaOutset>(deep);
    }

   
}
/// <summary>
/// <para>Alpha Replace Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:alphaRepl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlphaReplace : OpenXmlLeafElement
{
    private const string tagName = "alphaRepl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10062;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "a" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Alpha.</para>
    /// <para>Represents the following attribute in the schema: a </para>
    /// </summary>
    [SchemaAttr(0, "a")]
    public Int32Value Alpha
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AlphaReplace class.
    /// </summary>
    public AlphaReplace():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "a" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlphaReplace>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BiLevel Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:biLevel.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BiLevel : OpenXmlLeafElement
{
    private const string tagName = "biLevel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10063;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "thresh" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Threshold.</para>
    /// <para>Represents the following attribute in the schema: thresh </para>
    /// </summary>
    [SchemaAttr(0, "thresh")]
    public Int32Value Threshold
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BiLevel class.
    /// </summary>
    public BiLevel():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "thresh" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BiLevel>(deep);
    }

   
}
/// <summary>
/// <para>Blend Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blend.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectContainer &lt;a:cont></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectContainer))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Blend : OpenXmlCompositeElement
{
    private const string tagName = "blend";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10064;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blend" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Blend Mode.</para>
    /// <para>Represents the following attribute in the schema: blend </para>
    /// </summary>
    [SchemaAttr(0, "blend")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues> BlendMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Blend class.
    /// </summary>
    public Blend():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Blend class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Blend(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Blend class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Blend(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Blend class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Blend(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cont" == name)
    return new EffectContainer();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cont" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Effect to blend.</para>
    /// <para> Represents the following element tag in the schema: a:cont </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectContainer EffectContainer
    {
        get 
        {
            return GetElement<EffectContainer>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blend" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Blend>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Blur Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blur.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Blur : OpenXmlLeafElement
{
    private const string tagName = "blur";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10065;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rad","grow" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Radius.</para>
    /// <para>Represents the following attribute in the schema: rad </para>
    /// </summary>
    [SchemaAttr(0, "rad")]
    public Int64Value Radius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Grow Bounds.</para>
    /// <para>Represents the following attribute in the schema: grow </para>
    /// </summary>
    [SchemaAttr(0, "grow")]
    public BooleanValue Grow
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Blur class.
    /// </summary>
    public Blur():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rad" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "grow" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Blur>(deep);
    }

   
}
/// <summary>
/// <para>Color Change Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ColorFrom &lt;a:clrFrom></description></item>
///<item><description>ColorTo &lt;a:clrTo></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ColorFrom))]
    [ChildElementInfo(typeof(ColorTo))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorChange : OpenXmlCompositeElement
{
    private const string tagName = "clrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10066;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "useA" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Consider Alpha Values.</para>
    /// <para>Represents the following attribute in the schema: useA </para>
    /// </summary>
    [SchemaAttr(0, "useA")]
    public BooleanValue UseAlpha
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorChange class.
    /// </summary>
    public ColorChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "clrFrom" == name)
    return new ColorFrom();
    
if( 10 == namespaceId && "clrTo" == name)
    return new ColorTo();
    

    return null;
}

        private static readonly string[] eleTagNames = { "clrFrom","clrTo" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Change Color From.</para>
    /// <para> Represents the following element tag in the schema: a:clrFrom </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorFrom ColorFrom
    {
        get 
        {
            return GetElement<ColorFrom>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Change Color To.</para>
    /// <para> Represents the following element tag in the schema: a:clrTo </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorTo ColorTo
    {
        get 
        {
            return GetElement<ColorTo>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "useA" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorChange>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ColorReplacement Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrRepl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorReplacement : OpenXmlCompositeElement
{
    private const string tagName = "clrRepl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10067;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ColorReplacement class.
    /// </summary>
    public ColorReplacement():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorReplacement class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorReplacement(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorReplacement class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorReplacement(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorReplacement class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorReplacement(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorReplacement>(deep);
    }

   
}
/// <summary>
/// <para>Duotone Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:duotone.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Duotone : OpenXmlCompositeElement
{
    private const string tagName = "duotone";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10068;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Duotone class.
    /// </summary>
    public Duotone():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Duotone class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Duotone(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Duotone class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Duotone(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Duotone class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Duotone(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Duotone>(deep);
    }

   
}
/// <summary>
/// <para>Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fill : OpenXmlCompositeElement
{
    private const string tagName = "fill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10069;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Fill class.
    /// </summary>
    public Fill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Fill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

        private static readonly string[] eleTagNames = { "noFill","solidFill","gradFill","blipFill","pattFill","grpFill" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> NoFill.</para>
    /// <para> Represents the following element tag in the schema: a:noFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NoFill NoFill
    {
        get 
        {
            return GetElement<NoFill>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> SolidFill.</para>
    /// <para> Represents the following element tag in the schema: a:solidFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SolidFill SolidFill
    {
        get 
        {
            return GetElement<SolidFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GradientFill.</para>
    /// <para> Represents the following element tag in the schema: a:gradFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GradientFill GradientFill
    {
        get 
        {
            return GetElement<GradientFill>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BlipFill.</para>
    /// <para> Represents the following element tag in the schema: a:blipFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BlipFill BlipFill
    {
        get 
        {
            return GetElement<BlipFill>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Pattern Fill.</para>
    /// <para> Represents the following element tag in the schema: a:pattFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PatternFill PatternFill
    {
        get 
        {
            return GetElement<PatternFill>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Group Fill.</para>
    /// <para> Represents the following element tag in the schema: a:grpFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GroupFill GroupFill
    {
        get 
        {
            return GetElement<GroupFill>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fill>(deep);
    }

   
}
/// <summary>
/// <para>Fill Overlay Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fillOverlay.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillOverlay : OpenXmlCompositeElement
{
    private const string tagName = "fillOverlay";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10070;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blend" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Blend.</para>
    /// <para>Represents the following attribute in the schema: blend </para>
    /// </summary>
    [SchemaAttr(0, "blend")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues> Blend
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FillOverlay class.
    /// </summary>
    public FillOverlay():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FillOverlay class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillOverlay(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FillOverlay class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillOverlay(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FillOverlay class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FillOverlay(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

        private static readonly string[] eleTagNames = { "noFill","solidFill","gradFill","blipFill","pattFill","grpFill" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> NoFill.</para>
    /// <para> Represents the following element tag in the schema: a:noFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NoFill NoFill
    {
        get 
        {
            return GetElement<NoFill>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> SolidFill.</para>
    /// <para> Represents the following element tag in the schema: a:solidFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SolidFill SolidFill
    {
        get 
        {
            return GetElement<SolidFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GradientFill.</para>
    /// <para> Represents the following element tag in the schema: a:gradFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GradientFill GradientFill
    {
        get 
        {
            return GetElement<GradientFill>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BlipFill.</para>
    /// <para> Represents the following element tag in the schema: a:blipFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BlipFill BlipFill
    {
        get 
        {
            return GetElement<BlipFill>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Pattern Fill.</para>
    /// <para> Represents the following element tag in the schema: a:pattFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PatternFill PatternFill
    {
        get 
        {
            return GetElement<PatternFill>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Group Fill.</para>
    /// <para> Represents the following element tag in the schema: a:grpFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GroupFill GroupFill
    {
        get 
        {
            return GetElement<GroupFill>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blend" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BlendModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillOverlay>(deep);
    }

   
}
/// <summary>
/// <para>Glow Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:glow.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Glow : OpenXmlCompositeElement
{
    private const string tagName = "glow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10071;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rad" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Radius.</para>
    /// <para>Represents the following attribute in the schema: rad </para>
    /// </summary>
    [SchemaAttr(0, "rad")]
    public Int64Value Radius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Glow class.
    /// </summary>
    public Glow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Glow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Glow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Glow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Glow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Glow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Glow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rad" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Glow>(deep);
    }

   
}
/// <summary>
/// <para>Gray Scale Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:grayscl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Grayscale : OpenXmlLeafElement
{
    private const string tagName = "grayscl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10072;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Grayscale class.
    /// </summary>
    public Grayscale():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Grayscale>(deep);
    }

   
}
/// <summary>
/// <para>Hue Saturation Luminance Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hsl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hsl : OpenXmlLeafElement
{
    private const string tagName = "hsl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10073;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "hue","sat","lum" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hue.</para>
    /// <para>Represents the following attribute in the schema: hue </para>
    /// </summary>
    [SchemaAttr(0, "hue")]
    public Int32Value Hue
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Saturation.</para>
    /// <para>Represents the following attribute in the schema: sat </para>
    /// </summary>
    [SchemaAttr(0, "sat")]
    public Int32Value Saturation
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Luminance.</para>
    /// <para>Represents the following attribute in the schema: lum </para>
    /// </summary>
    [SchemaAttr(0, "lum")]
    public Int32Value Luminance
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Hsl class.
    /// </summary>
    public Hsl():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "hue" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sat" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "lum" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hsl>(deep);
    }

   
}
/// <summary>
/// <para>Inner Shadow Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:innerShdw.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InnerShadow : OpenXmlCompositeElement
{
    private const string tagName = "innerShdw";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10074;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blurRad","dist","dir" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Blur Radius.</para>
    /// <para>Represents the following attribute in the schema: blurRad </para>
    /// </summary>
    [SchemaAttr(0, "blurRad")]
    public Int64Value BlurRadius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Distance.</para>
    /// <para>Represents the following attribute in the schema: dist </para>
    /// </summary>
    [SchemaAttr(0, "dist")]
    public Int64Value Distance
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Direction.</para>
    /// <para>Represents the following attribute in the schema: dir </para>
    /// </summary>
    [SchemaAttr(0, "dir")]
    public Int32Value Direction
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the InnerShadow class.
    /// </summary>
    public InnerShadow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the InnerShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InnerShadow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InnerShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InnerShadow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InnerShadow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InnerShadow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blurRad" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dist" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dir" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InnerShadow>(deep);
    }

   
}
/// <summary>
/// <para>Luminance.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lum.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LuminanceEffect : OpenXmlLeafElement
{
    private const string tagName = "lum";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10075;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bright","contrast" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Brightness.</para>
    /// <para>Represents the following attribute in the schema: bright </para>
    /// </summary>
    [SchemaAttr(0, "bright")]
    public Int32Value Brightness
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Contrast.</para>
    /// <para>Represents the following attribute in the schema: contrast </para>
    /// </summary>
    [SchemaAttr(0, "contrast")]
    public Int32Value Contrast
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LuminanceEffect class.
    /// </summary>
    public LuminanceEffect():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bright" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "contrast" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LuminanceEffect>(deep);
    }

   
}
/// <summary>
/// <para>Outer Shadow Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:outerShdw.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OuterShadow : OpenXmlCompositeElement
{
    private const string tagName = "outerShdw";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10076;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blurRad","dist","dir","sx","sy","kx","ky","algn","rotWithShape" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Blur Radius.</para>
    /// <para>Represents the following attribute in the schema: blurRad </para>
    /// </summary>
    [SchemaAttr(0, "blurRad")]
    public Int64Value BlurRadius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Shadow Offset Distance.</para>
    /// <para>Represents the following attribute in the schema: dist </para>
    /// </summary>
    [SchemaAttr(0, "dist")]
    public Int64Value Distance
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Shadow Direction.</para>
    /// <para>Represents the following attribute in the schema: dir </para>
    /// </summary>
    [SchemaAttr(0, "dir")]
    public Int32Value Direction
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Scaling Factor.</para>
    /// <para>Represents the following attribute in the schema: sx </para>
    /// </summary>
    [SchemaAttr(0, "sx")]
    public Int32Value HorizontalRatio
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Scaling Factor.</para>
    /// <para>Represents the following attribute in the schema: sy </para>
    /// </summary>
    [SchemaAttr(0, "sy")]
    public Int32Value VerticalRatio
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Skew.</para>
    /// <para>Represents the following attribute in the schema: kx </para>
    /// </summary>
    [SchemaAttr(0, "kx")]
    public Int32Value HorizontalSkew
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Skew.</para>
    /// <para>Represents the following attribute in the schema: ky </para>
    /// </summary>
    [SchemaAttr(0, "ky")]
    public Int32Value VerticalSkew
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Shadow Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Rotate With Shape.</para>
    /// <para>Represents the following attribute in the schema: rotWithShape </para>
    /// </summary>
    [SchemaAttr(0, "rotWithShape")]
    public BooleanValue RotateWithShape
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OuterShadow class.
    /// </summary>
    public OuterShadow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OuterShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OuterShadow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OuterShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OuterShadow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OuterShadow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OuterShadow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blurRad" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dist" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dir" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sy" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "kx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "ky" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>();
    
if( 0 == namespaceId && "rotWithShape" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OuterShadow>(deep);
    }

   
}
/// <summary>
/// <para>Preset Shadow.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:prstShdw.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PresetShadow : OpenXmlCompositeElement
{
    private const string tagName = "prstShdw";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10077;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prst","dist","dir" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Shadow.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetShadowValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetShadowValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Distance.</para>
    /// <para>Represents the following attribute in the schema: dist </para>
    /// </summary>
    [SchemaAttr(0, "dist")]
    public Int64Value Distance
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Direction.</para>
    /// <para>Represents the following attribute in the schema: dir </para>
    /// </summary>
    [SchemaAttr(0, "dir")]
    public Int32Value Direction
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PresetShadow class.
    /// </summary>
    public PresetShadow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PresetShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetShadow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetShadow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetShadow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetShadow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PresetShadow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetShadowValues>();
    
if( 0 == namespaceId && "dist" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dir" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PresetShadow>(deep);
    }

   
}
/// <summary>
/// <para>Reflection Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:reflection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Reflection : OpenXmlLeafElement
{
    private const string tagName = "reflection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10078;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blurRad","stA","stPos","endA","endPos","dist","dir","fadeDir","sx","sy","kx","ky","algn","rotWithShape" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Blur Radius.</para>
    /// <para>Represents the following attribute in the schema: blurRad </para>
    /// </summary>
    [SchemaAttr(0, "blurRad")]
    public Int64Value BlurRadius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Start Opacity.</para>
    /// <para>Represents the following attribute in the schema: stA </para>
    /// </summary>
    [SchemaAttr(0, "stA")]
    public Int32Value StartOpacity
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Start Position.</para>
    /// <para>Represents the following attribute in the schema: stPos </para>
    /// </summary>
    [SchemaAttr(0, "stPos")]
    public Int32Value StartPosition
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> End Alpha.</para>
    /// <para>Represents the following attribute in the schema: endA </para>
    /// </summary>
    [SchemaAttr(0, "endA")]
    public Int32Value EndAlpha
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> End Position.</para>
    /// <para>Represents the following attribute in the schema: endPos </para>
    /// </summary>
    [SchemaAttr(0, "endPos")]
    public Int32Value EndPosition
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Distance.</para>
    /// <para>Represents the following attribute in the schema: dist </para>
    /// </summary>
    [SchemaAttr(0, "dist")]
    public Int64Value Distance
    {
        get { return (Int64Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Direction.</para>
    /// <para>Represents the following attribute in the schema: dir </para>
    /// </summary>
    [SchemaAttr(0, "dir")]
    public Int32Value Direction
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Fade Direction.</para>
    /// <para>Represents the following attribute in the schema: fadeDir </para>
    /// </summary>
    [SchemaAttr(0, "fadeDir")]
    public Int32Value FadeDirection
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Ratio.</para>
    /// <para>Represents the following attribute in the schema: sx </para>
    /// </summary>
    [SchemaAttr(0, "sx")]
    public Int32Value HorizontalRatio
    {
        get { return (Int32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Ratio.</para>
    /// <para>Represents the following attribute in the schema: sy </para>
    /// </summary>
    [SchemaAttr(0, "sy")]
    public Int32Value VerticalRatio
    {
        get { return (Int32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Skew.</para>
    /// <para>Represents the following attribute in the schema: kx </para>
    /// </summary>
    [SchemaAttr(0, "kx")]
    public Int32Value HorizontalSkew
    {
        get { return (Int32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Skew.</para>
    /// <para>Represents the following attribute in the schema: ky </para>
    /// </summary>
    [SchemaAttr(0, "ky")]
    public Int32Value VerticalSkew
    {
        get { return (Int32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Shadow Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Rotate With Shape.</para>
    /// <para>Represents the following attribute in the schema: rotWithShape </para>
    /// </summary>
    [SchemaAttr(0, "rotWithShape")]
    public BooleanValue RotateWithShape
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Reflection class.
    /// </summary>
    public Reflection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blurRad" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "stA" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "stPos" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "endA" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "endPos" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "dist" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dir" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "fadeDir" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sy" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "kx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "ky" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.RectangleAlignmentValues>();
    
if( 0 == namespaceId && "rotWithShape" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Reflection>(deep);
    }

   
}
/// <summary>
/// <para>Relative Offset Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:relOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RelativeOffset : OpenXmlLeafElement
{
    private const string tagName = "relOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10079;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "tx","ty" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Offset X.</para>
    /// <para>Represents the following attribute in the schema: tx </para>
    /// </summary>
    [SchemaAttr(0, "tx")]
    public Int32Value OffsetX
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Offset Y.</para>
    /// <para>Represents the following attribute in the schema: ty </para>
    /// </summary>
    [SchemaAttr(0, "ty")]
    public Int32Value OffsetY
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RelativeOffset class.
    /// </summary>
    public RelativeOffset():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "tx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "ty" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RelativeOffset>(deep);
    }

   
}
/// <summary>
/// <para>Soft Edge Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:softEdge.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SoftEdge : OpenXmlLeafElement
{
    private const string tagName = "softEdge";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10080;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rad" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Radius.</para>
    /// <para>Represents the following attribute in the schema: rad </para>
    /// </summary>
    [SchemaAttr(0, "rad")]
    public Int64Value Radius
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SoftEdge class.
    /// </summary>
    public SoftEdge():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rad" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SoftEdge>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TintEffect Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tint.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TintEffect : OpenXmlLeafElement
{
    private const string tagName = "tint";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10081;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "hue","amt" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hue.</para>
    /// <para>Represents the following attribute in the schema: hue </para>
    /// </summary>
    [SchemaAttr(0, "hue")]
    public Int32Value Hue
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Amount.</para>
    /// <para>Represents the following attribute in the schema: amt </para>
    /// </summary>
    [SchemaAttr(0, "amt")]
    public Int32Value Amount
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TintEffect class.
    /// </summary>
    public TintEffect():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "hue" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "amt" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TintEffect>(deep);
    }

   
}
/// <summary>
/// <para>Transform Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:xfrm.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TransformEffect : OpenXmlLeafElement
{
    private const string tagName = "xfrm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10082;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sx","sy","kx","ky","tx","ty" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Ratio.</para>
    /// <para>Represents the following attribute in the schema: sx </para>
    /// </summary>
    [SchemaAttr(0, "sx")]
    public Int32Value HorizontalRatio
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Ratio.</para>
    /// <para>Represents the following attribute in the schema: sy </para>
    /// </summary>
    [SchemaAttr(0, "sy")]
    public Int32Value VerticalRatio
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Skew.</para>
    /// <para>Represents the following attribute in the schema: kx </para>
    /// </summary>
    [SchemaAttr(0, "kx")]
    public Int32Value HorizontalSkew
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Skew.</para>
    /// <para>Represents the following attribute in the schema: ky </para>
    /// </summary>
    [SchemaAttr(0, "ky")]
    public Int32Value VerticalSkew
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Shift.</para>
    /// <para>Represents the following attribute in the schema: tx </para>
    /// </summary>
    [SchemaAttr(0, "tx")]
    public Int64Value HorizontalShift
    {
        get { return (Int64Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Shift.</para>
    /// <para>Represents the following attribute in the schema: ty </para>
    /// </summary>
    [SchemaAttr(0, "ty")]
    public Int64Value VerticalShift
    {
        get { return (Int64Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TransformEffect class.
    /// </summary>
    public TransformEffect():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sy" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "kx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "ky" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "tx" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "ty" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TransformEffect>(deep);
    }

   
}
/// <summary>
/// <para>Effect Container.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effectLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Blur &lt;a:blur></description></item>
///<item><description>FillOverlay &lt;a:fillOverlay></description></item>
///<item><description>Glow &lt;a:glow></description></item>
///<item><description>InnerShadow &lt;a:innerShdw></description></item>
///<item><description>OuterShadow &lt;a:outerShdw></description></item>
///<item><description>PresetShadow &lt;a:prstShdw></description></item>
///<item><description>Reflection &lt;a:reflection></description></item>
///<item><description>SoftEdge &lt;a:softEdge></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Blur))]
    [ChildElementInfo(typeof(FillOverlay))]
    [ChildElementInfo(typeof(Glow))]
    [ChildElementInfo(typeof(InnerShadow))]
    [ChildElementInfo(typeof(OuterShadow))]
    [ChildElementInfo(typeof(PresetShadow))]
    [ChildElementInfo(typeof(Reflection))]
    [ChildElementInfo(typeof(SoftEdge))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectList : OpenXmlCompositeElement
{
    private const string tagName = "effectLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10083;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EffectList class.
    /// </summary>
    public EffectList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EffectList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "blur" == name)
    return new Blur();
    
if( 10 == namespaceId && "fillOverlay" == name)
    return new FillOverlay();
    
if( 10 == namespaceId && "glow" == name)
    return new Glow();
    
if( 10 == namespaceId && "innerShdw" == name)
    return new InnerShadow();
    
if( 10 == namespaceId && "outerShdw" == name)
    return new OuterShadow();
    
if( 10 == namespaceId && "prstShdw" == name)
    return new PresetShadow();
    
if( 10 == namespaceId && "reflection" == name)
    return new Reflection();
    
if( 10 == namespaceId && "softEdge" == name)
    return new SoftEdge();
    

    return null;
}

        private static readonly string[] eleTagNames = { "blur","fillOverlay","glow","innerShdw","outerShdw","prstShdw","reflection","softEdge" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Blur Effect.</para>
    /// <para> Represents the following element tag in the schema: a:blur </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Blur Blur
    {
        get 
        {
            return GetElement<Blur>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> FillOverlay.</para>
    /// <para> Represents the following element tag in the schema: a:fillOverlay </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FillOverlay FillOverlay
    {
        get 
        {
            return GetElement<FillOverlay>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Glow.</para>
    /// <para> Represents the following element tag in the schema: a:glow </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Glow Glow
    {
        get 
        {
            return GetElement<Glow>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> InnerShadow.</para>
    /// <para> Represents the following element tag in the schema: a:innerShdw </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public InnerShadow InnerShadow
    {
        get 
        {
            return GetElement<InnerShadow>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> OuterShadow.</para>
    /// <para> Represents the following element tag in the schema: a:outerShdw </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public OuterShadow OuterShadow
    {
        get 
        {
            return GetElement<OuterShadow>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> PresetShadow.</para>
    /// <para> Represents the following element tag in the schema: a:prstShdw </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetShadow PresetShadow
    {
        get 
        {
            return GetElement<PresetShadow>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Reflection.</para>
    /// <para> Represents the following element tag in the schema: a:reflection </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Reflection Reflection
    {
        get 
        {
            return GetElement<Reflection>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> SoftEdge.</para>
    /// <para> Represents the following element tag in the schema: a:softEdge </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SoftEdge SoftEdge
    {
        get 
        {
            return GetElement<SoftEdge>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectList>(deep);
    }

   
}
/// <summary>
/// <para>Custom geometry.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:custGeom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AdjustValueList &lt;a:avLst></description></item>
///<item><description>ShapeGuideList &lt;a:gdLst></description></item>
///<item><description>AdjustHandleList &lt;a:ahLst></description></item>
///<item><description>ConnectionSiteList &lt;a:cxnLst></description></item>
///<item><description>Rectangle &lt;a:rect></description></item>
///<item><description>PathList &lt;a:pathLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AdjustValueList))]
    [ChildElementInfo(typeof(ShapeGuideList))]
    [ChildElementInfo(typeof(AdjustHandleList))]
    [ChildElementInfo(typeof(ConnectionSiteList))]
    [ChildElementInfo(typeof(Rectangle))]
    [ChildElementInfo(typeof(PathList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomGeometry : OpenXmlCompositeElement
{
    private const string tagName = "custGeom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10085;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomGeometry class.
    /// </summary>
    public CustomGeometry():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomGeometry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomGeometry(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomGeometry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomGeometry(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomGeometry class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomGeometry(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "avLst" == name)
    return new AdjustValueList();
    
if( 10 == namespaceId && "gdLst" == name)
    return new ShapeGuideList();
    
if( 10 == namespaceId && "ahLst" == name)
    return new AdjustHandleList();
    
if( 10 == namespaceId && "cxnLst" == name)
    return new ConnectionSiteList();
    
if( 10 == namespaceId && "rect" == name)
    return new Rectangle();
    
if( 10 == namespaceId && "pathLst" == name)
    return new PathList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "avLst","gdLst","ahLst","cxnLst","rect","pathLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Adjust Value List.</para>
    /// <para> Represents the following element tag in the schema: a:avLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public AdjustValueList AdjustValueList
    {
        get 
        {
            return GetElement<AdjustValueList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> List of Shape Guides.</para>
    /// <para> Represents the following element tag in the schema: a:gdLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeGuideList ShapeGuideList
    {
        get 
        {
            return GetElement<ShapeGuideList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> List of Shape Adjust Handles.</para>
    /// <para> Represents the following element tag in the schema: a:ahLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public AdjustHandleList AdjustHandleList
    {
        get 
        {
            return GetElement<AdjustHandleList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> List of Shape Connection Sites.</para>
    /// <para> Represents the following element tag in the schema: a:cxnLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ConnectionSiteList ConnectionSiteList
    {
        get 
        {
            return GetElement<ConnectionSiteList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Shape Text Rectangle.</para>
    /// <para> Represents the following element tag in the schema: a:rect </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Rectangle Rectangle
    {
        get 
        {
            return GetElement<Rectangle>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> List of Shape Paths.</para>
    /// <para> Represents the following element tag in the schema: a:pathLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PathList PathList
    {
        get 
        {
            return GetElement<PathList>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomGeometry>(deep);
    }

   
}
/// <summary>
/// <para>Preset geometry.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:prstGeom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AdjustValueList &lt;a:avLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AdjustValueList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PresetGeometry : OpenXmlCompositeElement
{
    private const string tagName = "prstGeom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10086;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prst" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Shape.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ShapeTypeValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ShapeTypeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PresetGeometry class.
    /// </summary>
    public PresetGeometry():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PresetGeometry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetGeometry(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetGeometry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetGeometry(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetGeometry class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PresetGeometry(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "avLst" == name)
    return new AdjustValueList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "avLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> List of Shape Adjust Values.</para>
    /// <para> Represents the following element tag in the schema: a:avLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public AdjustValueList AdjustValueList
    {
        get 
        {
            return GetElement<AdjustValueList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ShapeTypeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PresetGeometry>(deep);
    }

   
}
/// <summary>
/// <para>Preset Text Warp.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:prstTxWarp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AdjustValueList &lt;a:avLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AdjustValueList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PresetTextWrap : OpenXmlCompositeElement
{
    private const string tagName = "prstTxWarp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10087;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prst" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Warp Shape.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextShapeValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextShapeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PresetTextWrap class.
    /// </summary>
    public PresetTextWrap():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PresetTextWrap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetTextWrap(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetTextWrap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PresetTextWrap(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PresetTextWrap class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PresetTextWrap(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "avLst" == name)
    return new AdjustValueList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "avLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Adjust Value List.</para>
    /// <para> Represents the following element tag in the schema: a:avLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public AdjustValueList AdjustValueList
    {
        get 
        {
            return GetElement<AdjustValueList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextShapeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PresetTextWrap>(deep);
    }

   
}
/// <summary>
/// <para>Round Line Join.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:round.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Round : OpenXmlLeafElement
{
    private const string tagName = "round";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10088;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Round class.
    /// </summary>
    public Round():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Round>(deep);
    }

   
}
/// <summary>
/// <para>Line Join Bevel.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bevel.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineJoinBevel : OpenXmlLeafElement
{
    private const string tagName = "bevel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10089;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the LineJoinBevel class.
    /// </summary>
    public LineJoinBevel():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineJoinBevel>(deep);
    }

   
}
/// <summary>
/// <para>Miter Line Join.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:miter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Miter : OpenXmlLeafElement
{
    private const string tagName = "miter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10090;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lim" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Miter Join Limit.</para>
    /// <para>Represents the following attribute in the schema: lim </para>
    /// </summary>
    [SchemaAttr(0, "lim")]
    public Int32Value Limit
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Miter class.
    /// </summary>
    public Miter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "lim" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Miter>(deep);
    }

   
}
/// <summary>
/// <para>Preset Dash.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:prstDash.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PresetDash : OpenXmlLeafElement
{
    private const string tagName = "prstDash";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10091;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetLineDashValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetLineDashValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PresetDash class.
    /// </summary>
    public PresetDash():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetLineDashValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PresetDash>(deep);
    }

   
}
/// <summary>
/// <para>Custom Dash.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:custDash.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DashStop &lt;a:ds></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DashStop))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomDash : OpenXmlCompositeElement
{
    private const string tagName = "custDash";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10092;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomDash class.
    /// </summary>
    public CustomDash():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomDash class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomDash(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomDash class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomDash(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomDash class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomDash(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ds" == name)
    return new DashStop();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomDash>(deep);
    }

   
}
/// <summary>
/// <para>Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillProperties : OpenXmlCompositeElement
{
    private const string tagName = "fill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10093;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FillProperties class.
    /// </summary>
    public FillProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FillProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FillProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FillProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FillProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

        private static readonly string[] eleTagNames = { "noFill","solidFill","gradFill","blipFill","pattFill","grpFill" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> NoFill.</para>
    /// <para> Represents the following element tag in the schema: a:noFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NoFill NoFill
    {
        get 
        {
            return GetElement<NoFill>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> SolidFill.</para>
    /// <para> Represents the following element tag in the schema: a:solidFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SolidFill SolidFill
    {
        get 
        {
            return GetElement<SolidFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GradientFill.</para>
    /// <para> Represents the following element tag in the schema: a:gradFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GradientFill GradientFill
    {
        get 
        {
            return GetElement<GradientFill>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BlipFill.</para>
    /// <para> Represents the following element tag in the schema: a:blipFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BlipFill BlipFill
    {
        get 
        {
            return GetElement<BlipFill>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Pattern Fill.</para>
    /// <para> Represents the following element tag in the schema: a:pattFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PatternFill PatternFill
    {
        get 
        {
            return GetElement<PatternFill>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Group Fill.</para>
    /// <para> Represents the following element tag in the schema: a:grpFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GroupFill GroupFill
    {
        get 
        {
            return GetElement<GroupFill>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillProperties>(deep);
    }

   
}
/// <summary>
/// <para>Fill Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fillRef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillReference : StyleMatrixReferenceType
{
    private const string tagName = "fillRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10094;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FillReference class.
    /// </summary>
    public FillReference():base(){}
            /// <summary>
    ///Initializes a new instance of the FillReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillReference(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FillReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillReference(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FillReference class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FillReference(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillReference>(deep);
    }

}
/// <summary>
/// <para>Effect Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effectRef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectReference : StyleMatrixReferenceType
{
    private const string tagName = "effectRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10096;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EffectReference class.
    /// </summary>
    public EffectReference():base(){}
            /// <summary>
    ///Initializes a new instance of the EffectReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectReference(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectReference(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectReference class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectReference(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectReference>(deep);
    }

}
/// <summary>
/// <para>Defines the LineReference Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnRef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineReference : StyleMatrixReferenceType
{
    private const string tagName = "lnRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10236;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LineReference class.
    /// </summary>
    public LineReference():base(){}
            /// <summary>
    ///Initializes a new instance of the LineReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineReference(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LineReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineReference(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LineReference class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LineReference(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineReference>(deep);
    }

}
/// <summary>
/// Defines the StyleMatrixReferenceType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class StyleMatrixReferenceType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "idx" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Style Matrix Index.</para>
    /// <para>Represents the following attribute in the schema: idx </para>
    /// </summary>
    [SchemaAttr(0, "idx")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "idx" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the StyleMatrixReferenceType class.
    /// </summary>
    protected StyleMatrixReferenceType(){}
    
            /// <summary>
    ///Initializes a new instance of the StyleMatrixReferenceType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected StyleMatrixReferenceType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleMatrixReferenceType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected StyleMatrixReferenceType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleMatrixReferenceType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected StyleMatrixReferenceType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Effect.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effect.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectPropertiesType : OpenXmlCompositeElement
{
    private const string tagName = "effect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10095;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EffectPropertiesType class.
    /// </summary>
    public EffectPropertiesType():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EffectPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectPropertiesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectPropertiesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectPropertiesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectPropertiesType(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    

    return null;
}

        private static readonly string[] eleTagNames = { "effectLst","effectDag" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Effect Container.</para>
    /// <para> Represents the following element tag in the schema: a:effectLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectList EffectList
    {
        get 
        {
            return GetElement<EffectList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Effect Container.</para>
    /// <para> Represents the following element tag in the schema: a:effectDag </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectDag EffectDag
    {
        get 
        {
            return GetElement<EffectDag>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectPropertiesType>(deep);
    }

   
}
/// <summary>
/// <para>Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:font.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SupplementalFont &lt;a:font></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fonts : FontCollectionType
{
    private const string tagName = "font";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10097;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Fonts class.
    /// </summary>
    public Fonts():base(){}
            /// <summary>
    ///Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fonts(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fonts>(deep);
    }

}
/// <summary>
/// <para>Major Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:majorFont.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SupplementalFont &lt;a:font></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MajorFont : FontCollectionType
{
    private const string tagName = "majorFont";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10136;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MajorFont class.
    /// </summary>
    public MajorFont():base(){}
            /// <summary>
    ///Initializes a new instance of the MajorFont class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MajorFont(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MajorFont class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MajorFont(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MajorFont class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MajorFont(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MajorFont>(deep);
    }

}
/// <summary>
/// <para>Minor fonts.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:minorFont.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SupplementalFont &lt;a:font></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MinorFont : FontCollectionType
{
    private const string tagName = "minorFont";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10137;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MinorFont class.
    /// </summary>
    public MinorFont():base(){}
            /// <summary>
    ///Initializes a new instance of the MinorFont class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MinorFont(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MinorFont class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MinorFont(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MinorFont class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MinorFont(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MinorFont>(deep);
    }

}
/// <summary>
/// Defines the FontCollectionType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SupplementalFont &lt;a:font></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LatinFont))]
    [ChildElementInfo(typeof(EastAsianFont))]
    [ChildElementInfo(typeof(ComplexScriptFont))]
    [ChildElementInfo(typeof(SupplementalFont))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class FontCollectionType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "latin" == name)
    return new LatinFont();
    
if( 10 == namespaceId && "ea" == name)
    return new EastAsianFont();
    
if( 10 == namespaceId && "cs" == name)
    return new ComplexScriptFont();
    
if( 10 == namespaceId && "font" == name)
    return new SupplementalFont();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "latin","ea","cs","font","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Latin Font.</para>
    /// <para> Represents the following element tag in the schema: a:latin </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LatinFont LatinFont
    {
        get 
        {
            return GetElement<LatinFont>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> East Asian Font.</para>
    /// <para> Represents the following element tag in the schema: a:ea </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EastAsianFont EastAsianFont
    {
        get 
        {
            return GetElement<EastAsianFont>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Complex Script Font.</para>
    /// <para> Represents the following element tag in the schema: a:cs </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ComplexScriptFont ComplexScriptFont
    {
        get 
        {
            return GetElement<ComplexScriptFont>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the FontCollectionType class.
    /// </summary>
    protected FontCollectionType(){}
    
            /// <summary>
    ///Initializes a new instance of the FontCollectionType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected FontCollectionType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FontCollectionType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected FontCollectionType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FontCollectionType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected FontCollectionType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the FontReference Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fontRef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontReference : OpenXmlCompositeElement
{
    private const string tagName = "fontRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10098;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "idx" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Identifier.</para>
    /// <para>Represents the following attribute in the schema: idx </para>
    /// </summary>
    [SchemaAttr(0, "idx")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.FontCollectionIndexValues> Index
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.FontCollectionIndexValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontReference class.
    /// </summary>
    public FontReference():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FontReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FontReference(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FontReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FontReference(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FontReference class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FontReference(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "idx" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.FontCollectionIndexValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontReference>(deep);
    }

   
}
/// <summary>
/// <para>No AutoFit.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:noAutofit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoAutoFit : OpenXmlLeafElement
{
    private const string tagName = "noAutofit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10099;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NoAutoFit class.
    /// </summary>
    public NoAutoFit():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoAutoFit>(deep);
    }

   
}
/// <summary>
/// <para>Normal AutoFit.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:normAutofit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NormalAutoFit : OpenXmlLeafElement
{
    private const string tagName = "normAutofit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10100;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fontScale","lnSpcReduction" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Scale.</para>
    /// <para>Represents the following attribute in the schema: fontScale </para>
    /// </summary>
    [SchemaAttr(0, "fontScale")]
    public Int32Value FontScale
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Line Space Reduction.</para>
    /// <para>Represents the following attribute in the schema: lnSpcReduction </para>
    /// </summary>
    [SchemaAttr(0, "lnSpcReduction")]
    public Int32Value LineSpaceReduction
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NormalAutoFit class.
    /// </summary>
    public NormalAutoFit():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fontScale" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "lnSpcReduction" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NormalAutoFit>(deep);
    }

   
}
/// <summary>
/// <para>Shape AutoFit.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spAutoFit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeAutoFit : OpenXmlLeafElement
{
    private const string tagName = "spAutoFit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10101;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ShapeAutoFit class.
    /// </summary>
    public ShapeAutoFit():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeAutoFit>(deep);
    }

   
}
/// <summary>
/// <para>Follow Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buClrTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletColorText : OpenXmlLeafElement
{
    private const string tagName = "buClrTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10102;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BulletColorText class.
    /// </summary>
    public BulletColorText():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletColorText>(deep);
    }

   
}
/// <summary>
/// <para>Color Specified.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletColor : ColorType
{
    private const string tagName = "buClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10103;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BulletColor class.
    /// </summary>
    public BulletColor():base(){}
            /// <summary>
    ///Initializes a new instance of the BulletColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BulletColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BulletColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BulletColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BulletColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BulletColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletColor>(deep);
    }

}
/// <summary>
/// <para>Extrusion Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extrusionClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExtrusionColor : ColorType
{
    private const string tagName = "extrusionClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10201;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ExtrusionColor class.
    /// </summary>
    public ExtrusionColor():base(){}
            /// <summary>
    ///Initializes a new instance of the ExtrusionColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtrusionColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtrusionColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtrusionColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtrusionColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExtrusionColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExtrusionColor>(deep);
    }

}
/// <summary>
/// <para>Contour Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:contourClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ContourColor : ColorType
{
    private const string tagName = "contourClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10202;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ContourColor class.
    /// </summary>
    public ContourColor():base(){}
            /// <summary>
    ///Initializes a new instance of the ContourColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ContourColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ContourColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ContourColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ContourColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ContourColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ContourColor>(deep);
    }

}
/// <summary>
/// <para>Change Color From.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrFrom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorFrom : ColorType
{
    private const string tagName = "clrFrom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10203;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorFrom class.
    /// </summary>
    public ColorFrom():base(){}
            /// <summary>
    ///Initializes a new instance of the ColorFrom class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorFrom(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorFrom class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorFrom(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorFrom class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorFrom(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorFrom>(deep);
    }

}
/// <summary>
/// <para>Change Color To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorTo : ColorType
{
    private const string tagName = "clrTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10204;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorTo class.
    /// </summary>
    public ColorTo():base(){}
            /// <summary>
    ///Initializes a new instance of the ColorTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorTo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorTo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorTo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorTo(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorTo>(deep);
    }

}
/// <summary>
/// <para>Foreground color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fgClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ForegroundColor : ColorType
{
    private const string tagName = "fgClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10211;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ForegroundColor class.
    /// </summary>
    public ForegroundColor():base(){}
            /// <summary>
    ///Initializes a new instance of the ForegroundColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ForegroundColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ForegroundColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ForegroundColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ForegroundColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ForegroundColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ForegroundColor>(deep);
    }

}
/// <summary>
/// <para>Background color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bgClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BackgroundColor : ColorType
{
    private const string tagName = "bgClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10212;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BackgroundColor class.
    /// </summary>
    public BackgroundColor():base(){}
            /// <summary>
    ///Initializes a new instance of the BackgroundColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BackgroundColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BackgroundColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BackgroundColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BackgroundColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BackgroundColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BackgroundColor>(deep);
    }

}
/// <summary>
/// <para>Defines the Highlight Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:highlight.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Highlight : ColorType
{
    private const string tagName = "highlight";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10341;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Highlight class.
    /// </summary>
    public Highlight():base(){}
            /// <summary>
    ///Initializes a new instance of the Highlight class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Highlight(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Highlight class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Highlight(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Highlight class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Highlight(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Highlight>(deep);
    }

}
/// <summary>
/// Defines the ColorType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ColorType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the ColorType class.
    /// </summary>
    protected ColorType(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ColorType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ColorType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected ColorType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Bullet Size Follows Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buSzTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletSizeText : OpenXmlLeafElement
{
    private const string tagName = "buSzTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10104;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BulletSizeText class.
    /// </summary>
    public BulletSizeText():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletSizeText>(deep);
    }

   
}
/// <summary>
/// <para>Bullet Size Percentage.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buSzPct.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletSizePercentage : OpenXmlLeafElement
{
    private const string tagName = "buSzPct";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10105;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BulletSizePercentage class.
    /// </summary>
    public BulletSizePercentage():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletSizePercentage>(deep);
    }

   
}
/// <summary>
/// <para>Bullet Size Points.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buSzPts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletSizePoints : OpenXmlLeafElement
{
    private const string tagName = "buSzPts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10106;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BulletSizePoints class.
    /// </summary>
    public BulletSizePoints():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletSizePoints>(deep);
    }

   
}
/// <summary>
/// <para>Follow text.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buFontTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletFontText : OpenXmlLeafElement
{
    private const string tagName = "buFontTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10107;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BulletFontText class.
    /// </summary>
    public BulletFontText():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletFontText>(deep);
    }

   
}
/// <summary>
/// <para>Specified.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buFont.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BulletFont : TextFontType
{
    private const string tagName = "buFont";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10108;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BulletFont class.
    /// </summary>
    public BulletFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BulletFont>(deep);
    }

}
/// <summary>
/// <para>Latin Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:latin.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LatinFont : TextFontType
{
    private const string tagName = "latin";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10131;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LatinFont class.
    /// </summary>
    public LatinFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LatinFont>(deep);
    }

}
/// <summary>
/// <para>East Asian Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ea.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EastAsianFont : TextFontType
{
    private const string tagName = "ea";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10132;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EastAsianFont class.
    /// </summary>
    public EastAsianFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EastAsianFont>(deep);
    }

}
/// <summary>
/// <para>Complex Script Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ComplexScriptFont : TextFontType
{
    private const string tagName = "cs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10133;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ComplexScriptFont class.
    /// </summary>
    public ComplexScriptFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ComplexScriptFont>(deep);
    }

}
/// <summary>
/// <para>Defines the SymbolFont Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sym.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SymbolFont : TextFontType
{
    private const string tagName = "sym";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10342;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SymbolFont class.
    /// </summary>
    public SymbolFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SymbolFont>(deep);
    }

}
/// <summary>
/// Defines the TextFontType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TextFontType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "typeface","panose","pitchFamily","charset" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Text Typeface.</para>
    /// <para>Represents the following attribute in the schema: typeface </para>
    /// </summary>
    [SchemaAttr(0, "typeface")]
    public StringValue Typeface
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Panose Setting.</para>
    /// <para>Represents the following attribute in the schema: panose </para>
    /// </summary>
    [SchemaAttr(0, "panose")]
    public HexBinaryValue Panose
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Similar Font Family.</para>
    /// <para>Represents the following attribute in the schema: pitchFamily </para>
    /// </summary>
    [SchemaAttr(0, "pitchFamily")]
    public SByteValue PitchFamily
    {
        get { return (SByteValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Similar Character Set.</para>
    /// <para>Represents the following attribute in the schema: charset </para>
    /// </summary>
    [SchemaAttr(0, "charset")]
    public SByteValue CharacterSet
    {
        get { return (SByteValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "typeface" == name)
    return new StringValue();
    
if( 0 == namespaceId && "panose" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "pitchFamily" == name)
    return new SByteValue();
    
if( 0 == namespaceId && "charset" == name)
    return new SByteValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TextFontType class.
    /// </summary>
    protected TextFontType(){}
    
    
    
}
/// <summary>
/// <para>No Bullet.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buNone.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoBullet : OpenXmlLeafElement
{
    private const string tagName = "buNone";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10109;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NoBullet class.
    /// </summary>
    public NoBullet():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoBullet>(deep);
    }

   
}
/// <summary>
/// <para>Auto-Numbered Bullet.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buAutoNum.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoNumberedBullet : OpenXmlLeafElement
{
    private const string tagName = "buAutoNum";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10110;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","startAt" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Bullet Autonumbering Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextAutoNumberSchemeValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextAutoNumberSchemeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Start Numbering At.</para>
    /// <para>Represents the following attribute in the schema: startAt </para>
    /// </summary>
    [SchemaAttr(0, "startAt")]
    public Int32Value StartAt
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoNumberedBullet class.
    /// </summary>
    public AutoNumberedBullet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextAutoNumberSchemeValues>();
    
if( 0 == namespaceId && "startAt" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoNumberedBullet>(deep);
    }

   
}
/// <summary>
/// <para>Character Bullet.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buChar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CharacterBullet : OpenXmlLeafElement
{
    private const string tagName = "buChar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10111;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "char" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Bullet Character.</para>
    /// <para>Represents the following attribute in the schema: char </para>
    /// </summary>
    [SchemaAttr(0, "char")]
    public StringValue Char
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CharacterBullet class.
    /// </summary>
    public CharacterBullet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "char" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CharacterBullet>(deep);
    }

   
}
/// <summary>
/// <para>Picture Bullet.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:buBlip.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Blip &lt;a:blip></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Blip))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PictureBullet : OpenXmlCompositeElement
{
    private const string tagName = "buBlip";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10112;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PictureBullet class.
    /// </summary>
    public PictureBullet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PictureBullet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureBullet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureBullet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureBullet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureBullet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PictureBullet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "blip" == name)
    return new Blip();
    

    return null;
}

        private static readonly string[] eleTagNames = { "blip" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Blip.</para>
    /// <para> Represents the following element tag in the schema: a:blip </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Blip Blip
    {
        get 
        {
            return GetElement<Blip>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PictureBullet>(deep);
    }

   
}
/// <summary>
/// <para>Underline Follows Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:uLnTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnderlineFollowsText : OpenXmlLeafElement
{
    private const string tagName = "uLnTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10113;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the UnderlineFollowsText class.
    /// </summary>
    public UnderlineFollowsText():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnderlineFollowsText>(deep);
    }

   
}
/// <summary>
/// <para>Underline Stroke.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:uLn.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Underline : LinePropertiesType
{
    private const string tagName = "uLn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10114;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Underline class.
    /// </summary>
    public Underline():base(){}
            /// <summary>
    ///Initializes a new instance of the Underline class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Underline(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Underline class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Underline(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Underline class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Underline(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Underline>(deep);
    }

}
/// <summary>
/// <para>Defines the Outline Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ln.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Outline : LinePropertiesType
{
    private const string tagName = "ln";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10138;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Outline class.
    /// </summary>
    public Outline():base(){}
            /// <summary>
    ///Initializes a new instance of the Outline class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Outline(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Outline class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Outline(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Outline class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Outline(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Outline>(deep);
    }

}
/// <summary>
/// <para>Left Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnL.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnL";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10247;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftBorderLineProperties class.
    /// </summary>
    public LeftBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the LeftBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LeftBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftBorderLineProperties>(deep);
    }

}
/// <summary>
/// <para>Right Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnR.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnR";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10248;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightBorderLineProperties class.
    /// </summary>
    public RightBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the RightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RightBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightBorderLineProperties>(deep);
    }

}
/// <summary>
/// <para>Top Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnT.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnT";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10249;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopBorderLineProperties class.
    /// </summary>
    public TopBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the TopBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopBorderLineProperties>(deep);
    }

}
/// <summary>
/// <para>Bottom Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnB.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnB";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10250;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomBorderLineProperties class.
    /// </summary>
    public BottomBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the BottomBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BottomBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomBorderLineProperties>(deep);
    }

}
/// <summary>
/// <para>Top-Left to Bottom-Right Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnTlToBr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopLeftToBottomRightBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnTlToBr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10251;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorderLineProperties class.
    /// </summary>
    public TopLeftToBottomRightBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the TopLeftToBottomRightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopLeftToBottomRightBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopLeftToBottomRightBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopLeftToBottomRightBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopLeftToBottomRightBorderLineProperties>(deep);
    }

}
/// <summary>
/// <para>Bottom-Left to Top-Right Border Line Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnBlToTr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomLeftToTopRightBorderLineProperties : LinePropertiesType
{
    private const string tagName = "lnBlToTr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10252;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomLeftToTopRightBorderLineProperties class.
    /// </summary>
    public BottomLeftToTopRightBorderLineProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the BottomLeftToTopRightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomLeftToTopRightBorderLineProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomLeftToTopRightBorderLineProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomLeftToTopRightBorderLineProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomLeftToTopRightBorderLineProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BottomLeftToTopRightBorderLineProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomLeftToTopRightBorderLineProperties>(deep);
    }

}
/// <summary>
/// Defines the LinePropertiesType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>PresetDash &lt;a:prstDash></description></item>
///<item><description>CustomDash &lt;a:custDash></description></item>
///<item><description>Round &lt;a:round></description></item>
///<item><description>LineJoinBevel &lt;a:bevel></description></item>
///<item><description>Miter &lt;a:miter></description></item>
///<item><description>HeadEnd &lt;a:headEnd></description></item>
///<item><description>TailEnd &lt;a:tailEnd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(PresetDash))]
    [ChildElementInfo(typeof(CustomDash))]
    [ChildElementInfo(typeof(Round))]
    [ChildElementInfo(typeof(LineJoinBevel))]
    [ChildElementInfo(typeof(Miter))]
    [ChildElementInfo(typeof(HeadEnd))]
    [ChildElementInfo(typeof(TailEnd))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class LinePropertiesType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "w","cap","cmpd","algn" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Line Width.</para>
    /// <para>Represents the following attribute in the schema: w </para>
    /// </summary>
    [SchemaAttr(0, "w")]
    public Int32Value Width
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Line Ending Cap Type.</para>
    /// <para>Represents the following attribute in the schema: cap </para>
    /// </summary>
    [SchemaAttr(0, "cap")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LineCapValues> CapType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LineCapValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Compound Line Type.</para>
    /// <para>Represents the following attribute in the schema: cmpd </para>
    /// </summary>
    [SchemaAttr(0, "cmpd")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.CompoundLineValues> CompoundLineType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.CompoundLineValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Stroke Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PenAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PenAlignmentValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "prstDash" == name)
    return new PresetDash();
    
if( 10 == namespaceId && "custDash" == name)
    return new CustomDash();
    
if( 10 == namespaceId && "round" == name)
    return new Round();
    
if( 10 == namespaceId && "bevel" == name)
    return new LineJoinBevel();
    
if( 10 == namespaceId && "miter" == name)
    return new Miter();
    
if( 10 == namespaceId && "headEnd" == name)
    return new HeadEnd();
    
if( 10 == namespaceId && "tailEnd" == name)
    return new TailEnd();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "w" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "cap" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LineCapValues>();
    
if( 0 == namespaceId && "cmpd" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.CompoundLineValues>();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PenAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the LinePropertiesType class.
    /// </summary>
    protected LinePropertiesType(){}
    
            /// <summary>
    ///Initializes a new instance of the LinePropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected LinePropertiesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LinePropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected LinePropertiesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LinePropertiesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected LinePropertiesType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Underline Fill Properties Follow Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:uFillTx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnderlineFillText : OpenXmlLeafElement
{
    private const string tagName = "uFillTx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10115;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the UnderlineFillText class.
    /// </summary>
    public UnderlineFillText():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnderlineFillText>(deep);
    }

   
}
/// <summary>
/// <para>Underline Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:uFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnderlineFill : OpenXmlCompositeElement
{
    private const string tagName = "uFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10116;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the UnderlineFill class.
    /// </summary>
    public UnderlineFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the UnderlineFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public UnderlineFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the UnderlineFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public UnderlineFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the UnderlineFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public UnderlineFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

        private static readonly string[] eleTagNames = { "noFill","solidFill","gradFill","blipFill","pattFill","grpFill" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> NoFill.</para>
    /// <para> Represents the following element tag in the schema: a:noFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NoFill NoFill
    {
        get 
        {
            return GetElement<NoFill>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> SolidFill.</para>
    /// <para> Represents the following element tag in the schema: a:solidFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SolidFill SolidFill
    {
        get 
        {
            return GetElement<SolidFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GradientFill.</para>
    /// <para> Represents the following element tag in the schema: a:gradFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GradientFill GradientFill
    {
        get 
        {
            return GetElement<GradientFill>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BlipFill.</para>
    /// <para> Represents the following element tag in the schema: a:blipFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BlipFill BlipFill
    {
        get 
        {
            return GetElement<BlipFill>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Pattern Fill.</para>
    /// <para> Represents the following element tag in the schema: a:pattFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PatternFill PatternFill
    {
        get 
        {
            return GetElement<PatternFill>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Group Fill.</para>
    /// <para> Represents the following element tag in the schema: a:grpFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GroupFill GroupFill
    {
        get 
        {
            return GetElement<GroupFill>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnderlineFill>(deep);
    }

   
}
/// <summary>
/// <para>Text Run.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:r.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;a:rPr></description></item>
///<item><description>Text &lt;a:t></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(Text))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Run : OpenXmlCompositeElement
{
    private const string tagName = "r";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10117;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Run class.
    /// </summary>
    public Run():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Run(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 10 == namespaceId && "t" == name)
    return new Text();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr","t" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Character Properties.</para>
    /// <para> Represents the following element tag in the schema: a:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RunProperties RunProperties
    {
        get 
        {
            return GetElement<RunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Text String.</para>
    /// <para> Represents the following element tag in the schema: a:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Text Text
    {
        get 
        {
            return GetElement<Text>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Run>(deep);
    }

   
}
/// <summary>
/// <para>Text Line Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:br.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;a:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Break : OpenXmlCompositeElement
{
    private const string tagName = "br";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10118;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Break class.
    /// </summary>
    public Break():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Break class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Break(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Break class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Break(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Break class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Break(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "rPr" == name)
    return new RunProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Run Properties.</para>
    /// <para> Represents the following element tag in the schema: a:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RunProperties RunProperties
    {
        get 
        {
            return GetElement<RunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Break>(deep);
    }

   
}
/// <summary>
/// <para>Text Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fld.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;a:rPr></description></item>
///<item><description>ParagraphProperties &lt;a:pPr></description></item>
///<item><description>Text &lt;a:t></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(ParagraphProperties))]
    [ChildElementInfo(typeof(Text))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Field : OpenXmlCompositeElement
{
    private const string tagName = "fld";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10119;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","type" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field ID.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public StringValue Type
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Field class.
    /// </summary>
    public Field():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Field class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Field(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Field class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Field(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Field class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Field(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 10 == namespaceId && "pPr" == name)
    return new ParagraphProperties();
    
if( 10 == namespaceId && "t" == name)
    return new Text();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr","pPr","t" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Character Properties.</para>
    /// <para> Represents the following element tag in the schema: a:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RunProperties RunProperties
    {
        get 
        {
            return GetElement<RunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Text Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: a:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ParagraphProperties ParagraphProperties
    {
        get 
        {
            return GetElement<ParagraphProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Text.</para>
    /// <para> Represents the following element tag in the schema: a:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Text Text
    {
        get 
        {
            return GetElement<Text>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "type" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Field>(deep);
    }

   
}
/// <summary>
/// <para>Graphic Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:graphic.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GraphicData &lt;a:graphicData></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GraphicData))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Graphic : OpenXmlCompositeElement
{
    private const string tagName = "graphic";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10120;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Graphic class.
    /// </summary>
    public Graphic():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Graphic class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Graphic(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Graphic class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Graphic(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Graphic class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Graphic(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "graphicData" == name)
    return new GraphicData();
    

    return null;
}

        private static readonly string[] eleTagNames = { "graphicData" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Graphic Object Data.</para>
    /// <para> Represents the following element tag in the schema: a:graphicData </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GraphicData GraphicData
    {
        get 
        {
            return GetElement<GraphicData>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Graphic>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Blip Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:blip.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AlphaBiLevel &lt;a:alphaBiLevel></description></item>
///<item><description>AlphaCeiling &lt;a:alphaCeiling></description></item>
///<item><description>AlphaFloor &lt;a:alphaFloor></description></item>
///<item><description>AlphaInverse &lt;a:alphaInv></description></item>
///<item><description>AlphaModulationEffect &lt;a:alphaMod></description></item>
///<item><description>AlphaModulationFixed &lt;a:alphaModFix></description></item>
///<item><description>AlphaReplace &lt;a:alphaRepl></description></item>
///<item><description>BiLevel &lt;a:biLevel></description></item>
///<item><description>Blur &lt;a:blur></description></item>
///<item><description>ColorChange &lt;a:clrChange></description></item>
///<item><description>ColorReplacement &lt;a:clrRepl></description></item>
///<item><description>Duotone &lt;a:duotone></description></item>
///<item><description>FillOverlay &lt;a:fillOverlay></description></item>
///<item><description>Grayscale &lt;a:grayscl></description></item>
///<item><description>Hsl &lt;a:hsl></description></item>
///<item><description>LuminanceEffect &lt;a:lum></description></item>
///<item><description>TintEffect &lt;a:tint></description></item>
///<item><description>BlipExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AlphaBiLevel))]
    [ChildElementInfo(typeof(AlphaCeiling))]
    [ChildElementInfo(typeof(AlphaFloor))]
    [ChildElementInfo(typeof(AlphaInverse))]
    [ChildElementInfo(typeof(AlphaModulationEffect))]
    [ChildElementInfo(typeof(AlphaModulationFixed))]
    [ChildElementInfo(typeof(AlphaReplace))]
    [ChildElementInfo(typeof(BiLevel))]
    [ChildElementInfo(typeof(Blur))]
    [ChildElementInfo(typeof(ColorChange))]
    [ChildElementInfo(typeof(ColorReplacement))]
    [ChildElementInfo(typeof(Duotone))]
    [ChildElementInfo(typeof(FillOverlay))]
    [ChildElementInfo(typeof(Grayscale))]
    [ChildElementInfo(typeof(Hsl))]
    [ChildElementInfo(typeof(LuminanceEffect))]
    [ChildElementInfo(typeof(TintEffect))]
    [ChildElementInfo(typeof(BlipExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Blip : OpenXmlCompositeElement
{
    private const string tagName = "blip";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10121;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "embed","link","cstate" };
    private static byte[] attributeNamespaceIds = { 19,19,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Embedded Picture Reference.</para>
    /// <para>Represents the following attribute in the schema: r:embed </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "embed")]
    public StringValue Embed
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Linked Picture Reference.</para>
    /// <para>Represents the following attribute in the schema: r:link </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "link")]
    public StringValue Link
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> cstate.</para>
    /// <para>Represents the following attribute in the schema: cstate </para>
    /// </summary>
    [SchemaAttr(0, "cstate")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BlipCompressionValues> CompressionState
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BlipCompressionValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Blip class.
    /// </summary>
    public Blip():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Blip class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Blip(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Blip class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Blip(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Blip class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Blip(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "alphaBiLevel" == name)
    return new AlphaBiLevel();
    
if( 10 == namespaceId && "alphaCeiling" == name)
    return new AlphaCeiling();
    
if( 10 == namespaceId && "alphaFloor" == name)
    return new AlphaFloor();
    
if( 10 == namespaceId && "alphaInv" == name)
    return new AlphaInverse();
    
if( 10 == namespaceId && "alphaMod" == name)
    return new AlphaModulationEffect();
    
if( 10 == namespaceId && "alphaModFix" == name)
    return new AlphaModulationFixed();
    
if( 10 == namespaceId && "alphaRepl" == name)
    return new AlphaReplace();
    
if( 10 == namespaceId && "biLevel" == name)
    return new BiLevel();
    
if( 10 == namespaceId && "blur" == name)
    return new Blur();
    
if( 10 == namespaceId && "clrChange" == name)
    return new ColorChange();
    
if( 10 == namespaceId && "clrRepl" == name)
    return new ColorReplacement();
    
if( 10 == namespaceId && "duotone" == name)
    return new Duotone();
    
if( 10 == namespaceId && "fillOverlay" == name)
    return new FillOverlay();
    
if( 10 == namespaceId && "grayscl" == name)
    return new Grayscale();
    
if( 10 == namespaceId && "hsl" == name)
    return new Hsl();
    
if( 10 == namespaceId && "lum" == name)
    return new LuminanceEffect();
    
if( 10 == namespaceId && "tint" == name)
    return new TintEffect();
    
if( 10 == namespaceId && "extLst" == name)
    return new BlipExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "embed" == name)
    return new StringValue();
    
if( 19 == namespaceId && "link" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cstate" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BlipCompressionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Blip>(deep);
    }

   
}
/// <summary>
/// <para>Theme. The root element of ThemePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:theme.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ThemeElements &lt;a:themeElements></description></item>
///<item><description>ObjectDefaults &lt;a:objectDefaults></description></item>
///<item><description>ExtraColorSchemeList &lt;a:extraClrSchemeLst></description></item>
///<item><description>CustomColorList &lt;a:custClrLst></description></item>
///<item><description>OfficeStyleSheetExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ThemeElements))]
    [ChildElementInfo(typeof(ObjectDefaults))]
    [ChildElementInfo(typeof(ExtraColorSchemeList))]
    [ChildElementInfo(typeof(CustomColorList))]
    [ChildElementInfo(typeof(OfficeStyleSheetExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Theme : OpenXmlPartRootElement
{
    private const string tagName = "theme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10122;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","id" };
    private static byte[] attributeNamespaceIds = { 0,73 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: thm15:id </para>
    /// </summary>
///<remark> xmlns:thm15=http://schemas.microsoft.com/office/thememl/2012/main
///</remark>
    [SchemaAttr(73, "id")]
    public StringValue ThemeId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    /// <summary>
    /// Theme constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Theme.</param>
    internal Theme(ThemePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the ThemePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(ThemePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the ThemePart associated with this element.
    /// </summary>
    public ThemePart ThemePart
    {
		get
		{
			return OpenXmlPart as ThemePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Theme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Theme(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Theme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Theme(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Theme class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Theme(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Theme class.
    /// </summary>
    public Theme() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the ThemePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(ThemePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "themeElements" == name)
    return new ThemeElements();
    
if( 10 == namespaceId && "objectDefaults" == name)
    return new ObjectDefaults();
    
if( 10 == namespaceId && "extraClrSchemeLst" == name)
    return new ExtraColorSchemeList();
    
if( 10 == namespaceId && "custClrLst" == name)
    return new CustomColorList();
    
if( 10 == namespaceId && "extLst" == name)
    return new OfficeStyleSheetExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "themeElements","objectDefaults","extraClrSchemeLst","custClrLst","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ThemeElements.</para>
    /// <para> Represents the following element tag in the schema: a:themeElements </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ThemeElements ThemeElements
    {
        get 
        {
            return GetElement<ThemeElements>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ObjectDefaults.</para>
    /// <para> Represents the following element tag in the schema: a:objectDefaults </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ObjectDefaults ObjectDefaults
    {
        get 
        {
            return GetElement<ObjectDefaults>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtraColorSchemeList.</para>
    /// <para> Represents the following element tag in the schema: a:extraClrSchemeLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtraColorSchemeList ExtraColorSchemeList
    {
        get 
        {
            return GetElement<ExtraColorSchemeList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> CustomColorList.</para>
    /// <para> Represents the following element tag in the schema: a:custClrLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public CustomColorList CustomColorList
    {
        get 
        {
            return GetElement<CustomColorList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> OfficeStyleSheetExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public OfficeStyleSheetExtensionList OfficeStyleSheetExtensionList
    {
        get 
        {
            return GetElement<OfficeStyleSheetExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 73 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Theme>(deep);
    }

}
/// <summary>
/// <para>Theme Override. The root element of ThemeOverridePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:themeOverride.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ColorScheme &lt;a:clrScheme></description></item>
///<item><description>FontScheme &lt;a:fontScheme></description></item>
///<item><description>FormatScheme &lt;a:fmtScheme></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ColorScheme))]
    [ChildElementInfo(typeof(FontScheme))]
    [ChildElementInfo(typeof(FormatScheme))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ThemeOverride : OpenXmlPartRootElement
{
    private const string tagName = "themeOverride";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10123;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// ThemeOverride constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the ThemeOverride.</param>
    internal ThemeOverride(ThemeOverridePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the ThemeOverridePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(ThemeOverridePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the ThemeOverridePart associated with this element.
    /// </summary>
    public ThemeOverridePart ThemeOverridePart
    {
		get
		{
			return OpenXmlPart as ThemeOverridePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the ThemeOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ThemeOverride(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ThemeOverride(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeOverride class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ThemeOverride(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the ThemeOverride class.
    /// </summary>
    public ThemeOverride() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the ThemeOverridePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(ThemeOverridePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "clrScheme" == name)
    return new ColorScheme();
    
if( 10 == namespaceId && "fontScheme" == name)
    return new FontScheme();
    
if( 10 == namespaceId && "fmtScheme" == name)
    return new FormatScheme();
    

    return null;
}

        private static readonly string[] eleTagNames = { "clrScheme","fontScheme","fmtScheme" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Color Scheme.</para>
    /// <para> Represents the following element tag in the schema: a:clrScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorScheme ColorScheme
    {
        get 
        {
            return GetElement<ColorScheme>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> FontScheme.</para>
    /// <para> Represents the following element tag in the schema: a:fontScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FontScheme FontScheme
    {
        get 
        {
            return GetElement<FontScheme>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> FormatScheme.</para>
    /// <para> Represents the following element tag in the schema: a:fmtScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FormatScheme FormatScheme
    {
        get 
        {
            return GetElement<FormatScheme>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ThemeOverride>(deep);
    }

}
/// <summary>
/// <para>Theme Manager.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:themeManager.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ThemeManager : EmptyType
{
    private const string tagName = "themeManager";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10124;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ThemeManager class.
    /// </summary>
    public ThemeManager():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ThemeManager>(deep);
    }

}
/// <summary>
/// <para>Master Color Mapping.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:masterClrMapping.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MasterColorMapping : EmptyType
{
    private const string tagName = "masterClrMapping";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10242;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MasterColorMapping class.
    /// </summary>
    public MasterColorMapping():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MasterColorMapping>(deep);
    }

}
/// <summary>
/// Defines the EmptyType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class EmptyType : OpenXmlLeafElement
{
        
    
    
    
    
    
    /// <summary>
    /// Initializes a new instance of the EmptyType class.
    /// </summary>
    protected EmptyType(){}
    
    
    
}
/// <summary>
/// <para>Table.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tbl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableProperties &lt;a:tblPr></description></item>
///<item><description>TableGrid &lt;a:tblGrid></description></item>
///<item><description>TableRow &lt;a:tr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableProperties))]
    [ChildElementInfo(typeof(TableGrid))]
    [ChildElementInfo(typeof(TableRow))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Table : OpenXmlCompositeElement
{
    private const string tagName = "tbl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10125;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Table class.
    /// </summary>
    public Table():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Table(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tblPr" == name)
    return new TableProperties();
    
if( 10 == namespaceId && "tblGrid" == name)
    return new TableGrid();
    
if( 10 == namespaceId && "tr" == name)
    return new TableRow();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblPr","tblGrid","tr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Properties.</para>
    /// <para> Represents the following element tag in the schema: a:tblPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableProperties TableProperties
    {
        get 
        {
            return GetElement<TableProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Grid.</para>
    /// <para> Represents the following element tag in the schema: a:tblGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableGrid TableGrid
    {
        get 
        {
            return GetElement<TableGrid>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Table>(deep);
    }

   
}
/// <summary>
/// <para>Table Style List. The root element of TableStylesPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tblStyleLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyleEntry &lt;a:tblStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyleEntry))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleList : OpenXmlPartRootElement
{
    private const string tagName = "tblStyleLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10126;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "def" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Default.</para>
    /// <para>Represents the following attribute in the schema: def </para>
    /// </summary>
    [SchemaAttr(0, "def")]
    public StringValue Default
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// TableStyleList constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the TableStyleList.</param>
    internal TableStyleList(TableStylesPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the TableStylesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(TableStylesPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the TableStylesPart associated with this element.
    /// </summary>
    public TableStylesPart TableStylesPart
    {
		get
		{
			return OpenXmlPart as TableStylesPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the TableStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleList(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the TableStyleList class.
    /// </summary>
    public TableStyleList() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the TableStylesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(TableStylesPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tblStyle" == name)
    return new TableStyleEntry();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "def" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleList>(deep);
    }

}
/// <summary>
/// <para>Defines the ExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Extension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Extension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10127;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class.
    /// </summary>
    public ExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new Extension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Audio Start Time.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:st.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StartTime : AudioCDTimeType
{
    private const string tagName = "st";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10128;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartTime class.
    /// </summary>
    public StartTime():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartTime>(deep);
    }

}
/// <summary>
/// <para>Audio End Time.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:end.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndTime : AudioCDTimeType
{
    private const string tagName = "end";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10129;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndTime class.
    /// </summary>
    public EndTime():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndTime>(deep);
    }

}
/// <summary>
/// Defines the AudioCDTimeType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class AudioCDTimeType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "track","time" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Track.</para>
    /// <para>Represents the following attribute in the schema: track </para>
    /// </summary>
    [SchemaAttr(0, "track")]
    public ByteValue Track
    {
        get { return (ByteValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Time.</para>
    /// <para>Represents the following attribute in the schema: time </para>
    /// </summary>
    [SchemaAttr(0, "time")]
    public UInt32Value Time
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "track" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "time" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the AudioCDTimeType class.
    /// </summary>
    protected AudioCDTimeType(){}
    
    
    
}
/// <summary>
/// <para>Custom color.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:custClr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomColor : OpenXmlCompositeElement
{
    private const string tagName = "custClr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10130;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomColor class.
    /// </summary>
    public CustomColor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomColor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomColor>(deep);
    }

   
}
/// <summary>
/// <para>Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:font.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SupplementalFont : OpenXmlLeafElement
{
    private const string tagName = "font";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10134;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "script","typeface" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Script.</para>
    /// <para>Represents the following attribute in the schema: script </para>
    /// </summary>
    [SchemaAttr(0, "script")]
    public StringValue Script
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Typeface.</para>
    /// <para>Represents the following attribute in the schema: typeface </para>
    /// </summary>
    [SchemaAttr(0, "typeface")]
    public StringValue Typeface
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SupplementalFont class.
    /// </summary>
    public SupplementalFont():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "script" == name)
    return new StringValue();
    
if( 0 == namespaceId && "typeface" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SupplementalFont>(deep);
    }

   
}
/// <summary>
/// <para>3D Scene Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:scene3d.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Camera &lt;a:camera></description></item>
///<item><description>LightRig &lt;a:lightRig></description></item>
///<item><description>Backdrop &lt;a:backdrop></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Camera))]
    [ChildElementInfo(typeof(LightRig))]
    [ChildElementInfo(typeof(Backdrop))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Scene3DType : OpenXmlCompositeElement
{
    private const string tagName = "scene3d";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10135;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Scene3DType class.
    /// </summary>
    public Scene3DType():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Scene3DType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scene3DType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Scene3DType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scene3DType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Scene3DType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Scene3DType(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "camera" == name)
    return new Camera();
    
if( 10 == namespaceId && "lightRig" == name)
    return new LightRig();
    
if( 10 == namespaceId && "backdrop" == name)
    return new Backdrop();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "camera","lightRig","backdrop","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Camera.</para>
    /// <para> Represents the following element tag in the schema: a:camera </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Camera Camera
    {
        get 
        {
            return GetElement<Camera>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Light Rig.</para>
    /// <para> Represents the following element tag in the schema: a:lightRig </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LightRig LightRig
    {
        get 
        {
            return GetElement<LightRig>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Backdrop Plane.</para>
    /// <para> Represents the following element tag in the schema: a:backdrop </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Backdrop Backdrop
    {
        get 
        {
            return GetElement<Backdrop>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Scene3DType>(deep);
    }

   
}
/// <summary>
/// <para>Effect Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effectStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Scene3DType &lt;a:scene3d></description></item>
///<item><description>Shape3DType &lt;a:sp3d></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
    [ChildElementInfo(typeof(Scene3DType))]
    [ChildElementInfo(typeof(Shape3DType))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectStyle : OpenXmlCompositeElement
{
    private const string tagName = "effectStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10139;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EffectStyle class.
    /// </summary>
    public EffectStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EffectStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    
if( 10 == namespaceId && "scene3d" == name)
    return new Scene3DType();
    
if( 10 == namespaceId && "sp3d" == name)
    return new Shape3DType();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectStyle>(deep);
    }

   
}
/// <summary>
/// <para>Fill Style List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fillStyleLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillStyleList : OpenXmlCompositeElement
{
    private const string tagName = "fillStyleLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10140;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FillStyleList class.
    /// </summary>
    public FillStyleList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FillStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillStyleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FillStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FillStyleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FillStyleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FillStyleList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillStyleList>(deep);
    }

   
}
/// <summary>
/// <para>Line Style List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnStyleLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Outline))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineStyleList : OpenXmlCompositeElement
{
    private const string tagName = "lnStyleLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10141;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the LineStyleList class.
    /// </summary>
    public LineStyleList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the LineStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineStyleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LineStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineStyleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LineStyleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LineStyleList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ln" == name)
    return new Outline();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineStyleList>(deep);
    }

   
}
/// <summary>
/// <para>Effect Style List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:effectStyleLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EffectStyle &lt;a:effectStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EffectStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EffectStyleList : OpenXmlCompositeElement
{
    private const string tagName = "effectStyleLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10142;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EffectStyleList class.
    /// </summary>
    public EffectStyleList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EffectStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectStyleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EffectStyleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EffectStyleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EffectStyleList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "effectStyle" == name)
    return new EffectStyle();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EffectStyleList>(deep);
    }

   
}
/// <summary>
/// <para>Background Fill Style List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bgFillStyleLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BackgroundFillStyleList : OpenXmlCompositeElement
{
    private const string tagName = "bgFillStyleLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10143;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BackgroundFillStyleList class.
    /// </summary>
    public BackgroundFillStyleList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BackgroundFillStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BackgroundFillStyleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BackgroundFillStyleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BackgroundFillStyleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BackgroundFillStyleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BackgroundFillStyleList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BackgroundFillStyleList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ColorScheme Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrScheme.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Dark1Color &lt;a:dk1></description></item>
///<item><description>Light1Color &lt;a:lt1></description></item>
///<item><description>Dark2Color &lt;a:dk2></description></item>
///<item><description>Light2Color &lt;a:lt2></description></item>
///<item><description>Accent1Color &lt;a:accent1></description></item>
///<item><description>Accent2Color &lt;a:accent2></description></item>
///<item><description>Accent3Color &lt;a:accent3></description></item>
///<item><description>Accent4Color &lt;a:accent4></description></item>
///<item><description>Accent5Color &lt;a:accent5></description></item>
///<item><description>Accent6Color &lt;a:accent6></description></item>
///<item><description>Hyperlink &lt;a:hlink></description></item>
///<item><description>FollowedHyperlinkColor &lt;a:folHlink></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Dark1Color))]
    [ChildElementInfo(typeof(Light1Color))]
    [ChildElementInfo(typeof(Dark2Color))]
    [ChildElementInfo(typeof(Light2Color))]
    [ChildElementInfo(typeof(Accent1Color))]
    [ChildElementInfo(typeof(Accent2Color))]
    [ChildElementInfo(typeof(Accent3Color))]
    [ChildElementInfo(typeof(Accent4Color))]
    [ChildElementInfo(typeof(Accent5Color))]
    [ChildElementInfo(typeof(Accent6Color))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(FollowedHyperlinkColor))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorScheme : OpenXmlCompositeElement
{
    private const string tagName = "clrScheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10144;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorScheme class.
    /// </summary>
    public ColorScheme():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorScheme(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorScheme(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorScheme class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorScheme(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "dk1" == name)
    return new Dark1Color();
    
if( 10 == namespaceId && "lt1" == name)
    return new Light1Color();
    
if( 10 == namespaceId && "dk2" == name)
    return new Dark2Color();
    
if( 10 == namespaceId && "lt2" == name)
    return new Light2Color();
    
if( 10 == namespaceId && "accent1" == name)
    return new Accent1Color();
    
if( 10 == namespaceId && "accent2" == name)
    return new Accent2Color();
    
if( 10 == namespaceId && "accent3" == name)
    return new Accent3Color();
    
if( 10 == namespaceId && "accent4" == name)
    return new Accent4Color();
    
if( 10 == namespaceId && "accent5" == name)
    return new Accent5Color();
    
if( 10 == namespaceId && "accent6" == name)
    return new Accent6Color();
    
if( 10 == namespaceId && "hlink" == name)
    return new Hyperlink();
    
if( 10 == namespaceId && "folHlink" == name)
    return new FollowedHyperlinkColor();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "dk1","lt1","dk2","lt2","accent1","accent2","accent3","accent4","accent5","accent6","hlink","folHlink","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Dark 1.</para>
    /// <para> Represents the following element tag in the schema: a:dk1 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Dark1Color Dark1Color
    {
        get 
        {
            return GetElement<Dark1Color>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Light 1.</para>
    /// <para> Represents the following element tag in the schema: a:lt1 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Light1Color Light1Color
    {
        get 
        {
            return GetElement<Light1Color>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Dark 2.</para>
    /// <para> Represents the following element tag in the schema: a:dk2 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Dark2Color Dark2Color
    {
        get 
        {
            return GetElement<Dark2Color>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Light 2.</para>
    /// <para> Represents the following element tag in the schema: a:lt2 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Light2Color Light2Color
    {
        get 
        {
            return GetElement<Light2Color>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Accent 1.</para>
    /// <para> Represents the following element tag in the schema: a:accent1 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent1Color Accent1Color
    {
        get 
        {
            return GetElement<Accent1Color>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Accent 2.</para>
    /// <para> Represents the following element tag in the schema: a:accent2 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent2Color Accent2Color
    {
        get 
        {
            return GetElement<Accent2Color>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Accent 3.</para>
    /// <para> Represents the following element tag in the schema: a:accent3 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent3Color Accent3Color
    {
        get 
        {
            return GetElement<Accent3Color>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Accent 4.</para>
    /// <para> Represents the following element tag in the schema: a:accent4 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent4Color Accent4Color
    {
        get 
        {
            return GetElement<Accent4Color>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Accent 5.</para>
    /// <para> Represents the following element tag in the schema: a:accent5 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent5Color Accent5Color
    {
        get 
        {
            return GetElement<Accent5Color>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Accent 6.</para>
    /// <para> Represents the following element tag in the schema: a:accent6 </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Accent6Color Accent6Color
    {
        get 
        {
            return GetElement<Accent6Color>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Hyperlink.</para>
    /// <para> Represents the following element tag in the schema: a:hlink </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Hyperlink Hyperlink
    {
        get 
        {
            return GetElement<Hyperlink>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Followed Hyperlink.</para>
    /// <para> Represents the following element tag in the schema: a:folHlink </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FollowedHyperlinkColor FollowedHyperlinkColor
    {
        get 
        {
            return GetElement<FollowedHyperlinkColor>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorScheme>(deep);
    }

   
}
/// <summary>
/// <para>Font Scheme.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fontScheme.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MajorFont &lt;a:majorFont></description></item>
///<item><description>MinorFont &lt;a:minorFont></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MajorFont))]
    [ChildElementInfo(typeof(MinorFont))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontScheme : OpenXmlCompositeElement
{
    private const string tagName = "fontScheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10145;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontScheme class.
    /// </summary>
    public FontScheme():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FontScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FontScheme(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FontScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FontScheme(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FontScheme class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FontScheme(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "majorFont" == name)
    return new MajorFont();
    
if( 10 == namespaceId && "minorFont" == name)
    return new MinorFont();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "majorFont","minorFont","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Major Font.</para>
    /// <para> Represents the following element tag in the schema: a:majorFont </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public MajorFont MajorFont
    {
        get 
        {
            return GetElement<MajorFont>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Minor fonts.</para>
    /// <para> Represents the following element tag in the schema: a:minorFont </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public MinorFont MinorFont
    {
        get 
        {
            return GetElement<MinorFont>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontScheme>(deep);
    }

   
}
/// <summary>
/// <para>Format Scheme.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fmtScheme.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FillStyleList &lt;a:fillStyleLst></description></item>
///<item><description>LineStyleList &lt;a:lnStyleLst></description></item>
///<item><description>EffectStyleList &lt;a:effectStyleLst></description></item>
///<item><description>BackgroundFillStyleList &lt;a:bgFillStyleLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FillStyleList))]
    [ChildElementInfo(typeof(LineStyleList))]
    [ChildElementInfo(typeof(EffectStyleList))]
    [ChildElementInfo(typeof(BackgroundFillStyleList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormatScheme : OpenXmlCompositeElement
{
    private const string tagName = "fmtScheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10146;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FormatScheme class.
    /// </summary>
    public FormatScheme():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FormatScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FormatScheme(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FormatScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FormatScheme(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FormatScheme class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FormatScheme(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "fillStyleLst" == name)
    return new FillStyleList();
    
if( 10 == namespaceId && "lnStyleLst" == name)
    return new LineStyleList();
    
if( 10 == namespaceId && "effectStyleLst" == name)
    return new EffectStyleList();
    
if( 10 == namespaceId && "bgFillStyleLst" == name)
    return new BackgroundFillStyleList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fillStyleLst","lnStyleLst","effectStyleLst","bgFillStyleLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Fill Style List.</para>
    /// <para> Represents the following element tag in the schema: a:fillStyleLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FillStyleList FillStyleList
    {
        get 
        {
            return GetElement<FillStyleList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Line Style List.</para>
    /// <para> Represents the following element tag in the schema: a:lnStyleLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LineStyleList LineStyleList
    {
        get 
        {
            return GetElement<LineStyleList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Effect Style List.</para>
    /// <para> Represents the following element tag in the schema: a:effectStyleLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectStyleList EffectStyleList
    {
        get 
        {
            return GetElement<EffectStyleList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Background Fill Style List.</para>
    /// <para> Represents the following element tag in the schema: a:bgFillStyleLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BackgroundFillStyleList BackgroundFillStyleList
    {
        get 
        {
            return GetElement<BackgroundFillStyleList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormatScheme>(deep);
    }

   
}
/// <summary>
/// <para>Dark 1.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:dk1.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Dark1Color : Color2Type
{
    private const string tagName = "dk1";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10147;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Dark1Color class.
    /// </summary>
    public Dark1Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Dark1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dark1Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Dark1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dark1Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Dark1Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Dark1Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Dark1Color>(deep);
    }

}
/// <summary>
/// <para>Light 1.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lt1.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Light1Color : Color2Type
{
    private const string tagName = "lt1";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10148;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Light1Color class.
    /// </summary>
    public Light1Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Light1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Light1Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Light1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Light1Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Light1Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Light1Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Light1Color>(deep);
    }

}
/// <summary>
/// <para>Dark 2.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:dk2.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Dark2Color : Color2Type
{
    private const string tagName = "dk2";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10149;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Dark2Color class.
    /// </summary>
    public Dark2Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Dark2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dark2Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Dark2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dark2Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Dark2Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Dark2Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Dark2Color>(deep);
    }

}
/// <summary>
/// <para>Light 2.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lt2.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Light2Color : Color2Type
{
    private const string tagName = "lt2";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10150;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Light2Color class.
    /// </summary>
    public Light2Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Light2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Light2Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Light2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Light2Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Light2Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Light2Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Light2Color>(deep);
    }

}
/// <summary>
/// <para>Accent 1.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent1.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent1Color : Color2Type
{
    private const string tagName = "accent1";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10151;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent1Color class.
    /// </summary>
    public Accent1Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent1Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent1Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent1Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent1Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent1Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent1Color>(deep);
    }

}
/// <summary>
/// <para>Accent 2.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent2.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent2Color : Color2Type
{
    private const string tagName = "accent2";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10152;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent2Color class.
    /// </summary>
    public Accent2Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent2Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent2Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent2Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent2Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent2Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent2Color>(deep);
    }

}
/// <summary>
/// <para>Accent 3.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent3.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent3Color : Color2Type
{
    private const string tagName = "accent3";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10153;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent3Color class.
    /// </summary>
    public Accent3Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent3Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent3Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent3Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent3Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent3Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent3Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent3Color>(deep);
    }

}
/// <summary>
/// <para>Accent 4.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent4.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent4Color : Color2Type
{
    private const string tagName = "accent4";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10154;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent4Color class.
    /// </summary>
    public Accent4Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent4Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent4Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent4Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent4Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent4Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent4Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent4Color>(deep);
    }

}
/// <summary>
/// <para>Accent 5.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent5.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent5Color : Color2Type
{
    private const string tagName = "accent5";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10155;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent5Color class.
    /// </summary>
    public Accent5Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent5Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent5Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent5Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent5Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent5Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent5Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent5Color>(deep);
    }

}
/// <summary>
/// <para>Accent 6.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:accent6.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Accent6Color : Color2Type
{
    private const string tagName = "accent6";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10156;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Accent6Color class.
    /// </summary>
    public Accent6Color():base(){}
            /// <summary>
    ///Initializes a new instance of the Accent6Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent6Color(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent6Color class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Accent6Color(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Accent6Color class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Accent6Color(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Accent6Color>(deep);
    }

}
/// <summary>
/// <para>Hyperlink.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hlink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hyperlink : Color2Type
{
    private const string tagName = "hlink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10157;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Hyperlink class.
    /// </summary>
    public Hyperlink():base(){}
            /// <summary>
    ///Initializes a new instance of the Hyperlink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlink(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlink(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlink class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Hyperlink(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hyperlink>(deep);
    }

}
/// <summary>
/// <para>Followed Hyperlink.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:folHlink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FollowedHyperlinkColor : Color2Type
{
    private const string tagName = "folHlink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10158;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FollowedHyperlinkColor class.
    /// </summary>
    public FollowedHyperlinkColor():base(){}
            /// <summary>
    ///Initializes a new instance of the FollowedHyperlinkColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FollowedHyperlinkColor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FollowedHyperlinkColor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FollowedHyperlinkColor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FollowedHyperlinkColor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FollowedHyperlinkColor(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FollowedHyperlinkColor>(deep);
    }

}
/// <summary>
/// Defines the Color2Type class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class Color2Type : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the Color2Type class.
    /// </summary>
    protected Color2Type(){}
    
            /// <summary>
    ///Initializes a new instance of the Color2Type class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected Color2Type(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Color2Type class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected Color2Type(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Color2Type class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected Color2Type(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Horizontal Ratio.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ScaleX : RatioType
{
    private const string tagName = "sx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10159;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ScaleX class.
    /// </summary>
    public ScaleX():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ScaleX>(deep);
    }

}
/// <summary>
/// <para>Vertical Ratio.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sy.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ScaleY : RatioType
{
    private const string tagName = "sy";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10160;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ScaleY class.
    /// </summary>
    public ScaleY():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ScaleY>(deep);
    }

}
/// <summary>
/// Defines the RatioType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RatioType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "n","d" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Numerator.</para>
    /// <para>Represents the following attribute in the schema: n </para>
    /// </summary>
    [SchemaAttr(0, "n")]
    public Int32Value Numerator
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Denominator.</para>
    /// <para>Represents the following attribute in the schema: d </para>
    /// </summary>
    [SchemaAttr(0, "d")]
    public Int32Value Denominator
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "n" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "d" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the RatioType class.
    /// </summary>
    protected RatioType(){}
    
    
    
}
/// <summary>
/// <para>Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:off.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Offset : Point2DType
{
    private const string tagName = "off";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10161;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Offset class.
    /// </summary>
    public Offset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Offset>(deep);
    }

}
/// <summary>
/// <para>Child Offset.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:chOff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChildOffset : Point2DType
{
    private const string tagName = "chOff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10163;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ChildOffset class.
    /// </summary>
    public ChildOffset():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChildOffset>(deep);
    }

}
/// <summary>
/// Defines the Point2DType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class Point2DType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "x","y" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> X-Axis Coordinate.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public Int64Value X
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Y-Axis Coordinate.</para>
    /// <para>Represents the following attribute in the schema: y </para>
    /// </summary>
    [SchemaAttr(0, "y")]
    public Int64Value Y
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "y" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the Point2DType class.
    /// </summary>
    protected Point2DType(){}
    
    
    
}
/// <summary>
/// <para>Extents.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Extents : PositiveSize2DType
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10162;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Extents class.
    /// </summary>
    public Extents():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Extents>(deep);
    }

}
/// <summary>
/// <para>Child Extents.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:chExt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChildExtents : PositiveSize2DType
{
    private const string tagName = "chExt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10164;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ChildExtents class.
    /// </summary>
    public ChildExtents():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChildExtents>(deep);
    }

}
/// <summary>
/// Defines the PositiveSize2DType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PositiveSize2DType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "cx","cy" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Extent Length.</para>
    /// <para>Represents the following attribute in the schema: cx </para>
    /// </summary>
    [SchemaAttr(0, "cx")]
    public Int64Value Cx
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Extent Width.</para>
    /// <para>Represents the following attribute in the schema: cy </para>
    /// </summary>
    [SchemaAttr(0, "cy")]
    public Int64Value Cy
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "cx" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "cy" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PositiveSize2DType class.
    /// </summary>
    protected PositiveSize2DType(){}
    
    
    
}
/// <summary>
/// <para>Shape Locks.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spLocks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeLocks : OpenXmlCompositeElement
{
    private const string tagName = "spLocks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10166;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "noGrp","noSelect","noRot","noChangeAspect","noMove","noResize","noEditPoints","noAdjustHandles","noChangeArrowheads","noChangeShapeType","noTextEdit" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disallow Shape Grouping.</para>
    /// <para>Represents the following attribute in the schema: noGrp </para>
    /// </summary>
    [SchemaAttr(0, "noGrp")]
    public BooleanValue NoGrouping
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Selection.</para>
    /// <para>Represents the following attribute in the schema: noSelect </para>
    /// </summary>
    [SchemaAttr(0, "noSelect")]
    public BooleanValue NoSelection
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Rotation.</para>
    /// <para>Represents the following attribute in the schema: noRot </para>
    /// </summary>
    [SchemaAttr(0, "noRot")]
    public BooleanValue NoRotation
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Aspect Ratio Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeAspect </para>
    /// </summary>
    [SchemaAttr(0, "noChangeAspect")]
    public BooleanValue NoChangeAspect
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Movement.</para>
    /// <para>Represents the following attribute in the schema: noMove </para>
    /// </summary>
    [SchemaAttr(0, "noMove")]
    public BooleanValue NoMove
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Resize.</para>
    /// <para>Represents the following attribute in the schema: noResize </para>
    /// </summary>
    [SchemaAttr(0, "noResize")]
    public BooleanValue NoResize
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Point Editing.</para>
    /// <para>Represents the following attribute in the schema: noEditPoints </para>
    /// </summary>
    [SchemaAttr(0, "noEditPoints")]
    public BooleanValue NoEditPoints
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Showing Adjust Handles.</para>
    /// <para>Represents the following attribute in the schema: noAdjustHandles </para>
    /// </summary>
    [SchemaAttr(0, "noAdjustHandles")]
    public BooleanValue NoAdjustHandles
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Arrowhead Changes.</para>
    /// <para>Represents the following attribute in the schema: noChangeArrowheads </para>
    /// </summary>
    [SchemaAttr(0, "noChangeArrowheads")]
    public BooleanValue NoChangeArrowheads
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Type Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeShapeType </para>
    /// </summary>
    [SchemaAttr(0, "noChangeShapeType")]
    public BooleanValue NoChangeShapeType
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Text Editing.</para>
    /// <para>Represents the following attribute in the schema: noTextEdit </para>
    /// </summary>
    [SchemaAttr(0, "noTextEdit")]
    public BooleanValue NoTextEdit
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeLocks class.
    /// </summary>
    public ShapeLocks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeLocks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeLocks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeLocks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeLocks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "noGrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noSelect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noRot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeAspect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noMove" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noResize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noEditPoints" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noAdjustHandles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeArrowheads" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeShapeType" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noTextEdit" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeLocks>(deep);
    }

   
}
/// <summary>
/// <para>Connection Shape Locks.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cxnSpLocks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConnectorLockingExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConnectorLockingExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionShapeLocks : OpenXmlCompositeElement
{
    private const string tagName = "cxnSpLocks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10167;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "noGrp","noSelect","noRot","noChangeAspect","noMove","noResize","noEditPoints","noAdjustHandles","noChangeArrowheads","noChangeShapeType" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disallow Shape Grouping.</para>
    /// <para>Represents the following attribute in the schema: noGrp </para>
    /// </summary>
    [SchemaAttr(0, "noGrp")]
    public BooleanValue NoGrouping
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Selection.</para>
    /// <para>Represents the following attribute in the schema: noSelect </para>
    /// </summary>
    [SchemaAttr(0, "noSelect")]
    public BooleanValue NoSelection
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Rotation.</para>
    /// <para>Represents the following attribute in the schema: noRot </para>
    /// </summary>
    [SchemaAttr(0, "noRot")]
    public BooleanValue NoRotation
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Aspect Ratio Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeAspect </para>
    /// </summary>
    [SchemaAttr(0, "noChangeAspect")]
    public BooleanValue NoChangeAspect
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Movement.</para>
    /// <para>Represents the following attribute in the schema: noMove </para>
    /// </summary>
    [SchemaAttr(0, "noMove")]
    public BooleanValue NoMove
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Resize.</para>
    /// <para>Represents the following attribute in the schema: noResize </para>
    /// </summary>
    [SchemaAttr(0, "noResize")]
    public BooleanValue NoResize
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Point Editing.</para>
    /// <para>Represents the following attribute in the schema: noEditPoints </para>
    /// </summary>
    [SchemaAttr(0, "noEditPoints")]
    public BooleanValue NoEditPoints
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Showing Adjust Handles.</para>
    /// <para>Represents the following attribute in the schema: noAdjustHandles </para>
    /// </summary>
    [SchemaAttr(0, "noAdjustHandles")]
    public BooleanValue NoAdjustHandles
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Arrowhead Changes.</para>
    /// <para>Represents the following attribute in the schema: noChangeArrowheads </para>
    /// </summary>
    [SchemaAttr(0, "noChangeArrowheads")]
    public BooleanValue NoChangeArrowheads
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Type Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeShapeType </para>
    /// </summary>
    [SchemaAttr(0, "noChangeShapeType")]
    public BooleanValue NoChangeShapeType
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConnectionShapeLocks class.
    /// </summary>
    public ConnectionShapeLocks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionShapeLocks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionShapeLocks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionShapeLocks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionShapeLocks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ConnectorLockingExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ConnectorLockingExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ConnectorLockingExtensionList ConnectorLockingExtensionList
    {
        get 
        {
            return GetElement<ConnectorLockingExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "noGrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noSelect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noRot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeAspect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noMove" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noResize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noEditPoints" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noAdjustHandles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeArrowheads" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeShapeType" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionShapeLocks>(deep);
    }

   
}
/// <summary>
/// <para>Connection Start.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:stCxn.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StartConnection : ConnectionType
{
    private const string tagName = "stCxn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10168;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartConnection class.
    /// </summary>
    public StartConnection():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartConnection>(deep);
    }

}
/// <summary>
/// <para>Connection End.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:endCxn.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndConnection : ConnectionType
{
    private const string tagName = "endCxn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10169;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndConnection class.
    /// </summary>
    public EndConnection():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndConnection>(deep);
    }

}
/// <summary>
/// Defines the ConnectionType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ConnectionType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "id","idx" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Identifier.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Index.</para>
    /// <para>Represents the following attribute in the schema: idx </para>
    /// </summary>
    [SchemaAttr(0, "idx")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "idx" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the ConnectionType class.
    /// </summary>
    protected ConnectionType(){}
    
    
    
}
/// <summary>
/// <para>Graphic Frame Locks.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:graphicFrameLocks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GraphicFrameLocks : OpenXmlCompositeElement
{
    private const string tagName = "graphicFrameLocks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10170;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "noGrp","noDrilldown","noSelect","noChangeAspect","noMove","noResize" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disallow Shape Grouping.</para>
    /// <para>Represents the following attribute in the schema: noGrp </para>
    /// </summary>
    [SchemaAttr(0, "noGrp")]
    public BooleanValue NoGrouping
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Selection of Child Shapes.</para>
    /// <para>Represents the following attribute in the schema: noDrilldown </para>
    /// </summary>
    [SchemaAttr(0, "noDrilldown")]
    public BooleanValue NoDrilldown
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Selection.</para>
    /// <para>Represents the following attribute in the schema: noSelect </para>
    /// </summary>
    [SchemaAttr(0, "noSelect")]
    public BooleanValue NoSelection
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Aspect Ratio Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeAspect </para>
    /// </summary>
    [SchemaAttr(0, "noChangeAspect")]
    public BooleanValue NoChangeAspect
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Movement.</para>
    /// <para>Represents the following attribute in the schema: noMove </para>
    /// </summary>
    [SchemaAttr(0, "noMove")]
    public BooleanValue NoMove
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Resize.</para>
    /// <para>Represents the following attribute in the schema: noResize </para>
    /// </summary>
    [SchemaAttr(0, "noResize")]
    public BooleanValue NoResize
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GraphicFrameLocks class.
    /// </summary>
    public GraphicFrameLocks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GraphicFrameLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicFrameLocks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicFrameLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicFrameLocks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicFrameLocks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GraphicFrameLocks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "noGrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noDrilldown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noSelect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeAspect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noMove" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noResize" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GraphicFrameLocks>(deep);
    }

   
}
/// <summary>
/// <para>Graphic Object Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:graphicData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Graphic &lt;a:graphic></description></item>
///<item><description>Blip &lt;a:blip></description></item>
///<item><description>Theme &lt;a:theme></description></item>
///<item><description>ThemeOverride &lt;a:themeOverride></description></item>
///<item><description>ThemeManager &lt;a:themeManager></description></item>
///<item><description>Table &lt;a:tbl></description></item>
///<item><description>TableStyleList &lt;a:tblStyleLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty &lt;wp15:webVideoPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily &lt;thm15:themeFamily></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties &lt;a15:backgroundPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties &lt;a15:nonVisualGroupProps></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties &lt;a15:objectPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine &lt;a15:signatureLine></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.CameraTool &lt;a14:cameraTool></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension &lt;a14:compatExt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas &lt;a14:isCanvas></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart &lt;a14:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured &lt;a14:shadowObscured></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties &lt;a14:hiddenFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties &lt;a14:hiddenLine></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties &lt;a14:hiddenEffects></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D &lt;a14:hiddenScene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D &lt;a14:hiddenSp3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties &lt;a14:imgProps></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi &lt;a14:useLocalDpi></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.TextMath &lt;a14:m></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties &lt;dgm14:cNvPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages &lt;dgm14:recolorImg></description></item>
///<item><description>DocumentFormat.OpenXml.Office.Drawing.Drawing &lt;dsp:drawing></description></item>
///<item><description>DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock &lt;dsp:dataModelExt></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinition &lt;dgm:colorsDef></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader &lt;dgm:colorsDefHdr></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeaderList &lt;dgm:colorsDefHdrLst></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.DataModelRoot &lt;dgm:dataModel></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinition &lt;dgm:layoutDef></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader &lt;dgm:layoutDefHdr></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeaderList &lt;dgm:layoutDefHdrLst></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.RelationshipIds &lt;dgm:relIds></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinition &lt;dgm:styleDef></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader &lt;dgm:styleDefHdr></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeaderList &lt;dgm:styleDefHdrLst></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Charts.ChartSpace &lt;c:chartSpace></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Charts.UserShapes &lt;c:userShapes></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Charts.ChartReference &lt;c:chart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.PivotSource &lt;c15:pivotSource></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.NumberingFormat &lt;c15:numFmt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShapeProperties &lt;c15:spPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.Layout &lt;c15:layout></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FullReference &lt;c15:fullRef></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.LevelReference &lt;c15:levelRef></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FormulaReference &lt;c15:formulaRef></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSeriesTitle &lt;c15:filteredSeriesTitle></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredCategoryTitle &lt;c15:filteredCategoryTitle></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredAreaSeries &lt;c15:filteredAreaSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBarSeries &lt;c15:filteredBarSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBubbleSeries &lt;c15:filteredBubbleSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredLineSeriesExtension &lt;c15:filteredLineSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredPieSeries &lt;c15:filteredPieSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredRadarSeries &lt;c15:filteredRadarSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredScatterSeries &lt;c15:filteredScatterSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSurfaceSeries &lt;c15:filteredSurfaceSeries></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelsRange &lt;c15:datalabelsRange></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.CategoryFilterExceptions &lt;c15:categoryFilterExceptions></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelFieldTable &lt;c15:dlblFieldTable></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.ExceptionForSave &lt;c15:xForSave></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowDataLabelsRange &lt;c15:showDataLabelsRange></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.ChartText &lt;c15:tx></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowLeaderLines &lt;c15:showLeaderLines></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.LeaderLines &lt;c15:leaderLines></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.Chart.AutoGeneneratedCategories &lt;c15:autoCat></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Charts.PivotOptions &lt;c14:pivotOptions></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Charts.SketchOptions &lt;c14:sketchOptions></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Charts.InvertSolidFillFormat &lt;c14:invertSolidFillFmt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Charts.Style &lt;c14:style></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.ChartDrawing.ContentPart &lt;cdr14:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.LegacyCompatibility.LegacyDrawing &lt;comp:legacyDrawing></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.LockedCanvas.LockedCanvas &lt;lc:lockedCanvas></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline &lt;wp:inline></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor &lt;wp:anchor></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionHeightOffset &lt;wp14:pctPosHOffset></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionVerticalOffset &lt;wp14:pctPosVOffset></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeWidth &lt;wp14:sizeRelH></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeHeight &lt;wp14:sizeRelV></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Pictures.Picture &lt;pic:pic></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Pictures.ShapeStyle &lt;pic14:style></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Pictures.OfficeArtExtensionList &lt;pic14:extLst></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.WorksheetDrawing &lt;xdr:wsDr></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ContentPart &lt;xdr:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.Drawing.ContentPart &lt;xdr14:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.CommentAuthorList &lt;p:cmAuthorLst></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.CommentList &lt;p:cmLst></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.OleObject &lt;p:oleObj></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.Presentation &lt;p:presentation></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.PresentationProperties &lt;p:presentationPr></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.Slide &lt;p:sld></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.SlideLayout &lt;p:sldLayout></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.SlideMaster &lt;p:sldMaster></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.HandoutMaster &lt;p:handoutMaster></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.NotesMaster &lt;p:notesMaster></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.NotesSlide &lt;p:notes></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.SlideSyncProperties &lt;p:sldSyncPr></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.TagList &lt;p:tagLst></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.ViewProperties &lt;p:viewPr></description></item>
///<item><description>DocumentFormat.OpenXml.Presentation.ContentPart &lt;p:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.PresetTransition &lt;p15:prstTrans></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.PresenceInfo &lt;p15:presenceInfo></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.ThreadingInfo &lt;p15:threadingInfo></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.SlideGuideList &lt;p15:sldGuideLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.NotesGuideList &lt;p15:notesGuideLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.PowerPoint.ChartTrackingReferenceBased &lt;p15:chartTrackingRefBased></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.NonVisualContentPartProperties &lt;p14:nvContentPartPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.Transform2D &lt;p14:xfrm></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ExtensionListModify &lt;p14:extLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.Media &lt;p14:media></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.VortexTransition &lt;p14:vortex></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.SwitchTransition &lt;p14:switch></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.FlipTransition &lt;p14:flip></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.RippleTransition &lt;p14:ripple></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.HoneycombTransition &lt;p14:honeycomb></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.PrismTransition &lt;p14:prism></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.DoorsTransition &lt;p14:doors></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.WindowTransition &lt;p14:window></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.FerrisTransition &lt;p14:ferris></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.GalleryTransition &lt;p14:gallery></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ConveyorTransition &lt;p14:conveyor></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.PanTransition &lt;p14:pan></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.GlitterTransition &lt;p14:glitter></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.WarpTransition &lt;p14:warp></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.FlythroughTransition &lt;p14:flythrough></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.FlashTransition &lt;p14:flash></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ShredTransition &lt;p14:shred></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.RevealTransition &lt;p14:reveal></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.WheelReverseTransition &lt;p14:wheelReverse></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.BookmarkTarget &lt;p14:bmkTgt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.SectionProperties &lt;p14:sectionPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.SectionList &lt;p14:sectionLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.BrowseMode &lt;p14:browseMode></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.LaserColor &lt;p14:laserClr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.DefaultImageDpi &lt;p14:defaultImageDpi></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.DiscardImageEditData &lt;p14:discardImageEditData></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ShowMediaControls &lt;p14:showMediaCtrls></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.LaserTraceList &lt;p14:laserTraceLst></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.CreationId &lt;p14:creationId></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ModificationId &lt;p14:modId></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.PowerPoint.ShowEventRecordList &lt;p14:showEvtLst></description></item>
///<item><description>DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary &lt;sl:schemaLibrary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathProperties &lt;m:mathPr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Recipients &lt;w:recipients></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.TextBoxContent &lt;w:txbxContent></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Comments &lt;w:comments></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Footnotes &lt;w:footnotes></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Endnotes &lt;w:endnotes></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Header &lt;w:hdr></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Footer &lt;w:ftr></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Settings &lt;w:settings></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.WebSettings &lt;w:webSettings></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Fonts &lt;w:fonts></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Numbering &lt;w:numbering></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Styles &lt;w:styles></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.Document &lt;w:document></description></item>
///<item><description>DocumentFormat.OpenXml.Wordprocessing.GlossaryDocument &lt;w:glossaryDocument></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Color &lt;w15:color></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.DataBinding &lt;w15:dataBinding></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Appearance &lt;w15:appearance></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.CommentsEx &lt;w15:commentsEx></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.People &lt;w15:people></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection &lt;w15:repeatingSection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem &lt;w15:repeatingSectionItem></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased &lt;w15:chartTrackingRefBased></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.DefaultCollapsed &lt;w15:collapsed></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId &lt;w15:docId></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns &lt;w15:footnoteColumns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked &lt;w15:webExtensionLinked></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated &lt;w15:webExtensionCreated></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ContentPart &lt;w14:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DocumentId &lt;w14:docId></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictMode &lt;w14:conflictMode></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData &lt;w14:discardImageEditingData></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi &lt;w14:defaultImageDpi></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty &lt;w14:entityPicker></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox &lt;w14:checkbox></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shape &lt;v:shape></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shapetype &lt;v:shapetype></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Group &lt;v:group></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Background &lt;v:background></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Fill &lt;v:fill></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Formulas &lt;v:formulas></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ShapeHandles &lt;v:handles></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ImageData &lt;v:imagedata></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Path &lt;v:path></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.TextBox &lt;v:textbox></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shadow &lt;v:shadow></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Stroke &lt;v:stroke></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.TextPath &lt;v:textpath></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Arc &lt;v:arc></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Curve &lt;v:curve></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ImageFile &lt;v:image></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Line &lt;v:line></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Oval &lt;v:oval></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.PolyLine &lt;v:polyline></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Rectangle &lt;v:rect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.RoundRectangle &lt;v:roundrect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeDefaults &lt;o:shapedefaults></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeLayout &lt;o:shapelayout></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.SignatureLine &lt;o:signatureline></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Ink &lt;o:ink></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Diagram &lt;o:diagram></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Skew &lt;o:skew></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Extrusion &lt;o:extrusion></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Callout &lt;o:callout></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Lock &lt;o:lock></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.OleObject &lt;o:OLEObject></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.Complex &lt;o:complex></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.LeftStroke &lt;o:left></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.TopStroke &lt;o:top></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.RightStroke &lt;o:right></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.BottomStroke &lt;o:bottom></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ColumnStroke &lt;o:column></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ClipPath &lt;o:clippath></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.FillExtendedProperties &lt;o:fill></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.TopBorder &lt;w10:bordertop></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.LeftBorder &lt;w10:borderleft></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.RightBorder &lt;w10:borderright></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.BottomBorder &lt;w10:borderbottom></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.TextWrap &lt;w10:wrap></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Wordprocessing.AnchorLock &lt;w10:anchorlock></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Spreadsheet.ClientData &lt;xvml:ClientData></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Presentation.InkAnnotationFlag &lt;pvml:iscomment></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Presentation.TextData &lt;pvml:textdata></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DrawingCanvas.WordprocessingCanvas &lt;wpc:wpc></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DrawingGroup.WordprocessingGroup &lt;wpg:wgp></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DrawingShape.WordprocessingShape &lt;wps:wsp></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Slicer.Slicer &lt;sle:slicer></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ColorStyle &lt;cs:colorStyle></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ChartStyle &lt;cs:chartStyle></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.WebExtension.WebExtension &lt;we:webextension></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.WebExtension.WebExtensionReference &lt;we:webextensionref></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.TimeSlicer.TimeSlicer &lt;tsle:timeslicer></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Graphic))]
    [ChildElementInfo(typeof(Blip))]
    [ChildElementInfo(typeof(Theme))]
    [ChildElementInfo(typeof(ThemeOverride))]
    [ChildElementInfo(typeof(ThemeManager))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(TableStyleList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.CameraTool),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.TextMath),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office.Drawing.Drawing))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinition))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeaderList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.DataModelRoot))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinition))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeaderList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.RelationshipIds))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinition))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeaderList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Charts.ChartSpace))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Charts.UserShapes))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Charts.ChartReference))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.PivotSource),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.NumberingFormat),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShapeProperties),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.Layout),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FullReference),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.LevelReference),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FormulaReference),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSeriesTitle),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredCategoryTitle),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredAreaSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBarSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBubbleSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredLineSeriesExtension),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredPieSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredRadarSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredScatterSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSurfaceSeries),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelsRange),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.CategoryFilterExceptions),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelFieldTable),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.ExceptionForSave),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowDataLabelsRange),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.ChartText),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowLeaderLines),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.LeaderLines),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.Chart.AutoGeneneratedCategories),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Charts.PivotOptions),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Charts.SketchOptions),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Charts.InvertSolidFillFormat),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Charts.Style),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.ChartDrawing.ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.LegacyCompatibility.LegacyDrawing))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.LockedCanvas.LockedCanvas))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionHeightOffset),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionVerticalOffset),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeWidth),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeHeight),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Pictures.Picture))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Pictures.ShapeStyle),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Pictures.OfficeArtExtensionList),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.WorksheetDrawing))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.Drawing.ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.CommentAuthorList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.CommentList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.OleObject))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.Presentation))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.PresentationProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.Slide))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.SlideLayout))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.SlideMaster))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.HandoutMaster))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.NotesMaster))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.NotesSlide))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.SlideSyncProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.TagList))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.ViewProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Presentation.ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.PresetTransition),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.PresenceInfo),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.ThreadingInfo),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.SlideGuideList),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.NotesGuideList),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.PowerPoint.ChartTrackingReferenceBased),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.NonVisualContentPartProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.Transform2D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ExtensionListModify),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.Media),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.VortexTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.SwitchTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.FlipTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.RippleTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.HoneycombTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.PrismTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.DoorsTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.WindowTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.FerrisTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.GalleryTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ConveyorTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.PanTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.GlitterTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.WarpTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.FlythroughTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.FlashTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ShredTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.RevealTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.WheelReverseTransition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.BookmarkTarget),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.SectionProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.SectionList),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.BrowseMode),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.LaserColor),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.DefaultImageDpi),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.DiscardImageEditData),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ShowMediaControls),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.LaserTraceList),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.CreationId),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ModificationId),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.PowerPoint.ShowEventRecordList),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Recipients))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.TextBoxContent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Comments))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Footnotes))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Endnotes))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Header))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Footer))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Settings))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.WebSettings))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Fonts))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Numbering))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Styles))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.Document))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Wordprocessing.GlossaryDocument))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Color),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.DataBinding),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Appearance),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.CommentsEx),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.People),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.DefaultCollapsed),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DocumentId),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictMode),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shape))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shapetype))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Group))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Background))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Fill))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Formulas))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ShapeHandles))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ImageData))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Path))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.TextBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shadow))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Stroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.TextPath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Arc))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Curve))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ImageFile))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Line))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Oval))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.PolyLine))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Rectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.RoundRectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ShapeDefaults))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ShapeLayout))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.SignatureLine))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Ink))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Diagram))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Skew))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Extrusion))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Callout))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Lock))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.OleObject))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.Complex))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.LeftStroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.TopStroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.RightStroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.BottomStroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ColumnStroke))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ClipPath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.FillExtendedProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.TopBorder))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.LeftBorder))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.RightBorder))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.BottomBorder))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.TextWrap))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Wordprocessing.AnchorLock))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Spreadsheet.ClientData))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Presentation.InkAnnotationFlag))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Presentation.TextData))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DrawingCanvas.WordprocessingCanvas),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DrawingGroup.WordprocessingGroup),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DrawingShape.WordprocessingShape),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Slicer.Slicer),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ColorStyle),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ChartStyle),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.WebExtension.WebExtension),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.WebExtension.WebExtensionReference),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.TimeSlicer.TimeSlicer),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GraphicData : OpenXmlCompositeElement
{
    private const string tagName = "graphicData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10171;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Uniform Resource Identifier.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GraphicData class.
    /// </summary>
    public GraphicData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GraphicData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GraphicData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "graphic" == name)
    return new Graphic();
    
if( 10 == namespaceId && "blip" == name)
    return new Blip();
    
if( 10 == namespaceId && "theme" == name)
    return new Theme();
    
if( 10 == namespaceId && "themeOverride" == name)
    return new ThemeOverride();
    
if( 10 == namespaceId && "themeManager" == name)
    return new ThemeManager();
    
if( 10 == namespaceId && "tbl" == name)
    return new Table();
    
if( 10 == namespaceId && "tblStyleLst" == name)
    return new TableStyleList();
    
if( 75 == namespaceId && "webVideoPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty();
    
if( 73 == namespaceId && "themeFamily" == name)
    return new DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily();
    
if( 67 == namespaceId && "backgroundPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties();
    
if( 67 == namespaceId && "nonVisualGroupProps" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties();
    
if( 67 == namespaceId && "objectPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties();
    
if( 67 == namespaceId && "signatureLine" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine();
    
if( 48 == namespaceId && "cameraTool" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.CameraTool();
    
if( 48 == namespaceId && "compatExt" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension();
    
if( 48 == namespaceId && "isCanvas" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas();
    
if( 48 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart();
    
if( 48 == namespaceId && "shadowObscured" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured();
    
if( 48 == namespaceId && "hiddenFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties();
    
if( 48 == namespaceId && "hiddenLine" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties();
    
if( 48 == namespaceId && "hiddenEffects" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties();
    
if( 48 == namespaceId && "hiddenScene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D();
    
if( 48 == namespaceId && "hiddenSp3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D();
    
if( 48 == namespaceId && "imgProps" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties();
    
if( 48 == namespaceId && "useLocalDpi" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi();
    
if( 48 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.TextMath();
    
if( 58 == namespaceId && "cNvPr" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties();
    
if( 58 == namespaceId && "recolorImg" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages();
    
if( 56 == namespaceId && "drawing" == name)
    return new DocumentFormat.OpenXml.Office.Drawing.Drawing();
    
if( 56 == namespaceId && "dataModelExt" == name)
    return new DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock();
    
if( 14 == namespaceId && "colorsDef" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinition();
    
if( 14 == namespaceId && "colorsDefHdr" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeader();
    
if( 14 == namespaceId && "colorsDefHdrLst" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.ColorsDefinitionHeaderList();
    
if( 14 == namespaceId && "dataModel" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.DataModelRoot();
    
if( 14 == namespaceId && "layoutDef" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinition();
    
if( 14 == namespaceId && "layoutDefHdr" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeader();
    
if( 14 == namespaceId && "layoutDefHdrLst" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.LayoutDefinitionHeaderList();
    
if( 14 == namespaceId && "relIds" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.RelationshipIds();
    
if( 14 == namespaceId && "styleDef" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinition();
    
if( 14 == namespaceId && "styleDefHdr" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeader();
    
if( 14 == namespaceId && "styleDefHdrLst" == name)
    return new DocumentFormat.OpenXml.Drawing.Diagrams.StyleDefinitionHeaderList();
    
if( 11 == namespaceId && "chartSpace" == name)
    return new DocumentFormat.OpenXml.Drawing.Charts.ChartSpace();
    
if( 11 == namespaceId && "userShapes" == name)
    return new DocumentFormat.OpenXml.Drawing.Charts.UserShapes();
    
if( 11 == namespaceId && "chart" == name)
    return new DocumentFormat.OpenXml.Drawing.Charts.ChartReference();
    
if( 64 == namespaceId && "pivotSource" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.PivotSource();
    
if( 64 == namespaceId && "numFmt" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.NumberingFormat();
    
if( 64 == namespaceId && "spPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShapeProperties();
    
if( 64 == namespaceId && "layout" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.Layout();
    
if( 64 == namespaceId && "fullRef" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FullReference();
    
if( 64 == namespaceId && "levelRef" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.LevelReference();
    
if( 64 == namespaceId && "formulaRef" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FormulaReference();
    
if( 64 == namespaceId && "filteredSeriesTitle" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSeriesTitle();
    
if( 64 == namespaceId && "filteredCategoryTitle" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredCategoryTitle();
    
if( 64 == namespaceId && "filteredAreaSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredAreaSeries();
    
if( 64 == namespaceId && "filteredBarSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBarSeries();
    
if( 64 == namespaceId && "filteredBubbleSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredBubbleSeries();
    
if( 64 == namespaceId && "filteredLineSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredLineSeriesExtension();
    
if( 64 == namespaceId && "filteredPieSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredPieSeries();
    
if( 64 == namespaceId && "filteredRadarSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredRadarSeries();
    
if( 64 == namespaceId && "filteredScatterSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredScatterSeries();
    
if( 64 == namespaceId && "filteredSurfaceSeries" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.FilteredSurfaceSeries();
    
if( 64 == namespaceId && "datalabelsRange" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelsRange();
    
if( 64 == namespaceId && "categoryFilterExceptions" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.CategoryFilterExceptions();
    
if( 64 == namespaceId && "dlblFieldTable" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.DataLabelFieldTable();
    
if( 64 == namespaceId && "xForSave" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.ExceptionForSave();
    
if( 64 == namespaceId && "showDataLabelsRange" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowDataLabelsRange();
    
if( 64 == namespaceId && "tx" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.ChartText();
    
if( 64 == namespaceId && "showLeaderLines" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.ShowLeaderLines();
    
if( 64 == namespaceId && "leaderLines" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.LeaderLines();
    
if( 64 == namespaceId && "autoCat" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.Chart.AutoGeneneratedCategories();
    
if( 46 == namespaceId && "pivotOptions" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Charts.PivotOptions();
    
if( 46 == namespaceId && "sketchOptions" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Charts.SketchOptions();
    
if( 46 == namespaceId && "invertSolidFillFmt" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Charts.InvertSolidFillFormat();
    
if( 46 == namespaceId && "style" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Charts.Style();
    
if( 47 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.ChartDrawing.ContentPart();
    
if( 13 == namespaceId && "legacyDrawing" == name)
    return new DocumentFormat.OpenXml.Drawing.LegacyCompatibility.LegacyDrawing();
    
if( 15 == namespaceId && "lockedCanvas" == name)
    return new DocumentFormat.OpenXml.Drawing.LockedCanvas.LockedCanvas();
    
if( 16 == namespaceId && "inline" == name)
    return new DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline();
    
if( 16 == namespaceId && "anchor" == name)
    return new DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor();
    
if( 51 == namespaceId && "pctPosHOffset" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionHeightOffset();
    
if( 51 == namespaceId && "pctPosVOffset" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Drawing.PercentagePositionVerticalOffset();
    
if( 51 == namespaceId && "sizeRelH" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeWidth();
    
if( 51 == namespaceId && "sizeRelV" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Drawing.RelativeHeight();
    
if( 17 == namespaceId && "pic" == name)
    return new DocumentFormat.OpenXml.Drawing.Pictures.Picture();
    
if( 50 == namespaceId && "style" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Pictures.ShapeStyle();
    
if( 50 == namespaceId && "extLst" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Pictures.OfficeArtExtensionList();
    
if( 18 == namespaceId && "wsDr" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.WorksheetDrawing();
    
if( 18 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.ContentPart();
    
if( 54 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.Drawing.ContentPart();
    
if( 24 == namespaceId && "cmAuthorLst" == name)
    return new DocumentFormat.OpenXml.Presentation.CommentAuthorList();
    
if( 24 == namespaceId && "cmLst" == name)
    return new DocumentFormat.OpenXml.Presentation.CommentList();
    
if( 24 == namespaceId && "oleObj" == name)
    return new DocumentFormat.OpenXml.Presentation.OleObject();
    
if( 24 == namespaceId && "presentation" == name)
    return new DocumentFormat.OpenXml.Presentation.Presentation();
    
if( 24 == namespaceId && "presentationPr" == name)
    return new DocumentFormat.OpenXml.Presentation.PresentationProperties();
    
if( 24 == namespaceId && "sld" == name)
    return new DocumentFormat.OpenXml.Presentation.Slide();
    
if( 24 == namespaceId && "sldLayout" == name)
    return new DocumentFormat.OpenXml.Presentation.SlideLayout();
    
if( 24 == namespaceId && "sldMaster" == name)
    return new DocumentFormat.OpenXml.Presentation.SlideMaster();
    
if( 24 == namespaceId && "handoutMaster" == name)
    return new DocumentFormat.OpenXml.Presentation.HandoutMaster();
    
if( 24 == namespaceId && "notesMaster" == name)
    return new DocumentFormat.OpenXml.Presentation.NotesMaster();
    
if( 24 == namespaceId && "notes" == name)
    return new DocumentFormat.OpenXml.Presentation.NotesSlide();
    
if( 24 == namespaceId && "sldSyncPr" == name)
    return new DocumentFormat.OpenXml.Presentation.SlideSyncProperties();
    
if( 24 == namespaceId && "tagLst" == name)
    return new DocumentFormat.OpenXml.Presentation.TagList();
    
if( 24 == namespaceId && "viewPr" == name)
    return new DocumentFormat.OpenXml.Presentation.ViewProperties();
    
if( 24 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Presentation.ContentPart();
    
if( 68 == namespaceId && "prstTrans" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.PresetTransition();
    
if( 68 == namespaceId && "presenceInfo" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.PresenceInfo();
    
if( 68 == namespaceId && "threadingInfo" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.ThreadingInfo();
    
if( 68 == namespaceId && "sldGuideLst" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.SlideGuideList();
    
if( 68 == namespaceId && "notesGuideLst" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.NotesGuideList();
    
if( 68 == namespaceId && "chartTrackingRefBased" == name)
    return new DocumentFormat.OpenXml.Office2013.PowerPoint.ChartTrackingReferenceBased();
    
if( 49 == namespaceId && "nvContentPartPr" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.NonVisualContentPartProperties();
    
if( 49 == namespaceId && "xfrm" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.Transform2D();
    
if( 49 == namespaceId && "extLst" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ExtensionListModify();
    
if( 49 == namespaceId && "media" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.Media();
    
if( 49 == namespaceId && "vortex" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.VortexTransition();
    
if( 49 == namespaceId && "switch" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.SwitchTransition();
    
if( 49 == namespaceId && "flip" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.FlipTransition();
    
if( 49 == namespaceId && "ripple" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.RippleTransition();
    
if( 49 == namespaceId && "honeycomb" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.HoneycombTransition();
    
if( 49 == namespaceId && "prism" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.PrismTransition();
    
if( 49 == namespaceId && "doors" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.DoorsTransition();
    
if( 49 == namespaceId && "window" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.WindowTransition();
    
if( 49 == namespaceId && "ferris" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.FerrisTransition();
    
if( 49 == namespaceId && "gallery" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.GalleryTransition();
    
if( 49 == namespaceId && "conveyor" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ConveyorTransition();
    
if( 49 == namespaceId && "pan" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.PanTransition();
    
if( 49 == namespaceId && "glitter" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.GlitterTransition();
    
if( 49 == namespaceId && "warp" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.WarpTransition();
    
if( 49 == namespaceId && "flythrough" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.FlythroughTransition();
    
if( 49 == namespaceId && "flash" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.FlashTransition();
    
if( 49 == namespaceId && "shred" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ShredTransition();
    
if( 49 == namespaceId && "reveal" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.RevealTransition();
    
if( 49 == namespaceId && "wheelReverse" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.WheelReverseTransition();
    
if( 49 == namespaceId && "bmkTgt" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.BookmarkTarget();
    
if( 49 == namespaceId && "sectionPr" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.SectionProperties();
    
if( 49 == namespaceId && "sectionLst" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.SectionList();
    
if( 49 == namespaceId && "browseMode" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.BrowseMode();
    
if( 49 == namespaceId && "laserClr" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.LaserColor();
    
if( 49 == namespaceId && "defaultImageDpi" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.DefaultImageDpi();
    
if( 49 == namespaceId && "discardImageEditData" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.DiscardImageEditData();
    
if( 49 == namespaceId && "showMediaCtrls" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ShowMediaControls();
    
if( 49 == namespaceId && "laserTraceLst" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.LaserTraceList();
    
if( 49 == namespaceId && "creationId" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.CreationId();
    
if( 49 == namespaceId && "modId" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ModificationId();
    
if( 49 == namespaceId && "showEvtLst" == name)
    return new DocumentFormat.OpenXml.Office2010.PowerPoint.ShowEventRecordList();
    
if( 25 == namespaceId && "schemaLibrary" == name)
    return new DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary();
    
if( 21 == namespaceId && "mathPr" == name)
    return new DocumentFormat.OpenXml.Math.MathProperties();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 23 == namespaceId && "recipients" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Recipients();
    
if( 23 == namespaceId && "txbxContent" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.TextBoxContent();
    
if( 23 == namespaceId && "comments" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Comments();
    
if( 23 == namespaceId && "footnotes" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Footnotes();
    
if( 23 == namespaceId && "endnotes" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Endnotes();
    
if( 23 == namespaceId && "hdr" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Header();
    
if( 23 == namespaceId && "ftr" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Footer();
    
if( 23 == namespaceId && "settings" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Settings();
    
if( 23 == namespaceId && "webSettings" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.WebSettings();
    
if( 23 == namespaceId && "fonts" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Fonts();
    
if( 23 == namespaceId && "numbering" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Numbering();
    
if( 23 == namespaceId && "styles" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Styles();
    
if( 23 == namespaceId && "document" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.Document();
    
if( 23 == namespaceId && "glossaryDocument" == name)
    return new DocumentFormat.OpenXml.Wordprocessing.GlossaryDocument();
    
if( 69 == namespaceId && "color" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Color();
    
if( 69 == namespaceId && "dataBinding" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.DataBinding();
    
if( 69 == namespaceId && "appearance" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Appearance();
    
if( 69 == namespaceId && "commentsEx" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.CommentsEx();
    
if( 69 == namespaceId && "people" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.People();
    
if( 69 == namespaceId && "repeatingSection" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection();
    
if( 69 == namespaceId && "repeatingSectionItem" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem();
    
if( 69 == namespaceId && "chartTrackingRefBased" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased();
    
if( 69 == namespaceId && "collapsed" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.DefaultCollapsed();
    
if( 69 == namespaceId && "docId" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId();
    
if( 69 == namespaceId && "footnoteColumns" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns();
    
if( 69 == namespaceId && "webExtensionLinked" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked();
    
if( 69 == namespaceId && "webExtensionCreated" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated();
    
if( 52 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ContentPart();
    
if( 52 == namespaceId && "docId" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DocumentId();
    
if( 52 == namespaceId && "conflictMode" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictMode();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 52 == namespaceId && "discardImageEditingData" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData();
    
if( 52 == namespaceId && "defaultImageDpi" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi();
    
if( 52 == namespaceId && "entityPicker" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty();
    
if( 52 == namespaceId && "checkbox" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox();
    
if( 26 == namespaceId && "shape" == name)
    return new DocumentFormat.OpenXml.Vml.Shape();
    
if( 26 == namespaceId && "shapetype" == name)
    return new DocumentFormat.OpenXml.Vml.Shapetype();
    
if( 26 == namespaceId && "group" == name)
    return new DocumentFormat.OpenXml.Vml.Group();
    
if( 26 == namespaceId && "background" == name)
    return new DocumentFormat.OpenXml.Vml.Background();
    
if( 26 == namespaceId && "fill" == name)
    return new DocumentFormat.OpenXml.Vml.Fill();
    
if( 26 == namespaceId && "formulas" == name)
    return new DocumentFormat.OpenXml.Vml.Formulas();
    
if( 26 == namespaceId && "handles" == name)
    return new DocumentFormat.OpenXml.Vml.ShapeHandles();
    
if( 26 == namespaceId && "imagedata" == name)
    return new DocumentFormat.OpenXml.Vml.ImageData();
    
if( 26 == namespaceId && "path" == name)
    return new DocumentFormat.OpenXml.Vml.Path();
    
if( 26 == namespaceId && "textbox" == name)
    return new DocumentFormat.OpenXml.Vml.TextBox();
    
if( 26 == namespaceId && "shadow" == name)
    return new DocumentFormat.OpenXml.Vml.Shadow();
    
if( 26 == namespaceId && "stroke" == name)
    return new DocumentFormat.OpenXml.Vml.Stroke();
    
if( 26 == namespaceId && "textpath" == name)
    return new DocumentFormat.OpenXml.Vml.TextPath();
    
if( 26 == namespaceId && "arc" == name)
    return new DocumentFormat.OpenXml.Vml.Arc();
    
if( 26 == namespaceId && "curve" == name)
    return new DocumentFormat.OpenXml.Vml.Curve();
    
if( 26 == namespaceId && "image" == name)
    return new DocumentFormat.OpenXml.Vml.ImageFile();
    
if( 26 == namespaceId && "line" == name)
    return new DocumentFormat.OpenXml.Vml.Line();
    
if( 26 == namespaceId && "oval" == name)
    return new DocumentFormat.OpenXml.Vml.Oval();
    
if( 26 == namespaceId && "polyline" == name)
    return new DocumentFormat.OpenXml.Vml.PolyLine();
    
if( 26 == namespaceId && "rect" == name)
    return new DocumentFormat.OpenXml.Vml.Rectangle();
    
if( 26 == namespaceId && "roundrect" == name)
    return new DocumentFormat.OpenXml.Vml.RoundRectangle();
    
if( 27 == namespaceId && "shapedefaults" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ShapeDefaults();
    
if( 27 == namespaceId && "shapelayout" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ShapeLayout();
    
if( 27 == namespaceId && "signatureline" == name)
    return new DocumentFormat.OpenXml.Vml.Office.SignatureLine();
    
if( 27 == namespaceId && "ink" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Ink();
    
if( 27 == namespaceId && "diagram" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Diagram();
    
if( 27 == namespaceId && "skew" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Skew();
    
if( 27 == namespaceId && "extrusion" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Extrusion();
    
if( 27 == namespaceId && "callout" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Callout();
    
if( 27 == namespaceId && "lock" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Lock();
    
if( 27 == namespaceId && "OLEObject" == name)
    return new DocumentFormat.OpenXml.Vml.Office.OleObject();
    
if( 27 == namespaceId && "complex" == name)
    return new DocumentFormat.OpenXml.Vml.Office.Complex();
    
if( 27 == namespaceId && "left" == name)
    return new DocumentFormat.OpenXml.Vml.Office.LeftStroke();
    
if( 27 == namespaceId && "top" == name)
    return new DocumentFormat.OpenXml.Vml.Office.TopStroke();
    
if( 27 == namespaceId && "right" == name)
    return new DocumentFormat.OpenXml.Vml.Office.RightStroke();
    
if( 27 == namespaceId && "bottom" == name)
    return new DocumentFormat.OpenXml.Vml.Office.BottomStroke();
    
if( 27 == namespaceId && "column" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ColumnStroke();
    
if( 27 == namespaceId && "clippath" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ClipPath();
    
if( 27 == namespaceId && "fill" == name)
    return new DocumentFormat.OpenXml.Vml.Office.FillExtendedProperties();
    
if( 28 == namespaceId && "bordertop" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.TopBorder();
    
if( 28 == namespaceId && "borderleft" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.LeftBorder();
    
if( 28 == namespaceId && "borderright" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.RightBorder();
    
if( 28 == namespaceId && "borderbottom" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.BottomBorder();
    
if( 28 == namespaceId && "wrap" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.TextWrap();
    
if( 28 == namespaceId && "anchorlock" == name)
    return new DocumentFormat.OpenXml.Vml.Wordprocessing.AnchorLock();
    
if( 29 == namespaceId && "ClientData" == name)
    return new DocumentFormat.OpenXml.Vml.Spreadsheet.ClientData();
    
if( 30 == namespaceId && "iscomment" == name)
    return new DocumentFormat.OpenXml.Vml.Presentation.InkAnnotationFlag();
    
if( 30 == namespaceId && "textdata" == name)
    return new DocumentFormat.OpenXml.Vml.Presentation.TextData();
    
if( 59 == namespaceId && "wpc" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DrawingCanvas.WordprocessingCanvas();
    
if( 60 == namespaceId && "wgp" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DrawingGroup.WordprocessingGroup();
    
if( 61 == namespaceId && "wsp" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DrawingShape.WordprocessingShape();
    
if( 62 == namespaceId && "slicer" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Slicer.Slicer();
    
if( 65 == namespaceId && "colorStyle" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ColorStyle();
    
if( 65 == namespaceId && "chartStyle" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.ChartStyle.ChartStyle();
    
if( 66 == namespaceId && "webextension" == name)
    return new DocumentFormat.OpenXml.Office2013.WebExtension.WebExtension();
    
if( 66 == namespaceId && "webextensionref" == name)
    return new DocumentFormat.OpenXml.Office2013.WebExtension.WebExtensionReference();
    
if( 77 == namespaceId && "timeslicer" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.TimeSlicer.TimeSlicer();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GraphicData>(deep);
    }

   
}
/// <summary>
/// <para>Diagram to Animate.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:dgm.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Diagram : OpenXmlLeafElement
{
    private const string tagName = "dgm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10172;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","bldStep" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Identifier.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Animation Build Step.</para>
    /// <para>Represents the following attribute in the schema: bldStep </para>
    /// </summary>
    [SchemaAttr(0, "bldStep")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.DiagramBuildStepValues> BuildStep
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.DiagramBuildStepValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Diagram class.
    /// </summary>
    public Diagram():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "bldStep" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.DiagramBuildStepValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Diagram>(deep);
    }

   
}
/// <summary>
/// <para>Chart to Animate.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:chart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Chart : OpenXmlLeafElement
{
    private const string tagName = "chart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10173;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "seriesIdx","categoryIdx","bldStep" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Series Index.</para>
    /// <para>Represents the following attribute in the schema: seriesIdx </para>
    /// </summary>
    [SchemaAttr(0, "seriesIdx")]
    public Int32Value SeriesIndex
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Category Index.</para>
    /// <para>Represents the following attribute in the schema: categoryIdx </para>
    /// </summary>
    [SchemaAttr(0, "categoryIdx")]
    public Int32Value CategoryIndex
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Animation Build Step.</para>
    /// <para>Represents the following attribute in the schema: bldStep </para>
    /// </summary>
    [SchemaAttr(0, "bldStep")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ChartBuildStepValues> BuildStep
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ChartBuildStepValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Chart class.
    /// </summary>
    public Chart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "seriesIdx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "categoryIdx" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "bldStep" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ChartBuildStepValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Chart>(deep);
    }

   
}
/// <summary>
/// <para>Build Diagram.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bldDgm.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BuildDiagram : OpenXmlLeafElement
{
    private const string tagName = "bldDgm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10174;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bld","rev" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Build.</para>
    /// <para>Represents the following attribute in the schema: bld </para>
    /// </summary>
    [SchemaAttr(0, "bld")]
    public StringValue Build
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Reverse Animation.</para>
    /// <para>Represents the following attribute in the schema: rev </para>
    /// </summary>
    [SchemaAttr(0, "rev")]
    public BooleanValue ReverseAnimation
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BuildDiagram class.
    /// </summary>
    public BuildDiagram():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bld" == name)
    return new StringValue();
    
if( 0 == namespaceId && "rev" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BuildDiagram>(deep);
    }

   
}
/// <summary>
/// <para>Build Chart.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bldChart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BuildChart : OpenXmlLeafElement
{
    private const string tagName = "bldChart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10175;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bld","animBg" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Build.</para>
    /// <para>Represents the following attribute in the schema: bld </para>
    /// </summary>
    [SchemaAttr(0, "bld")]
    public StringValue Build
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Animate Background.</para>
    /// <para>Represents the following attribute in the schema: animBg </para>
    /// </summary>
    [SchemaAttr(0, "animBg")]
    public BooleanValue AnimateBackground
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BuildChart class.
    /// </summary>
    public BuildChart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bld" == name)
    return new StringValue();
    
if( 0 == namespaceId && "animBg" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BuildChart>(deep);
    }

   
}
/// <summary>
/// <para>Shape Text Body.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:txBody.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>BodyProperties &lt;a:bodyPr></description></item>
///<item><description>ListStyle &lt;a:lstStyle></description></item>
///<item><description>Paragraph &lt;a:p></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(BodyProperties))]
    [ChildElementInfo(typeof(ListStyle))]
    [ChildElementInfo(typeof(Paragraph))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextBody : OpenXmlCompositeElement
{
    private const string tagName = "txBody";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10176;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TextBody class.
    /// </summary>
    public TextBody():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextBody class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextBody(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextBody class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextBody(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextBody class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextBody(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "bodyPr" == name)
    return new BodyProperties();
    
if( 10 == namespaceId && "lstStyle" == name)
    return new ListStyle();
    
if( 10 == namespaceId && "p" == name)
    return new Paragraph();
    

    return null;
}

        private static readonly string[] eleTagNames = { "bodyPr","lstStyle","p" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Body Properties.</para>
    /// <para> Represents the following element tag in the schema: a:bodyPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BodyProperties BodyProperties
    {
        get 
        {
            return GetElement<BodyProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Text List Styles.</para>
    /// <para> Represents the following element tag in the schema: a:lstStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ListStyle ListStyle
    {
        get 
        {
            return GetElement<ListStyle>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextBody>(deep);
    }

   
}
/// <summary>
/// <para>Use Shape Text Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:useSpRect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseShapeRectangle : OpenXmlLeafElement
{
    private const string tagName = "useSpRect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10177;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the UseShapeRectangle class.
    /// </summary>
    public UseShapeRectangle():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseShapeRectangle>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Transform2D Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:xfrm.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Offset &lt;a:off></description></item>
///<item><description>Extents &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Offset))]
    [ChildElementInfo(typeof(Extents))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Transform2D : OpenXmlCompositeElement
{
    private const string tagName = "xfrm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10178;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rot","flipH","flipV" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Rotation.</para>
    /// <para>Represents the following attribute in the schema: rot </para>
    /// </summary>
    [SchemaAttr(0, "rot")]
    public Int32Value Rotation
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Flip.</para>
    /// <para>Represents the following attribute in the schema: flipH </para>
    /// </summary>
    [SchemaAttr(0, "flipH")]
    public BooleanValue HorizontalFlip
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Flip.</para>
    /// <para>Represents the following attribute in the schema: flipV </para>
    /// </summary>
    [SchemaAttr(0, "flipV")]
    public BooleanValue VerticalFlip
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Transform2D class.
    /// </summary>
    public Transform2D():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Transform2D class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Transform2D(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Transform2D class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Transform2D(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Transform2D class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Transform2D(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "off" == name)
    return new Offset();
    
if( 10 == namespaceId && "ext" == name)
    return new Extents();
    

    return null;
}

        private static readonly string[] eleTagNames = { "off","ext" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Offset.</para>
    /// <para> Represents the following element tag in the schema: a:off </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Offset Offset
    {
        get 
        {
            return GetElement<Offset>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Extents.</para>
    /// <para> Represents the following element tag in the schema: a:ext </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Extents Extents
    {
        get 
        {
            return GetElement<Extents>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rot" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "flipH" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "flipV" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Transform2D>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualDrawingProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HyperlinkOnClick &lt;a:hlinkClick></description></item>
///<item><description>HyperlinkOnHover &lt;a:hlinkHover></description></item>
///<item><description>NonVisualDrawingPropertiesExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(HyperlinkOnClick))]
    [ChildElementInfo(typeof(HyperlinkOnHover))]
    [ChildElementInfo(typeof(NonVisualDrawingPropertiesExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10179;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","name","descr","hidden","title" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> descr.</para>
    /// <para>Represents the following attribute in the schema: descr </para>
    /// </summary>
    [SchemaAttr(0, "descr")]
    public StringValue Description
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> hidden.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> title.</para>
    /// <para>Represents the following attribute in the schema: title </para>
    /// </summary>
    [SchemaAttr(0, "title")]
    public StringValue Title
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingProperties class.
    /// </summary>
    public NonVisualDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "hlinkClick" == name)
    return new HyperlinkOnClick();
    
if( 10 == namespaceId && "hlinkHover" == name)
    return new HyperlinkOnHover();
    
if( 10 == namespaceId && "extLst" == name)
    return new NonVisualDrawingPropertiesExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "hlinkClick","hlinkHover","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> HyperlinkOnClick.</para>
    /// <para> Represents the following element tag in the schema: a:hlinkClick </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HyperlinkOnClick HyperlinkOnClick
    {
        get 
        {
            return GetElement<HyperlinkOnClick>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> HyperlinkOnHover.</para>
    /// <para> Represents the following element tag in the schema: a:hlinkHover </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HyperlinkOnHover HyperlinkOnHover
    {
        get 
        {
            return GetElement<HyperlinkOnHover>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> NonVisualDrawingPropertiesExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingPropertiesExtensionList NonVisualDrawingPropertiesExtensionList
    {
        get 
        {
            return GetElement<NonVisualDrawingPropertiesExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "descr" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "title" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Shape Drawing Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeLocks &lt;a:spLocks></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ShapeLocks))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualShapeDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10180;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "txBox" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Text Box.</para>
    /// <para>Represents the following attribute in the schema: txBox </para>
    /// </summary>
    [SchemaAttr(0, "txBox")]
    public BooleanValue TextBox
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualShapeDrawingProperties class.
    /// </summary>
    public NonVisualShapeDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualShapeDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualShapeDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualShapeDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualShapeDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "spLocks" == name)
    return new ShapeLocks();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "spLocks","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Shape Locks.</para>
    /// <para> Represents the following element tag in the schema: a:spLocks </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeLocks ShapeLocks
    {
        get 
        {
            return GetElement<ShapeLocks>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "txBox" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualShapeDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Properties for a Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nvSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingProperties &lt;a:cNvPr></description></item>
///<item><description>NonVisualShapeDrawingProperties &lt;a:cNvSpPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingProperties))]
    [ChildElementInfo(typeof(NonVisualShapeDrawingProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualShapeProperties : OpenXmlCompositeElement
{
    private const string tagName = "nvSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10181;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualShapeProperties class.
    /// </summary>
    public NonVisualShapeProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualShapeProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualShapeProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualShapeProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cNvPr" == name)
    return new NonVisualDrawingProperties();
    
if( 10 == namespaceId && "cNvSpPr" == name)
    return new NonVisualShapeDrawingProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cNvPr","cNvSpPr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> NonVisualDrawingProperties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingProperties NonVisualDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualDrawingProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Non-Visual Shape Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualShapeDrawingProperties NonVisualShapeDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualShapeDrawingProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualShapeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Visual Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Transform2D &lt;a:xfrm></description></item>
///<item><description>CustomGeometry &lt;a:custGeom></description></item>
///<item><description>PresetGeometry &lt;a:prstGeom></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Scene3DType &lt;a:scene3d></description></item>
///<item><description>Shape3DType &lt;a:sp3d></description></item>
///<item><description>ShapePropertiesExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Transform2D))]
    [ChildElementInfo(typeof(CustomGeometry))]
    [ChildElementInfo(typeof(PresetGeometry))]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
    [ChildElementInfo(typeof(Scene3DType))]
    [ChildElementInfo(typeof(Shape3DType))]
    [ChildElementInfo(typeof(ShapePropertiesExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeProperties : OpenXmlCompositeElement
{
    private const string tagName = "spPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10182;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bwMode" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Black and White Mode.</para>
    /// <para>Represents the following attribute in the schema: bwMode </para>
    /// </summary>
    [SchemaAttr(0, "bwMode")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues> BlackWhiteMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeProperties class.
    /// </summary>
    public ShapeProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "xfrm" == name)
    return new Transform2D();
    
if( 10 == namespaceId && "custGeom" == name)
    return new CustomGeometry();
    
if( 10 == namespaceId && "prstGeom" == name)
    return new PresetGeometry();
    
if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    
if( 10 == namespaceId && "ln" == name)
    return new Outline();
    
if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    
if( 10 == namespaceId && "scene3d" == name)
    return new Scene3DType();
    
if( 10 == namespaceId && "sp3d" == name)
    return new Shape3DType();
    
if( 10 == namespaceId && "extLst" == name)
    return new ShapePropertiesExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "xfrm","custGeom","prstGeom","noFill","solidFill","gradFill","blipFill","pattFill","grpFill","ln","effectLst","effectDag","scene3d","sp3d","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> 2D Transform for Individual Objects.</para>
    /// <para> Represents the following element tag in the schema: a:xfrm </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Transform2D Transform2D
    {
        get 
        {
            return GetElement<Transform2D>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bwMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Text Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:txSp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TextBody &lt;a:txBody></description></item>
///<item><description>UseShapeRectangle &lt;a:useSpRect></description></item>
///<item><description>Transform2D &lt;a:xfrm></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TextBody))]
    [ChildElementInfo(typeof(UseShapeRectangle))]
    [ChildElementInfo(typeof(Transform2D))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextShape : OpenXmlCompositeElement
{
    private const string tagName = "txSp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10183;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TextShape class.
    /// </summary>
    public TextShape():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextShape(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextShape(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextShape class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextShape(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "txBody" == name)
    return new TextBody();
    
if( 10 == namespaceId && "useSpRect" == name)
    return new UseShapeRectangle();
    
if( 10 == namespaceId && "xfrm" == name)
    return new Transform2D();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "txBody","useSpRect","xfrm","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Shape Text Body.</para>
    /// <para> Represents the following element tag in the schema: a:txBody </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TextBody TextBody
    {
        get 
        {
            return GetElement<TextBody>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextShape>(deep);
    }

   
}
/// <summary>
/// <para>Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:style.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineReference &lt;a:lnRef></description></item>
///<item><description>FillReference &lt;a:fillRef></description></item>
///<item><description>EffectReference &lt;a:effectRef></description></item>
///<item><description>FontReference &lt;a:fontRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LineReference))]
    [ChildElementInfo(typeof(FillReference))]
    [ChildElementInfo(typeof(EffectReference))]
    [ChildElementInfo(typeof(FontReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeStyle : OpenXmlCompositeElement
{
    private const string tagName = "style";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10184;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ShapeStyle class.
    /// </summary>
    public ShapeStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapeStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "lnRef" == name)
    return new LineReference();
    
if( 10 == namespaceId && "fillRef" == name)
    return new FillReference();
    
if( 10 == namespaceId && "effectRef" == name)
    return new EffectReference();
    
if( 10 == namespaceId && "fontRef" == name)
    return new FontReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "lnRef","fillRef","effectRef","fontRef" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> LineReference.</para>
    /// <para> Represents the following element tag in the schema: a:lnRef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LineReference LineReference
    {
        get 
        {
            return GetElement<LineReference>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> FillReference.</para>
    /// <para> Represents the following element tag in the schema: a:fillRef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FillReference FillReference
    {
        get 
        {
            return GetElement<FillReference>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> EffectReference.</para>
    /// <para> Represents the following element tag in the schema: a:effectRef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EffectReference EffectReference
    {
        get 
        {
            return GetElement<EffectReference>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Font Reference.</para>
    /// <para> Represents the following element tag in the schema: a:fontRef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FontReference FontReference
    {
        get 
        {
            return GetElement<FontReference>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeStyle>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Connector Shape Drawing Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvCxnSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConnectionShapeLocks &lt;a:cxnSpLocks></description></item>
///<item><description>StartConnection &lt;a:stCxn></description></item>
///<item><description>EndConnection &lt;a:endCxn></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConnectionShapeLocks))]
    [ChildElementInfo(typeof(StartConnection))]
    [ChildElementInfo(typeof(EndConnection))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualConnectorShapeDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvCxnSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10185;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectorShapeDrawingProperties class.
    /// </summary>
    public NonVisualConnectorShapeDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualConnectorShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualConnectorShapeDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectorShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualConnectorShapeDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectorShapeDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualConnectorShapeDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cxnSpLocks" == name)
    return new ConnectionShapeLocks();
    
if( 10 == namespaceId && "stCxn" == name)
    return new StartConnection();
    
if( 10 == namespaceId && "endCxn" == name)
    return new EndConnection();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cxnSpLocks","stCxn","endCxn","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Connection Shape Locks.</para>
    /// <para> Represents the following element tag in the schema: a:cxnSpLocks </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ConnectionShapeLocks ConnectionShapeLocks
    {
        get 
        {
            return GetElement<ConnectionShapeLocks>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Connection Start.</para>
    /// <para> Represents the following element tag in the schema: a:stCxn </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public StartConnection StartConnection
    {
        get 
        {
            return GetElement<StartConnection>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Connection End.</para>
    /// <para> Represents the following element tag in the schema: a:endCxn </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public EndConnection EndConnection
    {
        get 
        {
            return GetElement<EndConnection>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualConnectorShapeDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Properties for a Connection Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nvCxnSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingProperties &lt;a:cNvPr></description></item>
///<item><description>NonVisualConnectorShapeDrawingProperties &lt;a:cNvCxnSpPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingProperties))]
    [ChildElementInfo(typeof(NonVisualConnectorShapeDrawingProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualConnectionShapeProperties : OpenXmlCompositeElement
{
    private const string tagName = "nvCxnSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10186;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectionShapeProperties class.
    /// </summary>
    public NonVisualConnectionShapeProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualConnectionShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualConnectionShapeProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectionShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualConnectionShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualConnectionShapeProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualConnectionShapeProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cNvPr" == name)
    return new NonVisualDrawingProperties();
    
if( 10 == namespaceId && "cNvCxnSpPr" == name)
    return new NonVisualConnectorShapeDrawingProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cNvPr","cNvCxnSpPr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingProperties NonVisualDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualDrawingProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Non-Visual Connector Shape Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvCxnSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualConnectorShapeDrawingProperties NonVisualConnectorShapeDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualConnectorShapeDrawingProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualConnectionShapeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Picture Drawing Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvPicPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PictureLocks &lt;a:picLocks></description></item>
///<item><description>NonVisualPicturePropertiesExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PictureLocks))]
    [ChildElementInfo(typeof(NonVisualPicturePropertiesExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualPictureDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvPicPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10187;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "preferRelativeResize" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> preferRelativeResize.</para>
    /// <para>Represents the following attribute in the schema: preferRelativeResize </para>
    /// </summary>
    [SchemaAttr(0, "preferRelativeResize")]
    public BooleanValue PreferRelativeResize
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualPictureDrawingProperties class.
    /// </summary>
    public NonVisualPictureDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualPictureDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPictureDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPictureDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPictureDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPictureDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualPictureDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "picLocks" == name)
    return new PictureLocks();
    
if( 10 == namespaceId && "extLst" == name)
    return new NonVisualPicturePropertiesExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "picLocks","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> PictureLocks.</para>
    /// <para> Represents the following element tag in the schema: a:picLocks </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PictureLocks PictureLocks
    {
        get 
        {
            return GetElement<PictureLocks>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> NonVisualPicturePropertiesExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualPicturePropertiesExtensionList NonVisualPicturePropertiesExtensionList
    {
        get 
        {
            return GetElement<NonVisualPicturePropertiesExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "preferRelativeResize" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualPictureDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Properties for a Picture.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nvPicPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingProperties &lt;a:cNvPr></description></item>
///<item><description>NonVisualPictureDrawingProperties &lt;a:cNvPicPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingProperties))]
    [ChildElementInfo(typeof(NonVisualPictureDrawingProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualPictureProperties : OpenXmlCompositeElement
{
    private const string tagName = "nvPicPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10188;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPictureProperties class.
    /// </summary>
    public NonVisualPictureProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualPictureProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPictureProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPictureProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPictureProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPictureProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualPictureProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cNvPr" == name)
    return new NonVisualDrawingProperties();
    
if( 10 == namespaceId && "cNvPicPr" == name)
    return new NonVisualPictureDrawingProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cNvPr","cNvPicPr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> NonVisualDrawingProperties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingProperties NonVisualDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualDrawingProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Non-Visual Picture Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPicPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualPictureDrawingProperties NonVisualPictureDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualPictureDrawingProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualPictureProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Graphic Frame Drawing Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvGraphicFramePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GraphicFrameLocks &lt;a:graphicFrameLocks></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GraphicFrameLocks))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGraphicFrameDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvGraphicFramePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10189;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameDrawingProperties class.
    /// </summary>
    public NonVisualGraphicFrameDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGraphicFrameDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGraphicFrameDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGraphicFrameDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGraphicFrameDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "graphicFrameLocks" == name)
    return new GraphicFrameLocks();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "graphicFrameLocks","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Graphic Frame Locks.</para>
    /// <para> Represents the following element tag in the schema: a:graphicFrameLocks </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GraphicFrameLocks GraphicFrameLocks
    {
        get 
        {
            return GetElement<GraphicFrameLocks>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGraphicFrameDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Properties for a Graphic Frame.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nvGraphicFramePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingProperties &lt;a:cNvPr></description></item>
///<item><description>NonVisualGraphicFrameDrawingProperties &lt;a:cNvGraphicFramePr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingProperties))]
    [ChildElementInfo(typeof(NonVisualGraphicFrameDrawingProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGraphicFrameProperties : OpenXmlCompositeElement
{
    private const string tagName = "nvGraphicFramePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10190;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameProperties class.
    /// </summary>
    public NonVisualGraphicFrameProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGraphicFrameProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGraphicFrameProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGraphicFrameProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGraphicFrameProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGraphicFrameProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cNvPr" == name)
    return new NonVisualDrawingProperties();
    
if( 10 == namespaceId && "cNvGraphicFramePr" == name)
    return new NonVisualGraphicFrameDrawingProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cNvPr","cNvGraphicFramePr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> NonVisualDrawingProperties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingProperties NonVisualDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualDrawingProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Non-Visual Graphic Frame Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvGraphicFramePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualGraphicFrameDrawingProperties NonVisualGraphicFrameDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualGraphicFrameDrawingProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGraphicFrameProperties>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Group Shape Drawing Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cNvGrpSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GroupShapeLocks &lt;a:grpSpLocks></description></item>
///<item><description>NonVisualGroupDrawingShapePropsExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GroupShapeLocks))]
    [ChildElementInfo(typeof(NonVisualGroupDrawingShapePropsExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGroupShapeDrawingProperties : OpenXmlCompositeElement
{
    private const string tagName = "cNvGrpSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10191;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeDrawingProperties class.
    /// </summary>
    public NonVisualGroupShapeDrawingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGroupShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupShapeDrawingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeDrawingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupShapeDrawingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeDrawingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGroupShapeDrawingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "grpSpLocks" == name)
    return new GroupShapeLocks();
    
if( 10 == namespaceId && "extLst" == name)
    return new NonVisualGroupDrawingShapePropsExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "grpSpLocks","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> GroupShapeLocks.</para>
    /// <para> Represents the following element tag in the schema: a:grpSpLocks </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public GroupShapeLocks GroupShapeLocks
    {
        get 
        {
            return GetElement<GroupShapeLocks>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> NonVisualGroupDrawingShapePropsExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualGroupDrawingShapePropsExtensionList NonVisualGroupDrawingShapePropsExtensionList
    {
        get 
        {
            return GetElement<NonVisualGroupDrawingShapePropsExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGroupShapeDrawingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Rotation.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:rot.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Rotation : OpenXmlLeafElement
{
    private const string tagName = "rot";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10192;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lat","lon","rev" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Latitude.</para>
    /// <para>Represents the following attribute in the schema: lat </para>
    /// </summary>
    [SchemaAttr(0, "lat")]
    public Int32Value Latitude
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Longitude.</para>
    /// <para>Represents the following attribute in the schema: lon </para>
    /// </summary>
    [SchemaAttr(0, "lon")]
    public Int32Value Longitude
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revolution.</para>
    /// <para>Represents the following attribute in the schema: rev </para>
    /// </summary>
    [SchemaAttr(0, "rev")]
    public Int32Value Revolution
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Rotation class.
    /// </summary>
    public Rotation():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "lat" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "lon" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "rev" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Rotation>(deep);
    }

   
}
/// <summary>
/// <para>Camera.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:camera.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Rotation &lt;a:rot></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Rotation))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Camera : OpenXmlCompositeElement
{
    private const string tagName = "camera";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10193;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prst","fov","zoom" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Camera Type.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetCameraValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetCameraValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field of View.</para>
    /// <para>Represents the following attribute in the schema: fov </para>
    /// </summary>
    [SchemaAttr(0, "fov")]
    public Int32Value FieldOfView
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Zoom.</para>
    /// <para>Represents the following attribute in the schema: zoom </para>
    /// </summary>
    [SchemaAttr(0, "zoom")]
    public Int32Value Zoom
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Camera class.
    /// </summary>
    public Camera():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Camera class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Camera(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Camera class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Camera(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Camera class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Camera(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "rot" == name)
    return new Rotation();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rot" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Rotation.</para>
    /// <para> Represents the following element tag in the schema: a:rot </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Rotation Rotation
    {
        get 
        {
            return GetElement<Rotation>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetCameraValues>();
    
if( 0 == namespaceId && "fov" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "zoom" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Camera>(deep);
    }

   
}
/// <summary>
/// <para>Light Rig.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lightRig.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Rotation &lt;a:rot></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Rotation))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LightRig : OpenXmlCompositeElement
{
    private const string tagName = "lightRig";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10194;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rig","dir" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Rig Preset.</para>
    /// <para>Represents the following attribute in the schema: rig </para>
    /// </summary>
    [SchemaAttr(0, "rig")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LightRigValues> Rig
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LightRigValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Direction.</para>
    /// <para>Represents the following attribute in the schema: dir </para>
    /// </summary>
    [SchemaAttr(0, "dir")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LightRigDirectionValues> Direction
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LightRigDirectionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LightRig class.
    /// </summary>
    public LightRig():base(){}
    
            /// <summary>
    ///Initializes a new instance of the LightRig class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LightRig(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LightRig class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LightRig(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LightRig class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LightRig(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "rot" == name)
    return new Rotation();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rot" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Rotation.</para>
    /// <para> Represents the following element tag in the schema: a:rot </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Rotation Rotation
    {
        get 
        {
            return GetElement<Rotation>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rig" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LightRigValues>();
    
if( 0 == namespaceId && "dir" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LightRigDirectionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LightRig>(deep);
    }

   
}
/// <summary>
/// <para>Backdrop Plane.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:backdrop.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Anchor &lt;a:anchor></description></item>
///<item><description>Normal &lt;a:norm></description></item>
///<item><description>UpVector &lt;a:up></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Anchor))]
    [ChildElementInfo(typeof(Normal))]
    [ChildElementInfo(typeof(UpVector))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Backdrop : OpenXmlCompositeElement
{
    private const string tagName = "backdrop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10195;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Backdrop class.
    /// </summary>
    public Backdrop():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Backdrop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Backdrop(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Backdrop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Backdrop(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Backdrop class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Backdrop(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "anchor" == name)
    return new Anchor();
    
if( 10 == namespaceId && "norm" == name)
    return new Normal();
    
if( 10 == namespaceId && "up" == name)
    return new UpVector();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "anchor","norm","up","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Anchor Point.</para>
    /// <para> Represents the following element tag in the schema: a:anchor </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Anchor Anchor
    {
        get 
        {
            return GetElement<Anchor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Normal.</para>
    /// <para> Represents the following element tag in the schema: a:norm </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Normal Normal
    {
        get 
        {
            return GetElement<Normal>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Up Vector.</para>
    /// <para> Represents the following element tag in the schema: a:up </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public UpVector UpVector
    {
        get 
        {
            return GetElement<UpVector>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Backdrop>(deep);
    }

   
}
/// <summary>
/// <para>Anchor Point.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:anchor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Anchor : OpenXmlLeafElement
{
    private const string tagName = "anchor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10196;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "x","y","z" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> X-Coordinate in 3D.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public Int64Value X
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Y-Coordinate in 3D.</para>
    /// <para>Represents the following attribute in the schema: y </para>
    /// </summary>
    [SchemaAttr(0, "y")]
    public Int64Value Y
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Z-Coordinate in 3D.</para>
    /// <para>Represents the following attribute in the schema: z </para>
    /// </summary>
    [SchemaAttr(0, "z")]
    public Int64Value Z
    {
        get { return (Int64Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Anchor class.
    /// </summary>
    public Anchor():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "y" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "z" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Anchor>(deep);
    }

   
}
/// <summary>
/// <para>Normal.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:norm.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Normal : Vector3DType
{
    private const string tagName = "norm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10197;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Normal class.
    /// </summary>
    public Normal():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Normal>(deep);
    }

}
/// <summary>
/// <para>Up Vector.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:up.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UpVector : Vector3DType
{
    private const string tagName = "up";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10198;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UpVector class.
    /// </summary>
    public UpVector():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UpVector>(deep);
    }

}
/// <summary>
/// Defines the Vector3DType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class Vector3DType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "dx","dy","dz" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Distance along X-axis in 3D.</para>
    /// <para>Represents the following attribute in the schema: dx </para>
    /// </summary>
    [SchemaAttr(0, "dx")]
    public Int64Value Dx
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Distance along Y-axis in 3D.</para>
    /// <para>Represents the following attribute in the schema: dy </para>
    /// </summary>
    [SchemaAttr(0, "dy")]
    public Int64Value Dy
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Distance along Z-axis in 3D.</para>
    /// <para>Represents the following attribute in the schema: dz </para>
    /// </summary>
    [SchemaAttr(0, "dz")]
    public Int64Value Dz
    {
        get { return (Int64Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "dx" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dy" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "dz" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the Vector3DType class.
    /// </summary>
    protected Vector3DType(){}
    
    
    
}
/// <summary>
/// <para>Top Bevel.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bevelT.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BevelTop : BevelType
{
    private const string tagName = "bevelT";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10199;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BevelTop class.
    /// </summary>
    public BevelTop():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BevelTop>(deep);
    }

}
/// <summary>
/// <para>Bottom Bevel.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bevelB.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BevelBottom : BevelType
{
    private const string tagName = "bevelB";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10200;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BevelBottom class.
    /// </summary>
    public BevelBottom():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BevelBottom>(deep);
    }

}
/// <summary>
/// <para>Bevel.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bevel.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Bevel : BevelType
{
    private const string tagName = "bevel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10262;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Bevel class.
    /// </summary>
    public Bevel():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Bevel>(deep);
    }

}
/// <summary>
/// Defines the BevelType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class BevelType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "w","h","prst" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Width.</para>
    /// <para>Represents the following attribute in the schema: w </para>
    /// </summary>
    [SchemaAttr(0, "w")]
    public Int64Value Width
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Height.</para>
    /// <para>Represents the following attribute in the schema: h </para>
    /// </summary>
    [SchemaAttr(0, "h")]
    public Int64Value Height
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Preset Bevel.</para>
    /// <para>Represents the following attribute in the schema: prst </para>
    /// </summary>
    [SchemaAttr(0, "prst")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BevelPresetValues> Preset
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BevelPresetValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "w" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "h" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "prst" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BevelPresetValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the BevelType class.
    /// </summary>
    protected BevelType(){}
    
    
    
}
/// <summary>
/// <para>Fill To Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fillToRect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillToRectangle : RelativeRectangleType
{
    private const string tagName = "fillToRect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10205;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FillToRectangle class.
    /// </summary>
    public FillToRectangle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillToRectangle>(deep);
    }

}
/// <summary>
/// <para>Tile Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tileRect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TileRectangle : RelativeRectangleType
{
    private const string tagName = "tileRect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10208;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TileRectangle class.
    /// </summary>
    public TileRectangle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TileRectangle>(deep);
    }

}
/// <summary>
/// <para>Fill Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:fillRect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FillRectangle : RelativeRectangleType
{
    private const string tagName = "fillRect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10209;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FillRectangle class.
    /// </summary>
    public FillRectangle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FillRectangle>(deep);
    }

}
/// <summary>
/// <para>Source Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:srcRect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SourceRectangle : RelativeRectangleType
{
    private const string tagName = "srcRect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10210;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SourceRectangle class.
    /// </summary>
    public SourceRectangle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SourceRectangle>(deep);
    }

}
/// <summary>
/// Defines the RelativeRectangleType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RelativeRectangleType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "l","t","r","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Left Offset.</para>
    /// <para>Represents the following attribute in the schema: l </para>
    /// </summary>
    [SchemaAttr(0, "l")]
    public Int32Value Left
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Top Offset.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public Int32Value Top
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Right Offset.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public Int32Value Right
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Offset.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public Int32Value Bottom
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "l" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "t" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "r" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "b" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the RelativeRectangleType class.
    /// </summary>
    protected RelativeRectangleType(){}
    
    
    
}
/// <summary>
/// <para>Gradient stops.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GradientStop : OpenXmlCompositeElement
{
    private const string tagName = "gs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10206;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "pos" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Position.</para>
    /// <para>Represents the following attribute in the schema: pos </para>
    /// </summary>
    [SchemaAttr(0, "pos")]
    public Int32Value Position
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GradientStop class.
    /// </summary>
    public GradientStop():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GradientStop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStop(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStop(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStop class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GradientStop(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "scrgbClr","srgbClr","hslClr","sysClr","schemeClr","prstClr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> RGB Color Model - Percentage Variant.</para>
    /// <para> Represents the following element tag in the schema: a:scrgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelPercentage RgbColorModelPercentage
    {
        get 
        {
            return GetElement<RgbColorModelPercentage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RGB Color Model - Hex Variant.</para>
    /// <para> Represents the following element tag in the schema: a:srgbClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RgbColorModelHex RgbColorModelHex
    {
        get 
        {
            return GetElement<RgbColorModelHex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Hue, Saturation, Luminance Color Model.</para>
    /// <para> Represents the following element tag in the schema: a:hslClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HslColor HslColor
    {
        get 
        {
            return GetElement<HslColor>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> System Color.</para>
    /// <para> Represents the following element tag in the schema: a:sysClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SystemColor SystemColor
    {
        get 
        {
            return GetElement<SystemColor>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Scheme Color.</para>
    /// <para> Represents the following element tag in the schema: a:schemeClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SchemeColor SchemeColor
    {
        get 
        {
            return GetElement<SchemeColor>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Preset Color.</para>
    /// <para> Represents the following element tag in the schema: a:prstClr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetColor PresetColor
    {
        get 
        {
            return GetElement<PresetColor>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "pos" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GradientStop>(deep);
    }

   
}
/// <summary>
/// <para>Gradient Stop List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gsLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GradientStop &lt;a:gs></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GradientStop))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GradientStopList : OpenXmlCompositeElement
{
    private const string tagName = "gsLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10207;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the GradientStopList class.
    /// </summary>
    public GradientStopList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GradientStopList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStopList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStopList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStopList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStopList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GradientStopList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "gs" == name)
    return new GradientStop();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GradientStopList>(deep);
    }

   
}
/// <summary>
/// <para>Shape Guide.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeGuide : OpenXmlLeafElement
{
    private const string tagName = "gd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10213;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","fmla" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shape Guide Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Shape Guide Formula.</para>
    /// <para>Represents the following attribute in the schema: fmla </para>
    /// </summary>
    [SchemaAttr(0, "fmla")]
    public StringValue Formula
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeGuide class.
    /// </summary>
    public ShapeGuide():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "fmla" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeGuide>(deep);
    }

   
}
/// <summary>
/// <para>Position.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pos.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Position : AdjustPoint2DType
{
    private const string tagName = "pos";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10214;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Position class.
    /// </summary>
    public Position():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Position>(deep);
    }

}
/// <summary>
/// <para>Move end point.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Point : AdjustPoint2DType
{
    private const string tagName = "pt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10218;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Point class.
    /// </summary>
    public Point():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Point>(deep);
    }

}
/// <summary>
/// Defines the AdjustPoint2DType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class AdjustPoint2DType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "x","y" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> X-Coordinate.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public StringValue X
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Y-Coordinate.</para>
    /// <para>Represents the following attribute in the schema: y </para>
    /// </summary>
    [SchemaAttr(0, "y")]
    public StringValue Y
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new StringValue();
    
if( 0 == namespaceId && "y" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the AdjustPoint2DType class.
    /// </summary>
    protected AdjustPoint2DType(){}
    
    
    
}
/// <summary>
/// <para>XY Adjust Handle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ahXY.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Position &lt;a:pos></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Position))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustHandleXY : OpenXmlCompositeElement
{
    private const string tagName = "ahXY";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10215;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "gdRefX","minX","maxX","gdRefY","minY","maxY" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Adjustment Guide.</para>
    /// <para>Represents the following attribute in the schema: gdRefX </para>
    /// </summary>
    [SchemaAttr(0, "gdRefX")]
    public StringValue XAdjustmentGuide
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Horizontal Adjustment.</para>
    /// <para>Represents the following attribute in the schema: minX </para>
    /// </summary>
    [SchemaAttr(0, "minX")]
    public StringValue MinX
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Horizontal Adjustment.</para>
    /// <para>Represents the following attribute in the schema: maxX </para>
    /// </summary>
    [SchemaAttr(0, "maxX")]
    public StringValue MaxX
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Adjustment Guide.</para>
    /// <para>Represents the following attribute in the schema: gdRefY </para>
    /// </summary>
    [SchemaAttr(0, "gdRefY")]
    public StringValue YAdjustmentGuide
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Vertical Adjustment.</para>
    /// <para>Represents the following attribute in the schema: minY </para>
    /// </summary>
    [SchemaAttr(0, "minY")]
    public StringValue MinY
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Vertical Adjustment.</para>
    /// <para>Represents the following attribute in the schema: maxY </para>
    /// </summary>
    [SchemaAttr(0, "maxY")]
    public StringValue MaxY
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AdjustHandleXY class.
    /// </summary>
    public AdjustHandleXY():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AdjustHandleXY class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandleXY(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandleXY class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandleXY(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandleXY class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AdjustHandleXY(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pos" == name)
    return new Position();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: a:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "gdRefX" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minX" == name)
    return new StringValue();
    
if( 0 == namespaceId && "maxX" == name)
    return new StringValue();
    
if( 0 == namespaceId && "gdRefY" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minY" == name)
    return new StringValue();
    
if( 0 == namespaceId && "maxY" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustHandleXY>(deep);
    }

   
}
/// <summary>
/// <para>Polar Adjust Handle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ahPolar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Position &lt;a:pos></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Position))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustHandlePolar : OpenXmlCompositeElement
{
    private const string tagName = "ahPolar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10216;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "gdRefR","minR","maxR","gdRefAng","minAng","maxAng" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Radial Adjustment Guide.</para>
    /// <para>Represents the following attribute in the schema: gdRefR </para>
    /// </summary>
    [SchemaAttr(0, "gdRefR")]
    public StringValue RadialAdjustmentGuide
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Radial Adjustment.</para>
    /// <para>Represents the following attribute in the schema: minR </para>
    /// </summary>
    [SchemaAttr(0, "minR")]
    public StringValue MinRadial
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Radial Adjustment.</para>
    /// <para>Represents the following attribute in the schema: maxR </para>
    /// </summary>
    [SchemaAttr(0, "maxR")]
    public StringValue MaxRadial
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Angle Adjustment Guide.</para>
    /// <para>Represents the following attribute in the schema: gdRefAng </para>
    /// </summary>
    [SchemaAttr(0, "gdRefAng")]
    public StringValue AngleAdjustmentGuide
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Angle Adjustment.</para>
    /// <para>Represents the following attribute in the schema: minAng </para>
    /// </summary>
    [SchemaAttr(0, "minAng")]
    public StringValue MinAngle
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Angle Adjustment.</para>
    /// <para>Represents the following attribute in the schema: maxAng </para>
    /// </summary>
    [SchemaAttr(0, "maxAng")]
    public StringValue MaxAngle
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AdjustHandlePolar class.
    /// </summary>
    public AdjustHandlePolar():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AdjustHandlePolar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandlePolar(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandlePolar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandlePolar(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandlePolar class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AdjustHandlePolar(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pos" == name)
    return new Position();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Shape Position Coordinate.</para>
    /// <para> Represents the following element tag in the schema: a:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "gdRefR" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minR" == name)
    return new StringValue();
    
if( 0 == namespaceId && "maxR" == name)
    return new StringValue();
    
if( 0 == namespaceId && "gdRefAng" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minAng" == name)
    return new StringValue();
    
if( 0 == namespaceId && "maxAng" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustHandlePolar>(deep);
    }

   
}
/// <summary>
/// <para>Shape Connection Site.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cxn.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Position &lt;a:pos></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Position))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionSite : OpenXmlCompositeElement
{
    private const string tagName = "cxn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10217;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ang" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Connection Site Angle.</para>
    /// <para>Represents the following attribute in the schema: ang </para>
    /// </summary>
    [SchemaAttr(0, "ang")]
    public StringValue Angle
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConnectionSite class.
    /// </summary>
    public ConnectionSite():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionSite class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionSite(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionSite class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionSite(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionSite class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionSite(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pos" == name)
    return new Position();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: a:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ang" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionSite>(deep);
    }

   
}
/// <summary>
/// <para>Close Shape Path.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:close.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CloseShapePath : OpenXmlLeafElement
{
    private const string tagName = "close";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10219;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CloseShapePath class.
    /// </summary>
    public CloseShapePath():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CloseShapePath>(deep);
    }

   
}
/// <summary>
/// <para>Move Path To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:moveTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Point &lt;a:pt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Point))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveTo : OpenXmlCompositeElement
{
    private const string tagName = "moveTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10220;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the MoveTo class.
    /// </summary>
    public MoveTo():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MoveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveTo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveTo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveTo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MoveTo(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pt" == name)
    return new Point();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pt" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Move end point.</para>
    /// <para> Represents the following element tag in the schema: a:pt </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Point Point
    {
        get 
        {
            return GetElement<Point>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveTo>(deep);
    }

   
}
/// <summary>
/// <para>Draw Line To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Point &lt;a:pt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Point))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineTo : OpenXmlCompositeElement
{
    private const string tagName = "lnTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10221;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the LineTo class.
    /// </summary>
    public LineTo():base(){}
    
            /// <summary>
    ///Initializes a new instance of the LineTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineTo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LineTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineTo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LineTo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LineTo(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pt" == name)
    return new Point();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pt" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Line end point.</para>
    /// <para> Represents the following element tag in the schema: a:pt </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Point Point
    {
        get 
        {
            return GetElement<Point>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineTo>(deep);
    }

   
}
/// <summary>
/// <para>Draw Arc To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:arcTo.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ArcTo : OpenXmlLeafElement
{
    private const string tagName = "arcTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10222;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "wR","hR","stAng","swAng" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shape Arc Width Radius.</para>
    /// <para>Represents the following attribute in the schema: wR </para>
    /// </summary>
    [SchemaAttr(0, "wR")]
    public StringValue WidthRadius
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Shape Arc Height Radius.</para>
    /// <para>Represents the following attribute in the schema: hR </para>
    /// </summary>
    [SchemaAttr(0, "hR")]
    public StringValue HeightRadius
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Shape Arc Start Angle.</para>
    /// <para>Represents the following attribute in the schema: stAng </para>
    /// </summary>
    [SchemaAttr(0, "stAng")]
    public StringValue StartAngle
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Shape Arc Swing Angle.</para>
    /// <para>Represents the following attribute in the schema: swAng </para>
    /// </summary>
    [SchemaAttr(0, "swAng")]
    public StringValue SwingAngle
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ArcTo class.
    /// </summary>
    public ArcTo():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "wR" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hR" == name)
    return new StringValue();
    
if( 0 == namespaceId && "stAng" == name)
    return new StringValue();
    
if( 0 == namespaceId && "swAng" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ArcTo>(deep);
    }

   
}
/// <summary>
/// <para>Draw Quadratic Bezier Curve To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:quadBezTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Point &lt;a:pt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Point))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QuadraticBezierCurveTo : OpenXmlCompositeElement
{
    private const string tagName = "quadBezTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10223;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the QuadraticBezierCurveTo class.
    /// </summary>
    public QuadraticBezierCurveTo():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QuadraticBezierCurveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QuadraticBezierCurveTo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QuadraticBezierCurveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QuadraticBezierCurveTo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QuadraticBezierCurveTo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QuadraticBezierCurveTo(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pt" == name)
    return new Point();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QuadraticBezierCurveTo>(deep);
    }

   
}
/// <summary>
/// <para>Draw Cubic Bezier Curve To.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cubicBezTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Point &lt;a:pt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Point))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CubicBezierCurveTo : OpenXmlCompositeElement
{
    private const string tagName = "cubicBezTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10224;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CubicBezierCurveTo class.
    /// </summary>
    public CubicBezierCurveTo():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CubicBezierCurveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CubicBezierCurveTo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CubicBezierCurveTo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CubicBezierCurveTo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CubicBezierCurveTo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CubicBezierCurveTo(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pt" == name)
    return new Point();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CubicBezierCurveTo>(deep);
    }

   
}
/// <summary>
/// <para>Shape Path.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:path.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CloseShapePath &lt;a:close></description></item>
///<item><description>MoveTo &lt;a:moveTo></description></item>
///<item><description>LineTo &lt;a:lnTo></description></item>
///<item><description>ArcTo &lt;a:arcTo></description></item>
///<item><description>QuadraticBezierCurveTo &lt;a:quadBezTo></description></item>
///<item><description>CubicBezierCurveTo &lt;a:cubicBezTo></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CloseShapePath))]
    [ChildElementInfo(typeof(MoveTo))]
    [ChildElementInfo(typeof(LineTo))]
    [ChildElementInfo(typeof(ArcTo))]
    [ChildElementInfo(typeof(QuadraticBezierCurveTo))]
    [ChildElementInfo(typeof(CubicBezierCurveTo))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Path : OpenXmlCompositeElement
{
    private const string tagName = "path";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10225;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w","h","fill","stroke","extrusionOk" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Path Width.</para>
    /// <para>Represents the following attribute in the schema: w </para>
    /// </summary>
    [SchemaAttr(0, "w")]
    public Int64Value Width
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Path Height.</para>
    /// <para>Represents the following attribute in the schema: h </para>
    /// </summary>
    [SchemaAttr(0, "h")]
    public Int64Value Height
    {
        get { return (Int64Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Path Fill.</para>
    /// <para>Represents the following attribute in the schema: fill </para>
    /// </summary>
    [SchemaAttr(0, "fill")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PathFillModeValues> Fill
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PathFillModeValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Path Stroke.</para>
    /// <para>Represents the following attribute in the schema: stroke </para>
    /// </summary>
    [SchemaAttr(0, "stroke")]
    public BooleanValue Stroke
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> 3D Extrusion Allowed.</para>
    /// <para>Represents the following attribute in the schema: extrusionOk </para>
    /// </summary>
    [SchemaAttr(0, "extrusionOk")]
    public BooleanValue ExtrusionOk
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Path class.
    /// </summary>
    public Path():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Path class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Path(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Path class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Path(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Path class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Path(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "close" == name)
    return new CloseShapePath();
    
if( 10 == namespaceId && "moveTo" == name)
    return new MoveTo();
    
if( 10 == namespaceId && "lnTo" == name)
    return new LineTo();
    
if( 10 == namespaceId && "arcTo" == name)
    return new ArcTo();
    
if( 10 == namespaceId && "quadBezTo" == name)
    return new QuadraticBezierCurveTo();
    
if( 10 == namespaceId && "cubicBezTo" == name)
    return new CubicBezierCurveTo();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "w" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "h" == name)
    return new Int64Value();
    
if( 0 == namespaceId && "fill" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PathFillModeValues>();
    
if( 0 == namespaceId && "stroke" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "extrusionOk" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Path>(deep);
    }

   
}
/// <summary>
/// <para>List of Shape Adjust Values.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:avLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeGuide &lt;a:gd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustValueList : GeometryGuideListType
{
    private const string tagName = "avLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10226;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AdjustValueList class.
    /// </summary>
    public AdjustValueList():base(){}
            /// <summary>
    ///Initializes a new instance of the AdjustValueList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustValueList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustValueList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustValueList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustValueList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AdjustValueList(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustValueList>(deep);
    }

}
/// <summary>
/// <para>List of Shape Guides.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gdLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeGuide &lt;a:gd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeGuideList : GeometryGuideListType
{
    private const string tagName = "gdLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10227;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeGuideList class.
    /// </summary>
    public ShapeGuideList():base(){}
            /// <summary>
    ///Initializes a new instance of the ShapeGuideList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeGuideList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeGuideList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeGuideList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeGuideList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeGuideList(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeGuideList>(deep);
    }

}
/// <summary>
/// Defines the GeometryGuideListType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeGuide &lt;a:gd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ShapeGuide))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class GeometryGuideListType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "gd" == name)
    return new ShapeGuide();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the GeometryGuideListType class.
    /// </summary>
    protected GeometryGuideListType(){}
    
            /// <summary>
    ///Initializes a new instance of the GeometryGuideListType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected GeometryGuideListType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GeometryGuideListType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected GeometryGuideListType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GeometryGuideListType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected GeometryGuideListType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>List of Shape Adjust Handles.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ahLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AdjustHandleXY &lt;a:ahXY></description></item>
///<item><description>AdjustHandlePolar &lt;a:ahPolar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AdjustHandleXY))]
    [ChildElementInfo(typeof(AdjustHandlePolar))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustHandleList : OpenXmlCompositeElement
{
    private const string tagName = "ahLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10228;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandleList class.
    /// </summary>
    public AdjustHandleList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AdjustHandleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandleList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandleList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AdjustHandleList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AdjustHandleList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AdjustHandleList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ahXY" == name)
    return new AdjustHandleXY();
    
if( 10 == namespaceId && "ahPolar" == name)
    return new AdjustHandlePolar();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustHandleList>(deep);
    }

   
}
/// <summary>
/// <para>List of Shape Connection Sites.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cxnLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConnectionSite &lt;a:cxn></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConnectionSite))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionSiteList : OpenXmlCompositeElement
{
    private const string tagName = "cxnLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10229;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ConnectionSiteList class.
    /// </summary>
    public ConnectionSiteList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionSiteList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionSiteList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionSiteList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionSiteList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionSiteList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionSiteList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cxn" == name)
    return new ConnectionSite();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionSiteList>(deep);
    }

   
}
/// <summary>
/// <para>Shape Text Rectangle.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:rect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Rectangle : OpenXmlLeafElement
{
    private const string tagName = "rect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10230;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "l","t","r","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Left.</para>
    /// <para>Represents the following attribute in the schema: l </para>
    /// </summary>
    [SchemaAttr(0, "l")]
    public StringValue Left
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Top.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public StringValue Top
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Right.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue Right
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Position.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public StringValue Bottom
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Rectangle class.
    /// </summary>
    public Rectangle():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "l" == name)
    return new StringValue();
    
if( 0 == namespaceId && "t" == name)
    return new StringValue();
    
if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "b" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Rectangle>(deep);
    }

   
}
/// <summary>
/// <para>List of Shape Paths.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pathLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Path &lt;a:path></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Path))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PathList : OpenXmlCompositeElement
{
    private const string tagName = "pathLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10231;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PathList class.
    /// </summary>
    public PathList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PathList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PathList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PathList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PathList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PathList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PathList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "path" == name)
    return new Path();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PathList>(deep);
    }

   
}
/// <summary>
/// <para>Dash Stop.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ds.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DashStop : OpenXmlLeafElement
{
    private const string tagName = "ds";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10232;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "d","sp" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Dash Length.</para>
    /// <para>Represents the following attribute in the schema: d </para>
    /// </summary>
    [SchemaAttr(0, "d")]
    public Int32Value DashLength
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Space Length.</para>
    /// <para>Represents the following attribute in the schema: sp </para>
    /// </summary>
    [SchemaAttr(0, "sp")]
    public Int32Value SpaceLength
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DashStop class.
    /// </summary>
    public DashStop():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "d" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "sp" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DashStop>(deep);
    }

   
}
/// <summary>
/// <para>Line Head/End Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:headEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HeadEnd : LineEndPropertiesType
{
    private const string tagName = "headEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10233;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HeadEnd class.
    /// </summary>
    public HeadEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HeadEnd>(deep);
    }

}
/// <summary>
/// <para>Tail line end style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tailEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TailEnd : LineEndPropertiesType
{
    private const string tagName = "tailEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10234;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TailEnd class.
    /// </summary>
    public TailEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TailEnd>(deep);
    }

}
/// <summary>
/// Defines the LineEndPropertiesType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class LineEndPropertiesType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "type","w","len" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Line Head/End Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LineEndValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LineEndValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Width of Head/End.</para>
    /// <para>Represents the following attribute in the schema: w </para>
    /// </summary>
    [SchemaAttr(0, "w")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LineEndWidthValues> Width
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LineEndWidthValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Length of Head/End.</para>
    /// <para>Represents the following attribute in the schema: len </para>
    /// </summary>
    [SchemaAttr(0, "len")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.LineEndLengthValues> Length
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.LineEndLengthValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LineEndValues>();
    
if( 0 == namespaceId && "w" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LineEndWidthValues>();
    
if( 0 == namespaceId && "len" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.LineEndLengthValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the LineEndPropertiesType class.
    /// </summary>
    protected LineEndPropertiesType(){}
    
    
    
}
/// <summary>
/// <para>2D Transform for Grouped Objects.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:xfrm.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Offset &lt;a:off></description></item>
///<item><description>Extents &lt;a:ext></description></item>
///<item><description>ChildOffset &lt;a:chOff></description></item>
///<item><description>ChildExtents &lt;a:chExt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Offset))]
    [ChildElementInfo(typeof(Extents))]
    [ChildElementInfo(typeof(ChildOffset))]
    [ChildElementInfo(typeof(ChildExtents))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TransformGroup : OpenXmlCompositeElement
{
    private const string tagName = "xfrm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10235;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rot","flipH","flipV" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Rotation.</para>
    /// <para>Represents the following attribute in the schema: rot </para>
    /// </summary>
    [SchemaAttr(0, "rot")]
    public Int32Value Rotation
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Flip.</para>
    /// <para>Represents the following attribute in the schema: flipH </para>
    /// </summary>
    [SchemaAttr(0, "flipH")]
    public BooleanValue HorizontalFlip
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Flip.</para>
    /// <para>Represents the following attribute in the schema: flipV </para>
    /// </summary>
    [SchemaAttr(0, "flipV")]
    public BooleanValue VerticalFlip
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TransformGroup class.
    /// </summary>
    public TransformGroup():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TransformGroup class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TransformGroup(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TransformGroup class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TransformGroup(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TransformGroup class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TransformGroup(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "off" == name)
    return new Offset();
    
if( 10 == namespaceId && "ext" == name)
    return new Extents();
    
if( 10 == namespaceId && "chOff" == name)
    return new ChildOffset();
    
if( 10 == namespaceId && "chExt" == name)
    return new ChildExtents();
    

    return null;
}

        private static readonly string[] eleTagNames = { "off","ext","chOff","chExt" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Offset.</para>
    /// <para> Represents the following element tag in the schema: a:off </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Offset Offset
    {
        get 
        {
            return GetElement<Offset>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Extents.</para>
    /// <para> Represents the following element tag in the schema: a:ext </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Extents Extents
    {
        get 
        {
            return GetElement<Extents>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Child Offset.</para>
    /// <para> Represents the following element tag in the schema: a:chOff </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ChildOffset ChildOffset
    {
        get 
        {
            return GetElement<ChildOffset>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Child Extents.</para>
    /// <para> Represents the following element tag in the schema: a:chExt </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ChildExtents ChildExtents
    {
        get 
        {
            return GetElement<ChildExtents>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rot" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "flipH" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "flipV" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TransformGroup>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BodyProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bodyPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PresetTextWrap &lt;a:prstTxWarp></description></item>
///<item><description>NoAutoFit &lt;a:noAutofit></description></item>
///<item><description>NormalAutoFit &lt;a:normAutofit></description></item>
///<item><description>ShapeAutoFit &lt;a:spAutoFit></description></item>
///<item><description>Scene3DType &lt;a:scene3d></description></item>
///<item><description>Shape3DType &lt;a:sp3d></description></item>
///<item><description>FlatText &lt;a:flatTx></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PresetTextWrap))]
    [ChildElementInfo(typeof(NoAutoFit))]
    [ChildElementInfo(typeof(NormalAutoFit))]
    [ChildElementInfo(typeof(ShapeAutoFit))]
    [ChildElementInfo(typeof(Scene3DType))]
    [ChildElementInfo(typeof(Shape3DType))]
    [ChildElementInfo(typeof(FlatText))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BodyProperties : OpenXmlCompositeElement
{
    private const string tagName = "bodyPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10237;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rot","spcFirstLastPara","vertOverflow","horzOverflow","vert","wrap","lIns","tIns","rIns","bIns","numCol","spcCol","rtlCol","fromWordArt","anchor","anchorCtr","forceAA","upright","compatLnSpc" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Rotation.</para>
    /// <para>Represents the following attribute in the schema: rot </para>
    /// </summary>
    [SchemaAttr(0, "rot")]
    public Int32Value Rotation
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Paragraph Spacing.</para>
    /// <para>Represents the following attribute in the schema: spcFirstLastPara </para>
    /// </summary>
    [SchemaAttr(0, "spcFirstLastPara")]
    public BooleanValue UseParagraphSpacing
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Text Vertical Overflow.</para>
    /// <para>Represents the following attribute in the schema: vertOverflow </para>
    /// </summary>
    [SchemaAttr(0, "vertOverflow")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalOverflowValues> VerticalOverflow
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalOverflowValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Text Horizontal Overflow.</para>
    /// <para>Represents the following attribute in the schema: horzOverflow </para>
    /// </summary>
    [SchemaAttr(0, "horzOverflow")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues> HorizontalOverflow
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Text.</para>
    /// <para>Represents the following attribute in the schema: vert </para>
    /// </summary>
    [SchemaAttr(0, "vert")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues> Vertical
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Text Wrapping Type.</para>
    /// <para>Represents the following attribute in the schema: wrap </para>
    /// </summary>
    [SchemaAttr(0, "wrap")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextWrappingValues> Wrap
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextWrappingValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Left Inset.</para>
    /// <para>Represents the following attribute in the schema: lIns </para>
    /// </summary>
    [SchemaAttr(0, "lIns")]
    public Int32Value LeftInset
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Top Inset.</para>
    /// <para>Represents the following attribute in the schema: tIns </para>
    /// </summary>
    [SchemaAttr(0, "tIns")]
    public Int32Value TopInset
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Right Inset.</para>
    /// <para>Represents the following attribute in the schema: rIns </para>
    /// </summary>
    [SchemaAttr(0, "rIns")]
    public Int32Value RightInset
    {
        get { return (Int32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Inset.</para>
    /// <para>Represents the following attribute in the schema: bIns </para>
    /// </summary>
    [SchemaAttr(0, "bIns")]
    public Int32Value BottomInset
    {
        get { return (Int32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Number of Columns.</para>
    /// <para>Represents the following attribute in the schema: numCol </para>
    /// </summary>
    [SchemaAttr(0, "numCol")]
    public Int32Value ColumnCount
    {
        get { return (Int32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Space Between Columns.</para>
    /// <para>Represents the following attribute in the schema: spcCol </para>
    /// </summary>
    [SchemaAttr(0, "spcCol")]
    public Int32Value ColumnSpacing
    {
        get { return (Int32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Columns Right-To-Left.</para>
    /// <para>Represents the following attribute in the schema: rtlCol </para>
    /// </summary>
    [SchemaAttr(0, "rtlCol")]
    public BooleanValue RightToLeftColumns
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> From WordArt.</para>
    /// <para>Represents the following attribute in the schema: fromWordArt </para>
    /// </summary>
    [SchemaAttr(0, "fromWordArt")]
    public BooleanValue FromWordArt
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Anchor.</para>
    /// <para>Represents the following attribute in the schema: anchor </para>
    /// </summary>
    [SchemaAttr(0, "anchor")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues> Anchor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues>)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Anchor Center.</para>
    /// <para>Represents the following attribute in the schema: anchorCtr </para>
    /// </summary>
    [SchemaAttr(0, "anchorCtr")]
    public BooleanValue AnchorCenter
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Force Anti-Alias.</para>
    /// <para>Represents the following attribute in the schema: forceAA </para>
    /// </summary>
    [SchemaAttr(0, "forceAA")]
    public BooleanValue ForceAntiAlias
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Text Upright.</para>
    /// <para>Represents the following attribute in the schema: upright </para>
    /// </summary>
    [SchemaAttr(0, "upright")]
    public BooleanValue UpRight
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Compatible Line Spacing.</para>
    /// <para>Represents the following attribute in the schema: compatLnSpc </para>
    /// </summary>
    [SchemaAttr(0, "compatLnSpc")]
    public BooleanValue CompatibleLineSpacing
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BodyProperties class.
    /// </summary>
    public BodyProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BodyProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BodyProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BodyProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BodyProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BodyProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BodyProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "prstTxWarp" == name)
    return new PresetTextWrap();
    
if( 10 == namespaceId && "noAutofit" == name)
    return new NoAutoFit();
    
if( 10 == namespaceId && "normAutofit" == name)
    return new NormalAutoFit();
    
if( 10 == namespaceId && "spAutoFit" == name)
    return new ShapeAutoFit();
    
if( 10 == namespaceId && "scene3d" == name)
    return new Scene3DType();
    
if( 10 == namespaceId && "sp3d" == name)
    return new Shape3DType();
    
if( 10 == namespaceId && "flatTx" == name)
    return new FlatText();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "prstTxWarp","noAutofit","normAutofit","spAutoFit","scene3d","sp3d","flatTx","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Preset Text Shape.</para>
    /// <para> Represents the following element tag in the schema: a:prstTxWarp </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public PresetTextWrap PresetTextWrap
    {
        get 
        {
            return GetElement<PresetTextWrap>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rot" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "spcFirstLastPara" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "vertOverflow" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalOverflowValues>();
    
if( 0 == namespaceId && "horzOverflow" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues>();
    
if( 0 == namespaceId && "vert" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues>();
    
if( 0 == namespaceId && "wrap" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextWrappingValues>();
    
if( 0 == namespaceId && "lIns" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "tIns" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "rIns" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "bIns" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "numCol" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "spcCol" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "rtlCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fromWordArt" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "anchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues>();
    
if( 0 == namespaceId && "anchorCtr" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "forceAA" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "upright" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "compatLnSpc" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BodyProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ListStyle Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lstStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DefaultParagraphProperties &lt;a:defPPr></description></item>
///<item><description>Level1ParagraphProperties &lt;a:lvl1pPr></description></item>
///<item><description>Level2ParagraphProperties &lt;a:lvl2pPr></description></item>
///<item><description>Level3ParagraphProperties &lt;a:lvl3pPr></description></item>
///<item><description>Level4ParagraphProperties &lt;a:lvl4pPr></description></item>
///<item><description>Level5ParagraphProperties &lt;a:lvl5pPr></description></item>
///<item><description>Level6ParagraphProperties &lt;a:lvl6pPr></description></item>
///<item><description>Level7ParagraphProperties &lt;a:lvl7pPr></description></item>
///<item><description>Level8ParagraphProperties &lt;a:lvl8pPr></description></item>
///<item><description>Level9ParagraphProperties &lt;a:lvl9pPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DefaultParagraphProperties))]
    [ChildElementInfo(typeof(Level1ParagraphProperties))]
    [ChildElementInfo(typeof(Level2ParagraphProperties))]
    [ChildElementInfo(typeof(Level3ParagraphProperties))]
    [ChildElementInfo(typeof(Level4ParagraphProperties))]
    [ChildElementInfo(typeof(Level5ParagraphProperties))]
    [ChildElementInfo(typeof(Level6ParagraphProperties))]
    [ChildElementInfo(typeof(Level7ParagraphProperties))]
    [ChildElementInfo(typeof(Level8ParagraphProperties))]
    [ChildElementInfo(typeof(Level9ParagraphProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ListStyle : OpenXmlCompositeElement
{
    private const string tagName = "lstStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10238;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ListStyle class.
    /// </summary>
    public ListStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ListStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ListStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ListStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ListStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ListStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ListStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "defPPr" == name)
    return new DefaultParagraphProperties();
    
if( 10 == namespaceId && "lvl1pPr" == name)
    return new Level1ParagraphProperties();
    
if( 10 == namespaceId && "lvl2pPr" == name)
    return new Level2ParagraphProperties();
    
if( 10 == namespaceId && "lvl3pPr" == name)
    return new Level3ParagraphProperties();
    
if( 10 == namespaceId && "lvl4pPr" == name)
    return new Level4ParagraphProperties();
    
if( 10 == namespaceId && "lvl5pPr" == name)
    return new Level5ParagraphProperties();
    
if( 10 == namespaceId && "lvl6pPr" == name)
    return new Level6ParagraphProperties();
    
if( 10 == namespaceId && "lvl7pPr" == name)
    return new Level7ParagraphProperties();
    
if( 10 == namespaceId && "lvl8pPr" == name)
    return new Level8ParagraphProperties();
    
if( 10 == namespaceId && "lvl9pPr" == name)
    return new Level9ParagraphProperties();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "defPPr","lvl1pPr","lvl2pPr","lvl3pPr","lvl4pPr","lvl5pPr","lvl6pPr","lvl7pPr","lvl8pPr","lvl9pPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Default Paragraph Style.</para>
    /// <para> Represents the following element tag in the schema: a:defPPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public DefaultParagraphProperties DefaultParagraphProperties
    {
        get 
        {
            return GetElement<DefaultParagraphProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> List Level 1 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl1pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level1ParagraphProperties Level1ParagraphProperties
    {
        get 
        {
            return GetElement<Level1ParagraphProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> List Level 2 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl2pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level2ParagraphProperties Level2ParagraphProperties
    {
        get 
        {
            return GetElement<Level2ParagraphProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> List Level 3 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl3pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level3ParagraphProperties Level3ParagraphProperties
    {
        get 
        {
            return GetElement<Level3ParagraphProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> List Level 4 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl4pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level4ParagraphProperties Level4ParagraphProperties
    {
        get 
        {
            return GetElement<Level4ParagraphProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> List Level 5 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl5pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level5ParagraphProperties Level5ParagraphProperties
    {
        get 
        {
            return GetElement<Level5ParagraphProperties>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> List Level 6 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl6pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level6ParagraphProperties Level6ParagraphProperties
    {
        get 
        {
            return GetElement<Level6ParagraphProperties>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> List Level 7 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl7pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level7ParagraphProperties Level7ParagraphProperties
    {
        get 
        {
            return GetElement<Level7ParagraphProperties>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> List Level 8 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl8pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level8ParagraphProperties Level8ParagraphProperties
    {
        get 
        {
            return GetElement<Level8ParagraphProperties>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> List Level 9 Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:lvl9pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Level9ParagraphProperties Level9ParagraphProperties
    {
        get 
        {
            return GetElement<Level9ParagraphProperties>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ListStyle>(deep);
    }

   
}
/// <summary>
/// <para>Shape Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spDef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>BodyProperties &lt;a:bodyPr></description></item>
///<item><description>ListStyle &lt;a:lstStyle></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeDefault : DefaultShapeDefinitionType
{
    private const string tagName = "spDef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10239;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeDefault class.
    /// </summary>
    public ShapeDefault():base(){}
            /// <summary>
    ///Initializes a new instance of the ShapeDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeDefault(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeDefault>(deep);
    }

}
/// <summary>
/// <para>Line Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnDef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>BodyProperties &lt;a:bodyPr></description></item>
///<item><description>ListStyle &lt;a:lstStyle></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineDefault : DefaultShapeDefinitionType
{
    private const string tagName = "lnDef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10240;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LineDefault class.
    /// </summary>
    public LineDefault():base(){}
            /// <summary>
    ///Initializes a new instance of the LineDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LineDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LineDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LineDefault(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineDefault>(deep);
    }

}
/// <summary>
/// <para>Text Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:txDef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>BodyProperties &lt;a:bodyPr></description></item>
///<item><description>ListStyle &lt;a:lstStyle></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextDefault : DefaultShapeDefinitionType
{
    private const string tagName = "txDef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10241;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TextDefault class.
    /// </summary>
    public TextDefault():base(){}
            /// <summary>
    ///Initializes a new instance of the TextDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextDefault(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextDefault>(deep);
    }

}
/// <summary>
/// Defines the DefaultShapeDefinitionType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>BodyProperties &lt;a:bodyPr></description></item>
///<item><description>ListStyle &lt;a:lstStyle></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ShapeProperties))]
    [ChildElementInfo(typeof(BodyProperties))]
    [ChildElementInfo(typeof(ListStyle))]
    [ChildElementInfo(typeof(ShapeStyle))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class DefaultShapeDefinitionType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "spPr" == name)
    return new ShapeProperties();
    
if( 10 == namespaceId && "bodyPr" == name)
    return new BodyProperties();
    
if( 10 == namespaceId && "lstStyle" == name)
    return new ListStyle();
    
if( 10 == namespaceId && "style" == name)
    return new ShapeStyle();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "spPr","bodyPr","lstStyle","style","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Visual Properties.</para>
    /// <para> Represents the following element tag in the schema: a:spPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeProperties ShapeProperties
    {
        get 
        {
            return GetElement<ShapeProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> BodyProperties.</para>
    /// <para> Represents the following element tag in the schema: a:bodyPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BodyProperties BodyProperties
    {
        get 
        {
            return GetElement<BodyProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ListStyle.</para>
    /// <para> Represents the following element tag in the schema: a:lstStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ListStyle ListStyle
    {
        get 
        {
            return GetElement<ListStyle>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ShapeStyle.</para>
    /// <para> Represents the following element tag in the schema: a:style </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeStyle ShapeStyle
    {
        get 
        {
            return GetElement<ShapeStyle>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the DefaultShapeDefinitionType class.
    /// </summary>
    protected DefaultShapeDefinitionType(){}
    
            /// <summary>
    ///Initializes a new instance of the DefaultShapeDefinitionType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DefaultShapeDefinitionType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultShapeDefinitionType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DefaultShapeDefinitionType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultShapeDefinitionType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected DefaultShapeDefinitionType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Override Color Mapping.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:overrideClrMapping.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OverrideColorMapping : ColorMappingType
{
    private const string tagName = "overrideClrMapping";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10243;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OverrideColorMapping class.
    /// </summary>
    public OverrideColorMapping():base(){}
            /// <summary>
    ///Initializes a new instance of the OverrideColorMapping class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OverrideColorMapping(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OverrideColorMapping class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OverrideColorMapping(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OverrideColorMapping class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OverrideColorMapping(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OverrideColorMapping>(deep);
    }

}
/// <summary>
/// <para>Defines the ColorMap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:clrMap.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorMap : ColorMappingType
{
    private const string tagName = "clrMap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10244;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorMap class.
    /// </summary>
    public ColorMap():base(){}
            /// <summary>
    ///Initializes a new instance of the ColorMap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorMap(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorMap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorMap(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorMap class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorMap(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorMap>(deep);
    }

}
/// <summary>
/// Defines the ColorMappingType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ColorMappingType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "bg1","tx1","bg2","tx2","accent1","accent2","accent3","accent4","accent5","accent6","hlink","folHlink" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Background 1.</para>
    /// <para>Represents the following attribute in the schema: bg1 </para>
    /// </summary>
    [SchemaAttr(0, "bg1")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Background1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Text 1.</para>
    /// <para>Represents the following attribute in the schema: tx1 </para>
    /// </summary>
    [SchemaAttr(0, "tx1")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Text1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Background 2.</para>
    /// <para>Represents the following attribute in the schema: bg2 </para>
    /// </summary>
    [SchemaAttr(0, "bg2")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Background2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Text 2.</para>
    /// <para>Represents the following attribute in the schema: tx2 </para>
    /// </summary>
    [SchemaAttr(0, "tx2")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Text2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Accent 1.</para>
    /// <para>Represents the following attribute in the schema: accent1 </para>
    /// </summary>
    [SchemaAttr(0, "accent1")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Accent 2.</para>
    /// <para>Represents the following attribute in the schema: accent2 </para>
    /// </summary>
    [SchemaAttr(0, "accent2")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Accent 3.</para>
    /// <para>Represents the following attribute in the schema: accent3 </para>
    /// </summary>
    [SchemaAttr(0, "accent3")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent3
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Accent 4.</para>
    /// <para>Represents the following attribute in the schema: accent4 </para>
    /// </summary>
    [SchemaAttr(0, "accent4")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent4
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Accent 5.</para>
    /// <para>Represents the following attribute in the schema: accent5 </para>
    /// </summary>
    [SchemaAttr(0, "accent5")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent5
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Accent 6.</para>
    /// <para>Represents the following attribute in the schema: accent6 </para>
    /// </summary>
    [SchemaAttr(0, "accent6")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Accent6
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Hyperlink.</para>
    /// <para>Represents the following attribute in the schema: hlink </para>
    /// </summary>
    [SchemaAttr(0, "hlink")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> Hyperlink
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Followed Hyperlink.</para>
    /// <para>Represents the following attribute in the schema: folHlink </para>
    /// </summary>
    [SchemaAttr(0, "folHlink")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues> FollowedHyperlink
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bg1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "tx1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "bg2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "tx2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent3" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent4" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent5" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "accent6" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "hlink" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    
if( 0 == namespaceId && "folHlink" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.ColorSchemeIndexValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the ColorMappingType class.
    /// </summary>
    protected ColorMappingType(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorMappingType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ColorMappingType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorMappingType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ColorMappingType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorMappingType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected ColorMappingType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Extra Color Scheme.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extraClrScheme.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ColorScheme &lt;a:clrScheme></description></item>
///<item><description>ColorMap &lt;a:clrMap></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ColorScheme))]
    [ChildElementInfo(typeof(ColorMap))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExtraColorScheme : OpenXmlCompositeElement
{
    private const string tagName = "extraClrScheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10245;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorScheme class.
    /// </summary>
    public ExtraColorScheme():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExtraColorScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtraColorScheme(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorScheme class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtraColorScheme(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorScheme class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExtraColorScheme(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "clrScheme" == name)
    return new ColorScheme();
    
if( 10 == namespaceId && "clrMap" == name)
    return new ColorMap();
    

    return null;
}

        private static readonly string[] eleTagNames = { "clrScheme","clrMap" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ColorScheme.</para>
    /// <para> Represents the following element tag in the schema: a:clrScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorScheme ColorScheme
    {
        get 
        {
            return GetElement<ColorScheme>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ColorMap.</para>
    /// <para> Represents the following element tag in the schema: a:clrMap </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorMap ColorMap
    {
        get 
        {
            return GetElement<ColorMap>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExtraColorScheme>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ThemeElements Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:themeElements.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ColorScheme &lt;a:clrScheme></description></item>
///<item><description>FontScheme &lt;a:fontScheme></description></item>
///<item><description>FormatScheme &lt;a:fmtScheme></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ColorScheme))]
    [ChildElementInfo(typeof(FontScheme))]
    [ChildElementInfo(typeof(FormatScheme))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ThemeElements : OpenXmlCompositeElement
{
    private const string tagName = "themeElements";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10246;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ThemeElements class.
    /// </summary>
    public ThemeElements():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ThemeElements class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ThemeElements(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeElements class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ThemeElements(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeElements class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ThemeElements(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "clrScheme" == name)
    return new ColorScheme();
    
if( 10 == namespaceId && "fontScheme" == name)
    return new FontScheme();
    
if( 10 == namespaceId && "fmtScheme" == name)
    return new FormatScheme();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "clrScheme","fontScheme","fmtScheme","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ColorScheme.</para>
    /// <para> Represents the following element tag in the schema: a:clrScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ColorScheme ColorScheme
    {
        get 
        {
            return GetElement<ColorScheme>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Font Scheme.</para>
    /// <para> Represents the following element tag in the schema: a:fontScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FontScheme FontScheme
    {
        get 
        {
            return GetElement<FontScheme>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Format Scheme.</para>
    /// <para> Represents the following element tag in the schema: a:fmtScheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FormatScheme FormatScheme
    {
        get 
        {
            return GetElement<FormatScheme>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ThemeElements>(deep);
    }

   
}
/// <summary>
/// <para>Cell 3-D.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cell3D.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Bevel &lt;a:bevel></description></item>
///<item><description>LightRig &lt;a:lightRig></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Bevel))]
    [ChildElementInfo(typeof(LightRig))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Cell3DProperties : OpenXmlCompositeElement
{
    private const string tagName = "cell3D";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10253;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prstMaterial" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preset Material.</para>
    /// <para>Represents the following attribute in the schema: prstMaterial </para>
    /// </summary>
    [SchemaAttr(0, "prstMaterial")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues> PresetMaterial
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Cell3DProperties class.
    /// </summary>
    public Cell3DProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Cell3DProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Cell3DProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Cell3DProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Cell3DProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Cell3DProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Cell3DProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "bevel" == name)
    return new Bevel();
    
if( 10 == namespaceId && "lightRig" == name)
    return new LightRig();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "bevel","lightRig","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Bevel.</para>
    /// <para> Represents the following element tag in the schema: a:bevel </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Bevel Bevel
    {
        get 
        {
            return GetElement<Bevel>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Light Rig.</para>
    /// <para> Represents the following element tag in the schema: a:lightRig </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LightRig LightRig
    {
        get 
        {
            return GetElement<LightRig>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prstMaterial" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.PresetMaterialTypeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Cell3DProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tcPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LeftBorderLineProperties &lt;a:lnL></description></item>
///<item><description>RightBorderLineProperties &lt;a:lnR></description></item>
///<item><description>TopBorderLineProperties &lt;a:lnT></description></item>
///<item><description>BottomBorderLineProperties &lt;a:lnB></description></item>
///<item><description>TopLeftToBottomRightBorderLineProperties &lt;a:lnTlToBr></description></item>
///<item><description>BottomLeftToTopRightBorderLineProperties &lt;a:lnBlToTr></description></item>
///<item><description>Cell3DProperties &lt;a:cell3D></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LeftBorderLineProperties))]
    [ChildElementInfo(typeof(RightBorderLineProperties))]
    [ChildElementInfo(typeof(TopBorderLineProperties))]
    [ChildElementInfo(typeof(BottomBorderLineProperties))]
    [ChildElementInfo(typeof(TopLeftToBottomRightBorderLineProperties))]
    [ChildElementInfo(typeof(BottomLeftToTopRightBorderLineProperties))]
    [ChildElementInfo(typeof(Cell3DProperties))]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "tcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10254;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "marL","marR","marT","marB","vert","anchor","anchorCtr","horzOverflow" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Left Margin.</para>
    /// <para>Represents the following attribute in the schema: marL </para>
    /// </summary>
    [SchemaAttr(0, "marL")]
    public Int32Value LeftMargin
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Right Margin.</para>
    /// <para>Represents the following attribute in the schema: marR </para>
    /// </summary>
    [SchemaAttr(0, "marR")]
    public Int32Value RightMargin
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Top Margin.</para>
    /// <para>Represents the following attribute in the schema: marT </para>
    /// </summary>
    [SchemaAttr(0, "marT")]
    public Int32Value TopMargin
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Margin.</para>
    /// <para>Represents the following attribute in the schema: marB </para>
    /// </summary>
    [SchemaAttr(0, "marB")]
    public Int32Value BottomMargin
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Text Direction.</para>
    /// <para>Represents the following attribute in the schema: vert </para>
    /// </summary>
    [SchemaAttr(0, "vert")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues> Vertical
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Anchor.</para>
    /// <para>Represents the following attribute in the schema: anchor </para>
    /// </summary>
    [SchemaAttr(0, "anchor")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues> Anchor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Anchor Center.</para>
    /// <para>Represents the following attribute in the schema: anchorCtr </para>
    /// </summary>
    [SchemaAttr(0, "anchorCtr")]
    public BooleanValue AnchorCenter
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Overflow.</para>
    /// <para>Represents the following attribute in the schema: horzOverflow </para>
    /// </summary>
    [SchemaAttr(0, "horzOverflow")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues> HorizontalOverflow
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellProperties class.
    /// </summary>
    public TableCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "lnL" == name)
    return new LeftBorderLineProperties();
    
if( 10 == namespaceId && "lnR" == name)
    return new RightBorderLineProperties();
    
if( 10 == namespaceId && "lnT" == name)
    return new TopBorderLineProperties();
    
if( 10 == namespaceId && "lnB" == name)
    return new BottomBorderLineProperties();
    
if( 10 == namespaceId && "lnTlToBr" == name)
    return new TopLeftToBottomRightBorderLineProperties();
    
if( 10 == namespaceId && "lnBlToTr" == name)
    return new BottomLeftToTopRightBorderLineProperties();
    
if( 10 == namespaceId && "cell3D" == name)
    return new Cell3DProperties();
    
if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "lnL","lnR","lnT","lnB","lnTlToBr","lnBlToTr","cell3D","noFill","solidFill","gradFill","blipFill","pattFill","grpFill","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Left Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnL </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LeftBorderLineProperties LeftBorderLineProperties
    {
        get 
        {
            return GetElement<LeftBorderLineProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Right Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnR </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RightBorderLineProperties RightBorderLineProperties
    {
        get 
        {
            return GetElement<RightBorderLineProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Top Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnT </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TopBorderLineProperties TopBorderLineProperties
    {
        get 
        {
            return GetElement<TopBorderLineProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Bottom Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnB </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BottomBorderLineProperties BottomBorderLineProperties
    {
        get 
        {
            return GetElement<BottomBorderLineProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Top-Left to Bottom-Right Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnTlToBr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TopLeftToBottomRightBorderLineProperties TopLeftToBottomRightBorderLineProperties
    {
        get 
        {
            return GetElement<TopLeftToBottomRightBorderLineProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Bottom-Left to Top-Right Border Line Properties.</para>
    /// <para> Represents the following element tag in the schema: a:lnBlToTr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BottomLeftToTopRightBorderLineProperties BottomLeftToTopRightBorderLineProperties
    {
        get 
        {
            return GetElement<BottomLeftToTopRightBorderLineProperties>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Cell 3-D.</para>
    /// <para> Represents the following element tag in the schema: a:cell3D </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Cell3DProperties Cell3DProperties
    {
        get 
        {
            return GetElement<Cell3DProperties>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "marL" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "marR" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "marT" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "marB" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "vert" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextVerticalValues>();
    
if( 0 == namespaceId && "anchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextAnchoringTypeValues>();
    
if( 0 == namespaceId && "anchorCtr" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "horzOverflow" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextHorizontalOverflowValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TextBody &lt;a:txBody></description></item>
///<item><description>TableCellProperties &lt;a:tcPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TextBody))]
    [ChildElementInfo(typeof(TableCellProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCell : OpenXmlCompositeElement
{
    private const string tagName = "tc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10255;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rowSpan","gridSpan","hMerge","vMerge" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Row Span.</para>
    /// <para>Represents the following attribute in the schema: rowSpan </para>
    /// </summary>
    [SchemaAttr(0, "rowSpan")]
    public Int32Value RowSpan
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Grid Span.</para>
    /// <para>Represents the following attribute in the schema: gridSpan </para>
    /// </summary>
    [SchemaAttr(0, "gridSpan")]
    public Int32Value GridSpan
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Merge.</para>
    /// <para>Represents the following attribute in the schema: hMerge </para>
    /// </summary>
    [SchemaAttr(0, "hMerge")]
    public BooleanValue HorizontalMerge
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Merge.</para>
    /// <para>Represents the following attribute in the schema: vMerge </para>
    /// </summary>
    [SchemaAttr(0, "vMerge")]
    public BooleanValue VerticalMerge
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCell class.
    /// </summary>
    public TableCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "txBody" == name)
    return new TextBody();
    
if( 10 == namespaceId && "tcPr" == name)
    return new TableCellProperties();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "txBody","tcPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Body.</para>
    /// <para> Represents the following element tag in the schema: a:txBody </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TextBody TextBody
    {
        get 
        {
            return GetElement<TextBody>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: a:tcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableCellProperties TableCellProperties
    {
        get 
        {
            return GetElement<TableCellProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rowSpan" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "gridSpan" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "hMerge" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "vMerge" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCell>(deep);
    }

   
}
/// <summary>
/// <para>Table Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tableStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableBackground &lt;a:tblBg></description></item>
///<item><description>WholeTable &lt;a:wholeTbl></description></item>
///<item><description>Band1Horizontal &lt;a:band1H></description></item>
///<item><description>Band2Horizontal &lt;a:band2H></description></item>
///<item><description>Band1Vertical &lt;a:band1V></description></item>
///<item><description>Band2Vertical &lt;a:band2V></description></item>
///<item><description>LastColumn &lt;a:lastCol></description></item>
///<item><description>FirstColumn &lt;a:firstCol></description></item>
///<item><description>LastRow &lt;a:lastRow></description></item>
///<item><description>SoutheastCell &lt;a:seCell></description></item>
///<item><description>SouthwestCell &lt;a:swCell></description></item>
///<item><description>FirstRow &lt;a:firstRow></description></item>
///<item><description>NortheastCell &lt;a:neCell></description></item>
///<item><description>NorthwestCell &lt;a:nwCell></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyle : TableStyleType
{
    private const string tagName = "tableStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10256;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyle class.
    /// </summary>
    public TableStyle():base(){}
            /// <summary>
    ///Initializes a new instance of the TableStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyle(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyle>(deep);
    }

}
/// <summary>
/// <para>Table Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tblStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableBackground &lt;a:tblBg></description></item>
///<item><description>WholeTable &lt;a:wholeTbl></description></item>
///<item><description>Band1Horizontal &lt;a:band1H></description></item>
///<item><description>Band2Horizontal &lt;a:band2H></description></item>
///<item><description>Band1Vertical &lt;a:band1V></description></item>
///<item><description>Band2Vertical &lt;a:band2V></description></item>
///<item><description>LastColumn &lt;a:lastCol></description></item>
///<item><description>FirstColumn &lt;a:firstCol></description></item>
///<item><description>LastRow &lt;a:lastRow></description></item>
///<item><description>SoutheastCell &lt;a:seCell></description></item>
///<item><description>SouthwestCell &lt;a:swCell></description></item>
///<item><description>FirstRow &lt;a:firstRow></description></item>
///<item><description>NortheastCell &lt;a:neCell></description></item>
///<item><description>NorthwestCell &lt;a:nwCell></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleEntry : TableStyleType
{
    private const string tagName = "tblStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10288;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleEntry class.
    /// </summary>
    public TableStyleEntry():base(){}
            /// <summary>
    ///Initializes a new instance of the TableStyleEntry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleEntry(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleEntry class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleEntry(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleEntry class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleEntry(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleEntry>(deep);
    }

}
/// <summary>
/// Defines the TableStyleType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableBackground &lt;a:tblBg></description></item>
///<item><description>WholeTable &lt;a:wholeTbl></description></item>
///<item><description>Band1Horizontal &lt;a:band1H></description></item>
///<item><description>Band2Horizontal &lt;a:band2H></description></item>
///<item><description>Band1Vertical &lt;a:band1V></description></item>
///<item><description>Band2Vertical &lt;a:band2V></description></item>
///<item><description>LastColumn &lt;a:lastCol></description></item>
///<item><description>FirstColumn &lt;a:firstCol></description></item>
///<item><description>LastRow &lt;a:lastRow></description></item>
///<item><description>SoutheastCell &lt;a:seCell></description></item>
///<item><description>SouthwestCell &lt;a:swCell></description></item>
///<item><description>FirstRow &lt;a:firstRow></description></item>
///<item><description>NortheastCell &lt;a:neCell></description></item>
///<item><description>NorthwestCell &lt;a:nwCell></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableBackground))]
    [ChildElementInfo(typeof(WholeTable))]
    [ChildElementInfo(typeof(Band1Horizontal))]
    [ChildElementInfo(typeof(Band2Horizontal))]
    [ChildElementInfo(typeof(Band1Vertical))]
    [ChildElementInfo(typeof(Band2Vertical))]
    [ChildElementInfo(typeof(LastColumn))]
    [ChildElementInfo(typeof(FirstColumn))]
    [ChildElementInfo(typeof(LastRow))]
    [ChildElementInfo(typeof(SoutheastCell))]
    [ChildElementInfo(typeof(SouthwestCell))]
    [ChildElementInfo(typeof(FirstRow))]
    [ChildElementInfo(typeof(NortheastCell))]
    [ChildElementInfo(typeof(NorthwestCell))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TableStyleType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "styleId","styleName" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Style ID.</para>
    /// <para>Represents the following attribute in the schema: styleId </para>
    /// </summary>
    [SchemaAttr(0, "styleId")]
    public StringValue StyleId
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: styleName </para>
    /// </summary>
    [SchemaAttr(0, "styleName")]
    public StringValue StyleName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tblBg" == name)
    return new TableBackground();
    
if( 10 == namespaceId && "wholeTbl" == name)
    return new WholeTable();
    
if( 10 == namespaceId && "band1H" == name)
    return new Band1Horizontal();
    
if( 10 == namespaceId && "band2H" == name)
    return new Band2Horizontal();
    
if( 10 == namespaceId && "band1V" == name)
    return new Band1Vertical();
    
if( 10 == namespaceId && "band2V" == name)
    return new Band2Vertical();
    
if( 10 == namespaceId && "lastCol" == name)
    return new LastColumn();
    
if( 10 == namespaceId && "firstCol" == name)
    return new FirstColumn();
    
if( 10 == namespaceId && "lastRow" == name)
    return new LastRow();
    
if( 10 == namespaceId && "seCell" == name)
    return new SoutheastCell();
    
if( 10 == namespaceId && "swCell" == name)
    return new SouthwestCell();
    
if( 10 == namespaceId && "firstRow" == name)
    return new FirstRow();
    
if( 10 == namespaceId && "neCell" == name)
    return new NortheastCell();
    
if( 10 == namespaceId && "nwCell" == name)
    return new NorthwestCell();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblBg","wholeTbl","band1H","band2H","band1V","band2V","lastCol","firstCol","lastRow","seCell","swCell","firstRow","neCell","nwCell","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Background.</para>
    /// <para> Represents the following element tag in the schema: a:tblBg </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableBackground TableBackground
    {
        get 
        {
            return GetElement<TableBackground>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Whole Table.</para>
    /// <para> Represents the following element tag in the schema: a:wholeTbl </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public WholeTable WholeTable
    {
        get 
        {
            return GetElement<WholeTable>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Band 1 Horizontal.</para>
    /// <para> Represents the following element tag in the schema: a:band1H </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Band1Horizontal Band1Horizontal
    {
        get 
        {
            return GetElement<Band1Horizontal>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Band 2 Horizontal.</para>
    /// <para> Represents the following element tag in the schema: a:band2H </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Band2Horizontal Band2Horizontal
    {
        get 
        {
            return GetElement<Band2Horizontal>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Band 1 Vertical.</para>
    /// <para> Represents the following element tag in the schema: a:band1V </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Band1Vertical Band1Vertical
    {
        get 
        {
            return GetElement<Band1Vertical>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Band 2 Vertical.</para>
    /// <para> Represents the following element tag in the schema: a:band2V </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Band2Vertical Band2Vertical
    {
        get 
        {
            return GetElement<Band2Vertical>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Last Column.</para>
    /// <para> Represents the following element tag in the schema: a:lastCol </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LastColumn LastColumn
    {
        get 
        {
            return GetElement<LastColumn>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> First Column.</para>
    /// <para> Represents the following element tag in the schema: a:firstCol </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FirstColumn FirstColumn
    {
        get 
        {
            return GetElement<FirstColumn>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Last Row.</para>
    /// <para> Represents the following element tag in the schema: a:lastRow </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LastRow LastRow
    {
        get 
        {
            return GetElement<LastRow>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Southeast Cell.</para>
    /// <para> Represents the following element tag in the schema: a:seCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SoutheastCell SoutheastCell
    {
        get 
        {
            return GetElement<SoutheastCell>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Southwest Cell.</para>
    /// <para> Represents the following element tag in the schema: a:swCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SouthwestCell SouthwestCell
    {
        get 
        {
            return GetElement<SouthwestCell>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> First Row.</para>
    /// <para> Represents the following element tag in the schema: a:firstRow </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public FirstRow FirstRow
    {
        get 
        {
            return GetElement<FirstRow>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Northeast Cell.</para>
    /// <para> Represents the following element tag in the schema: a:neCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NortheastCell NortheastCell
    {
        get 
        {
            return GetElement<NortheastCell>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Northwest Cell.</para>
    /// <para> Represents the following element tag in the schema: a:nwCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NorthwestCell NorthwestCell
    {
        get 
        {
            return GetElement<NorthwestCell>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "styleId" == name)
    return new StringValue();
    
if( 0 == namespaceId && "styleName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TableStyleType class.
    /// </summary>
    protected TableStyleType(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TableStyleType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TableStyleType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TableStyleType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Table Style ID.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tableStyleId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleId : OpenXmlLeafTextElement
{
    private const string tagName = "tableStyleId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10257;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableStyleId class.
    /// </summary>
    public TableStyleId():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the TableStyleId class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public TableStyleId(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    
 
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleId>(deep);
    }

   
}
/// <summary>
/// <para>Table Grid Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:gridCol.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GridColumn : OpenXmlCompositeElement
{
    private const string tagName = "gridCol";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10258;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Width.</para>
    /// <para>Represents the following attribute in the schema: w </para>
    /// </summary>
    [SchemaAttr(0, "w")]
    public Int64Value Width
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GridColumn class.
    /// </summary>
    public GridColumn():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GridColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GridColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GridColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GridColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GridColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GridColumn(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "w" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GridColumn>(deep);
    }

   
}
/// <summary>
/// <para>Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tblPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>TableStyle &lt;a:tableStyle></description></item>
///<item><description>TableStyleId &lt;a:tableStyleId></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
    [ChildElementInfo(typeof(TableStyle))]
    [ChildElementInfo(typeof(TableStyleId))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10259;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rtl","firstRow","firstCol","lastRow","lastCol","bandRow","bandCol" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Right-to-Left.</para>
    /// <para>Represents the following attribute in the schema: rtl </para>
    /// </summary>
    [SchemaAttr(0, "rtl")]
    public BooleanValue RightToLeft
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> First Row.</para>
    /// <para>Represents the following attribute in the schema: firstRow </para>
    /// </summary>
    [SchemaAttr(0, "firstRow")]
    public BooleanValue FirstRow
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> First Column.</para>
    /// <para>Represents the following attribute in the schema: firstCol </para>
    /// </summary>
    [SchemaAttr(0, "firstCol")]
    public BooleanValue FirstColumn
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Last Row.</para>
    /// <para>Represents the following attribute in the schema: lastRow </para>
    /// </summary>
    [SchemaAttr(0, "lastRow")]
    public BooleanValue LastRow
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Last Column.</para>
    /// <para>Represents the following attribute in the schema: lastCol </para>
    /// </summary>
    [SchemaAttr(0, "lastCol")]
    public BooleanValue LastColumn
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Banded Rows.</para>
    /// <para>Represents the following attribute in the schema: bandRow </para>
    /// </summary>
    [SchemaAttr(0, "bandRow")]
    public BooleanValue BandRow
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Banded Columns.</para>
    /// <para>Represents the following attribute in the schema: bandCol </para>
    /// </summary>
    [SchemaAttr(0, "bandCol")]
    public BooleanValue BandColumn
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableProperties class.
    /// </summary>
    public TableProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    
if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    
if( 10 == namespaceId && "tableStyle" == name)
    return new TableStyle();
    
if( 10 == namespaceId && "tableStyleId" == name)
    return new TableStyleId();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rtl" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "firstRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "firstCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "lastRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "lastCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "bandRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "bandCol" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Grid.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tblGrid.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GridColumn &lt;a:gridCol></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GridColumn))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableGrid : OpenXmlCompositeElement
{
    private const string tagName = "tblGrid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10260;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class.
    /// </summary>
    public TableGrid():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGrid(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGrid(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableGrid(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "gridCol" == name)
    return new GridColumn();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableGrid>(deep);
    }

   
}
/// <summary>
/// <para>Table Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCell &lt;a:tc></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCell))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableRow : OpenXmlCompositeElement
{
    private const string tagName = "tr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10261;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "h" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Height.</para>
    /// <para>Represents the following attribute in the schema: h </para>
    /// </summary>
    [SchemaAttr(0, "h")]
    public Int64Value Height
    {
        get { return (Int64Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableRow class.
    /// </summary>
    public TableRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tc" == name)
    return new TableCell();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "h" == name)
    return new Int64Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableRow>(deep);
    }

   
}
/// <summary>
/// <para>Left Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:left.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftBorder : ThemeableLineStyleType
{
    private const string tagName = "left";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10263;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftBorder class.
    /// </summary>
    public LeftBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the LeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LeftBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftBorder>(deep);
    }

}
/// <summary>
/// <para>Right Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:right.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightBorder : ThemeableLineStyleType
{
    private const string tagName = "right";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10264;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightBorder class.
    /// </summary>
    public RightBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the RightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RightBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightBorder>(deep);
    }

}
/// <summary>
/// <para>Top Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:top.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopBorder : ThemeableLineStyleType
{
    private const string tagName = "top";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10265;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopBorder class.
    /// </summary>
    public TopBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the TopBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopBorder>(deep);
    }

}
/// <summary>
/// <para>Bottom Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:bottom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomBorder : ThemeableLineStyleType
{
    private const string tagName = "bottom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10266;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomBorder class.
    /// </summary>
    public BottomBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the BottomBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BottomBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomBorder>(deep);
    }

}
/// <summary>
/// <para>Inside Horizontal Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:insideH.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsideHorizontalBorder : ThemeableLineStyleType
{
    private const string tagName = "insideH";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10267;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InsideHorizontalBorder class.
    /// </summary>
    public InsideHorizontalBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the InsideHorizontalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsideHorizontalBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InsideHorizontalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsideHorizontalBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InsideHorizontalBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InsideHorizontalBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsideHorizontalBorder>(deep);
    }

}
/// <summary>
/// <para>Inside Vertical Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:insideV.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsideVerticalBorder : ThemeableLineStyleType
{
    private const string tagName = "insideV";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10268;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InsideVerticalBorder class.
    /// </summary>
    public InsideVerticalBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the InsideVerticalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsideVerticalBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InsideVerticalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsideVerticalBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InsideVerticalBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InsideVerticalBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsideVerticalBorder>(deep);
    }

}
/// <summary>
/// <para>Top Left to Bottom Right Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tl2br.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopLeftToBottomRightBorder : ThemeableLineStyleType
{
    private const string tagName = "tl2br";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10269;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorder class.
    /// </summary>
    public TopLeftToBottomRightBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the TopLeftToBottomRightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopLeftToBottomRightBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopLeftToBottomRightBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopLeftToBottomRightBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopLeftToBottomRightBorder>(deep);
    }

}
/// <summary>
/// <para>Top Right to Bottom Left Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tr2bl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopRightToBottomLeftBorder : ThemeableLineStyleType
{
    private const string tagName = "tr2bl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10270;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopRightToBottomLeftBorder class.
    /// </summary>
    public TopRightToBottomLeftBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the TopRightToBottomLeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopRightToBottomLeftBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopRightToBottomLeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopRightToBottomLeftBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopRightToBottomLeftBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopRightToBottomLeftBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopRightToBottomLeftBorder>(deep);
    }

}
/// <summary>
/// Defines the ThemeableLineStyleType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>LineReference &lt;a:lnRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(LineReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ThemeableLineStyleType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ln" == name)
    return new Outline();
    
if( 10 == namespaceId && "lnRef" == name)
    return new LineReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ln","lnRef" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: a:ln </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Line Reference.</para>
    /// <para> Represents the following element tag in the schema: a:lnRef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LineReference LineReference
    {
        get 
        {
            return GetElement<LineReference>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the ThemeableLineStyleType class.
    /// </summary>
    protected ThemeableLineStyleType(){}
    
            /// <summary>
    ///Initializes a new instance of the ThemeableLineStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ThemeableLineStyleType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeableLineStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ThemeableLineStyleType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ThemeableLineStyleType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected ThemeableLineStyleType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Table Cell Borders.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tcBdr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LeftBorder &lt;a:left></description></item>
///<item><description>RightBorder &lt;a:right></description></item>
///<item><description>TopBorder &lt;a:top></description></item>
///<item><description>BottomBorder &lt;a:bottom></description></item>
///<item><description>InsideHorizontalBorder &lt;a:insideH></description></item>
///<item><description>InsideVerticalBorder &lt;a:insideV></description></item>
///<item><description>TopLeftToBottomRightBorder &lt;a:tl2br></description></item>
///<item><description>TopRightToBottomLeftBorder &lt;a:tr2bl></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(RightBorder))]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(InsideHorizontalBorder))]
    [ChildElementInfo(typeof(InsideVerticalBorder))]
    [ChildElementInfo(typeof(TopLeftToBottomRightBorder))]
    [ChildElementInfo(typeof(TopRightToBottomLeftBorder))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellBorders : OpenXmlCompositeElement
{
    private const string tagName = "tcBdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10271;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class.
    /// </summary>
    public TableCellBorders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellBorders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellBorders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellBorders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 10 == namespaceId && "right" == name)
    return new RightBorder();
    
if( 10 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 10 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 10 == namespaceId && "insideH" == name)
    return new InsideHorizontalBorder();
    
if( 10 == namespaceId && "insideV" == name)
    return new InsideVerticalBorder();
    
if( 10 == namespaceId && "tl2br" == name)
    return new TopLeftToBottomRightBorder();
    
if( 10 == namespaceId && "tr2bl" == name)
    return new TopRightToBottomLeftBorder();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "left","right","top","bottom","insideH","insideV","tl2br","tr2bl","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Left Border.</para>
    /// <para> Represents the following element tag in the schema: a:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Right Border.</para>
    /// <para> Represents the following element tag in the schema: a:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Top Border.</para>
    /// <para> Represents the following element tag in the schema: a:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Bottom Border.</para>
    /// <para> Represents the following element tag in the schema: a:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Inside Horizontal Border.</para>
    /// <para> Represents the following element tag in the schema: a:insideH </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public InsideHorizontalBorder InsideHorizontalBorder
    {
        get 
        {
            return GetElement<InsideHorizontalBorder>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Inside Vertical Border.</para>
    /// <para> Represents the following element tag in the schema: a:insideV </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public InsideVerticalBorder InsideVerticalBorder
    {
        get 
        {
            return GetElement<InsideVerticalBorder>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Top Left to Bottom Right Border.</para>
    /// <para> Represents the following element tag in the schema: a:tl2br </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TopLeftToBottomRightBorder TopLeftToBottomRightBorder
    {
        get 
        {
            return GetElement<TopLeftToBottomRightBorder>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Top Right to Bottom Left Border.</para>
    /// <para> Represents the following element tag in the schema: a:tr2bl </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TopRightToBottomLeftBorder TopRightToBottomLeftBorder
    {
        get 
        {
            return GetElement<TopRightToBottomLeftBorder>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellBorders>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tcTxStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Fonts &lt;a:font></description></item>
///<item><description>FontReference &lt;a:fontRef></description></item>
///<item><description>RgbColorModelPercentage &lt;a:scrgbClr></description></item>
///<item><description>RgbColorModelHex &lt;a:srgbClr></description></item>
///<item><description>HslColor &lt;a:hslClr></description></item>
///<item><description>SystemColor &lt;a:sysClr></description></item>
///<item><description>SchemeColor &lt;a:schemeClr></description></item>
///<item><description>PresetColor &lt;a:prstClr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Fonts))]
    [ChildElementInfo(typeof(FontReference))]
    [ChildElementInfo(typeof(RgbColorModelPercentage))]
    [ChildElementInfo(typeof(RgbColorModelHex))]
    [ChildElementInfo(typeof(HslColor))]
    [ChildElementInfo(typeof(SystemColor))]
    [ChildElementInfo(typeof(SchemeColor))]
    [ChildElementInfo(typeof(PresetColor))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellTextStyle : OpenXmlCompositeElement
{
    private const string tagName = "tcTxStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10272;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "b","i" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Bold.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues> Bold
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Italic.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues> Italic
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellTextStyle class.
    /// </summary>
    public TableCellTextStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellTextStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellTextStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellTextStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellTextStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellTextStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellTextStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "font" == name)
    return new Fonts();
    
if( 10 == namespaceId && "fontRef" == name)
    return new FontReference();
    
if( 10 == namespaceId && "scrgbClr" == name)
    return new RgbColorModelPercentage();
    
if( 10 == namespaceId && "srgbClr" == name)
    return new RgbColorModelHex();
    
if( 10 == namespaceId && "hslClr" == name)
    return new HslColor();
    
if( 10 == namespaceId && "sysClr" == name)
    return new SystemColor();
    
if( 10 == namespaceId && "schemeClr" == name)
    return new SchemeColor();
    
if( 10 == namespaceId && "prstClr" == name)
    return new PresetColor();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "b" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues>();
    
if( 0 == namespaceId && "i" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BooleanStyleValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellTextStyle>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tcStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellBorders &lt;a:tcBdr></description></item>
///<item><description>FillProperties &lt;a:fill></description></item>
///<item><description>FillReference &lt;a:fillRef></description></item>
///<item><description>Cell3DProperties &lt;a:cell3D></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCellBorders))]
    [ChildElementInfo(typeof(FillProperties))]
    [ChildElementInfo(typeof(FillReference))]
    [ChildElementInfo(typeof(Cell3DProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellStyle : OpenXmlCompositeElement
{
    private const string tagName = "tcStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10273;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellStyle class.
    /// </summary>
    public TableCellStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tcBdr" == name)
    return new TableCellBorders();
    
if( 10 == namespaceId && "fill" == name)
    return new FillProperties();
    
if( 10 == namespaceId && "fillRef" == name)
    return new FillReference();
    
if( 10 == namespaceId && "cell3D" == name)
    return new Cell3DProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tcBdr","fill","fillRef","cell3D" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Borders.</para>
    /// <para> Represents the following element tag in the schema: a:tcBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableCellBorders TableCellBorders
    {
        get 
        {
            return GetElement<TableCellBorders>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellStyle>(deep);
    }

   
}
/// <summary>
/// <para>Table Background.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tblBg.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FillProperties &lt;a:fill></description></item>
///<item><description>FillReference &lt;a:fillRef></description></item>
///<item><description>EffectPropertiesType &lt;a:effect></description></item>
///<item><description>EffectReference &lt;a:effectRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FillProperties))]
    [ChildElementInfo(typeof(FillReference))]
    [ChildElementInfo(typeof(EffectPropertiesType))]
    [ChildElementInfo(typeof(EffectReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableBackground : OpenXmlCompositeElement
{
    private const string tagName = "tblBg";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10274;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableBackground class.
    /// </summary>
    public TableBackground():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableBackground class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableBackground(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableBackground class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableBackground(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableBackground class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableBackground(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "fill" == name)
    return new FillProperties();
    
if( 10 == namespaceId && "fillRef" == name)
    return new FillReference();
    
if( 10 == namespaceId && "effect" == name)
    return new EffectPropertiesType();
    
if( 10 == namespaceId && "effectRef" == name)
    return new EffectReference();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableBackground>(deep);
    }

   
}
/// <summary>
/// <para>Whole Table.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:wholeTbl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WholeTable : TablePartStyleType
{
    private const string tagName = "wholeTbl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10275;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WholeTable class.
    /// </summary>
    public WholeTable():base(){}
            /// <summary>
    ///Initializes a new instance of the WholeTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WholeTable(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WholeTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WholeTable(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WholeTable class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WholeTable(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WholeTable>(deep);
    }

}
/// <summary>
/// <para>Band 1 Horizontal.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:band1H.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Band1Horizontal : TablePartStyleType
{
    private const string tagName = "band1H";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10276;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Band1Horizontal class.
    /// </summary>
    public Band1Horizontal():base(){}
            /// <summary>
    ///Initializes a new instance of the Band1Horizontal class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band1Horizontal(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Band1Horizontal class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band1Horizontal(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Band1Horizontal class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Band1Horizontal(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Band1Horizontal>(deep);
    }

}
/// <summary>
/// <para>Band 2 Horizontal.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:band2H.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Band2Horizontal : TablePartStyleType
{
    private const string tagName = "band2H";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10277;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Band2Horizontal class.
    /// </summary>
    public Band2Horizontal():base(){}
            /// <summary>
    ///Initializes a new instance of the Band2Horizontal class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band2Horizontal(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Band2Horizontal class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band2Horizontal(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Band2Horizontal class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Band2Horizontal(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Band2Horizontal>(deep);
    }

}
/// <summary>
/// <para>Band 1 Vertical.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:band1V.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Band1Vertical : TablePartStyleType
{
    private const string tagName = "band1V";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10278;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Band1Vertical class.
    /// </summary>
    public Band1Vertical():base(){}
            /// <summary>
    ///Initializes a new instance of the Band1Vertical class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band1Vertical(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Band1Vertical class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band1Vertical(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Band1Vertical class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Band1Vertical(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Band1Vertical>(deep);
    }

}
/// <summary>
/// <para>Band 2 Vertical.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:band2V.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Band2Vertical : TablePartStyleType
{
    private const string tagName = "band2V";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10279;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Band2Vertical class.
    /// </summary>
    public Band2Vertical():base(){}
            /// <summary>
    ///Initializes a new instance of the Band2Vertical class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band2Vertical(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Band2Vertical class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Band2Vertical(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Band2Vertical class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Band2Vertical(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Band2Vertical>(deep);
    }

}
/// <summary>
/// <para>Last Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lastCol.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LastColumn : TablePartStyleType
{
    private const string tagName = "lastCol";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10280;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LastColumn class.
    /// </summary>
    public LastColumn():base(){}
            /// <summary>
    ///Initializes a new instance of the LastColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LastColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LastColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LastColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LastColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LastColumn(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LastColumn>(deep);
    }

}
/// <summary>
/// <para>First Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:firstCol.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FirstColumn : TablePartStyleType
{
    private const string tagName = "firstCol";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10281;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FirstColumn class.
    /// </summary>
    public FirstColumn():base(){}
            /// <summary>
    ///Initializes a new instance of the FirstColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FirstColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FirstColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FirstColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FirstColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FirstColumn(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FirstColumn>(deep);
    }

}
/// <summary>
/// <para>Last Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lastRow.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LastRow : TablePartStyleType
{
    private const string tagName = "lastRow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10282;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LastRow class.
    /// </summary>
    public LastRow():base(){}
            /// <summary>
    ///Initializes a new instance of the LastRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LastRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LastRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LastRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LastRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LastRow(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LastRow>(deep);
    }

}
/// <summary>
/// <para>Southeast Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:seCell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SoutheastCell : TablePartStyleType
{
    private const string tagName = "seCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10283;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SoutheastCell class.
    /// </summary>
    public SoutheastCell():base(){}
            /// <summary>
    ///Initializes a new instance of the SoutheastCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SoutheastCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SoutheastCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SoutheastCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SoutheastCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SoutheastCell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SoutheastCell>(deep);
    }

}
/// <summary>
/// <para>Southwest Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:swCell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SouthwestCell : TablePartStyleType
{
    private const string tagName = "swCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10284;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SouthwestCell class.
    /// </summary>
    public SouthwestCell():base(){}
            /// <summary>
    ///Initializes a new instance of the SouthwestCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SouthwestCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SouthwestCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SouthwestCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SouthwestCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SouthwestCell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SouthwestCell>(deep);
    }

}
/// <summary>
/// <para>First Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:firstRow.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FirstRow : TablePartStyleType
{
    private const string tagName = "firstRow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10285;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FirstRow class.
    /// </summary>
    public FirstRow():base(){}
            /// <summary>
    ///Initializes a new instance of the FirstRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FirstRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FirstRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FirstRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FirstRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FirstRow(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FirstRow>(deep);
    }

}
/// <summary>
/// <para>Northeast Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:neCell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NortheastCell : TablePartStyleType
{
    private const string tagName = "neCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10286;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NortheastCell class.
    /// </summary>
    public NortheastCell():base(){}
            /// <summary>
    ///Initializes a new instance of the NortheastCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NortheastCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NortheastCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NortheastCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NortheastCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NortheastCell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NortheastCell>(deep);
    }

}
/// <summary>
/// <para>Northwest Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nwCell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NorthwestCell : TablePartStyleType
{
    private const string tagName = "nwCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10287;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NorthwestCell class.
    /// </summary>
    public NorthwestCell():base(){}
            /// <summary>
    ///Initializes a new instance of the NorthwestCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NorthwestCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NorthwestCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NorthwestCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NorthwestCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NorthwestCell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NorthwestCell>(deep);
    }

}
/// <summary>
/// Defines the TablePartStyleType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellTextStyle &lt;a:tcTxStyle></description></item>
///<item><description>TableCellStyle &lt;a:tcStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCellTextStyle))]
    [ChildElementInfo(typeof(TableCellStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TablePartStyleType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tcTxStyle" == name)
    return new TableCellTextStyle();
    
if( 10 == namespaceId && "tcStyle" == name)
    return new TableCellStyle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tcTxStyle","tcStyle" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Text Style.</para>
    /// <para> Represents the following element tag in the schema: a:tcTxStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableCellTextStyle TableCellTextStyle
    {
        get 
        {
            return GetElement<TableCellTextStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Style.</para>
    /// <para> Represents the following element tag in the schema: a:tcStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TableCellStyle TableCellStyle
    {
        get 
        {
            return GetElement<TableCellStyle>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the TablePartStyleType class.
    /// </summary>
    protected TablePartStyleType(){}
    
            /// <summary>
    ///Initializes a new instance of the TablePartStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TablePartStyleType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePartStyleType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TablePartStyleType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePartStyleType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TablePartStyleType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Text Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10289;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class.
    /// </summary>
    public ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>Default Paragraph Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:defPPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "defPPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10291;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultParagraphProperties class.
    /// </summary>
    public DefaultParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the DefaultParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefaultParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefaultParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DefaultParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 1 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl1pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level1ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl1pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10292;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level1ParagraphProperties class.
    /// </summary>
    public Level1ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level1ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level1ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level1ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level1ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level1ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level1ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level1ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 2 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl2pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level2ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl2pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10293;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level2ParagraphProperties class.
    /// </summary>
    public Level2ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level2ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level2ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level2ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level2ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level2ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level2ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level2ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 3 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl3pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level3ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl3pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10294;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level3ParagraphProperties class.
    /// </summary>
    public Level3ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level3ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level3ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level3ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level3ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level3ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level3ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level3ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 4 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl4pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level4ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl4pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10295;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level4ParagraphProperties class.
    /// </summary>
    public Level4ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level4ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level4ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level4ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level4ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level4ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level4ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level4ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 5 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl5pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level5ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl5pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10296;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level5ParagraphProperties class.
    /// </summary>
    public Level5ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level5ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level5ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level5ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level5ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level5ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level5ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level5ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 6 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl6pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level6ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl6pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10297;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level6ParagraphProperties class.
    /// </summary>
    public Level6ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level6ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level6ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level6ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level6ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level6ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level6ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level6ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 7 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl7pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level7ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl7pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10298;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level7ParagraphProperties class.
    /// </summary>
    public Level7ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level7ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level7ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level7ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level7ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level7ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level7ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level7ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 8 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl8pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level8ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl8pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10299;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level8ParagraphProperties class.
    /// </summary>
    public Level8ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level8ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level8ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level8ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level8ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level8ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level8ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level8ParagraphProperties>(deep);
    }

}
/// <summary>
/// <para>List Level 9 Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lvl9pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level9ParagraphProperties : TextParagraphPropertiesType
{
    private const string tagName = "lvl9pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10300;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Level9ParagraphProperties class.
    /// </summary>
    public Level9ParagraphProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the Level9ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level9ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level9ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level9ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level9ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level9ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level9ParagraphProperties>(deep);
    }

}
/// <summary>
/// Defines the TextParagraphPropertiesType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LineSpacing &lt;a:lnSpc></description></item>
///<item><description>SpaceBefore &lt;a:spcBef></description></item>
///<item><description>SpaceAfter &lt;a:spcAft></description></item>
///<item><description>BulletColorText &lt;a:buClrTx></description></item>
///<item><description>BulletColor &lt;a:buClr></description></item>
///<item><description>BulletSizeText &lt;a:buSzTx></description></item>
///<item><description>BulletSizePercentage &lt;a:buSzPct></description></item>
///<item><description>BulletSizePoints &lt;a:buSzPts></description></item>
///<item><description>BulletFontText &lt;a:buFontTx></description></item>
///<item><description>BulletFont &lt;a:buFont></description></item>
///<item><description>NoBullet &lt;a:buNone></description></item>
///<item><description>AutoNumberedBullet &lt;a:buAutoNum></description></item>
///<item><description>CharacterBullet &lt;a:buChar></description></item>
///<item><description>PictureBullet &lt;a:buBlip></description></item>
///<item><description>TabStopList &lt;a:tabLst></description></item>
///<item><description>DefaultRunProperties &lt;a:defRPr></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LineSpacing))]
    [ChildElementInfo(typeof(SpaceBefore))]
    [ChildElementInfo(typeof(SpaceAfter))]
    [ChildElementInfo(typeof(BulletColorText))]
    [ChildElementInfo(typeof(BulletColor))]
    [ChildElementInfo(typeof(BulletSizeText))]
    [ChildElementInfo(typeof(BulletSizePercentage))]
    [ChildElementInfo(typeof(BulletSizePoints))]
    [ChildElementInfo(typeof(BulletFontText))]
    [ChildElementInfo(typeof(BulletFont))]
    [ChildElementInfo(typeof(NoBullet))]
    [ChildElementInfo(typeof(AutoNumberedBullet))]
    [ChildElementInfo(typeof(CharacterBullet))]
    [ChildElementInfo(typeof(PictureBullet))]
    [ChildElementInfo(typeof(TabStopList))]
    [ChildElementInfo(typeof(DefaultRunProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TextParagraphPropertiesType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "marL","marR","lvl","indent","algn","defTabSz","rtl","eaLnBrk","fontAlgn","latinLnBrk","hangingPunct" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Left Margin.</para>
    /// <para>Represents the following attribute in the schema: marL </para>
    /// </summary>
    [SchemaAttr(0, "marL")]
    public Int32Value LeftMargin
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Right Margin.</para>
    /// <para>Represents the following attribute in the schema: marR </para>
    /// </summary>
    [SchemaAttr(0, "marR")]
    public Int32Value RightMargin
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Level.</para>
    /// <para>Represents the following attribute in the schema: lvl </para>
    /// </summary>
    [SchemaAttr(0, "lvl")]
    public Int32Value Level
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Indent.</para>
    /// <para>Represents the following attribute in the schema: indent </para>
    /// </summary>
    [SchemaAttr(0, "indent")]
    public Int32Value Indent
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextAlignmentTypeValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextAlignmentTypeValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Default Tab Size.</para>
    /// <para>Represents the following attribute in the schema: defTabSz </para>
    /// </summary>
    [SchemaAttr(0, "defTabSz")]
    public Int32Value DefaultTabSize
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Right To Left.</para>
    /// <para>Represents the following attribute in the schema: rtl </para>
    /// </summary>
    [SchemaAttr(0, "rtl")]
    public BooleanValue RightToLeft
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> East Asian Line Break.</para>
    /// <para>Represents the following attribute in the schema: eaLnBrk </para>
    /// </summary>
    [SchemaAttr(0, "eaLnBrk")]
    public BooleanValue EastAsianLineBreak
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Font Alignment.</para>
    /// <para>Represents the following attribute in the schema: fontAlgn </para>
    /// </summary>
    [SchemaAttr(0, "fontAlgn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextFontAlignmentValues> FontAlignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextFontAlignmentValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Latin Line Break.</para>
    /// <para>Represents the following attribute in the schema: latinLnBrk </para>
    /// </summary>
    [SchemaAttr(0, "latinLnBrk")]
    public BooleanValue LatinLineBreak
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Hanging Punctuation.</para>
    /// <para>Represents the following attribute in the schema: hangingPunct </para>
    /// </summary>
    [SchemaAttr(0, "hangingPunct")]
    public BooleanValue Height
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "lnSpc" == name)
    return new LineSpacing();
    
if( 10 == namespaceId && "spcBef" == name)
    return new SpaceBefore();
    
if( 10 == namespaceId && "spcAft" == name)
    return new SpaceAfter();
    
if( 10 == namespaceId && "buClrTx" == name)
    return new BulletColorText();
    
if( 10 == namespaceId && "buClr" == name)
    return new BulletColor();
    
if( 10 == namespaceId && "buSzTx" == name)
    return new BulletSizeText();
    
if( 10 == namespaceId && "buSzPct" == name)
    return new BulletSizePercentage();
    
if( 10 == namespaceId && "buSzPts" == name)
    return new BulletSizePoints();
    
if( 10 == namespaceId && "buFontTx" == name)
    return new BulletFontText();
    
if( 10 == namespaceId && "buFont" == name)
    return new BulletFont();
    
if( 10 == namespaceId && "buNone" == name)
    return new NoBullet();
    
if( 10 == namespaceId && "buAutoNum" == name)
    return new AutoNumberedBullet();
    
if( 10 == namespaceId && "buChar" == name)
    return new CharacterBullet();
    
if( 10 == namespaceId && "buBlip" == name)
    return new PictureBullet();
    
if( 10 == namespaceId && "tabLst" == name)
    return new TabStopList();
    
if( 10 == namespaceId && "defRPr" == name)
    return new DefaultRunProperties();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "lnSpc","spcBef","spcAft","buClrTx","buClr","buSzTx","buSzPct","buSzPts","buFontTx","buFont","buNone","buAutoNum","buChar","buBlip","tabLst","defRPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Line Spacing.</para>
    /// <para> Represents the following element tag in the schema: a:lnSpc </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LineSpacing LineSpacing
    {
        get 
        {
            return GetElement<LineSpacing>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Space Before.</para>
    /// <para> Represents the following element tag in the schema: a:spcBef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SpaceBefore SpaceBefore
    {
        get 
        {
            return GetElement<SpaceBefore>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Space After.</para>
    /// <para> Represents the following element tag in the schema: a:spcAft </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SpaceAfter SpaceAfter
    {
        get 
        {
            return GetElement<SpaceAfter>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "marL" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "marR" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "lvl" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "indent" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextAlignmentTypeValues>();
    
if( 0 == namespaceId && "defTabSz" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "rtl" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "eaLnBrk" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fontAlgn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextFontAlignmentValues>();
    
if( 0 == namespaceId && "latinLnBrk" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hangingPunct" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TextParagraphPropertiesType class.
    /// </summary>
    protected TextParagraphPropertiesType(){}
    
            /// <summary>
    ///Initializes a new instance of the TextParagraphPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextParagraphPropertiesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextParagraphPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextParagraphPropertiesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextParagraphPropertiesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TextParagraphPropertiesType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>End Paragraph Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:endParaRPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Highlight &lt;a:highlight></description></item>
///<item><description>UnderlineFollowsText &lt;a:uLnTx></description></item>
///<item><description>Underline &lt;a:uLn></description></item>
///<item><description>UnderlineFillText &lt;a:uFillTx></description></item>
///<item><description>UnderlineFill &lt;a:uFill></description></item>
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SymbolFont &lt;a:sym></description></item>
///<item><description>HyperlinkOnClick &lt;a:hlinkClick></description></item>
///<item><description>HyperlinkOnMouseOver &lt;a:hlinkMouseOver></description></item>
///<item><description>RightToLeft &lt;a:rtl></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndParagraphRunProperties : TextCharacterPropertiesType
{
    private const string tagName = "endParaRPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10290;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndParagraphRunProperties class.
    /// </summary>
    public EndParagraphRunProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the EndParagraphRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndParagraphRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EndParagraphRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndParagraphRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EndParagraphRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EndParagraphRunProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndParagraphRunProperties>(deep);
    }

}
/// <summary>
/// <para>Text Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Highlight &lt;a:highlight></description></item>
///<item><description>UnderlineFollowsText &lt;a:uLnTx></description></item>
///<item><description>Underline &lt;a:uLn></description></item>
///<item><description>UnderlineFillText &lt;a:uFillTx></description></item>
///<item><description>UnderlineFill &lt;a:uFill></description></item>
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SymbolFont &lt;a:sym></description></item>
///<item><description>HyperlinkOnClick &lt;a:hlinkClick></description></item>
///<item><description>HyperlinkOnMouseOver &lt;a:hlinkMouseOver></description></item>
///<item><description>RightToLeft &lt;a:rtl></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunProperties : TextCharacterPropertiesType
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10303;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RunProperties class.
    /// </summary>
    public RunProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunProperties>(deep);
    }

}
/// <summary>
/// <para>Default Text Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:defRPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Highlight &lt;a:highlight></description></item>
///<item><description>UnderlineFollowsText &lt;a:uLnTx></description></item>
///<item><description>Underline &lt;a:uLn></description></item>
///<item><description>UnderlineFillText &lt;a:uFillTx></description></item>
///<item><description>UnderlineFill &lt;a:uFill></description></item>
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SymbolFont &lt;a:sym></description></item>
///<item><description>HyperlinkOnClick &lt;a:hlinkClick></description></item>
///<item><description>HyperlinkOnMouseOver &lt;a:hlinkMouseOver></description></item>
///<item><description>RightToLeft &lt;a:rtl></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultRunProperties : TextCharacterPropertiesType
{
    private const string tagName = "defRPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10310;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultRunProperties class.
    /// </summary>
    public DefaultRunProperties():base(){}
            /// <summary>
    ///Initializes a new instance of the DefaultRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefaultRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefaultRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DefaultRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DefaultRunProperties(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultRunProperties>(deep);
    }

}
/// <summary>
/// Defines the TextCharacterPropertiesType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Outline &lt;a:ln></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Highlight &lt;a:highlight></description></item>
///<item><description>UnderlineFollowsText &lt;a:uLnTx></description></item>
///<item><description>Underline &lt;a:uLn></description></item>
///<item><description>UnderlineFillText &lt;a:uFillTx></description></item>
///<item><description>UnderlineFill &lt;a:uFill></description></item>
///<item><description>LatinFont &lt;a:latin></description></item>
///<item><description>EastAsianFont &lt;a:ea></description></item>
///<item><description>ComplexScriptFont &lt;a:cs></description></item>
///<item><description>SymbolFont &lt;a:sym></description></item>
///<item><description>HyperlinkOnClick &lt;a:hlinkClick></description></item>
///<item><description>HyperlinkOnMouseOver &lt;a:hlinkMouseOver></description></item>
///<item><description>RightToLeft &lt;a:rtl></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
    [ChildElementInfo(typeof(Highlight))]
    [ChildElementInfo(typeof(UnderlineFollowsText))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(UnderlineFillText))]
    [ChildElementInfo(typeof(UnderlineFill))]
    [ChildElementInfo(typeof(LatinFont))]
    [ChildElementInfo(typeof(EastAsianFont))]
    [ChildElementInfo(typeof(ComplexScriptFont))]
    [ChildElementInfo(typeof(SymbolFont))]
    [ChildElementInfo(typeof(HyperlinkOnClick))]
    [ChildElementInfo(typeof(HyperlinkOnMouseOver))]
    [ChildElementInfo(typeof(RightToLeft))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TextCharacterPropertiesType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "kumimoji","lang","altLang","sz","b","i","u","strike","kern","cap","spc","normalizeH","baseline","noProof","dirty","err","smtClean","smtId","bmk" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> kumimoji.</para>
    /// <para>Represents the following attribute in the schema: kumimoji </para>
    /// </summary>
    [SchemaAttr(0, "kumimoji")]
    public BooleanValue Kumimoji
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> lang.</para>
    /// <para>Represents the following attribute in the schema: lang </para>
    /// </summary>
    [SchemaAttr(0, "lang")]
    public StringValue Language
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> altLang.</para>
    /// <para>Represents the following attribute in the schema: altLang </para>
    /// </summary>
    [SchemaAttr(0, "altLang")]
    public StringValue AlternativeLanguage
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> sz.</para>
    /// <para>Represents the following attribute in the schema: sz </para>
    /// </summary>
    [SchemaAttr(0, "sz")]
    public Int32Value FontSize
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> b.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> i.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> u.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextUnderlineValues> Underline
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextUnderlineValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> strike.</para>
    /// <para>Represents the following attribute in the schema: strike </para>
    /// </summary>
    [SchemaAttr(0, "strike")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextStrikeValues> Strike
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextStrikeValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> kern.</para>
    /// <para>Represents the following attribute in the schema: kern </para>
    /// </summary>
    [SchemaAttr(0, "kern")]
    public Int32Value Kerning
    {
        get { return (Int32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> cap.</para>
    /// <para>Represents the following attribute in the schema: cap </para>
    /// </summary>
    [SchemaAttr(0, "cap")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextCapsValues> Capital
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextCapsValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> spc.</para>
    /// <para>Represents the following attribute in the schema: spc </para>
    /// </summary>
    [SchemaAttr(0, "spc")]
    public Int32Value Spacing
    {
        get { return (Int32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> normalizeH.</para>
    /// <para>Represents the following attribute in the schema: normalizeH </para>
    /// </summary>
    [SchemaAttr(0, "normalizeH")]
    public BooleanValue NormalizeHeight
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> baseline.</para>
    /// <para>Represents the following attribute in the schema: baseline </para>
    /// </summary>
    [SchemaAttr(0, "baseline")]
    public Int32Value Baseline
    {
        get { return (Int32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> noProof.</para>
    /// <para>Represents the following attribute in the schema: noProof </para>
    /// </summary>
    [SchemaAttr(0, "noProof")]
    public BooleanValue NoProof
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> dirty.</para>
    /// <para>Represents the following attribute in the schema: dirty </para>
    /// </summary>
    [SchemaAttr(0, "dirty")]
    public BooleanValue Dirty
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> err.</para>
    /// <para>Represents the following attribute in the schema: err </para>
    /// </summary>
    [SchemaAttr(0, "err")]
    public BooleanValue SpellingError
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> smtClean.</para>
    /// <para>Represents the following attribute in the schema: smtClean </para>
    /// </summary>
    [SchemaAttr(0, "smtClean")]
    public BooleanValue SmtClean
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> smtId.</para>
    /// <para>Represents the following attribute in the schema: smtId </para>
    /// </summary>
    [SchemaAttr(0, "smtId")]
    public UInt32Value SmtId
    {
        get { return (UInt32Value)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> bmk.</para>
    /// <para>Represents the following attribute in the schema: bmk </para>
    /// </summary>
    [SchemaAttr(0, "bmk")]
    public StringValue Bookmark
    {
        get { return (StringValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ln" == name)
    return new Outline();
    
if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    
if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    
if( 10 == namespaceId && "highlight" == name)
    return new Highlight();
    
if( 10 == namespaceId && "uLnTx" == name)
    return new UnderlineFollowsText();
    
if( 10 == namespaceId && "uLn" == name)
    return new Underline();
    
if( 10 == namespaceId && "uFillTx" == name)
    return new UnderlineFillText();
    
if( 10 == namespaceId && "uFill" == name)
    return new UnderlineFill();
    
if( 10 == namespaceId && "latin" == name)
    return new LatinFont();
    
if( 10 == namespaceId && "ea" == name)
    return new EastAsianFont();
    
if( 10 == namespaceId && "cs" == name)
    return new ComplexScriptFont();
    
if( 10 == namespaceId && "sym" == name)
    return new SymbolFont();
    
if( 10 == namespaceId && "hlinkClick" == name)
    return new HyperlinkOnClick();
    
if( 10 == namespaceId && "hlinkMouseOver" == name)
    return new HyperlinkOnMouseOver();
    
if( 10 == namespaceId && "rtl" == name)
    return new RightToLeft();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ln","noFill","solidFill","gradFill","blipFill","pattFill","grpFill","effectLst","effectDag","highlight","uLnTx","uLn","uFillTx","uFill","latin","ea","cs","sym","hlinkClick","hlinkMouseOver","rtl","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: a:ln </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "kumimoji" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "lang" == name)
    return new StringValue();
    
if( 0 == namespaceId && "altLang" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sz" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "u" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextUnderlineValues>();
    
if( 0 == namespaceId && "strike" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextStrikeValues>();
    
if( 0 == namespaceId && "kern" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "cap" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextCapsValues>();
    
if( 0 == namespaceId && "spc" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "normalizeH" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "baseline" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "noProof" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dirty" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "err" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "smtClean" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "smtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bmk" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TextCharacterPropertiesType class.
    /// </summary>
    protected TextCharacterPropertiesType(){}
    
            /// <summary>
    ///Initializes a new instance of the TextCharacterPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextCharacterPropertiesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextCharacterPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextCharacterPropertiesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextCharacterPropertiesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TextCharacterPropertiesType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Text Paragraphs.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:p.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphProperties &lt;a:pPr></description></item>
///<item><description>Run &lt;a:r></description></item>
///<item><description>Break &lt;a:br></description></item>
///<item><description>Field &lt;a:fld></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.TextMath &lt;a14:m></description></item>
///<item><description>EndParagraphRunProperties &lt;a:endParaRPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphProperties))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(Break))]
    [ChildElementInfo(typeof(Field))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.TextMath),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(EndParagraphRunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Paragraph : OpenXmlCompositeElement
{
    private const string tagName = "p";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10301;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Paragraph class.
    /// </summary>
    public Paragraph():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Paragraph class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Paragraph(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Paragraph class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Paragraph(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Paragraph class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Paragraph(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "pPr" == name)
    return new ParagraphProperties();
    
if( 10 == namespaceId && "r" == name)
    return new Run();
    
if( 10 == namespaceId && "br" == name)
    return new Break();
    
if( 10 == namespaceId && "fld" == name)
    return new Field();
    
if( 48 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.TextMath();
    
if( 10 == namespaceId && "endParaRPr" == name)
    return new EndParagraphRunProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pPr","r","br","fld","m","endParaRPr" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,48,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: a:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ParagraphProperties ParagraphProperties
    {
        get 
        {
            return GetElement<ParagraphProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Paragraph>(deep);
    }

   
}
/// <summary>
/// <para>Tab Stop.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tab.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TabStop : OpenXmlLeafElement
{
    private const string tagName = "tab";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10302;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "pos","algn" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Tab Position.</para>
    /// <para>Represents the following attribute in the schema: pos </para>
    /// </summary>
    [SchemaAttr(0, "pos")]
    public Int32Value Position
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Tab Alignment.</para>
    /// <para>Represents the following attribute in the schema: algn </para>
    /// </summary>
    [SchemaAttr(0, "algn")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.TextTabAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.TextTabAlignmentValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TabStop class.
    /// </summary>
    public TabStop():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "pos" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "algn" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.TextTabAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TabStop>(deep);
    }

   
}
/// <summary>
/// <para>Spacing Percent.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spcPct.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpacingPercent : OpenXmlLeafElement
{
    private const string tagName = "spcPct";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10304;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SpacingPercent class.
    /// </summary>
    public SpacingPercent():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpacingPercent>(deep);
    }

   
}
/// <summary>
/// <para>Spacing Points.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spcPts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpacingPoints : OpenXmlLeafElement
{
    private const string tagName = "spcPts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10305;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SpacingPoints class.
    /// </summary>
    public SpacingPoints():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpacingPoints>(deep);
    }

   
}
/// <summary>
/// <para>Line Spacing.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:lnSpc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SpacingPercent &lt;a:spcPct></description></item>
///<item><description>SpacingPoints &lt;a:spcPts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineSpacing : TextSpacingType
{
    private const string tagName = "lnSpc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10306;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LineSpacing class.
    /// </summary>
    public LineSpacing():base(){}
            /// <summary>
    ///Initializes a new instance of the LineSpacing class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineSpacing(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LineSpacing class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LineSpacing(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LineSpacing class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LineSpacing(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineSpacing>(deep);
    }

}
/// <summary>
/// <para>Space Before.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spcBef.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SpacingPercent &lt;a:spcPct></description></item>
///<item><description>SpacingPoints &lt;a:spcPts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpaceBefore : TextSpacingType
{
    private const string tagName = "spcBef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10307;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SpaceBefore class.
    /// </summary>
    public SpaceBefore():base(){}
            /// <summary>
    ///Initializes a new instance of the SpaceBefore class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SpaceBefore(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SpaceBefore class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SpaceBefore(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SpaceBefore class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SpaceBefore(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpaceBefore>(deep);
    }

}
/// <summary>
/// <para>Space After.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:spcAft.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SpacingPercent &lt;a:spcPct></description></item>
///<item><description>SpacingPoints &lt;a:spcPts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpaceAfter : TextSpacingType
{
    private const string tagName = "spcAft";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10308;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SpaceAfter class.
    /// </summary>
    public SpaceAfter():base(){}
            /// <summary>
    ///Initializes a new instance of the SpaceAfter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SpaceAfter(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SpaceAfter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SpaceAfter(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SpaceAfter class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SpaceAfter(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpaceAfter>(deep);
    }

}
/// <summary>
/// Defines the TextSpacingType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SpacingPercent &lt;a:spcPct></description></item>
///<item><description>SpacingPoints &lt;a:spcPts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SpacingPercent))]
    [ChildElementInfo(typeof(SpacingPoints))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TextSpacingType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "spcPct" == name)
    return new SpacingPercent();
    
if( 10 == namespaceId && "spcPts" == name)
    return new SpacingPoints();
    

    return null;
}

        private static readonly string[] eleTagNames = { "spcPct","spcPts" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Spacing Percent.</para>
    /// <para> Represents the following element tag in the schema: a:spcPct </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SpacingPercent SpacingPercent
    {
        get 
        {
            return GetElement<SpacingPercent>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Spacing Points.</para>
    /// <para> Represents the following element tag in the schema: a:spcPts </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public SpacingPoints SpacingPoints
    {
        get 
        {
            return GetElement<SpacingPoints>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the TextSpacingType class.
    /// </summary>
    protected TextSpacingType(){}
    
            /// <summary>
    ///Initializes a new instance of the TextSpacingType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextSpacingType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextSpacingType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TextSpacingType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextSpacingType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TextSpacingType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Tab List.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:tabLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TabStop &lt;a:tab></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TabStop))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TabStopList : OpenXmlCompositeElement
{
    private const string tagName = "tabLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10309;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TabStopList class.
    /// </summary>
    public TabStopList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TabStopList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TabStopList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TabStopList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TabStopList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TabStopList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TabStopList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "tab" == name)
    return new TabStop();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TabStopList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Text Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:t.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Text : OpenXmlLeafTextElement
{
    private const string tagName = "t";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10311;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Text class.
    /// </summary>
    public Text():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the Text class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Text(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    
 
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Text>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ShapePropertiesExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties &lt;a14:hiddenFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties &lt;a14:hiddenLine></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties &lt;a14:hiddenEffects></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D &lt;a14:hiddenScene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D &lt;a14:hiddenSp3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured &lt;a14:shadowObscured></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapePropertiesExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10312;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtension class.
    /// </summary>
    public ShapePropertiesExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapePropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapePropertiesExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapePropertiesExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapePropertiesExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 48 == namespaceId && "hiddenFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenFillProperties();
    
if( 48 == namespaceId && "hiddenLine" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenLineProperties();
    
if( 48 == namespaceId && "hiddenEffects" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenEffectsProperties();
    
if( 48 == namespaceId && "hiddenScene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenScene3D();
    
if( 48 == namespaceId && "hiddenSp3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.HiddenShape3D();
    
if( 48 == namespaceId && "shadowObscured" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.ShadowObscured();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapePropertiesExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the GvmlGroupShapeExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas &lt;a14:isCanvas></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GvmlGroupShapeExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10313;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtension class.
    /// </summary>
    public GvmlGroupShapeExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GvmlGroupShapeExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GvmlGroupShapeExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GvmlGroupShapeExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GvmlGroupShapeExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 48 == namespaceId && "isCanvas" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.IsCanvas();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GvmlGroupShapeExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ShapePropertiesExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapePropertiesExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ShapePropertiesExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapePropertiesExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10314;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtensionList class.
    /// </summary>
    public ShapePropertiesExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapePropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapePropertiesExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapePropertiesExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapePropertiesExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapePropertiesExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new ShapePropertiesExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapePropertiesExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Non-Visual Properties for a Group Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:nvGrpSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingProperties &lt;a:cNvPr></description></item>
///<item><description>NonVisualGroupShapeDrawingProperties &lt;a:cNvGrpSpPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingProperties))]
    [ChildElementInfo(typeof(NonVisualGroupShapeDrawingProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGroupShapeProperties : OpenXmlCompositeElement
{
    private const string tagName = "nvGrpSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10315;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeProperties class.
    /// </summary>
    public NonVisualGroupShapeProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGroupShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupShapeProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupShapeProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGroupShapeProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "cNvPr" == name)
    return new NonVisualDrawingProperties();
    
if( 10 == namespaceId && "cNvGrpSpPr" == name)
    return new NonVisualGroupShapeDrawingProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cNvPr","cNvGrpSpPr" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> NonVisualDrawingProperties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualDrawingProperties NonVisualDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualDrawingProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Non-Visual Group Shape Drawing Properties.</para>
    /// <para> Represents the following element tag in the schema: a:cNvGrpSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualGroupShapeDrawingProperties NonVisualGroupShapeDrawingProperties
    {
        get 
        {
            return GetElement<NonVisualGroupShapeDrawingProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGroupShapeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Visual Group Shape Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:grpSpPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TransformGroup &lt;a:xfrm></description></item>
///<item><description>NoFill &lt;a:noFill></description></item>
///<item><description>SolidFill &lt;a:solidFill></description></item>
///<item><description>GradientFill &lt;a:gradFill></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>PatternFill &lt;a:pattFill></description></item>
///<item><description>GroupFill &lt;a:grpFill></description></item>
///<item><description>EffectList &lt;a:effectLst></description></item>
///<item><description>EffectDag &lt;a:effectDag></description></item>
///<item><description>Scene3DType &lt;a:scene3d></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TransformGroup))]
    [ChildElementInfo(typeof(NoFill))]
    [ChildElementInfo(typeof(SolidFill))]
    [ChildElementInfo(typeof(GradientFill))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GroupFill))]
    [ChildElementInfo(typeof(EffectList))]
    [ChildElementInfo(typeof(EffectDag))]
    [ChildElementInfo(typeof(Scene3DType))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VisualGroupShapeProperties : OpenXmlCompositeElement
{
    private const string tagName = "grpSpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10316;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bwMode" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Black and White Mode.</para>
    /// <para>Represents the following attribute in the schema: bwMode </para>
    /// </summary>
    [SchemaAttr(0, "bwMode")]
    public EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues> BlackWhiteMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VisualGroupShapeProperties class.
    /// </summary>
    public VisualGroupShapeProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the VisualGroupShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VisualGroupShapeProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the VisualGroupShapeProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VisualGroupShapeProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the VisualGroupShapeProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public VisualGroupShapeProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "xfrm" == name)
    return new TransformGroup();
    
if( 10 == namespaceId && "noFill" == name)
    return new NoFill();
    
if( 10 == namespaceId && "solidFill" == name)
    return new SolidFill();
    
if( 10 == namespaceId && "gradFill" == name)
    return new GradientFill();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "pattFill" == name)
    return new PatternFill();
    
if( 10 == namespaceId && "grpFill" == name)
    return new GroupFill();
    
if( 10 == namespaceId && "effectLst" == name)
    return new EffectList();
    
if( 10 == namespaceId && "effectDag" == name)
    return new EffectDag();
    
if( 10 == namespaceId && "scene3d" == name)
    return new Scene3DType();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "xfrm","noFill","solidFill","gradFill","blipFill","pattFill","grpFill","effectLst","effectDag","scene3d","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> 2D Transform for Grouped Objects.</para>
    /// <para> Represents the following element tag in the schema: a:xfrm </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TransformGroup TransformGroup
    {
        get 
        {
            return GetElement<TransformGroup>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "bwMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Drawing.BlackWhiteModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VisualGroupShapeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:sp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualShapeProperties &lt;a:nvSpPr></description></item>
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>TextShape &lt;a:txSp></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualShapeProperties))]
    [ChildElementInfo(typeof(ShapeProperties))]
    [ChildElementInfo(typeof(TextShape))]
    [ChildElementInfo(typeof(ShapeStyle))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shape : OpenXmlCompositeElement
{
    private const string tagName = "sp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10317;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Shape class.
    /// </summary>
    public Shape():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Shape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Shape(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Shape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Shape(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Shape class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Shape(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "nvSpPr" == name)
    return new NonVisualShapeProperties();
    
if( 10 == namespaceId && "spPr" == name)
    return new ShapeProperties();
    
if( 10 == namespaceId && "txSp" == name)
    return new TextShape();
    
if( 10 == namespaceId && "style" == name)
    return new ShapeStyle();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nvSpPr","spPr","txSp","style","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Properties for a Shape.</para>
    /// <para> Represents the following element tag in the schema: a:nvSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualShapeProperties NonVisualShapeProperties
    {
        get 
        {
            return GetElement<NonVisualShapeProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Visual Properties.</para>
    /// <para> Represents the following element tag in the schema: a:spPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeProperties ShapeProperties
    {
        get 
        {
            return GetElement<ShapeProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Text Shape.</para>
    /// <para> Represents the following element tag in the schema: a:txSp </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TextShape TextShape
    {
        get 
        {
            return GetElement<TextShape>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Style.</para>
    /// <para> Represents the following element tag in the schema: a:style </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeStyle ShapeStyle
    {
        get 
        {
            return GetElement<ShapeStyle>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shape>(deep);
    }

   
}
/// <summary>
/// <para>Connection Shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:cxnSp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualConnectionShapeProperties &lt;a:nvCxnSpPr></description></item>
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualConnectionShapeProperties))]
    [ChildElementInfo(typeof(ShapeProperties))]
    [ChildElementInfo(typeof(ShapeStyle))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionShape : OpenXmlCompositeElement
{
    private const string tagName = "cxnSp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10318;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ConnectionShape class.
    /// </summary>
    public ConnectionShape():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionShape(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionShape(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionShape class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionShape(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "nvCxnSpPr" == name)
    return new NonVisualConnectionShapeProperties();
    
if( 10 == namespaceId && "spPr" == name)
    return new ShapeProperties();
    
if( 10 == namespaceId && "style" == name)
    return new ShapeStyle();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nvCxnSpPr","spPr","style","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Properties for a Connection Shape.</para>
    /// <para> Represents the following element tag in the schema: a:nvCxnSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualConnectionShapeProperties NonVisualConnectionShapeProperties
    {
        get 
        {
            return GetElement<NonVisualConnectionShapeProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Visual Properties.</para>
    /// <para> Represents the following element tag in the schema: a:spPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeProperties ShapeProperties
    {
        get 
        {
            return GetElement<ShapeProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Shape Style.</para>
    /// <para> Represents the following element tag in the schema: a:style </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeStyle ShapeStyle
    {
        get 
        {
            return GetElement<ShapeStyle>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionShape>(deep);
    }

   
}
/// <summary>
/// <para>Picture.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:pic.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualPictureProperties &lt;a:nvPicPr></description></item>
///<item><description>BlipFill &lt;a:blipFill></description></item>
///<item><description>ShapeProperties &lt;a:spPr></description></item>
///<item><description>ShapeStyle &lt;a:style></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualPictureProperties))]
    [ChildElementInfo(typeof(BlipFill))]
    [ChildElementInfo(typeof(ShapeProperties))]
    [ChildElementInfo(typeof(ShapeStyle))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Picture : OpenXmlCompositeElement
{
    private const string tagName = "pic";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10319;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Picture class.
    /// </summary>
    public Picture():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Picture class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Picture(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Picture class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Picture(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Picture class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Picture(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "nvPicPr" == name)
    return new NonVisualPictureProperties();
    
if( 10 == namespaceId && "blipFill" == name)
    return new BlipFill();
    
if( 10 == namespaceId && "spPr" == name)
    return new ShapeProperties();
    
if( 10 == namespaceId && "style" == name)
    return new ShapeStyle();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nvPicPr","blipFill","spPr","style","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Properties for a Picture.</para>
    /// <para> Represents the following element tag in the schema: a:nvPicPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualPictureProperties NonVisualPictureProperties
    {
        get 
        {
            return GetElement<NonVisualPictureProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Picture Fill.</para>
    /// <para> Represents the following element tag in the schema: a:blipFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public BlipFill BlipFill
    {
        get 
        {
            return GetElement<BlipFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Shape Properties.</para>
    /// <para> Represents the following element tag in the schema: a:spPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeProperties ShapeProperties
    {
        get 
        {
            return GetElement<ShapeProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ShapeStyle.</para>
    /// <para> Represents the following element tag in the schema: a:style </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeStyle ShapeStyle
    {
        get 
        {
            return GetElement<ShapeStyle>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Picture>(deep);
    }

   
}
/// <summary>
/// <para>Graphic Frame.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:graphicFrame.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualGraphicFrameProperties &lt;a:nvGraphicFramePr></description></item>
///<item><description>Graphic &lt;a:graphic></description></item>
///<item><description>Transform2D &lt;a:xfrm></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualGraphicFrameProperties))]
    [ChildElementInfo(typeof(Graphic))]
    [ChildElementInfo(typeof(Transform2D))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GraphicFrame : OpenXmlCompositeElement
{
    private const string tagName = "graphicFrame";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10320;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the GraphicFrame class.
    /// </summary>
    public GraphicFrame():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GraphicFrame class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicFrame(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicFrame class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GraphicFrame(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GraphicFrame class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GraphicFrame(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "nvGraphicFramePr" == name)
    return new NonVisualGraphicFrameProperties();
    
if( 10 == namespaceId && "graphic" == name)
    return new Graphic();
    
if( 10 == namespaceId && "xfrm" == name)
    return new Transform2D();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nvGraphicFramePr","graphic","xfrm","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Properties for a Graphic Frame.</para>
    /// <para> Represents the following element tag in the schema: a:nvGraphicFramePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualGraphicFrameProperties NonVisualGraphicFrameProperties
    {
        get 
        {
            return GetElement<NonVisualGraphicFrameProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Graphic.</para>
    /// <para> Represents the following element tag in the schema: a:graphic </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Graphic Graphic
    {
        get 
        {
            return GetElement<Graphic>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Transform2D.</para>
    /// <para> Represents the following element tag in the schema: a:xfrm </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public Transform2D Transform2D
    {
        get 
        {
            return GetElement<Transform2D>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GraphicFrame>(deep);
    }

   
}
/// <summary>
/// <para>Group shape.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:grpSp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualGroupShapeProperties &lt;a:nvGrpSpPr></description></item>
///<item><description>VisualGroupShapeProperties &lt;a:grpSpPr></description></item>
///<item><description>TextShape &lt;a:txSp></description></item>
///<item><description>Shape &lt;a:sp></description></item>
///<item><description>ConnectionShape &lt;a:cxnSp></description></item>
///<item><description>Picture &lt;a:pic></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart &lt;a14:contentPart></description></item>
///<item><description>GraphicFrame &lt;a:graphicFrame></description></item>
///<item><description>GroupShape &lt;a:grpSp></description></item>
///<item><description>GvmlGroupShapeExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualGroupShapeProperties))]
    [ChildElementInfo(typeof(VisualGroupShapeProperties))]
    [ChildElementInfo(typeof(TextShape))]
    [ChildElementInfo(typeof(Shape))]
    [ChildElementInfo(typeof(ConnectionShape))]
    [ChildElementInfo(typeof(Picture))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(GraphicFrame))]
    [ChildElementInfo(typeof(GroupShape))]
    [ChildElementInfo(typeof(GvmlGroupShapeExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupShape : OpenXmlCompositeElement
{
    private const string tagName = "grpSp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10321;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the GroupShape class.
    /// </summary>
    public GroupShape():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupShape(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupShape class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupShape(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupShape class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupShape(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "nvGrpSpPr" == name)
    return new NonVisualGroupShapeProperties();
    
if( 10 == namespaceId && "grpSpPr" == name)
    return new VisualGroupShapeProperties();
    
if( 10 == namespaceId && "txSp" == name)
    return new TextShape();
    
if( 10 == namespaceId && "sp" == name)
    return new Shape();
    
if( 10 == namespaceId && "cxnSp" == name)
    return new ConnectionShape();
    
if( 10 == namespaceId && "pic" == name)
    return new Picture();
    
if( 48 == namespaceId && "contentPart" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.GvmlContentPart();
    
if( 10 == namespaceId && "graphicFrame" == name)
    return new GraphicFrame();
    
if( 10 == namespaceId && "grpSp" == name)
    return new GroupShape();
    
if( 10 == namespaceId && "extLst" == name)
    return new GvmlGroupShapeExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nvGrpSpPr","grpSpPr","txSp","sp","cxnSp","pic","contentPart","graphicFrame","grpSp","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10,10,10,48,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Non-Visual Properties for a Group Shape.</para>
    /// <para> Represents the following element tag in the schema: a:nvGrpSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public NonVisualGroupShapeProperties NonVisualGroupShapeProperties
    {
        get 
        {
            return GetElement<NonVisualGroupShapeProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Visual Group Shape Properties.</para>
    /// <para> Represents the following element tag in the schema: a:grpSpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public VisualGroupShapeProperties VisualGroupShapeProperties
    {
        get 
        {
            return GetElement<VisualGroupShapeProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupShape>(deep);
    }

   
}
/// <summary>
/// <para>Defines the GvmlGroupShapeExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GvmlGroupShapeExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GvmlGroupShapeExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GvmlGroupShapeExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10322;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtensionList class.
    /// </summary>
    public GvmlGroupShapeExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GvmlGroupShapeExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GvmlGroupShapeExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GvmlGroupShapeExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GvmlGroupShapeExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GvmlGroupShapeExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new GvmlGroupShapeExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GvmlGroupShapeExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualGroupDrawingShapePropsExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties &lt;a15:nonVisualGroupProps></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGroupDrawingShapePropsExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10323;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtension class.
    /// </summary>
    public NonVisualGroupDrawingShapePropsExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGroupDrawingShapePropsExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupDrawingShapePropsExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupDrawingShapePropsExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGroupDrawingShapePropsExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 67 == namespaceId && "nonVisualGroupProps" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.NonVisualGroupProperties();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGroupDrawingShapePropsExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OfficeStyleSheetExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily &lt;thm15:themeFamily></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OfficeStyleSheetExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10324;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtension class.
    /// </summary>
    public OfficeStyleSheetExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OfficeStyleSheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OfficeStyleSheetExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OfficeStyleSheetExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OfficeStyleSheetExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 73 == namespaceId && "themeFamily" == name)
    return new DocumentFormat.OpenXml.Office2013.Theme.ThemeFamily();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OfficeStyleSheetExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConnectorLockingExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Graphic &lt;a:graphic></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Graphic),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectorLockingExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10325;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtension class.
    /// </summary>
    public ConnectorLockingExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectorLockingExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectorLockingExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectorLockingExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectorLockingExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "graphic" == name)
    return new Graphic();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectorLockingExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the HyperlinkOnClick Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hlinkClick.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HyperlinkSound &lt;a:snd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyperlinkOnClick : HyperlinkType
{
    private const string tagName = "hlinkClick";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10326;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HyperlinkOnClick class.
    /// </summary>
    public HyperlinkOnClick():base(){}
            /// <summary>
    ///Initializes a new instance of the HyperlinkOnClick class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnClick(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnClick class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnClick(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnClick class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HyperlinkOnClick(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyperlinkOnClick>(deep);
    }

}
/// <summary>
/// <para>Defines the HyperlinkOnHover Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hlinkHover.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HyperlinkSound &lt;a:snd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyperlinkOnHover : HyperlinkType
{
    private const string tagName = "hlinkHover";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10327;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HyperlinkOnHover class.
    /// </summary>
    public HyperlinkOnHover():base(){}
            /// <summary>
    ///Initializes a new instance of the HyperlinkOnHover class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnHover(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnHover class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnHover(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnHover class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HyperlinkOnHover(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyperlinkOnHover>(deep);
    }

}
/// <summary>
/// <para>Defines the HyperlinkOnMouseOver Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:hlinkMouseOver.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HyperlinkSound &lt;a:snd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyperlinkOnMouseOver : HyperlinkType
{
    private const string tagName = "hlinkMouseOver";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10343;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HyperlinkOnMouseOver class.
    /// </summary>
    public HyperlinkOnMouseOver():base(){}
            /// <summary>
    ///Initializes a new instance of the HyperlinkOnMouseOver class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnMouseOver(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnMouseOver class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkOnMouseOver(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkOnMouseOver class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HyperlinkOnMouseOver(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyperlinkOnMouseOver>(deep);
    }

}
/// <summary>
/// Defines the HyperlinkType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HyperlinkSound &lt;a:snd></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(HyperlinkSound))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class HyperlinkType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "id","invalidUrl","action","tgtFrame","tooltip","history","highlightClick","endSnd" };
    private static byte[] attributeNamespaceIds = { 19,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Drawing Object Hyperlink Target.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Invalid URL.</para>
    /// <para>Represents the following attribute in the schema: invalidUrl </para>
    /// </summary>
    [SchemaAttr(0, "invalidUrl")]
    public StringValue InvalidUrl
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Action Setting.</para>
    /// <para>Represents the following attribute in the schema: action </para>
    /// </summary>
    [SchemaAttr(0, "action")]
    public StringValue Action
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Target Frame.</para>
    /// <para>Represents the following attribute in the schema: tgtFrame </para>
    /// </summary>
    [SchemaAttr(0, "tgtFrame")]
    public StringValue TargetFrame
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hyperlink Tooltip.</para>
    /// <para>Represents the following attribute in the schema: tooltip </para>
    /// </summary>
    [SchemaAttr(0, "tooltip")]
    public StringValue Tooltip
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Add Hyperlink to Page History.</para>
    /// <para>Represents the following attribute in the schema: history </para>
    /// </summary>
    [SchemaAttr(0, "history")]
    public BooleanValue History
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Highlight Click.</para>
    /// <para>Represents the following attribute in the schema: highlightClick </para>
    /// </summary>
    [SchemaAttr(0, "highlightClick")]
    public BooleanValue HighlightClick
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> End Sounds.</para>
    /// <para>Represents the following attribute in the schema: endSnd </para>
    /// </summary>
    [SchemaAttr(0, "endSnd")]
    public BooleanValue EndSound
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "snd" == name)
    return new HyperlinkSound();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "snd","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Hyperlink Sound.</para>
    /// <para> Represents the following element tag in the schema: a:snd </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public HyperlinkSound HyperlinkSound
    {
        get 
        {
            return GetElement<HyperlinkSound>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "invalidUrl" == name)
    return new StringValue();
    
if( 0 == namespaceId && "action" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tgtFrame" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tooltip" == name)
    return new StringValue();
    
if( 0 == namespaceId && "history" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "highlightClick" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "endSnd" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the HyperlinkType class.
    /// </summary>
    protected HyperlinkType(){}
    
            /// <summary>
    ///Initializes a new instance of the HyperlinkType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected HyperlinkType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected HyperlinkType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected HyperlinkType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the NonVisualDrawingPropertiesExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualDrawingPropertiesExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualDrawingPropertiesExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualDrawingPropertiesExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10328;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtensionList class.
    /// </summary>
    public NonVisualDrawingPropertiesExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualDrawingPropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingPropertiesExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingPropertiesExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualDrawingPropertiesExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new NonVisualDrawingPropertiesExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualDrawingPropertiesExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualDrawingPropertiesExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension &lt;a14:compatExt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties &lt;a15:backgroundPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualDrawingPropertiesExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10329;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtension class.
    /// </summary>
    public NonVisualDrawingPropertiesExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualDrawingPropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingPropertiesExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualDrawingPropertiesExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualDrawingPropertiesExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualDrawingPropertiesExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 48 == namespaceId && "compatExt" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.CompatExtension();
    
if( 67 == namespaceId && "backgroundPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.BackgroundProperties();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualDrawingPropertiesExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PictureLocks Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:picLocks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PictureLocks : OpenXmlCompositeElement
{
    private const string tagName = "picLocks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10330;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "noGrp","noSelect","noRot","noChangeAspect","noMove","noResize","noEditPoints","noAdjustHandles","noChangeArrowheads","noChangeShapeType","noCrop" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disallow Shape Grouping.</para>
    /// <para>Represents the following attribute in the schema: noGrp </para>
    /// </summary>
    [SchemaAttr(0, "noGrp")]
    public BooleanValue NoGrouping
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Selection.</para>
    /// <para>Represents the following attribute in the schema: noSelect </para>
    /// </summary>
    [SchemaAttr(0, "noSelect")]
    public BooleanValue NoSelection
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Rotation.</para>
    /// <para>Represents the following attribute in the schema: noRot </para>
    /// </summary>
    [SchemaAttr(0, "noRot")]
    public BooleanValue NoRotation
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Aspect Ratio Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeAspect </para>
    /// </summary>
    [SchemaAttr(0, "noChangeAspect")]
    public BooleanValue NoChangeAspect
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Movement.</para>
    /// <para>Represents the following attribute in the schema: noMove </para>
    /// </summary>
    [SchemaAttr(0, "noMove")]
    public BooleanValue NoMove
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Resize.</para>
    /// <para>Represents the following attribute in the schema: noResize </para>
    /// </summary>
    [SchemaAttr(0, "noResize")]
    public BooleanValue NoResize
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Point Editing.</para>
    /// <para>Represents the following attribute in the schema: noEditPoints </para>
    /// </summary>
    [SchemaAttr(0, "noEditPoints")]
    public BooleanValue NoEditPoints
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Showing Adjust Handles.</para>
    /// <para>Represents the following attribute in the schema: noAdjustHandles </para>
    /// </summary>
    [SchemaAttr(0, "noAdjustHandles")]
    public BooleanValue NoAdjustHandles
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Arrowhead Changes.</para>
    /// <para>Represents the following attribute in the schema: noChangeArrowheads </para>
    /// </summary>
    [SchemaAttr(0, "noChangeArrowheads")]
    public BooleanValue NoChangeArrowheads
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Type Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeShapeType </para>
    /// </summary>
    [SchemaAttr(0, "noChangeShapeType")]
    public BooleanValue NoChangeShapeType
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Crop Changes.</para>
    /// <para>Represents the following attribute in the schema: noCrop </para>
    /// </summary>
    [SchemaAttr(0, "noCrop")]
    public BooleanValue NoCrop
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PictureLocks class.
    /// </summary>
    public PictureLocks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PictureLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureLocks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureLocks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureLocks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PictureLocks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "noGrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noSelect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noRot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeAspect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noMove" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noResize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noEditPoints" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noAdjustHandles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeArrowheads" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeShapeType" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noCrop" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PictureLocks>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualPicturePropertiesExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualPicturePropertiesExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualPicturePropertiesExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualPicturePropertiesExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10331;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtensionList class.
    /// </summary>
    public NonVisualPicturePropertiesExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualPicturePropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPicturePropertiesExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPicturePropertiesExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualPicturePropertiesExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new NonVisualPicturePropertiesExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualPicturePropertiesExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualPicturePropertiesExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.CameraTool &lt;a14:cameraTool></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine &lt;a15:signatureLine></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties &lt;a15:objectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.CameraTool),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualPicturePropertiesExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10332;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtension class.
    /// </summary>
    public NonVisualPicturePropertiesExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualPicturePropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPicturePropertiesExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualPicturePropertiesExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualPicturePropertiesExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualPicturePropertiesExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 48 == namespaceId && "cameraTool" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.CameraTool();
    
if( 67 == namespaceId && "signatureLine" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.SignatureLine();
    
if( 67 == namespaceId && "objectPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Drawing.ObjectProperties();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualPicturePropertiesExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the GroupShapeLocks Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:grpSpLocks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupShapeLocks : OpenXmlCompositeElement
{
    private const string tagName = "grpSpLocks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10333;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "noGrp","noUngrp","noSelect","noRot","noChangeAspect","noMove","noResize" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disallow Shape Grouping.</para>
    /// <para>Represents the following attribute in the schema: noGrp </para>
    /// </summary>
    [SchemaAttr(0, "noGrp")]
    public BooleanValue NoGrouping
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Ungrouping.</para>
    /// <para>Represents the following attribute in the schema: noUngrp </para>
    /// </summary>
    [SchemaAttr(0, "noUngrp")]
    public BooleanValue NoUngrouping
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Selection.</para>
    /// <para>Represents the following attribute in the schema: noSelect </para>
    /// </summary>
    [SchemaAttr(0, "noSelect")]
    public BooleanValue NoSelection
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Rotation.</para>
    /// <para>Represents the following attribute in the schema: noRot </para>
    /// </summary>
    [SchemaAttr(0, "noRot")]
    public BooleanValue NoRotation
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Aspect Ratio Change.</para>
    /// <para>Represents the following attribute in the schema: noChangeAspect </para>
    /// </summary>
    [SchemaAttr(0, "noChangeAspect")]
    public BooleanValue NoChangeAspect
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Moving Shape.</para>
    /// <para>Represents the following attribute in the schema: noMove </para>
    /// </summary>
    [SchemaAttr(0, "noMove")]
    public BooleanValue NoMove
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Disallow Shape Resizing.</para>
    /// <para>Represents the following attribute in the schema: noResize </para>
    /// </summary>
    [SchemaAttr(0, "noResize")]
    public BooleanValue NoResize
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupShapeLocks class.
    /// </summary>
    public GroupShapeLocks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupShapeLocks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupShapeLocks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupShapeLocks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupShapeLocks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupShapeLocks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "noGrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noUngrp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noSelect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noRot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noChangeAspect" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noMove" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "noResize" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupShapeLocks>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NonVisualGroupDrawingShapePropsExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NonVisualGroupDrawingShapePropsExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NonVisualGroupDrawingShapePropsExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NonVisualGroupDrawingShapePropsExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10334;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtensionList class.
    /// </summary>
    public NonVisualGroupDrawingShapePropsExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NonVisualGroupDrawingShapePropsExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupDrawingShapePropsExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NonVisualGroupDrawingShapePropsExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NonVisualGroupDrawingShapePropsExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NonVisualGroupDrawingShapePropsExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new NonVisualGroupDrawingShapePropsExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NonVisualGroupDrawingShapePropsExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BlipExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>BlipExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(BlipExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlipExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10335;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BlipExtensionList class.
    /// </summary>
    public BlipExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BlipExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BlipExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new BlipExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlipExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BlipExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties &lt;a14:imgProps></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi &lt;a14:useLocalDpi></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty &lt;wp15:webVideoPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlipExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10336;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BlipExtension class.
    /// </summary>
    public BlipExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BlipExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BlipExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BlipExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BlipExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 48 == namespaceId && "imgProps" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.ImageProperties();
    
if( 48 == namespaceId && "useLocalDpi" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.UseLocalDpi();
    
if( 75 == namespaceId && "webVideoPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Drawing.WebVideoProperty();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlipExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ObjectDefaults Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:objectDefaults.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ShapeDefault &lt;a:spDef></description></item>
///<item><description>LineDefault &lt;a:lnDef></description></item>
///<item><description>TextDefault &lt;a:txDef></description></item>
///<item><description>ExtensionList &lt;a:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ShapeDefault))]
    [ChildElementInfo(typeof(LineDefault))]
    [ChildElementInfo(typeof(TextDefault))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ObjectDefaults : OpenXmlCompositeElement
{
    private const string tagName = "objectDefaults";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10337;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ObjectDefaults class.
    /// </summary>
    public ObjectDefaults():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ObjectDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ObjectDefaults(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ObjectDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ObjectDefaults(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ObjectDefaults class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ObjectDefaults(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "spDef" == name)
    return new ShapeDefault();
    
if( 10 == namespaceId && "lnDef" == name)
    return new LineDefault();
    
if( 10 == namespaceId && "txDef" == name)
    return new TextDefault();
    
if( 10 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "spDef","lnDef","txDef","extLst" };
    private static readonly byte[] eleNamespaceIds = { 10,10,10,10 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Shape Default.</para>
    /// <para> Represents the following element tag in the schema: a:spDef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ShapeDefault ShapeDefault
    {
        get 
        {
            return GetElement<ShapeDefault>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Line Default.</para>
    /// <para> Represents the following element tag in the schema: a:lnDef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public LineDefault LineDefault
    {
        get 
        {
            return GetElement<LineDefault>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Text Default.</para>
    /// <para> Represents the following element tag in the schema: a:txDef </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public TextDefault TextDefault
    {
        get 
        {
            return GetElement<TextDefault>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: a:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:a = http://schemas.openxmlformats.org/drawingml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ObjectDefaults>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ExtraColorSchemeList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extraClrSchemeLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtraColorScheme &lt;a:extraClrScheme></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtraColorScheme))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExtraColorSchemeList : OpenXmlCompositeElement
{
    private const string tagName = "extraClrSchemeLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10338;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorSchemeList class.
    /// </summary>
    public ExtraColorSchemeList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExtraColorSchemeList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtraColorSchemeList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorSchemeList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtraColorSchemeList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtraColorSchemeList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExtraColorSchemeList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "extraClrScheme" == name)
    return new ExtraColorScheme();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExtraColorSchemeList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CustomColorList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:custClrLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomColor &lt;a:custClr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomColorList : OpenXmlCompositeElement
{
    private const string tagName = "custClrLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10339;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomColorList class.
    /// </summary>
    public CustomColorList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomColorList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomColorList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomColorList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomColorList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomColorList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomColorList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "custClr" == name)
    return new CustomColor();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomColorList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OfficeStyleSheetExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OfficeStyleSheetExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OfficeStyleSheetExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OfficeStyleSheetExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10340;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtensionList class.
    /// </summary>
    public OfficeStyleSheetExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OfficeStyleSheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OfficeStyleSheetExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OfficeStyleSheetExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OfficeStyleSheetExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OfficeStyleSheetExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new OfficeStyleSheetExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OfficeStyleSheetExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RightToLeft Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:rtl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightToLeft : OpenXmlLeafElement
{
    private const string tagName = "rtl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10344;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public BooleanValue Val
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RightToLeft class.
    /// </summary>
    public RightToLeft():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightToLeft>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConnectorLockingExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConnectorLockingExtension &lt;a:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConnectorLockingExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectorLockingExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10345;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtensionList class.
    /// </summary>
    public ConnectorLockingExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectorLockingExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectorLockingExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectorLockingExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectorLockingExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectorLockingExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 10 == namespaceId && "ext" == name)
    return new ConnectorLockingExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectorLockingExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataModelExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock &lt;dsp:dataModelExt></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages &lt;dgm14:recolorImg></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataModelExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10346;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataModelExtension class.
    /// </summary>
    public DataModelExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataModelExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataModelExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataModelExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataModelExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataModelExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataModelExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 56 == namespaceId && "dataModelExt" == name)
    return new DocumentFormat.OpenXml.Office.Drawing.DataModelExtensionBlock();
    
if( 58 == namespaceId && "recolorImg" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Diagram.RecolorImages();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataModelExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PtExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is a:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties &lt;dgm14:cNvPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PtExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 10;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 10347;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PtExtension class.
    /// </summary>
    public PtExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PtExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PtExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PtExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PtExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PtExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PtExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 58 == namespaceId && "cNvPr" == name)
    return new DocumentFormat.OpenXml.Office2010.Drawing.Diagram.NonVisualDrawingProperties();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PtExtension>(deep);
    }

   
}
/// <summary>
/// Font Collection Index 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FontCollectionIndexValues
{  
	///<summary>
///Major Font.
///<para>When the item is serialized out as xml, its value is "major".</para>
///</summary>
[EnumString("major")]
Major,
///<summary>
///Minor Font.
///<para>When the item is serialized out as xml, its value is "minor".</para>
///</summary>
[EnumString("minor")]
Minor,
///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Theme Color Reference 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ColorSchemeIndexValues
{  
	///<summary>
///Dark 1.
///<para>When the item is serialized out as xml, its value is "dk1".</para>
///</summary>
[EnumString("dk1")]
Dark1,
///<summary>
///Light 1.
///<para>When the item is serialized out as xml, its value is "lt1".</para>
///</summary>
[EnumString("lt1")]
Light1,
///<summary>
///Dark 2.
///<para>When the item is serialized out as xml, its value is "dk2".</para>
///</summary>
[EnumString("dk2")]
Dark2,
///<summary>
///Light 2.
///<para>When the item is serialized out as xml, its value is "lt2".</para>
///</summary>
[EnumString("lt2")]
Light2,
///<summary>
///Accent 1.
///<para>When the item is serialized out as xml, its value is "accent1".</para>
///</summary>
[EnumString("accent1")]
Accent1,
///<summary>
///Accent 2.
///<para>When the item is serialized out as xml, its value is "accent2".</para>
///</summary>
[EnumString("accent2")]
Accent2,
///<summary>
///Accent 3.
///<para>When the item is serialized out as xml, its value is "accent3".</para>
///</summary>
[EnumString("accent3")]
Accent3,
///<summary>
///Accent 4.
///<para>When the item is serialized out as xml, its value is "accent4".</para>
///</summary>
[EnumString("accent4")]
Accent4,
///<summary>
///Accent 5.
///<para>When the item is serialized out as xml, its value is "accent5".</para>
///</summary>
[EnumString("accent5")]
Accent5,
///<summary>
///Accent 6.
///<para>When the item is serialized out as xml, its value is "accent6".</para>
///</summary>
[EnumString("accent6")]
Accent6,
///<summary>
///Hyperlink.
///<para>When the item is serialized out as xml, its value is "hlink".</para>
///</summary>
[EnumString("hlink")]
Hyperlink,
///<summary>
///Followed Hyperlink.
///<para>When the item is serialized out as xml, its value is "folHlink".</para>
///</summary>
[EnumString("folHlink")]
FollowedHyperlink,
 
}
/// <summary>
/// System Color Value 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SystemColorValues
{  
	///<summary>
///Scroll Bar System Color.
///<para>When the item is serialized out as xml, its value is "scrollBar".</para>
///</summary>
[EnumString("scrollBar")]
ScrollBar,
///<summary>
///Background System Color.
///<para>When the item is serialized out as xml, its value is "background".</para>
///</summary>
[EnumString("background")]
Background,
///<summary>
///Active Caption System Color.
///<para>When the item is serialized out as xml, its value is "activeCaption".</para>
///</summary>
[EnumString("activeCaption")]
ActiveCaption,
///<summary>
///Inactive Caption System Color.
///<para>When the item is serialized out as xml, its value is "inactiveCaption".</para>
///</summary>
[EnumString("inactiveCaption")]
InactiveCaption,
///<summary>
///Menu System Color.
///<para>When the item is serialized out as xml, its value is "menu".</para>
///</summary>
[EnumString("menu")]
Menu,
///<summary>
///Window System Color.
///<para>When the item is serialized out as xml, its value is "window".</para>
///</summary>
[EnumString("window")]
Window,
///<summary>
///Window Frame System Color.
///<para>When the item is serialized out as xml, its value is "windowFrame".</para>
///</summary>
[EnumString("windowFrame")]
WindowFrame,
///<summary>
///Menu Text System Color.
///<para>When the item is serialized out as xml, its value is "menuText".</para>
///</summary>
[EnumString("menuText")]
MenuText,
///<summary>
///Window Text System Color.
///<para>When the item is serialized out as xml, its value is "windowText".</para>
///</summary>
[EnumString("windowText")]
WindowText,
///<summary>
///Caption Text System Color.
///<para>When the item is serialized out as xml, its value is "captionText".</para>
///</summary>
[EnumString("captionText")]
CaptionText,
///<summary>
///Active Border System Color.
///<para>When the item is serialized out as xml, its value is "activeBorder".</para>
///</summary>
[EnumString("activeBorder")]
ActiveBorder,
///<summary>
///Inactive Border System Color.
///<para>When the item is serialized out as xml, its value is "inactiveBorder".</para>
///</summary>
[EnumString("inactiveBorder")]
InactiveBorder,
///<summary>
///Application Workspace System Color.
///<para>When the item is serialized out as xml, its value is "appWorkspace".</para>
///</summary>
[EnumString("appWorkspace")]
ApplicationWorkspace,
///<summary>
///Highlight System Color.
///<para>When the item is serialized out as xml, its value is "highlight".</para>
///</summary>
[EnumString("highlight")]
Highlight,
///<summary>
///Highlight Text System Color.
///<para>When the item is serialized out as xml, its value is "highlightText".</para>
///</summary>
[EnumString("highlightText")]
HighlightText,
///<summary>
///Button Face System Color.
///<para>When the item is serialized out as xml, its value is "btnFace".</para>
///</summary>
[EnumString("btnFace")]
ButtonFace,
///<summary>
///Button Shadow System Color.
///<para>When the item is serialized out as xml, its value is "btnShadow".</para>
///</summary>
[EnumString("btnShadow")]
ButtonShadow,
///<summary>
///Gray Text System Color.
///<para>When the item is serialized out as xml, its value is "grayText".</para>
///</summary>
[EnumString("grayText")]
GrayText,
///<summary>
///Button Text System Color.
///<para>When the item is serialized out as xml, its value is "btnText".</para>
///</summary>
[EnumString("btnText")]
ButtonText,
///<summary>
///Inactive Caption Text System Color.
///<para>When the item is serialized out as xml, its value is "inactiveCaptionText".</para>
///</summary>
[EnumString("inactiveCaptionText")]
InactiveCaptionText,
///<summary>
///Button Highlight System Color.
///<para>When the item is serialized out as xml, its value is "btnHighlight".</para>
///</summary>
[EnumString("btnHighlight")]
ButtonHighlight,
///<summary>
///3D Dark System Color.
///<para>When the item is serialized out as xml, its value is "3dDkShadow".</para>
///</summary>
[EnumString("3dDkShadow")]
ThreeDDarkShadow,
///<summary>
///3D Light System Color.
///<para>When the item is serialized out as xml, its value is "3dLight".</para>
///</summary>
[EnumString("3dLight")]
ThreeDLight,
///<summary>
///Info Text System Color.
///<para>When the item is serialized out as xml, its value is "infoText".</para>
///</summary>
[EnumString("infoText")]
InfoText,
///<summary>
///Info Back System Color.
///<para>When the item is serialized out as xml, its value is "infoBk".</para>
///</summary>
[EnumString("infoBk")]
InfoBack,
///<summary>
///Hot Light System Color.
///<para>When the item is serialized out as xml, its value is "hotLight".</para>
///</summary>
[EnumString("hotLight")]
HotLight,
///<summary>
///Gradient Active Caption System Color.
///<para>When the item is serialized out as xml, its value is "gradientActiveCaption".</para>
///</summary>
[EnumString("gradientActiveCaption")]
GradientActiveCaption,
///<summary>
///Gradient Inactive Caption System Color.
///<para>When the item is serialized out as xml, its value is "gradientInactiveCaption".</para>
///</summary>
[EnumString("gradientInactiveCaption")]
GradientInactiveCaption,
///<summary>
///Menu Highlight System Color.
///<para>When the item is serialized out as xml, its value is "menuHighlight".</para>
///</summary>
[EnumString("menuHighlight")]
MenuHighlight,
///<summary>
///Menu Bar System Color.
///<para>When the item is serialized out as xml, its value is "menuBar".</para>
///</summary>
[EnumString("menuBar")]
MenuBar,
 
}
/// <summary>
/// Scheme Color 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SchemeColorValues
{  
	///<summary>
///Background Color 1.
///<para>When the item is serialized out as xml, its value is "bg1".</para>
///</summary>
[EnumString("bg1")]
Background1,
///<summary>
///Text Color 1.
///<para>When the item is serialized out as xml, its value is "tx1".</para>
///</summary>
[EnumString("tx1")]
Text1,
///<summary>
///Background Color 2.
///<para>When the item is serialized out as xml, its value is "bg2".</para>
///</summary>
[EnumString("bg2")]
Background2,
///<summary>
///Text Color 2.
///<para>When the item is serialized out as xml, its value is "tx2".</para>
///</summary>
[EnumString("tx2")]
Text2,
///<summary>
///Accent Color 1.
///<para>When the item is serialized out as xml, its value is "accent1".</para>
///</summary>
[EnumString("accent1")]
Accent1,
///<summary>
///Accent Color 2.
///<para>When the item is serialized out as xml, its value is "accent2".</para>
///</summary>
[EnumString("accent2")]
Accent2,
///<summary>
///Accent Color 3.
///<para>When the item is serialized out as xml, its value is "accent3".</para>
///</summary>
[EnumString("accent3")]
Accent3,
///<summary>
///Accent Color 4.
///<para>When the item is serialized out as xml, its value is "accent4".</para>
///</summary>
[EnumString("accent4")]
Accent4,
///<summary>
///Accent Color 5.
///<para>When the item is serialized out as xml, its value is "accent5".</para>
///</summary>
[EnumString("accent5")]
Accent5,
///<summary>
///Accent Color 6.
///<para>When the item is serialized out as xml, its value is "accent6".</para>
///</summary>
[EnumString("accent6")]
Accent6,
///<summary>
///Hyperlink Color.
///<para>When the item is serialized out as xml, its value is "hlink".</para>
///</summary>
[EnumString("hlink")]
Hyperlink,
///<summary>
///Followed Hyperlink Color.
///<para>When the item is serialized out as xml, its value is "folHlink".</para>
///</summary>
[EnumString("folHlink")]
FollowedHyperlink,
///<summary>
///Style Color.
///<para>When the item is serialized out as xml, its value is "phClr".</para>
///</summary>
[EnumString("phClr")]
PhColor,
///<summary>
///Dark Color 1.
///<para>When the item is serialized out as xml, its value is "dk1".</para>
///</summary>
[EnumString("dk1")]
Dark1,
///<summary>
///Light Color 1.
///<para>When the item is serialized out as xml, its value is "lt1".</para>
///</summary>
[EnumString("lt1")]
Light1,
///<summary>
///Dark Color 2.
///<para>When the item is serialized out as xml, its value is "dk2".</para>
///</summary>
[EnumString("dk2")]
Dark2,
///<summary>
///Light Color 2.
///<para>When the item is serialized out as xml, its value is "lt2".</para>
///</summary>
[EnumString("lt2")]
Light2,
 
}
/// <summary>
/// Rectangle Alignments 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RectangleAlignmentValues
{  
	///<summary>
///Rectangle Alignment Enum ( Top Left ).
///<para>When the item is serialized out as xml, its value is "tl".</para>
///</summary>
[EnumString("tl")]
TopLeft,
///<summary>
///Rectangle Alignment Enum ( Top ).
///<para>When the item is serialized out as xml, its value is "t".</para>
///</summary>
[EnumString("t")]
Top,
///<summary>
///Rectangle Alignment Enum ( Top Right ).
///<para>When the item is serialized out as xml, its value is "tr".</para>
///</summary>
[EnumString("tr")]
TopRight,
///<summary>
///Rectangle Alignment Enum ( Left ).
///<para>When the item is serialized out as xml, its value is "l".</para>
///</summary>
[EnumString("l")]
Left,
///<summary>
///Rectangle Alignment Enum ( Center ).
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Rectangle Alignment Enum ( Right ).
///<para>When the item is serialized out as xml, its value is "r".</para>
///</summary>
[EnumString("r")]
Right,
///<summary>
///Rectangle Alignment Enum ( Bottom Left ).
///<para>When the item is serialized out as xml, its value is "bl".</para>
///</summary>
[EnumString("bl")]
BottomLeft,
///<summary>
///Rectangle Alignment Enum ( Bottom ).
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Bottom,
///<summary>
///Rectangle Alignment Enum ( Bottom Right ).
///<para>When the item is serialized out as xml, its value is "br".</para>
///</summary>
[EnumString("br")]
BottomRight,
 
}
/// <summary>
/// Black and White Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BlackWhiteModeValues
{  
	///<summary>
///Color.
///<para>When the item is serialized out as xml, its value is "clr".</para>
///</summary>
[EnumString("clr")]
Color,
///<summary>
///Automatic.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
///<summary>
///Gray.
///<para>When the item is serialized out as xml, its value is "gray".</para>
///</summary>
[EnumString("gray")]
Gray,
///<summary>
///Light Gray.
///<para>When the item is serialized out as xml, its value is "ltGray".</para>
///</summary>
[EnumString("ltGray")]
LightGray,
///<summary>
///Inverse Gray.
///<para>When the item is serialized out as xml, its value is "invGray".</para>
///</summary>
[EnumString("invGray")]
InvGray,
///<summary>
///Gray and White.
///<para>When the item is serialized out as xml, its value is "grayWhite".</para>
///</summary>
[EnumString("grayWhite")]
GrayWhite,
///<summary>
///Black and Gray.
///<para>When the item is serialized out as xml, its value is "blackGray".</para>
///</summary>
[EnumString("blackGray")]
BlackGray,
///<summary>
///Black and White.
///<para>When the item is serialized out as xml, its value is "blackWhite".</para>
///</summary>
[EnumString("blackWhite")]
BlackWhite,
///<summary>
///Black.
///<para>When the item is serialized out as xml, its value is "black".</para>
///</summary>
[EnumString("black")]
Black,
///<summary>
///White.
///<para>When the item is serialized out as xml, its value is "white".</para>
///</summary>
[EnumString("white")]
White,
///<summary>
///Hidden.
///<para>When the item is serialized out as xml, its value is "hidden".</para>
///</summary>
[EnumString("hidden")]
Hidden,
 
}
/// <summary>
/// Chart Animation Build Step 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ChartBuildStepValues
{  
	///<summary>
///Category.
///<para>When the item is serialized out as xml, its value is "category".</para>
///</summary>
[EnumString("category")]
Category,
///<summary>
///Category Points.
///<para>When the item is serialized out as xml, its value is "ptInCategory".</para>
///</summary>
[EnumString("ptInCategory")]
CategoryPoints,
///<summary>
///Series.
///<para>When the item is serialized out as xml, its value is "series".</para>
///</summary>
[EnumString("series")]
Series,
///<summary>
///Series Points.
///<para>When the item is serialized out as xml, its value is "ptInSeries".</para>
///</summary>
[EnumString("ptInSeries")]
SeriesPoints,
///<summary>
///All Points.
///<para>When the item is serialized out as xml, its value is "allPts".</para>
///</summary>
[EnumString("allPts")]
AllPoints,
///<summary>
///Grid and Legend.
///<para>When the item is serialized out as xml, its value is "gridLegend".</para>
///</summary>
[EnumString("gridLegend")]
GridLegend,
 
}
/// <summary>
/// Diagram Animation Build Steps 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DiagramBuildStepValues
{  
	///<summary>
///Shape.
///<para>When the item is serialized out as xml, its value is "sp".</para>
///</summary>
[EnumString("sp")]
Shape,
///<summary>
///Background.
///<para>When the item is serialized out as xml, its value is "bg".</para>
///</summary>
[EnumString("bg")]
Background,
 
}
/// <summary>
/// Animation Build Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AnimationBuildValues
{  
	///<summary>
///Animate At Once.
///<para>When the item is serialized out as xml, its value is "allAtOnce".</para>
///</summary>
[EnumString("allAtOnce")]
AllAtOnce,
 
}
/// <summary>
/// Diagram only Animation Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AnimationDiagramOnlyBuildValues
{  
	///<summary>
///Elements One-by-One.
///<para>When the item is serialized out as xml, its value is "one".</para>
///</summary>
[EnumString("one")]
One,
///<summary>
///Level One-by-One.
///<para>When the item is serialized out as xml, its value is "lvlOne".</para>
///</summary>
[EnumString("lvlOne")]
LevelOne,
///<summary>
///Each Level at Once.
///<para>When the item is serialized out as xml, its value is "lvlAtOnce".</para>
///</summary>
[EnumString("lvlAtOnce")]
LevelAtOnce,
 
}
/// <summary>
/// Chart only Animation Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AnimationChartOnlyBuildValues
{  
	///<summary>
///Series.
///<para>When the item is serialized out as xml, its value is "series".</para>
///</summary>
[EnumString("series")]
Series,
///<summary>
///Catefory.
///<para>When the item is serialized out as xml, its value is "category".</para>
///</summary>
[EnumString("category")]
Category,
///<summary>
///Series Element.
///<para>When the item is serialized out as xml, its value is "seriesEl".</para>
///</summary>
[EnumString("seriesEl")]
SeriesElement,
///<summary>
///Category Element.
///<para>When the item is serialized out as xml, its value is "categoryEl".</para>
///</summary>
[EnumString("categoryEl")]
CategoryElement,
 
}
/// <summary>
/// Preset Camera Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetCameraValues
{  
	///<summary>
///Legacy Oblique Top Left.
///<para>When the item is serialized out as xml, its value is "legacyObliqueTopLeft".</para>
///</summary>
[EnumString("legacyObliqueTopLeft")]
LegacyObliqueTopLeft,
///<summary>
///Legacy Oblique Top.
///<para>When the item is serialized out as xml, its value is "legacyObliqueTop".</para>
///</summary>
[EnumString("legacyObliqueTop")]
LegacyObliqueTop,
///<summary>
///Legacy Oblique Top Right.
///<para>When the item is serialized out as xml, its value is "legacyObliqueTopRight".</para>
///</summary>
[EnumString("legacyObliqueTopRight")]
LegacyObliqueTopRight,
///<summary>
///Legacy Oblique Left.
///<para>When the item is serialized out as xml, its value is "legacyObliqueLeft".</para>
///</summary>
[EnumString("legacyObliqueLeft")]
LegacyObliqueLeft,
///<summary>
///Legacy Oblique Front.
///<para>When the item is serialized out as xml, its value is "legacyObliqueFront".</para>
///</summary>
[EnumString("legacyObliqueFront")]
LegacyObliqueFront,
///<summary>
///Legacy Oblique Right.
///<para>When the item is serialized out as xml, its value is "legacyObliqueRight".</para>
///</summary>
[EnumString("legacyObliqueRight")]
LegacyObliqueRight,
///<summary>
///Legacy Oblique Bottom Left.
///<para>When the item is serialized out as xml, its value is "legacyObliqueBottomLeft".</para>
///</summary>
[EnumString("legacyObliqueBottomLeft")]
LegacyObliqueBottomLeft,
///<summary>
///Legacy Oblique Bottom.
///<para>When the item is serialized out as xml, its value is "legacyObliqueBottom".</para>
///</summary>
[EnumString("legacyObliqueBottom")]
LegacyObliqueBottom,
///<summary>
///Legacy Oblique Bottom Right.
///<para>When the item is serialized out as xml, its value is "legacyObliqueBottomRight".</para>
///</summary>
[EnumString("legacyObliqueBottomRight")]
LegacyObliqueBottomRight,
///<summary>
///Legacy Perspective Top Left.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveTopLeft".</para>
///</summary>
[EnumString("legacyPerspectiveTopLeft")]
LegacyPerspectiveTopLeft,
///<summary>
///Legacy Perspective Top.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveTop".</para>
///</summary>
[EnumString("legacyPerspectiveTop")]
LegacyPerspectiveTop,
///<summary>
///Legacy Perspective Top Right.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveTopRight".</para>
///</summary>
[EnumString("legacyPerspectiveTopRight")]
LegacyPerspectiveTopRight,
///<summary>
///Legacy Perspective Left.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveLeft".</para>
///</summary>
[EnumString("legacyPerspectiveLeft")]
LegacyPerspectiveLeft,
///<summary>
///Legacy Perspective Front.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveFront".</para>
///</summary>
[EnumString("legacyPerspectiveFront")]
LegacyPerspectiveFront,
///<summary>
///Legacy Perspective Right.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveRight".</para>
///</summary>
[EnumString("legacyPerspectiveRight")]
LegacyPerspectiveRight,
///<summary>
///Legacy Perspective Bottom Left.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveBottomLeft".</para>
///</summary>
[EnumString("legacyPerspectiveBottomLeft")]
LegacyPerspectiveBottomLeft,
///<summary>
///Legacy Perspective Bottom.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveBottom".</para>
///</summary>
[EnumString("legacyPerspectiveBottom")]
LegacyPerspectiveBottom,
///<summary>
///Legacy Perspective Bottom Right.
///<para>When the item is serialized out as xml, its value is "legacyPerspectiveBottomRight".</para>
///</summary>
[EnumString("legacyPerspectiveBottomRight")]
LegacyPerspectiveBottomRight,
///<summary>
///Orthographic Front.
///<para>When the item is serialized out as xml, its value is "orthographicFront".</para>
///</summary>
[EnumString("orthographicFront")]
OrthographicFront,
///<summary>
///Isometric Top Up.
///<para>When the item is serialized out as xml, its value is "isometricTopUp".</para>
///</summary>
[EnumString("isometricTopUp")]
IsometricTopUp,
///<summary>
///Isometric Top Down.
///<para>When the item is serialized out as xml, its value is "isometricTopDown".</para>
///</summary>
[EnumString("isometricTopDown")]
IsometricTopDown,
///<summary>
///Isometric Bottom Up.
///<para>When the item is serialized out as xml, its value is "isometricBottomUp".</para>
///</summary>
[EnumString("isometricBottomUp")]
IsometricBottomUp,
///<summary>
///Isometric Bottom Down.
///<para>When the item is serialized out as xml, its value is "isometricBottomDown".</para>
///</summary>
[EnumString("isometricBottomDown")]
IsometricBottomDown,
///<summary>
///Isometric Left Up.
///<para>When the item is serialized out as xml, its value is "isometricLeftUp".</para>
///</summary>
[EnumString("isometricLeftUp")]
IsometricLeftUp,
///<summary>
///Isometric Left Down.
///<para>When the item is serialized out as xml, its value is "isometricLeftDown".</para>
///</summary>
[EnumString("isometricLeftDown")]
IsometricLeftDown,
///<summary>
///Isometric Right Up.
///<para>When the item is serialized out as xml, its value is "isometricRightUp".</para>
///</summary>
[EnumString("isometricRightUp")]
IsometricRightUp,
///<summary>
///Isometric Right Down.
///<para>When the item is serialized out as xml, its value is "isometricRightDown".</para>
///</summary>
[EnumString("isometricRightDown")]
IsometricRightDown,
///<summary>
///Isometric Off Axis 1 Left.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis1Left".</para>
///</summary>
[EnumString("isometricOffAxis1Left")]
IsometricOffAxis1Left,
///<summary>
///Isometric Off Axis 1 Right.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis1Right".</para>
///</summary>
[EnumString("isometricOffAxis1Right")]
IsometricOffAxis1Right,
///<summary>
///Isometric Off Axis 1 Top.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis1Top".</para>
///</summary>
[EnumString("isometricOffAxis1Top")]
IsometricOffAxis1Top,
///<summary>
///Isometric Off Axis 2 Left.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis2Left".</para>
///</summary>
[EnumString("isometricOffAxis2Left")]
IsometricOffAxis2Left,
///<summary>
///Isometric Off Axis 2 Right.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis2Right".</para>
///</summary>
[EnumString("isometricOffAxis2Right")]
IsometricOffAxis2Right,
///<summary>
///Isometric Off Axis 2 Top.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis2Top".</para>
///</summary>
[EnumString("isometricOffAxis2Top")]
IsometricOffAxis2Top,
///<summary>
///Isometric Off Axis 3 Left.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis3Left".</para>
///</summary>
[EnumString("isometricOffAxis3Left")]
IsometricOffAxis3Left,
///<summary>
///Isometric Off Axis 3 Right.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis3Right".</para>
///</summary>
[EnumString("isometricOffAxis3Right")]
IsometricOffAxis3Right,
///<summary>
///Isometric Off Axis 3 Bottom.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis3Bottom".</para>
///</summary>
[EnumString("isometricOffAxis3Bottom")]
IsometricOffAxis3Bottom,
///<summary>
///Isometric Off Axis 4 Left.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis4Left".</para>
///</summary>
[EnumString("isometricOffAxis4Left")]
IsometricOffAxis4Left,
///<summary>
///Isometric Off Axis 4 Right.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis4Right".</para>
///</summary>
[EnumString("isometricOffAxis4Right")]
IsometricOffAxis4Right,
///<summary>
///Isometric Off Axis 4 Bottom.
///<para>When the item is serialized out as xml, its value is "isometricOffAxis4Bottom".</para>
///</summary>
[EnumString("isometricOffAxis4Bottom")]
IsometricOffAxis4Bottom,
///<summary>
///Oblique Top Left.
///<para>When the item is serialized out as xml, its value is "obliqueTopLeft".</para>
///</summary>
[EnumString("obliqueTopLeft")]
ObliqueTopLeft,
///<summary>
///Oblique Top.
///<para>When the item is serialized out as xml, its value is "obliqueTop".</para>
///</summary>
[EnumString("obliqueTop")]
ObliqueTop,
///<summary>
///Oblique Top Right.
///<para>When the item is serialized out as xml, its value is "obliqueTopRight".</para>
///</summary>
[EnumString("obliqueTopRight")]
ObliqueTopRight,
///<summary>
///Oblique Left.
///<para>When the item is serialized out as xml, its value is "obliqueLeft".</para>
///</summary>
[EnumString("obliqueLeft")]
ObliqueLeft,
///<summary>
///Oblique Right.
///<para>When the item is serialized out as xml, its value is "obliqueRight".</para>
///</summary>
[EnumString("obliqueRight")]
ObliqueRight,
///<summary>
///Oblique Bottom Left.
///<para>When the item is serialized out as xml, its value is "obliqueBottomLeft".</para>
///</summary>
[EnumString("obliqueBottomLeft")]
ObliqueBottomLeft,
///<summary>
///Oblique Bottom.
///<para>When the item is serialized out as xml, its value is "obliqueBottom".</para>
///</summary>
[EnumString("obliqueBottom")]
ObliqueBottom,
///<summary>
///Oblique Bottom Right.
///<para>When the item is serialized out as xml, its value is "obliqueBottomRight".</para>
///</summary>
[EnumString("obliqueBottomRight")]
ObliqueBottomRight,
///<summary>
///Perspective Front.
///<para>When the item is serialized out as xml, its value is "perspectiveFront".</para>
///</summary>
[EnumString("perspectiveFront")]
PerspectiveFront,
///<summary>
///Perspective Left.
///<para>When the item is serialized out as xml, its value is "perspectiveLeft".</para>
///</summary>
[EnumString("perspectiveLeft")]
PerspectiveLeft,
///<summary>
///Perspective Right.
///<para>When the item is serialized out as xml, its value is "perspectiveRight".</para>
///</summary>
[EnumString("perspectiveRight")]
PerspectiveRight,
///<summary>
///Orthographic Above.
///<para>When the item is serialized out as xml, its value is "perspectiveAbove".</para>
///</summary>
[EnumString("perspectiveAbove")]
PerspectiveAbove,
///<summary>
///Perspective Below.
///<para>When the item is serialized out as xml, its value is "perspectiveBelow".</para>
///</summary>
[EnumString("perspectiveBelow")]
PerspectiveBelow,
///<summary>
///Perspective Above Left Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveAboveLeftFacing".</para>
///</summary>
[EnumString("perspectiveAboveLeftFacing")]
PerspectiveAboveLeftFacing,
///<summary>
///Perspective Above Right Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveAboveRightFacing".</para>
///</summary>
[EnumString("perspectiveAboveRightFacing")]
PerspectiveAboveRightFacing,
///<summary>
///Perspective Contrasting Left Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveContrastingLeftFacing".</para>
///</summary>
[EnumString("perspectiveContrastingLeftFacing")]
PerspectiveContrastingLeftFacing,
///<summary>
///Perspective Contrasting Right Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveContrastingRightFacing".</para>
///</summary>
[EnumString("perspectiveContrastingRightFacing")]
PerspectiveContrastingRightFacing,
///<summary>
///Perspective Heroic Left Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveHeroicLeftFacing".</para>
///</summary>
[EnumString("perspectiveHeroicLeftFacing")]
PerspectiveHeroicLeftFacing,
///<summary>
///Perspective Heroic Right Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveHeroicRightFacing".</para>
///</summary>
[EnumString("perspectiveHeroicRightFacing")]
PerspectiveHeroicRightFacing,
///<summary>
///Perspective Heroic Extreme Left Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveHeroicExtremeLeftFacing".</para>
///</summary>
[EnumString("perspectiveHeroicExtremeLeftFacing")]
PerspectiveHeroicExtremeLeftFacing,
///<summary>
///Perspective Heroic Extreme Right Facing.
///<para>When the item is serialized out as xml, its value is "perspectiveHeroicExtremeRightFacing".</para>
///</summary>
[EnumString("perspectiveHeroicExtremeRightFacing")]
PerspectiveHeroicExtremeRightFacing,
///<summary>
///Perspective Relaxed.
///<para>When the item is serialized out as xml, its value is "perspectiveRelaxed".</para>
///</summary>
[EnumString("perspectiveRelaxed")]
PerspectiveRelaxed,
///<summary>
///Perspective Relaxed Moderately.
///<para>When the item is serialized out as xml, its value is "perspectiveRelaxedModerately".</para>
///</summary>
[EnumString("perspectiveRelaxedModerately")]
PerspectiveRelaxedModerately,
 
}
/// <summary>
/// Light Rig Direction 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LightRigDirectionValues
{  
	///<summary>
///Top Left.
///<para>When the item is serialized out as xml, its value is "tl".</para>
///</summary>
[EnumString("tl")]
TopLeft,
///<summary>
///Top.
///<para>When the item is serialized out as xml, its value is "t".</para>
///</summary>
[EnumString("t")]
Top,
///<summary>
///Top Right.
///<para>When the item is serialized out as xml, its value is "tr".</para>
///</summary>
[EnumString("tr")]
TopRight,
///<summary>
///Left.
///<para>When the item is serialized out as xml, its value is "l".</para>
///</summary>
[EnumString("l")]
Left,
///<summary>
///Right.
///<para>When the item is serialized out as xml, its value is "r".</para>
///</summary>
[EnumString("r")]
Right,
///<summary>
///Bottom Left.
///<para>When the item is serialized out as xml, its value is "bl".</para>
///</summary>
[EnumString("bl")]
BottomLeft,
///<summary>
///Bottom.
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Bottom,
///<summary>
///Bottom Right.
///<para>When the item is serialized out as xml, its value is "br".</para>
///</summary>
[EnumString("br")]
BottomRight,
 
}
/// <summary>
/// Light Rig Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LightRigValues
{  
	///<summary>
///Legacy Flat 1.
///<para>When the item is serialized out as xml, its value is "legacyFlat1".</para>
///</summary>
[EnumString("legacyFlat1")]
LegacyFlat1,
///<summary>
///Legacy Flat 2.
///<para>When the item is serialized out as xml, its value is "legacyFlat2".</para>
///</summary>
[EnumString("legacyFlat2")]
LegacyFlat2,
///<summary>
///Legacy Flat 3.
///<para>When the item is serialized out as xml, its value is "legacyFlat3".</para>
///</summary>
[EnumString("legacyFlat3")]
LegacyFlat3,
///<summary>
///Legacy Flat 4.
///<para>When the item is serialized out as xml, its value is "legacyFlat4".</para>
///</summary>
[EnumString("legacyFlat4")]
LegacyFlat4,
///<summary>
///Legacy Normal 1.
///<para>When the item is serialized out as xml, its value is "legacyNormal1".</para>
///</summary>
[EnumString("legacyNormal1")]
LegacyNormal1,
///<summary>
///Legacy Normal 2.
///<para>When the item is serialized out as xml, its value is "legacyNormal2".</para>
///</summary>
[EnumString("legacyNormal2")]
LegacyNormal2,
///<summary>
///Legacy Normal 3.
///<para>When the item is serialized out as xml, its value is "legacyNormal3".</para>
///</summary>
[EnumString("legacyNormal3")]
LegacyNormal3,
///<summary>
///Legacy Normal 4.
///<para>When the item is serialized out as xml, its value is "legacyNormal4".</para>
///</summary>
[EnumString("legacyNormal4")]
LegacyNormal4,
///<summary>
///Legacy Harsh 1.
///<para>When the item is serialized out as xml, its value is "legacyHarsh1".</para>
///</summary>
[EnumString("legacyHarsh1")]
LegacyHarsh1,
///<summary>
///Legacy Harsh 2.
///<para>When the item is serialized out as xml, its value is "legacyHarsh2".</para>
///</summary>
[EnumString("legacyHarsh2")]
LegacyHarsh2,
///<summary>
///Legacy Harsh 3.
///<para>When the item is serialized out as xml, its value is "legacyHarsh3".</para>
///</summary>
[EnumString("legacyHarsh3")]
LegacyHarsh3,
///<summary>
///Legacy Harsh 4.
///<para>When the item is serialized out as xml, its value is "legacyHarsh4".</para>
///</summary>
[EnumString("legacyHarsh4")]
LegacyHarsh4,
///<summary>
///Three Point.
///<para>When the item is serialized out as xml, its value is "threePt".</para>
///</summary>
[EnumString("threePt")]
ThreePoints,
///<summary>
///Light Rig Enum ( Balanced ).
///<para>When the item is serialized out as xml, its value is "balanced".</para>
///</summary>
[EnumString("balanced")]
Balanced,
///<summary>
///Soft.
///<para>When the item is serialized out as xml, its value is "soft".</para>
///</summary>
[EnumString("soft")]
Soft,
///<summary>
///Harsh.
///<para>When the item is serialized out as xml, its value is "harsh".</para>
///</summary>
[EnumString("harsh")]
Harsh,
///<summary>
///Flood.
///<para>When the item is serialized out as xml, its value is "flood".</para>
///</summary>
[EnumString("flood")]
Flood,
///<summary>
///Contrasting.
///<para>When the item is serialized out as xml, its value is "contrasting".</para>
///</summary>
[EnumString("contrasting")]
Contrasting,
///<summary>
///Morning.
///<para>When the item is serialized out as xml, its value is "morning".</para>
///</summary>
[EnumString("morning")]
Morning,
///<summary>
///Sunrise.
///<para>When the item is serialized out as xml, its value is "sunrise".</para>
///</summary>
[EnumString("sunrise")]
Sunrise,
///<summary>
///Sunset.
///<para>When the item is serialized out as xml, its value is "sunset".</para>
///</summary>
[EnumString("sunset")]
Sunset,
///<summary>
///Chilly.
///<para>When the item is serialized out as xml, its value is "chilly".</para>
///</summary>
[EnumString("chilly")]
Chilly,
///<summary>
///Freezing.
///<para>When the item is serialized out as xml, its value is "freezing".</para>
///</summary>
[EnumString("freezing")]
Freezing,
///<summary>
///Flat.
///<para>When the item is serialized out as xml, its value is "flat".</para>
///</summary>
[EnumString("flat")]
Flat,
///<summary>
///Two Point.
///<para>When the item is serialized out as xml, its value is "twoPt".</para>
///</summary>
[EnumString("twoPt")]
TwoPoints,
///<summary>
///Glow.
///<para>When the item is serialized out as xml, its value is "glow".</para>
///</summary>
[EnumString("glow")]
Glow,
///<summary>
///Bright Room.
///<para>When the item is serialized out as xml, its value is "brightRoom".</para>
///</summary>
[EnumString("brightRoom")]
BrightRoom,
 
}
/// <summary>
/// Bevel Presets 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BevelPresetValues
{  
	///<summary>
///Relaxed Inset.
///<para>When the item is serialized out as xml, its value is "relaxedInset".</para>
///</summary>
[EnumString("relaxedInset")]
RelaxedInset,
///<summary>
///Circle.
///<para>When the item is serialized out as xml, its value is "circle".</para>
///</summary>
[EnumString("circle")]
Circle,
///<summary>
///Slope.
///<para>When the item is serialized out as xml, its value is "slope".</para>
///</summary>
[EnumString("slope")]
Slope,
///<summary>
///Cross.
///<para>When the item is serialized out as xml, its value is "cross".</para>
///</summary>
[EnumString("cross")]
Cross,
///<summary>
///Angle.
///<para>When the item is serialized out as xml, its value is "angle".</para>
///</summary>
[EnumString("angle")]
Angle,
///<summary>
///Soft Round.
///<para>When the item is serialized out as xml, its value is "softRound".</para>
///</summary>
[EnumString("softRound")]
SoftRound,
///<summary>
///Convex.
///<para>When the item is serialized out as xml, its value is "convex".</para>
///</summary>
[EnumString("convex")]
Convex,
///<summary>
///Cool Slant.
///<para>When the item is serialized out as xml, its value is "coolSlant".</para>
///</summary>
[EnumString("coolSlant")]
CoolSlant,
///<summary>
///Divot.
///<para>When the item is serialized out as xml, its value is "divot".</para>
///</summary>
[EnumString("divot")]
Divot,
///<summary>
///Riblet.
///<para>When the item is serialized out as xml, its value is "riblet".</para>
///</summary>
[EnumString("riblet")]
Riblet,
///<summary>
///Hard Edge.
///<para>When the item is serialized out as xml, its value is "hardEdge".</para>
///</summary>
[EnumString("hardEdge")]
HardEdge,
///<summary>
///Art Deco.
///<para>When the item is serialized out as xml, its value is "artDeco".</para>
///</summary>
[EnumString("artDeco")]
ArtDeco,
 
}
/// <summary>
/// Preset Material Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetMaterialTypeValues
{  
	///<summary>
///Legacy Matte.
///<para>When the item is serialized out as xml, its value is "legacyMatte".</para>
///</summary>
[EnumString("legacyMatte")]
LegacyMatte,
///<summary>
///Legacy Plastic.
///<para>When the item is serialized out as xml, its value is "legacyPlastic".</para>
///</summary>
[EnumString("legacyPlastic")]
LegacyPlastic,
///<summary>
///Legacy Metal.
///<para>When the item is serialized out as xml, its value is "legacyMetal".</para>
///</summary>
[EnumString("legacyMetal")]
LegacyMetal,
///<summary>
///Legacy Wireframe.
///<para>When the item is serialized out as xml, its value is "legacyWireframe".</para>
///</summary>
[EnumString("legacyWireframe")]
LegacyWireframe,
///<summary>
///Matte.
///<para>When the item is serialized out as xml, its value is "matte".</para>
///</summary>
[EnumString("matte")]
Matte,
///<summary>
///Plastic.
///<para>When the item is serialized out as xml, its value is "plastic".</para>
///</summary>
[EnumString("plastic")]
Plastic,
///<summary>
///Metal.
///<para>When the item is serialized out as xml, its value is "metal".</para>
///</summary>
[EnumString("metal")]
Metal,
///<summary>
///Warm Matte.
///<para>When the item is serialized out as xml, its value is "warmMatte".</para>
///</summary>
[EnumString("warmMatte")]
WarmMatte,
///<summary>
///Translucent Powder.
///<para>When the item is serialized out as xml, its value is "translucentPowder".</para>
///</summary>
[EnumString("translucentPowder")]
TranslucentPowder,
///<summary>
///Powder.
///<para>When the item is serialized out as xml, its value is "powder".</para>
///</summary>
[EnumString("powder")]
Powder,
///<summary>
///Dark Edge.
///<para>When the item is serialized out as xml, its value is "dkEdge".</para>
///</summary>
[EnumString("dkEdge")]
DarkEdge,
///<summary>
///Soft Edge.
///<para>When the item is serialized out as xml, its value is "softEdge".</para>
///</summary>
[EnumString("softEdge")]
SoftEdge,
///<summary>
///Clear.
///<para>When the item is serialized out as xml, its value is "clear".</para>
///</summary>
[EnumString("clear")]
Clear,
///<summary>
///Flat.
///<para>When the item is serialized out as xml, its value is "flat".</para>
///</summary>
[EnumString("flat")]
Flat,
///<summary>
///Soft Metal.
///<para>When the item is serialized out as xml, its value is "softmetal".</para>
///</summary>
[EnumString("softmetal")]
SoftMetal,
 
}
/// <summary>
/// Preset Shadow Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetShadowValues
{  
	///<summary>
///Top Left Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw1".</para>
///</summary>
[EnumString("shdw1")]
TopLeftDropShadow,
///<summary>
///Top Right Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw2".</para>
///</summary>
[EnumString("shdw2")]
TopRightDropShadow,
///<summary>
///Back Left Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw3".</para>
///</summary>
[EnumString("shdw3")]
BackLeftPerspectiveShadow,
///<summary>
///Back Right Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw4".</para>
///</summary>
[EnumString("shdw4")]
BackRightPerspectiveShadow,
///<summary>
///Bottom Left Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw5".</para>
///</summary>
[EnumString("shdw5")]
BottomLeftDropShadow,
///<summary>
///Bottom Right Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw6".</para>
///</summary>
[EnumString("shdw6")]
BottomRightDropShadow,
///<summary>
///Front Left Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw7".</para>
///</summary>
[EnumString("shdw7")]
FrontLeftPerspectiveShadow,
///<summary>
///Front Right Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw8".</para>
///</summary>
[EnumString("shdw8")]
FrontRightPerspectiveShadow,
///<summary>
///Top Left Small Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw9".</para>
///</summary>
[EnumString("shdw9")]
TopLeftSmallDropShadow,
///<summary>
///Top Left Large Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw10".</para>
///</summary>
[EnumString("shdw10")]
TopLeftLargeDropShadow,
///<summary>
///Back Left Long Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw11".</para>
///</summary>
[EnumString("shdw11")]
BackLeftLongPerspectiveShadow,
///<summary>
///Back Right Long Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw12".</para>
///</summary>
[EnumString("shdw12")]
BackRightLongPerspectiveShadow,
///<summary>
///Top Left Double Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw13".</para>
///</summary>
[EnumString("shdw13")]
TopLeftDoubleDropShadow,
///<summary>
///Bottom Right Small Drop Shadow.
///<para>When the item is serialized out as xml, its value is "shdw14".</para>
///</summary>
[EnumString("shdw14")]
BottomRightSmallDropShadow,
///<summary>
///Front Left Long Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw15".</para>
///</summary>
[EnumString("shdw15")]
FrontLeftLongPerspectiveShadow,
///<summary>
///Front Right LongPerspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw16".</para>
///</summary>
[EnumString("shdw16")]
FrontRightLongPerspectiveShadow,
///<summary>
///3D Outer Box Shadow.
///<para>When the item is serialized out as xml, its value is "shdw17".</para>
///</summary>
[EnumString("shdw17")]
ThreeDimensionalOuterBoxShadow,
///<summary>
///3D Inner Box Shadow.
///<para>When the item is serialized out as xml, its value is "shdw18".</para>
///</summary>
[EnumString("shdw18")]
ThreeDimensionalInnerBoxShadow,
///<summary>
///Back Center Perspective Shadow.
///<para>When the item is serialized out as xml, its value is "shdw19".</para>
///</summary>
[EnumString("shdw19")]
BackCenterPerspectiveShadow,
///<summary>
///Front Bottom Shadow.
///<para>When the item is serialized out as xml, its value is "shdw20".</para>
///</summary>
[EnumString("shdw20")]
FrontBottomShadow,
 
}
/// <summary>
/// Path Shade Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PathShadeValues
{  
	///<summary>
///Shape.
///<para>When the item is serialized out as xml, its value is "shape".</para>
///</summary>
[EnumString("shape")]
Shape,
///<summary>
///Circle.
///<para>When the item is serialized out as xml, its value is "circle".</para>
///</summary>
[EnumString("circle")]
Circle,
///<summary>
///Rectangle.
///<para>When the item is serialized out as xml, its value is "rect".</para>
///</summary>
[EnumString("rect")]
Rectangle,
 
}
/// <summary>
/// Tile Flip Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TileFlipValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Horizontal.
///<para>When the item is serialized out as xml, its value is "x".</para>
///</summary>
[EnumString("x")]
Horizontal,
///<summary>
///Vertical.
///<para>When the item is serialized out as xml, its value is "y".</para>
///</summary>
[EnumString("y")]
Vertical,
///<summary>
///Horizontal and Vertical.
///<para>When the item is serialized out as xml, its value is "xy".</para>
///</summary>
[EnumString("xy")]
HorizontalAndVertical,
 
}
/// <summary>
/// Blip Compression Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BlipCompressionValues
{  
	///<summary>
///Email Compression.
///<para>When the item is serialized out as xml, its value is "email".</para>
///</summary>
[EnumString("email")]
Email,
///<summary>
///Screen Viewing Compression.
///<para>When the item is serialized out as xml, its value is "screen".</para>
///</summary>
[EnumString("screen")]
Screen,
///<summary>
///Printing Compression.
///<para>When the item is serialized out as xml, its value is "print".</para>
///</summary>
[EnumString("print")]
Print,
///<summary>
///High Quality Printing Compression.
///<para>When the item is serialized out as xml, its value is "hqprint".</para>
///</summary>
[EnumString("hqprint")]
HighQualityPrint,
///<summary>
///No Compression.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Preset Pattern Value 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetPatternValues
{  
	///<summary>
///5%.
///<para>When the item is serialized out as xml, its value is "pct5".</para>
///</summary>
[EnumString("pct5")]
Percent5,
///<summary>
///10%.
///<para>When the item is serialized out as xml, its value is "pct10".</para>
///</summary>
[EnumString("pct10")]
Percent10,
///<summary>
///20%.
///<para>When the item is serialized out as xml, its value is "pct20".</para>
///</summary>
[EnumString("pct20")]
Percent20,
///<summary>
///25%.
///<para>When the item is serialized out as xml, its value is "pct25".</para>
///</summary>
[EnumString("pct25")]
Percent25,
///<summary>
///30%.
///<para>When the item is serialized out as xml, its value is "pct30".</para>
///</summary>
[EnumString("pct30")]
Percent30,
///<summary>
///40%.
///<para>When the item is serialized out as xml, its value is "pct40".</para>
///</summary>
[EnumString("pct40")]
Percent40,
///<summary>
///50%.
///<para>When the item is serialized out as xml, its value is "pct50".</para>
///</summary>
[EnumString("pct50")]
Percent50,
///<summary>
///60%.
///<para>When the item is serialized out as xml, its value is "pct60".</para>
///</summary>
[EnumString("pct60")]
Percent60,
///<summary>
///70%.
///<para>When the item is serialized out as xml, its value is "pct70".</para>
///</summary>
[EnumString("pct70")]
Percent70,
///<summary>
///75%.
///<para>When the item is serialized out as xml, its value is "pct75".</para>
///</summary>
[EnumString("pct75")]
Percent75,
///<summary>
///80%.
///<para>When the item is serialized out as xml, its value is "pct80".</para>
///</summary>
[EnumString("pct80")]
Percent80,
///<summary>
///90%.
///<para>When the item is serialized out as xml, its value is "pct90".</para>
///</summary>
[EnumString("pct90")]
Percent90,
///<summary>
///Horizontal.
///<para>When the item is serialized out as xml, its value is "horz".</para>
///</summary>
[EnumString("horz")]
Horizontal,
///<summary>
///Vertical.
///<para>When the item is serialized out as xml, its value is "vert".</para>
///</summary>
[EnumString("vert")]
Vertical,
///<summary>
///Light Horizontal.
///<para>When the item is serialized out as xml, its value is "ltHorz".</para>
///</summary>
[EnumString("ltHorz")]
LightHorizontal,
///<summary>
///Light Vertical.
///<para>When the item is serialized out as xml, its value is "ltVert".</para>
///</summary>
[EnumString("ltVert")]
LightVertical,
///<summary>
///Dark Horizontal.
///<para>When the item is serialized out as xml, its value is "dkHorz".</para>
///</summary>
[EnumString("dkHorz")]
DarkHorizontal,
///<summary>
///Dark Vertical.
///<para>When the item is serialized out as xml, its value is "dkVert".</para>
///</summary>
[EnumString("dkVert")]
DarkVertical,
///<summary>
///Narrow Horizontal.
///<para>When the item is serialized out as xml, its value is "narHorz".</para>
///</summary>
[EnumString("narHorz")]
NarrowHorizontal,
///<summary>
///Narrow Vertical.
///<para>When the item is serialized out as xml, its value is "narVert".</para>
///</summary>
[EnumString("narVert")]
NarrowVertical,
///<summary>
///Dashed Horizontal.
///<para>When the item is serialized out as xml, its value is "dashHorz".</para>
///</summary>
[EnumString("dashHorz")]
DashedHorizontal,
///<summary>
///Dashed Vertical.
///<para>When the item is serialized out as xml, its value is "dashVert".</para>
///</summary>
[EnumString("dashVert")]
DashedVertical,
///<summary>
///Cross.
///<para>When the item is serialized out as xml, its value is "cross".</para>
///</summary>
[EnumString("cross")]
Cross,
///<summary>
///Downward Diagonal.
///<para>When the item is serialized out as xml, its value is "dnDiag".</para>
///</summary>
[EnumString("dnDiag")]
DownwardDiagonal,
///<summary>
///Upward Diagonal.
///<para>When the item is serialized out as xml, its value is "upDiag".</para>
///</summary>
[EnumString("upDiag")]
UpwardDiagonal,
///<summary>
///Light Downward Diagonal.
///<para>When the item is serialized out as xml, its value is "ltDnDiag".</para>
///</summary>
[EnumString("ltDnDiag")]
LightDownwardDiagonal,
///<summary>
///Light Upward Diagonal.
///<para>When the item is serialized out as xml, its value is "ltUpDiag".</para>
///</summary>
[EnumString("ltUpDiag")]
LightUpwardDiagonal,
///<summary>
///Dark Downward Diagonal.
///<para>When the item is serialized out as xml, its value is "dkDnDiag".</para>
///</summary>
[EnumString("dkDnDiag")]
DarkDownwardDiagonal,
///<summary>
///Dark Upward Diagonal.
///<para>When the item is serialized out as xml, its value is "dkUpDiag".</para>
///</summary>
[EnumString("dkUpDiag")]
DarkUpwardDiagonal,
///<summary>
///Wide Downward Diagonal.
///<para>When the item is serialized out as xml, its value is "wdDnDiag".</para>
///</summary>
[EnumString("wdDnDiag")]
WideDownwardDiagonal,
///<summary>
///Wide Upward Diagonal.
///<para>When the item is serialized out as xml, its value is "wdUpDiag".</para>
///</summary>
[EnumString("wdUpDiag")]
WideUpwardDiagonal,
///<summary>
///Dashed Downward Diagonal.
///<para>When the item is serialized out as xml, its value is "dashDnDiag".</para>
///</summary>
[EnumString("dashDnDiag")]
DashedDownwardDiagonal,
///<summary>
///Dashed Upward DIagonal.
///<para>When the item is serialized out as xml, its value is "dashUpDiag".</para>
///</summary>
[EnumString("dashUpDiag")]
DashedUpwardDiagonal,
///<summary>
///Diagonal Cross.
///<para>When the item is serialized out as xml, its value is "diagCross".</para>
///</summary>
[EnumString("diagCross")]
DiagonalCross,
///<summary>
///Small Checker Board.
///<para>When the item is serialized out as xml, its value is "smCheck".</para>
///</summary>
[EnumString("smCheck")]
SmallCheck,
///<summary>
///Large Checker Board.
///<para>When the item is serialized out as xml, its value is "lgCheck".</para>
///</summary>
[EnumString("lgCheck")]
LargeCheck,
///<summary>
///Small Grid.
///<para>When the item is serialized out as xml, its value is "smGrid".</para>
///</summary>
[EnumString("smGrid")]
SmallGrid,
///<summary>
///Large Grid.
///<para>When the item is serialized out as xml, its value is "lgGrid".</para>
///</summary>
[EnumString("lgGrid")]
LargeGrid,
///<summary>
///Dotted Grid.
///<para>When the item is serialized out as xml, its value is "dotGrid".</para>
///</summary>
[EnumString("dotGrid")]
DotGrid,
///<summary>
///Small Confetti.
///<para>When the item is serialized out as xml, its value is "smConfetti".</para>
///</summary>
[EnumString("smConfetti")]
SmallConfetti,
///<summary>
///Large Confetti.
///<para>When the item is serialized out as xml, its value is "lgConfetti".</para>
///</summary>
[EnumString("lgConfetti")]
LargeConfetti,
///<summary>
///Horizontal Brick.
///<para>When the item is serialized out as xml, its value is "horzBrick".</para>
///</summary>
[EnumString("horzBrick")]
HorizontalBrick,
///<summary>
///Diagonal Brick.
///<para>When the item is serialized out as xml, its value is "diagBrick".</para>
///</summary>
[EnumString("diagBrick")]
DiagonalBrick,
///<summary>
///Solid Diamond.
///<para>When the item is serialized out as xml, its value is "solidDmnd".</para>
///</summary>
[EnumString("solidDmnd")]
SolidDiamond,
///<summary>
///Open Diamond.
///<para>When the item is serialized out as xml, its value is "openDmnd".</para>
///</summary>
[EnumString("openDmnd")]
OpenDiamond,
///<summary>
///Dotted Diamond.
///<para>When the item is serialized out as xml, its value is "dotDmnd".</para>
///</summary>
[EnumString("dotDmnd")]
DottedDiamond,
///<summary>
///Plaid.
///<para>When the item is serialized out as xml, its value is "plaid".</para>
///</summary>
[EnumString("plaid")]
Plaid,
///<summary>
///Sphere.
///<para>When the item is serialized out as xml, its value is "sphere".</para>
///</summary>
[EnumString("sphere")]
Sphere,
///<summary>
///Weave.
///<para>When the item is serialized out as xml, its value is "weave".</para>
///</summary>
[EnumString("weave")]
Weave,
///<summary>
///Divot.
///<para>When the item is serialized out as xml, its value is "divot".</para>
///</summary>
[EnumString("divot")]
Divot,
///<summary>
///Shingle.
///<para>When the item is serialized out as xml, its value is "shingle".</para>
///</summary>
[EnumString("shingle")]
Shingle,
///<summary>
///Wave.
///<para>When the item is serialized out as xml, its value is "wave".</para>
///</summary>
[EnumString("wave")]
Wave,
///<summary>
///Trellis.
///<para>When the item is serialized out as xml, its value is "trellis".</para>
///</summary>
[EnumString("trellis")]
Trellis,
///<summary>
///Zig Zag.
///<para>When the item is serialized out as xml, its value is "zigZag".</para>
///</summary>
[EnumString("zigZag")]
ZigZag,
 
}
/// <summary>
/// Blend Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BlendModeValues
{  
	///<summary>
///Overlay.
///<para>When the item is serialized out as xml, its value is "over".</para>
///</summary>
[EnumString("over")]
Overlay,
///<summary>
///Multiply.
///<para>When the item is serialized out as xml, its value is "mult".</para>
///</summary>
[EnumString("mult")]
Multiply,
///<summary>
///Screen.
///<para>When the item is serialized out as xml, its value is "screen".</para>
///</summary>
[EnumString("screen")]
Screen,
///<summary>
///Darken.
///<para>When the item is serialized out as xml, its value is "darken".</para>
///</summary>
[EnumString("darken")]
Darken,
///<summary>
///Lighten.
///<para>When the item is serialized out as xml, its value is "lighten".</para>
///</summary>
[EnumString("lighten")]
Lighten,
 
}
/// <summary>
/// Effect Container Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum EffectContainerValues
{  
	///<summary>
///Sibling.
///<para>When the item is serialized out as xml, its value is "sib".</para>
///</summary>
[EnumString("sib")]
Sibling,
///<summary>
///Tree.
///<para>When the item is serialized out as xml, its value is "tree".</para>
///</summary>
[EnumString("tree")]
Tree,
 
}
/// <summary>
/// Preset Shape Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ShapeTypeValues
{  
	///<summary>
///Line Shape.
///<para>When the item is serialized out as xml, its value is "line".</para>
///</summary>
[EnumString("line")]
Line,
///<summary>
///Line Inverse Shape.
///<para>When the item is serialized out as xml, its value is "lineInv".</para>
///</summary>
[EnumString("lineInv")]
LineInverse,
///<summary>
///Triangle Shape.
///<para>When the item is serialized out as xml, its value is "triangle".</para>
///</summary>
[EnumString("triangle")]
Triangle,
///<summary>
///Right Triangle Shape.
///<para>When the item is serialized out as xml, its value is "rtTriangle".</para>
///</summary>
[EnumString("rtTriangle")]
RightTriangle,
///<summary>
///Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "rect".</para>
///</summary>
[EnumString("rect")]
Rectangle,
///<summary>
///Diamond Shape.
///<para>When the item is serialized out as xml, its value is "diamond".</para>
///</summary>
[EnumString("diamond")]
Diamond,
///<summary>
///Parallelogram Shape.
///<para>When the item is serialized out as xml, its value is "parallelogram".</para>
///</summary>
[EnumString("parallelogram")]
Parallelogram,
///<summary>
///Trapezoid Shape.
///<para>When the item is serialized out as xml, its value is "trapezoid".</para>
///</summary>
[EnumString("trapezoid")]
Trapezoid,
///<summary>
///Non-Isosceles Trapezoid Shape.
///<para>When the item is serialized out as xml, its value is "nonIsoscelesTrapezoid".</para>
///</summary>
[EnumString("nonIsoscelesTrapezoid")]
NonIsoscelesTrapezoid,
///<summary>
///Pentagon Shape.
///<para>When the item is serialized out as xml, its value is "pentagon".</para>
///</summary>
[EnumString("pentagon")]
Pentagon,
///<summary>
///Hexagon Shape.
///<para>When the item is serialized out as xml, its value is "hexagon".</para>
///</summary>
[EnumString("hexagon")]
Hexagon,
///<summary>
///Heptagon Shape.
///<para>When the item is serialized out as xml, its value is "heptagon".</para>
///</summary>
[EnumString("heptagon")]
Heptagon,
///<summary>
///Octagon Shape.
///<para>When the item is serialized out as xml, its value is "octagon".</para>
///</summary>
[EnumString("octagon")]
Octagon,
///<summary>
///Decagon Shape.
///<para>When the item is serialized out as xml, its value is "decagon".</para>
///</summary>
[EnumString("decagon")]
Decagon,
///<summary>
///Dodecagon Shape.
///<para>When the item is serialized out as xml, its value is "dodecagon".</para>
///</summary>
[EnumString("dodecagon")]
Dodecagon,
///<summary>
///Four Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star4".</para>
///</summary>
[EnumString("star4")]
Star4,
///<summary>
///Five Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star5".</para>
///</summary>
[EnumString("star5")]
Star5,
///<summary>
///Six Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star6".</para>
///</summary>
[EnumString("star6")]
Star6,
///<summary>
///Seven Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star7".</para>
///</summary>
[EnumString("star7")]
Star7,
///<summary>
///Eight Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star8".</para>
///</summary>
[EnumString("star8")]
Star8,
///<summary>
///Ten Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star10".</para>
///</summary>
[EnumString("star10")]
Star10,
///<summary>
///Twelve Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star12".</para>
///</summary>
[EnumString("star12")]
Star12,
///<summary>
///Sixteen Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star16".</para>
///</summary>
[EnumString("star16")]
Star16,
///<summary>
///Twenty Four Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star24".</para>
///</summary>
[EnumString("star24")]
Star24,
///<summary>
///Thirty Two Pointed Star Shape.
///<para>When the item is serialized out as xml, its value is "star32".</para>
///</summary>
[EnumString("star32")]
Star32,
///<summary>
///Round Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "roundRect".</para>
///</summary>
[EnumString("roundRect")]
RoundRectangle,
///<summary>
///One Round Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "round1Rect".</para>
///</summary>
[EnumString("round1Rect")]
Round1Rectangle,
///<summary>
///Two Same-side Round Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "round2SameRect".</para>
///</summary>
[EnumString("round2SameRect")]
Round2SameRectangle,
///<summary>
///Two Diagonal Round Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "round2DiagRect".</para>
///</summary>
[EnumString("round2DiagRect")]
Round2DiagonalRectangle,
///<summary>
///One Snip One Round Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "snipRoundRect".</para>
///</summary>
[EnumString("snipRoundRect")]
SnipRoundRectangle,
///<summary>
///One Snip Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "snip1Rect".</para>
///</summary>
[EnumString("snip1Rect")]
Snip1Rectangle,
///<summary>
///Two Same-side Snip Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "snip2SameRect".</para>
///</summary>
[EnumString("snip2SameRect")]
Snip2SameRectangle,
///<summary>
///Two Diagonal Snip Corner Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "snip2DiagRect".</para>
///</summary>
[EnumString("snip2DiagRect")]
Snip2DiagonalRectangle,
///<summary>
///Plaque Shape.
///<para>When the item is serialized out as xml, its value is "plaque".</para>
///</summary>
[EnumString("plaque")]
Plaque,
///<summary>
///Ellipse Shape.
///<para>When the item is serialized out as xml, its value is "ellipse".</para>
///</summary>
[EnumString("ellipse")]
Ellipse,
///<summary>
///Teardrop Shape.
///<para>When the item is serialized out as xml, its value is "teardrop".</para>
///</summary>
[EnumString("teardrop")]
Teardrop,
///<summary>
///Home Plate Shape.
///<para>When the item is serialized out as xml, its value is "homePlate".</para>
///</summary>
[EnumString("homePlate")]
HomePlate,
///<summary>
///Chevron Shape.
///<para>When the item is serialized out as xml, its value is "chevron".</para>
///</summary>
[EnumString("chevron")]
Chevron,
///<summary>
///Pie Wedge Shape.
///<para>When the item is serialized out as xml, its value is "pieWedge".</para>
///</summary>
[EnumString("pieWedge")]
PieWedge,
///<summary>
///Pie Shape.
///<para>When the item is serialized out as xml, its value is "pie".</para>
///</summary>
[EnumString("pie")]
Pie,
///<summary>
///Block Arc Shape.
///<para>When the item is serialized out as xml, its value is "blockArc".</para>
///</summary>
[EnumString("blockArc")]
BlockArc,
///<summary>
///Donut Shape.
///<para>When the item is serialized out as xml, its value is "donut".</para>
///</summary>
[EnumString("donut")]
Donut,
///<summary>
///No Smoking Shape.
///<para>When the item is serialized out as xml, its value is "noSmoking".</para>
///</summary>
[EnumString("noSmoking")]
NoSmoking,
///<summary>
///Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "rightArrow".</para>
///</summary>
[EnumString("rightArrow")]
RightArrow,
///<summary>
///Left Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftArrow".</para>
///</summary>
[EnumString("leftArrow")]
LeftArrow,
///<summary>
///Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "upArrow".</para>
///</summary>
[EnumString("upArrow")]
UpArrow,
///<summary>
///Down Arrow Shape.
///<para>When the item is serialized out as xml, its value is "downArrow".</para>
///</summary>
[EnumString("downArrow")]
DownArrow,
///<summary>
///Striped Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "stripedRightArrow".</para>
///</summary>
[EnumString("stripedRightArrow")]
StripedRightArrow,
///<summary>
///Notched Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "notchedRightArrow".</para>
///</summary>
[EnumString("notchedRightArrow")]
NotchedRightArrow,
///<summary>
///Bent Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "bentUpArrow".</para>
///</summary>
[EnumString("bentUpArrow")]
BentUpArrow,
///<summary>
///Left Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftRightArrow".</para>
///</summary>
[EnumString("leftRightArrow")]
LeftRightArrow,
///<summary>
///Up Down Arrow Shape.
///<para>When the item is serialized out as xml, its value is "upDownArrow".</para>
///</summary>
[EnumString("upDownArrow")]
UpDownArrow,
///<summary>
///Left Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftUpArrow".</para>
///</summary>
[EnumString("leftUpArrow")]
LeftUpArrow,
///<summary>
///Left Right Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftRightUpArrow".</para>
///</summary>
[EnumString("leftRightUpArrow")]
LeftRightUpArrow,
///<summary>
///Quad-Arrow Shape.
///<para>When the item is serialized out as xml, its value is "quadArrow".</para>
///</summary>
[EnumString("quadArrow")]
QuadArrow,
///<summary>
///Callout Left Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftArrowCallout".</para>
///</summary>
[EnumString("leftArrowCallout")]
LeftArrowCallout,
///<summary>
///Callout Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "rightArrowCallout".</para>
///</summary>
[EnumString("rightArrowCallout")]
RightArrowCallout,
///<summary>
///Callout Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "upArrowCallout".</para>
///</summary>
[EnumString("upArrowCallout")]
UpArrowCallout,
///<summary>
///Callout Down Arrow Shape.
///<para>When the item is serialized out as xml, its value is "downArrowCallout".</para>
///</summary>
[EnumString("downArrowCallout")]
DownArrowCallout,
///<summary>
///Callout Left Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftRightArrowCallout".</para>
///</summary>
[EnumString("leftRightArrowCallout")]
LeftRightArrowCallout,
///<summary>
///Callout Up Down Arrow Shape.
///<para>When the item is serialized out as xml, its value is "upDownArrowCallout".</para>
///</summary>
[EnumString("upDownArrowCallout")]
UpDownArrowCallout,
///<summary>
///Callout Quad-Arrow Shape.
///<para>When the item is serialized out as xml, its value is "quadArrowCallout".</para>
///</summary>
[EnumString("quadArrowCallout")]
QuadArrowCallout,
///<summary>
///Bent Arrow Shape.
///<para>When the item is serialized out as xml, its value is "bentArrow".</para>
///</summary>
[EnumString("bentArrow")]
BentArrow,
///<summary>
///U-Turn Arrow Shape.
///<para>When the item is serialized out as xml, its value is "uturnArrow".</para>
///</summary>
[EnumString("uturnArrow")]
UTurnArrow,
///<summary>
///Circular Arrow Shape.
///<para>When the item is serialized out as xml, its value is "circularArrow".</para>
///</summary>
[EnumString("circularArrow")]
CircularArrow,
///<summary>
///Left Circular Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftCircularArrow".</para>
///</summary>
[EnumString("leftCircularArrow")]
LeftCircularArrow,
///<summary>
///Left Right Circular Arrow Shape.
///<para>When the item is serialized out as xml, its value is "leftRightCircularArrow".</para>
///</summary>
[EnumString("leftRightCircularArrow")]
LeftRightCircularArrow,
///<summary>
///Curved Right Arrow Shape.
///<para>When the item is serialized out as xml, its value is "curvedRightArrow".</para>
///</summary>
[EnumString("curvedRightArrow")]
CurvedRightArrow,
///<summary>
///Curved Left Arrow Shape.
///<para>When the item is serialized out as xml, its value is "curvedLeftArrow".</para>
///</summary>
[EnumString("curvedLeftArrow")]
CurvedLeftArrow,
///<summary>
///Curved Up Arrow Shape.
///<para>When the item is serialized out as xml, its value is "curvedUpArrow".</para>
///</summary>
[EnumString("curvedUpArrow")]
CurvedUpArrow,
///<summary>
///Curved Down Arrow Shape.
///<para>When the item is serialized out as xml, its value is "curvedDownArrow".</para>
///</summary>
[EnumString("curvedDownArrow")]
CurvedDownArrow,
///<summary>
///Swoosh Arrow Shape.
///<para>When the item is serialized out as xml, its value is "swooshArrow".</para>
///</summary>
[EnumString("swooshArrow")]
SwooshArrow,
///<summary>
///Cube Shape.
///<para>When the item is serialized out as xml, its value is "cube".</para>
///</summary>
[EnumString("cube")]
Cube,
///<summary>
///Can Shape.
///<para>When the item is serialized out as xml, its value is "can".</para>
///</summary>
[EnumString("can")]
Can,
///<summary>
///Lightning Bolt Shape.
///<para>When the item is serialized out as xml, its value is "lightningBolt".</para>
///</summary>
[EnumString("lightningBolt")]
LightningBolt,
///<summary>
///Heart Shape.
///<para>When the item is serialized out as xml, its value is "heart".</para>
///</summary>
[EnumString("heart")]
Heart,
///<summary>
///Sun Shape.
///<para>When the item is serialized out as xml, its value is "sun".</para>
///</summary>
[EnumString("sun")]
Sun,
///<summary>
///Moon Shape.
///<para>When the item is serialized out as xml, its value is "moon".</para>
///</summary>
[EnumString("moon")]
Moon,
///<summary>
///Smiley Face Shape.
///<para>When the item is serialized out as xml, its value is "smileyFace".</para>
///</summary>
[EnumString("smileyFace")]
SmileyFace,
///<summary>
///Irregular Seal 1 Shape.
///<para>When the item is serialized out as xml, its value is "irregularSeal1".</para>
///</summary>
[EnumString("irregularSeal1")]
IrregularSeal1,
///<summary>
///Irregular Seal 2 Shape.
///<para>When the item is serialized out as xml, its value is "irregularSeal2".</para>
///</summary>
[EnumString("irregularSeal2")]
IrregularSeal2,
///<summary>
///Folded Corner Shape.
///<para>When the item is serialized out as xml, its value is "foldedCorner".</para>
///</summary>
[EnumString("foldedCorner")]
FoldedCorner,
///<summary>
///Bevel Shape.
///<para>When the item is serialized out as xml, its value is "bevel".</para>
///</summary>
[EnumString("bevel")]
Bevel,
///<summary>
///Frame Shape.
///<para>When the item is serialized out as xml, its value is "frame".</para>
///</summary>
[EnumString("frame")]
Frame,
///<summary>
///Half Frame Shape.
///<para>When the item is serialized out as xml, its value is "halfFrame".</para>
///</summary>
[EnumString("halfFrame")]
HalfFrame,
///<summary>
///Corner Shape.
///<para>When the item is serialized out as xml, its value is "corner".</para>
///</summary>
[EnumString("corner")]
Corner,
///<summary>
///Diagonal Stripe Shape.
///<para>When the item is serialized out as xml, its value is "diagStripe".</para>
///</summary>
[EnumString("diagStripe")]
DiagonalStripe,
///<summary>
///Chord Shape.
///<para>When the item is serialized out as xml, its value is "chord".</para>
///</summary>
[EnumString("chord")]
Chord,
///<summary>
///Curved Arc Shape.
///<para>When the item is serialized out as xml, its value is "arc".</para>
///</summary>
[EnumString("arc")]
Arc,
///<summary>
///Left Bracket Shape.
///<para>When the item is serialized out as xml, its value is "leftBracket".</para>
///</summary>
[EnumString("leftBracket")]
LeftBracket,
///<summary>
///Right Bracket Shape.
///<para>When the item is serialized out as xml, its value is "rightBracket".</para>
///</summary>
[EnumString("rightBracket")]
RightBracket,
///<summary>
///Left Brace Shape.
///<para>When the item is serialized out as xml, its value is "leftBrace".</para>
///</summary>
[EnumString("leftBrace")]
LeftBrace,
///<summary>
///Right Brace Shape.
///<para>When the item is serialized out as xml, its value is "rightBrace".</para>
///</summary>
[EnumString("rightBrace")]
RightBrace,
///<summary>
///Bracket Pair Shape.
///<para>When the item is serialized out as xml, its value is "bracketPair".</para>
///</summary>
[EnumString("bracketPair")]
BracketPair,
///<summary>
///Brace Pair Shape.
///<para>When the item is serialized out as xml, its value is "bracePair".</para>
///</summary>
[EnumString("bracePair")]
BracePair,
///<summary>
///Straight Connector 1 Shape.
///<para>When the item is serialized out as xml, its value is "straightConnector1".</para>
///</summary>
[EnumString("straightConnector1")]
StraightConnector1,
///<summary>
///Bent Connector 2 Shape.
///<para>When the item is serialized out as xml, its value is "bentConnector2".</para>
///</summary>
[EnumString("bentConnector2")]
BentConnector2,
///<summary>
///Bent Connector 3 Shape.
///<para>When the item is serialized out as xml, its value is "bentConnector3".</para>
///</summary>
[EnumString("bentConnector3")]
BentConnector3,
///<summary>
///Bent Connector 4 Shape.
///<para>When the item is serialized out as xml, its value is "bentConnector4".</para>
///</summary>
[EnumString("bentConnector4")]
BentConnector4,
///<summary>
///Bent Connector 5 Shape.
///<para>When the item is serialized out as xml, its value is "bentConnector5".</para>
///</summary>
[EnumString("bentConnector5")]
BentConnector5,
///<summary>
///Curved Connector 2 Shape.
///<para>When the item is serialized out as xml, its value is "curvedConnector2".</para>
///</summary>
[EnumString("curvedConnector2")]
CurvedConnector2,
///<summary>
///Curved Connector 3 Shape.
///<para>When the item is serialized out as xml, its value is "curvedConnector3".</para>
///</summary>
[EnumString("curvedConnector3")]
CurvedConnector3,
///<summary>
///Curved Connector 4 Shape.
///<para>When the item is serialized out as xml, its value is "curvedConnector4".</para>
///</summary>
[EnumString("curvedConnector4")]
CurvedConnector4,
///<summary>
///Curved Connector 5 Shape.
///<para>When the item is serialized out as xml, its value is "curvedConnector5".</para>
///</summary>
[EnumString("curvedConnector5")]
CurvedConnector5,
///<summary>
///Callout 1 Shape.
///<para>When the item is serialized out as xml, its value is "callout1".</para>
///</summary>
[EnumString("callout1")]
Callout1,
///<summary>
///Callout 2 Shape.
///<para>When the item is serialized out as xml, its value is "callout2".</para>
///</summary>
[EnumString("callout2")]
Callout2,
///<summary>
///Callout 3 Shape.
///<para>When the item is serialized out as xml, its value is "callout3".</para>
///</summary>
[EnumString("callout3")]
Callout3,
///<summary>
///Callout 1 Shape.
///<para>When the item is serialized out as xml, its value is "accentCallout1".</para>
///</summary>
[EnumString("accentCallout1")]
AccentCallout1,
///<summary>
///Callout 2 Shape.
///<para>When the item is serialized out as xml, its value is "accentCallout2".</para>
///</summary>
[EnumString("accentCallout2")]
AccentCallout2,
///<summary>
///Callout 3 Shape.
///<para>When the item is serialized out as xml, its value is "accentCallout3".</para>
///</summary>
[EnumString("accentCallout3")]
AccentCallout3,
///<summary>
///Callout 1 with Border Shape.
///<para>When the item is serialized out as xml, its value is "borderCallout1".</para>
///</summary>
[EnumString("borderCallout1")]
BorderCallout1,
///<summary>
///Callout 2 with Border Shape.
///<para>When the item is serialized out as xml, its value is "borderCallout2".</para>
///</summary>
[EnumString("borderCallout2")]
BorderCallout2,
///<summary>
///Callout 3 with Border Shape.
///<para>When the item is serialized out as xml, its value is "borderCallout3".</para>
///</summary>
[EnumString("borderCallout3")]
BorderCallout3,
///<summary>
///Callout 1 with Border and Accent Shape.
///<para>When the item is serialized out as xml, its value is "accentBorderCallout1".</para>
///</summary>
[EnumString("accentBorderCallout1")]
AccentBorderCallout1,
///<summary>
///Callout 2 with Border and Accent Shape.
///<para>When the item is serialized out as xml, its value is "accentBorderCallout2".</para>
///</summary>
[EnumString("accentBorderCallout2")]
AccentBorderCallout2,
///<summary>
///Callout 3 with Border and Accent Shape.
///<para>When the item is serialized out as xml, its value is "accentBorderCallout3".</para>
///</summary>
[EnumString("accentBorderCallout3")]
AccentBorderCallout3,
///<summary>
///Callout Wedge Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "wedgeRectCallout".</para>
///</summary>
[EnumString("wedgeRectCallout")]
WedgeRectangleCallout,
///<summary>
///Callout Wedge Round Rectangle Shape.
///<para>When the item is serialized out as xml, its value is "wedgeRoundRectCallout".</para>
///</summary>
[EnumString("wedgeRoundRectCallout")]
WedgeRoundRectangleCallout,
///<summary>
///Callout Wedge Ellipse Shape.
///<para>When the item is serialized out as xml, its value is "wedgeEllipseCallout".</para>
///</summary>
[EnumString("wedgeEllipseCallout")]
WedgeEllipseCallout,
///<summary>
///Callout Cloud Shape.
///<para>When the item is serialized out as xml, its value is "cloudCallout".</para>
///</summary>
[EnumString("cloudCallout")]
CloudCallout,
///<summary>
///Cloud Shape.
///<para>When the item is serialized out as xml, its value is "cloud".</para>
///</summary>
[EnumString("cloud")]
Cloud,
///<summary>
///Ribbon Shape.
///<para>When the item is serialized out as xml, its value is "ribbon".</para>
///</summary>
[EnumString("ribbon")]
Ribbon,
///<summary>
///Ribbon 2 Shape.
///<para>When the item is serialized out as xml, its value is "ribbon2".</para>
///</summary>
[EnumString("ribbon2")]
Ribbon2,
///<summary>
///Ellipse Ribbon Shape.
///<para>When the item is serialized out as xml, its value is "ellipseRibbon".</para>
///</summary>
[EnumString("ellipseRibbon")]
EllipseRibbon,
///<summary>
///Ellipse Ribbon 2 Shape.
///<para>When the item is serialized out as xml, its value is "ellipseRibbon2".</para>
///</summary>
[EnumString("ellipseRibbon2")]
EllipseRibbon2,
///<summary>
///Left Right Ribbon Shape.
///<para>When the item is serialized out as xml, its value is "leftRightRibbon".</para>
///</summary>
[EnumString("leftRightRibbon")]
LeftRightRibbon,
///<summary>
///Vertical Scroll Shape.
///<para>When the item is serialized out as xml, its value is "verticalScroll".</para>
///</summary>
[EnumString("verticalScroll")]
VerticalScroll,
///<summary>
///Horizontal Scroll Shape.
///<para>When the item is serialized out as xml, its value is "horizontalScroll".</para>
///</summary>
[EnumString("horizontalScroll")]
HorizontalScroll,
///<summary>
///Wave Shape.
///<para>When the item is serialized out as xml, its value is "wave".</para>
///</summary>
[EnumString("wave")]
Wave,
///<summary>
///Double Wave Shape.
///<para>When the item is serialized out as xml, its value is "doubleWave".</para>
///</summary>
[EnumString("doubleWave")]
DoubleWave,
///<summary>
///Plus Shape.
///<para>When the item is serialized out as xml, its value is "plus".</para>
///</summary>
[EnumString("plus")]
Plus,
///<summary>
///Process Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartProcess".</para>
///</summary>
[EnumString("flowChartProcess")]
FlowChartProcess,
///<summary>
///Decision Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartDecision".</para>
///</summary>
[EnumString("flowChartDecision")]
FlowChartDecision,
///<summary>
///Input Output Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartInputOutput".</para>
///</summary>
[EnumString("flowChartInputOutput")]
FlowChartInputOutput,
///<summary>
///Predefined Process Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartPredefinedProcess".</para>
///</summary>
[EnumString("flowChartPredefinedProcess")]
FlowChartPredefinedProcess,
///<summary>
///Internal Storage Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartInternalStorage".</para>
///</summary>
[EnumString("flowChartInternalStorage")]
FlowChartInternalStorage,
///<summary>
///Document Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartDocument".</para>
///</summary>
[EnumString("flowChartDocument")]
FlowChartDocument,
///<summary>
///Multi-Document Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartMultidocument".</para>
///</summary>
[EnumString("flowChartMultidocument")]
FlowChartMultidocument,
///<summary>
///Terminator Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartTerminator".</para>
///</summary>
[EnumString("flowChartTerminator")]
FlowChartTerminator,
///<summary>
///Preparation Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartPreparation".</para>
///</summary>
[EnumString("flowChartPreparation")]
FlowChartPreparation,
///<summary>
///Manual Input Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartManualInput".</para>
///</summary>
[EnumString("flowChartManualInput")]
FlowChartManualInput,
///<summary>
///Manual Operation Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartManualOperation".</para>
///</summary>
[EnumString("flowChartManualOperation")]
FlowChartManualOperation,
///<summary>
///Connector Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartConnector".</para>
///</summary>
[EnumString("flowChartConnector")]
FlowChartConnector,
///<summary>
///Punched Card Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartPunchedCard".</para>
///</summary>
[EnumString("flowChartPunchedCard")]
FlowChartPunchedCard,
///<summary>
///Punched Tape Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartPunchedTape".</para>
///</summary>
[EnumString("flowChartPunchedTape")]
FlowChartPunchedTape,
///<summary>
///Summing Junction Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartSummingJunction".</para>
///</summary>
[EnumString("flowChartSummingJunction")]
FlowChartSummingJunction,
///<summary>
///Or Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartOr".</para>
///</summary>
[EnumString("flowChartOr")]
FlowChartOr,
///<summary>
///Collate Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartCollate".</para>
///</summary>
[EnumString("flowChartCollate")]
FlowChartCollate,
///<summary>
///Sort Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartSort".</para>
///</summary>
[EnumString("flowChartSort")]
FlowChartSort,
///<summary>
///Extract Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartExtract".</para>
///</summary>
[EnumString("flowChartExtract")]
FlowChartExtract,
///<summary>
///Merge Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartMerge".</para>
///</summary>
[EnumString("flowChartMerge")]
FlowChartMerge,
///<summary>
///Offline Storage Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartOfflineStorage".</para>
///</summary>
[EnumString("flowChartOfflineStorage")]
FlowChartOfflineStorage,
///<summary>
///Online Storage Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartOnlineStorage".</para>
///</summary>
[EnumString("flowChartOnlineStorage")]
FlowChartOnlineStorage,
///<summary>
///Magnetic Tape Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartMagneticTape".</para>
///</summary>
[EnumString("flowChartMagneticTape")]
FlowChartMagneticTape,
///<summary>
///Magnetic Disk Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartMagneticDisk".</para>
///</summary>
[EnumString("flowChartMagneticDisk")]
FlowChartMagneticDisk,
///<summary>
///Magnetic Drum Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartMagneticDrum".</para>
///</summary>
[EnumString("flowChartMagneticDrum")]
FlowChartMagneticDrum,
///<summary>
///Display Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartDisplay".</para>
///</summary>
[EnumString("flowChartDisplay")]
FlowChartDisplay,
///<summary>
///Delay Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartDelay".</para>
///</summary>
[EnumString("flowChartDelay")]
FlowChartDelay,
///<summary>
///Alternate Process Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartAlternateProcess".</para>
///</summary>
[EnumString("flowChartAlternateProcess")]
FlowChartAlternateProcess,
///<summary>
///Off-Page Connector Flow Shape.
///<para>When the item is serialized out as xml, its value is "flowChartOffpageConnector".</para>
///</summary>
[EnumString("flowChartOffpageConnector")]
FlowChartOffpageConnector,
///<summary>
///Blank Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonBlank".</para>
///</summary>
[EnumString("actionButtonBlank")]
ActionButtonBlank,
///<summary>
///Home Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonHome".</para>
///</summary>
[EnumString("actionButtonHome")]
ActionButtonHome,
///<summary>
///Help Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonHelp".</para>
///</summary>
[EnumString("actionButtonHelp")]
ActionButtonHelp,
///<summary>
///Information Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonInformation".</para>
///</summary>
[EnumString("actionButtonInformation")]
ActionButtonInformation,
///<summary>
///Forward or Next Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonForwardNext".</para>
///</summary>
[EnumString("actionButtonForwardNext")]
ActionButtonForwardNext,
///<summary>
///Back or Previous Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonBackPrevious".</para>
///</summary>
[EnumString("actionButtonBackPrevious")]
ActionButtonBackPrevious,
///<summary>
///End Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonEnd".</para>
///</summary>
[EnumString("actionButtonEnd")]
ActionButtonEnd,
///<summary>
///Beginning Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonBeginning".</para>
///</summary>
[EnumString("actionButtonBeginning")]
ActionButtonBeginning,
///<summary>
///Return Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonReturn".</para>
///</summary>
[EnumString("actionButtonReturn")]
ActionButtonReturn,
///<summary>
///Document Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonDocument".</para>
///</summary>
[EnumString("actionButtonDocument")]
ActionButtonDocument,
///<summary>
///Sound Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonSound".</para>
///</summary>
[EnumString("actionButtonSound")]
ActionButtonSound,
///<summary>
///Movie Button Shape.
///<para>When the item is serialized out as xml, its value is "actionButtonMovie".</para>
///</summary>
[EnumString("actionButtonMovie")]
ActionButtonMovie,
///<summary>
///Gear 6 Shape.
///<para>When the item is serialized out as xml, its value is "gear6".</para>
///</summary>
[EnumString("gear6")]
Gear6,
///<summary>
///Gear 9 Shape.
///<para>When the item is serialized out as xml, its value is "gear9".</para>
///</summary>
[EnumString("gear9")]
Gear9,
///<summary>
///Funnel Shape.
///<para>When the item is serialized out as xml, its value is "funnel".</para>
///</summary>
[EnumString("funnel")]
Funnel,
///<summary>
///Plus Math Shape.
///<para>When the item is serialized out as xml, its value is "mathPlus".</para>
///</summary>
[EnumString("mathPlus")]
MathPlus,
///<summary>
///Minus Math Shape.
///<para>When the item is serialized out as xml, its value is "mathMinus".</para>
///</summary>
[EnumString("mathMinus")]
MathMinus,
///<summary>
///Multiply Math Shape.
///<para>When the item is serialized out as xml, its value is "mathMultiply".</para>
///</summary>
[EnumString("mathMultiply")]
MathMultiply,
///<summary>
///Divide Math Shape.
///<para>When the item is serialized out as xml, its value is "mathDivide".</para>
///</summary>
[EnumString("mathDivide")]
MathDivide,
///<summary>
///Equal Math Shape.
///<para>When the item is serialized out as xml, its value is "mathEqual".</para>
///</summary>
[EnumString("mathEqual")]
MathEqual,
///<summary>
///Not Equal Math Shape.
///<para>When the item is serialized out as xml, its value is "mathNotEqual".</para>
///</summary>
[EnumString("mathNotEqual")]
MathNotEqual,
///<summary>
///Corner Tabs Shape.
///<para>When the item is serialized out as xml, its value is "cornerTabs".</para>
///</summary>
[EnumString("cornerTabs")]
CornerTabs,
///<summary>
///Square Tabs Shape.
///<para>When the item is serialized out as xml, its value is "squareTabs".</para>
///</summary>
[EnumString("squareTabs")]
SquareTabs,
///<summary>
///Plaque Tabs Shape.
///<para>When the item is serialized out as xml, its value is "plaqueTabs".</para>
///</summary>
[EnumString("plaqueTabs")]
PlaqueTabs,
///<summary>
///Chart X Shape.
///<para>When the item is serialized out as xml, its value is "chartX".</para>
///</summary>
[EnumString("chartX")]
ChartX,
///<summary>
///Chart Star Shape.
///<para>When the item is serialized out as xml, its value is "chartStar".</para>
///</summary>
[EnumString("chartStar")]
ChartStar,
///<summary>
///Chart Plus Shape.
///<para>When the item is serialized out as xml, its value is "chartPlus".</para>
///</summary>
[EnumString("chartPlus")]
ChartPlus,
 
}
/// <summary>
/// Preset Text Shape Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextShapeValues
{  
	///<summary>
///No Text Shape.
///<para>When the item is serialized out as xml, its value is "textNoShape".</para>
///</summary>
[EnumString("textNoShape")]
TextNoShape,
///<summary>
///Plain Text Shape.
///<para>When the item is serialized out as xml, its value is "textPlain".</para>
///</summary>
[EnumString("textPlain")]
TextPlain,
///<summary>
///Stop Sign Text Shape.
///<para>When the item is serialized out as xml, its value is "textStop".</para>
///</summary>
[EnumString("textStop")]
TextStop,
///<summary>
///Triangle Text Shape.
///<para>When the item is serialized out as xml, its value is "textTriangle".</para>
///</summary>
[EnumString("textTriangle")]
TextTriangle,
///<summary>
///Inverted Triangle Text Shape.
///<para>When the item is serialized out as xml, its value is "textTriangleInverted".</para>
///</summary>
[EnumString("textTriangleInverted")]
TextTriangleInverted,
///<summary>
///Chevron Text Shape.
///<para>When the item is serialized out as xml, its value is "textChevron".</para>
///</summary>
[EnumString("textChevron")]
TextChevron,
///<summary>
///Inverted Chevron Text Shape.
///<para>When the item is serialized out as xml, its value is "textChevronInverted".</para>
///</summary>
[EnumString("textChevronInverted")]
TextChevronInverted,
///<summary>
///Inside Ring Text Shape.
///<para>When the item is serialized out as xml, its value is "textRingInside".</para>
///</summary>
[EnumString("textRingInside")]
TextRingInside,
///<summary>
///Outside Ring Text Shape.
///<para>When the item is serialized out as xml, its value is "textRingOutside".</para>
///</summary>
[EnumString("textRingOutside")]
TextRingOutside,
///<summary>
///Upward Arch Text Shape.
///<para>When the item is serialized out as xml, its value is "textArchUp".</para>
///</summary>
[EnumString("textArchUp")]
TextArchUp,
///<summary>
///Downward Arch Text Shape.
///<para>When the item is serialized out as xml, its value is "textArchDown".</para>
///</summary>
[EnumString("textArchDown")]
TextArchDown,
///<summary>
///Circle Text Shape.
///<para>When the item is serialized out as xml, its value is "textCircle".</para>
///</summary>
[EnumString("textCircle")]
TextCircle,
///<summary>
///Button Text Shape.
///<para>When the item is serialized out as xml, its value is "textButton".</para>
///</summary>
[EnumString("textButton")]
TextButton,
///<summary>
///Upward Pour Arch Text Shape.
///<para>When the item is serialized out as xml, its value is "textArchUpPour".</para>
///</summary>
[EnumString("textArchUpPour")]
TextArchUpPour,
///<summary>
///Downward Pour Arch Text Shape.
///<para>When the item is serialized out as xml, its value is "textArchDownPour".</para>
///</summary>
[EnumString("textArchDownPour")]
TextArchDownPour,
///<summary>
///Circle Pour Text Shape.
///<para>When the item is serialized out as xml, its value is "textCirclePour".</para>
///</summary>
[EnumString("textCirclePour")]
TextCirclePour,
///<summary>
///Button Pour Text Shape.
///<para>When the item is serialized out as xml, its value is "textButtonPour".</para>
///</summary>
[EnumString("textButtonPour")]
TextButtonPour,
///<summary>
///Upward Curve Text Shape.
///<para>When the item is serialized out as xml, its value is "textCurveUp".</para>
///</summary>
[EnumString("textCurveUp")]
TextCurveUp,
///<summary>
///Downward Curve Text Shape.
///<para>When the item is serialized out as xml, its value is "textCurveDown".</para>
///</summary>
[EnumString("textCurveDown")]
TextCurveDown,
///<summary>
///Upward Can Text Shape.
///<para>When the item is serialized out as xml, its value is "textCanUp".</para>
///</summary>
[EnumString("textCanUp")]
TextCanUp,
///<summary>
///Downward Can Text Shape.
///<para>When the item is serialized out as xml, its value is "textCanDown".</para>
///</summary>
[EnumString("textCanDown")]
TextCanDown,
///<summary>
///Wave 1 Text Shape.
///<para>When the item is serialized out as xml, its value is "textWave1".</para>
///</summary>
[EnumString("textWave1")]
TextWave1,
///<summary>
///Wave 2 Text Shape.
///<para>When the item is serialized out as xml, its value is "textWave2".</para>
///</summary>
[EnumString("textWave2")]
TextWave2,
///<summary>
///Double Wave 1 Text Shape.
///<para>When the item is serialized out as xml, its value is "textDoubleWave1".</para>
///</summary>
[EnumString("textDoubleWave1")]
TextDoubleWave1,
///<summary>
///Wave 4 Text Shape.
///<para>When the item is serialized out as xml, its value is "textWave4".</para>
///</summary>
[EnumString("textWave4")]
TextWave4,
///<summary>
///Inflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textInflate".</para>
///</summary>
[EnumString("textInflate")]
TextInflate,
///<summary>
///Deflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textDeflate".</para>
///</summary>
[EnumString("textDeflate")]
TextDeflate,
///<summary>
///Bottom Inflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textInflateBottom".</para>
///</summary>
[EnumString("textInflateBottom")]
TextInflateBottom,
///<summary>
///Bottom Deflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textDeflateBottom".</para>
///</summary>
[EnumString("textDeflateBottom")]
TextDeflateBottom,
///<summary>
///Top Inflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textInflateTop".</para>
///</summary>
[EnumString("textInflateTop")]
TextInflateTop,
///<summary>
///Top Deflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textDeflateTop".</para>
///</summary>
[EnumString("textDeflateTop")]
TextDeflateTop,
///<summary>
///Deflate-Inflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textDeflateInflate".</para>
///</summary>
[EnumString("textDeflateInflate")]
TextDeflateInflate,
///<summary>
///Deflate-Inflate-Deflate Text Shape.
///<para>When the item is serialized out as xml, its value is "textDeflateInflateDeflate".</para>
///</summary>
[EnumString("textDeflateInflateDeflate")]
TextDeflateInflateDeflate,
///<summary>
///Right Fade Text Shape.
///<para>When the item is serialized out as xml, its value is "textFadeRight".</para>
///</summary>
[EnumString("textFadeRight")]
TextFadeRight,
///<summary>
///Left Fade Text Shape.
///<para>When the item is serialized out as xml, its value is "textFadeLeft".</para>
///</summary>
[EnumString("textFadeLeft")]
TextFadeLeft,
///<summary>
///Upward Fade Text Shape.
///<para>When the item is serialized out as xml, its value is "textFadeUp".</para>
///</summary>
[EnumString("textFadeUp")]
TextFadeUp,
///<summary>
///Downward Fade Text Shape.
///<para>When the item is serialized out as xml, its value is "textFadeDown".</para>
///</summary>
[EnumString("textFadeDown")]
TextFadeDown,
///<summary>
///Upward Slant Text Shape.
///<para>When the item is serialized out as xml, its value is "textSlantUp".</para>
///</summary>
[EnumString("textSlantUp")]
TextSlantUp,
///<summary>
///Downward Slant Text Shape.
///<para>When the item is serialized out as xml, its value is "textSlantDown".</para>
///</summary>
[EnumString("textSlantDown")]
TextSlantDown,
///<summary>
///Upward Cascade Text Shape.
///<para>When the item is serialized out as xml, its value is "textCascadeUp".</para>
///</summary>
[EnumString("textCascadeUp")]
TextCascadeUp,
///<summary>
///Downward Cascade Text Shape.
///<para>When the item is serialized out as xml, its value is "textCascadeDown".</para>
///</summary>
[EnumString("textCascadeDown")]
TextCascadeDown,
 
}
/// <summary>
/// Path Fill Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PathFillModeValues
{  
	///<summary>
///No Path Fill.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Normal Path Fill.
///<para>When the item is serialized out as xml, its value is "norm".</para>
///</summary>
[EnumString("norm")]
Norm,
///<summary>
///Lighten Path Fill.
///<para>When the item is serialized out as xml, its value is "lighten".</para>
///</summary>
[EnumString("lighten")]
Lighten,
///<summary>
///Lighten Path Fill Less.
///<para>When the item is serialized out as xml, its value is "lightenLess".</para>
///</summary>
[EnumString("lightenLess")]
LightenLess,
///<summary>
///Darken Path Fill.
///<para>When the item is serialized out as xml, its value is "darken".</para>
///</summary>
[EnumString("darken")]
Darken,
///<summary>
///Darken Path Fill Less.
///<para>When the item is serialized out as xml, its value is "darkenLess".</para>
///</summary>
[EnumString("darkenLess")]
DarkenLess,
 
}
/// <summary>
/// Line End Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineEndValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Triangle Arrow Head.
///<para>When the item is serialized out as xml, its value is "triangle".</para>
///</summary>
[EnumString("triangle")]
Triangle,
///<summary>
///Stealth Arrow.
///<para>When the item is serialized out as xml, its value is "stealth".</para>
///</summary>
[EnumString("stealth")]
Stealth,
///<summary>
///Diamond.
///<para>When the item is serialized out as xml, its value is "diamond".</para>
///</summary>
[EnumString("diamond")]
Diamond,
///<summary>
///Oval.
///<para>When the item is serialized out as xml, its value is "oval".</para>
///</summary>
[EnumString("oval")]
Oval,
///<summary>
///Arrow Head.
///<para>When the item is serialized out as xml, its value is "arrow".</para>
///</summary>
[EnumString("arrow")]
Arrow,
 
}
/// <summary>
/// Line End Width 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineEndWidthValues
{  
	///<summary>
///Small.
///<para>When the item is serialized out as xml, its value is "sm".</para>
///</summary>
[EnumString("sm")]
Small,
///<summary>
///Medium.
///<para>When the item is serialized out as xml, its value is "med".</para>
///</summary>
[EnumString("med")]
Medium,
///<summary>
///Large.
///<para>When the item is serialized out as xml, its value is "lg".</para>
///</summary>
[EnumString("lg")]
Large,
 
}
/// <summary>
/// Line End Length 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineEndLengthValues
{  
	///<summary>
///Small.
///<para>When the item is serialized out as xml, its value is "sm".</para>
///</summary>
[EnumString("sm")]
Small,
///<summary>
///Medium.
///<para>When the item is serialized out as xml, its value is "med".</para>
///</summary>
[EnumString("med")]
Medium,
///<summary>
///Large.
///<para>When the item is serialized out as xml, its value is "lg".</para>
///</summary>
[EnumString("lg")]
Large,
 
}
/// <summary>
/// Preset Line Dash Value 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetLineDashValues
{  
	///<summary>
///Solid.
///<para>When the item is serialized out as xml, its value is "solid".</para>
///</summary>
[EnumString("solid")]
Solid,
///<summary>
///Dot.
///<para>When the item is serialized out as xml, its value is "dot".</para>
///</summary>
[EnumString("dot")]
Dot,
///<summary>
///Dash.
///<para>When the item is serialized out as xml, its value is "dash".</para>
///</summary>
[EnumString("dash")]
Dash,
///<summary>
///Large Dash.
///<para>When the item is serialized out as xml, its value is "lgDash".</para>
///</summary>
[EnumString("lgDash")]
LargeDash,
///<summary>
///Dash Dot.
///<para>When the item is serialized out as xml, its value is "dashDot".</para>
///</summary>
[EnumString("dashDot")]
DashDot,
///<summary>
///Large Dash Dot.
///<para>When the item is serialized out as xml, its value is "lgDashDot".</para>
///</summary>
[EnumString("lgDashDot")]
LargeDashDot,
///<summary>
///Large Dash Dot Dot.
///<para>When the item is serialized out as xml, its value is "lgDashDotDot".</para>
///</summary>
[EnumString("lgDashDotDot")]
LargeDashDotDot,
///<summary>
///System Dash.
///<para>When the item is serialized out as xml, its value is "sysDash".</para>
///</summary>
[EnumString("sysDash")]
SystemDash,
///<summary>
///System Dot.
///<para>When the item is serialized out as xml, its value is "sysDot".</para>
///</summary>
[EnumString("sysDot")]
SystemDot,
///<summary>
///System Dash Dot.
///<para>When the item is serialized out as xml, its value is "sysDashDot".</para>
///</summary>
[EnumString("sysDashDot")]
SystemDashDot,
///<summary>
///System Dash Dot Dot.
///<para>When the item is serialized out as xml, its value is "sysDashDotDot".</para>
///</summary>
[EnumString("sysDashDotDot")]
SystemDashDotDot,
 
}
/// <summary>
/// End Line Cap 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineCapValues
{  
	///<summary>
///Round Line Cap.
///<para>When the item is serialized out as xml, its value is "rnd".</para>
///</summary>
[EnumString("rnd")]
Round,
///<summary>
///Square Line Cap.
///<para>When the item is serialized out as xml, its value is "sq".</para>
///</summary>
[EnumString("sq")]
Square,
///<summary>
///Flat Line Cap.
///<para>When the item is serialized out as xml, its value is "flat".</para>
///</summary>
[EnumString("flat")]
Flat,
 
}
/// <summary>
/// Alignment Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PenAlignmentValues
{  
	///<summary>
///Center Alignment.
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Inset Alignment.
///<para>When the item is serialized out as xml, its value is "in".</para>
///</summary>
[EnumString("in")]
Insert,
 
}
/// <summary>
/// Compound Line Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CompoundLineValues
{  
	///<summary>
///Single Line.
///<para>When the item is serialized out as xml, its value is "sng".</para>
///</summary>
[EnumString("sng")]
Single,
///<summary>
///Double Lines.
///<para>When the item is serialized out as xml, its value is "dbl".</para>
///</summary>
[EnumString("dbl")]
Double,
///<summary>
///Thick Thin Double Lines.
///<para>When the item is serialized out as xml, its value is "thickThin".</para>
///</summary>
[EnumString("thickThin")]
ThickThin,
///<summary>
///Thin Thick Double Lines.
///<para>When the item is serialized out as xml, its value is "thinThick".</para>
///</summary>
[EnumString("thinThick")]
ThinThick,
///<summary>
///Thin Thick Thin Triple Lines.
///<para>When the item is serialized out as xml, its value is "tri".</para>
///</summary>
[EnumString("tri")]
Triple,
 
}
/// <summary>
/// On/Off Style Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BooleanStyleValues
{  
	///<summary>
///On.
///<para>When the item is serialized out as xml, its value is "on".</para>
///</summary>
[EnumString("on")]
On,
///<summary>
///Off.
///<para>When the item is serialized out as xml, its value is "off".</para>
///</summary>
[EnumString("off")]
Off,
///<summary>
///Default.
///<para>When the item is serialized out as xml, its value is "def".</para>
///</summary>
[EnumString("def")]
Default,
 
}
/// <summary>
/// Text Vertical Overflow 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextVerticalOverflowValues
{  
	///<summary>
///Text Overflow Enum ( Overflow ).
///<para>When the item is serialized out as xml, its value is "overflow".</para>
///</summary>
[EnumString("overflow")]
Overflow,
///<summary>
///Text Overflow Enum ( Ellipsis ).
///<para>When the item is serialized out as xml, its value is "ellipsis".</para>
///</summary>
[EnumString("ellipsis")]
Ellipsis,
///<summary>
///Text Overflow Enum ( Clip ).
///<para>When the item is serialized out as xml, its value is "clip".</para>
///</summary>
[EnumString("clip")]
Clip,
 
}
/// <summary>
/// Text Horizontal Overflow Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextHorizontalOverflowValues
{  
	///<summary>
///Text Horizontal Overflow Enum ( Overflow ).
///<para>When the item is serialized out as xml, its value is "overflow".</para>
///</summary>
[EnumString("overflow")]
Overflow,
///<summary>
///Text Horizontal Overflow Enum ( Clip ).
///<para>When the item is serialized out as xml, its value is "clip".</para>
///</summary>
[EnumString("clip")]
Clip,
 
}
/// <summary>
/// Vertical Text Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextVerticalValues
{  
	///<summary>
///Vertical Text Type Enum ( Horizontal ).
///<para>When the item is serialized out as xml, its value is "horz".</para>
///</summary>
[EnumString("horz")]
Horizontal,
///<summary>
///Vertical Text Type Enum ( Vertical ).
///<para>When the item is serialized out as xml, its value is "vert".</para>
///</summary>
[EnumString("vert")]
Vertical,
///<summary>
///Vertical Text Type Enum ( Vertical 270 ).
///<para>When the item is serialized out as xml, its value is "vert270".</para>
///</summary>
[EnumString("vert270")]
Vertical270,
///<summary>
///Vertical Text Type Enum ( WordArt Vertical ).
///<para>When the item is serialized out as xml, its value is "wordArtVert".</para>
///</summary>
[EnumString("wordArtVert")]
WordArtVertical,
///<summary>
///Vertical Text Type Enum ( East Asian Vertical ).
///<para>When the item is serialized out as xml, its value is "eaVert".</para>
///</summary>
[EnumString("eaVert")]
EastAsianVetical,
///<summary>
///Vertical Text Type Enum ( Mongolian Vertical ).
///<para>When the item is serialized out as xml, its value is "mongolianVert".</para>
///</summary>
[EnumString("mongolianVert")]
MongolianVertical,
///<summary>
///Vertical WordArt Right to Left.
///<para>When the item is serialized out as xml, its value is "wordArtVertRtl".</para>
///</summary>
[EnumString("wordArtVertRtl")]
WordArtLeftToRight,
 
}
/// <summary>
/// Text Wrapping Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextWrappingValues
{  
	///<summary>
///Text Wrapping Type Enum ( None ).
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Text Wrapping Type Enum ( Square ).
///<para>When the item is serialized out as xml, its value is "square".</para>
///</summary>
[EnumString("square")]
Square,
 
}
/// <summary>
/// Text Anchoring Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextAnchoringTypeValues
{  
	///<summary>
///Text Anchoring Type Enum ( Top ).
///<para>When the item is serialized out as xml, its value is "t".</para>
///</summary>
[EnumString("t")]
Top,
///<summary>
///Text Anchor Enum ( Center ).
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Text Anchor Enum ( Bottom ).
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Bottom,
 
}
/// <summary>
/// Text Auto-number Schemes 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextAutoNumberSchemeValues
{  
	///<summary>
///Autonumber Enum ( alphaLcParenBoth ).
///<para>When the item is serialized out as xml, its value is "alphaLcParenBoth".</para>
///</summary>
[EnumString("alphaLcParenBoth")]
AlphaLowerCharacterParenBoth,
///<summary>
///Autonumbering Enum ( alphaUcParenBoth ).
///<para>When the item is serialized out as xml, its value is "alphaUcParenBoth".</para>
///</summary>
[EnumString("alphaUcParenBoth")]
AlphaUpperCharacterParenBoth,
///<summary>
///Autonumbering Enum ( alphaLcParenR ).
///<para>When the item is serialized out as xml, its value is "alphaLcParenR".</para>
///</summary>
[EnumString("alphaLcParenR")]
AlphaLowerCharacterParenR,
///<summary>
///Autonumbering Enum ( alphaUcParenR ).
///<para>When the item is serialized out as xml, its value is "alphaUcParenR".</para>
///</summary>
[EnumString("alphaUcParenR")]
AlphaUpperCharacterParenR,
///<summary>
///Autonumbering Enum ( alphaLcPeriod ).
///<para>When the item is serialized out as xml, its value is "alphaLcPeriod".</para>
///</summary>
[EnumString("alphaLcPeriod")]
AlphaLowerCharacterPeriod,
///<summary>
///Autonumbering Enum ( alphaUcPeriod ).
///<para>When the item is serialized out as xml, its value is "alphaUcPeriod".</para>
///</summary>
[EnumString("alphaUcPeriod")]
AlphaUpperCharacterPeriod,
///<summary>
///Autonumbering Enum ( arabicParenBoth ).
///<para>When the item is serialized out as xml, its value is "arabicParenBoth".</para>
///</summary>
[EnumString("arabicParenBoth")]
ArabicParenBoth,
///<summary>
///Autonumbering Enum ( arabicParenR ).
///<para>When the item is serialized out as xml, its value is "arabicParenR".</para>
///</summary>
[EnumString("arabicParenR")]
ArabicParenR,
///<summary>
///Autonumbering Enum ( arabicPeriod ).
///<para>When the item is serialized out as xml, its value is "arabicPeriod".</para>
///</summary>
[EnumString("arabicPeriod")]
ArabicPeriod,
///<summary>
///Autonumbering Enum ( arabicPlain ).
///<para>When the item is serialized out as xml, its value is "arabicPlain".</para>
///</summary>
[EnumString("arabicPlain")]
ArabicPlain,
///<summary>
///Autonumbering Enum ( romanLcParenBoth ).
///<para>When the item is serialized out as xml, its value is "romanLcParenBoth".</para>
///</summary>
[EnumString("romanLcParenBoth")]
RomanLowerCharacterParenBoth,
///<summary>
///Autonumbering Enum ( romanUcParenBoth ).
///<para>When the item is serialized out as xml, its value is "romanUcParenBoth".</para>
///</summary>
[EnumString("romanUcParenBoth")]
RomanUpperCharacterParenBoth,
///<summary>
///Autonumbering Enum ( romanLcParenR ).
///<para>When the item is serialized out as xml, its value is "romanLcParenR".</para>
///</summary>
[EnumString("romanLcParenR")]
RomanLowerCharacterParenR,
///<summary>
///Autonumbering Enum ( romanUcParenR ).
///<para>When the item is serialized out as xml, its value is "romanUcParenR".</para>
///</summary>
[EnumString("romanUcParenR")]
RomanUpperCharacterParenR,
///<summary>
///Autonumbering Enum ( romanLcPeriod ).
///<para>When the item is serialized out as xml, its value is "romanLcPeriod".</para>
///</summary>
[EnumString("romanLcPeriod")]
RomanLowerCharacterPeriod,
///<summary>
///Autonumbering Enum ( romanUcPeriod ).
///<para>When the item is serialized out as xml, its value is "romanUcPeriod".</para>
///</summary>
[EnumString("romanUcPeriod")]
RomanUpperCharacterPeriod,
///<summary>
///Autonumbering Enum ( circleNumDbPlain ).
///<para>When the item is serialized out as xml, its value is "circleNumDbPlain".</para>
///</summary>
[EnumString("circleNumDbPlain")]
CircleNumberDoubleBytePlain,
///<summary>
///Autonumbering Enum ( circleNumWdBlackPlain ).
///<para>When the item is serialized out as xml, its value is "circleNumWdBlackPlain".</para>
///</summary>
[EnumString("circleNumWdBlackPlain")]
CircleNumberWingdingsBlackPlain,
///<summary>
///Autonumbering Enum ( circleNumWdWhitePlain ).
///<para>When the item is serialized out as xml, its value is "circleNumWdWhitePlain".</para>
///</summary>
[EnumString("circleNumWdWhitePlain")]
CircleNumberWingdingsWhitePlain,
///<summary>
///Autonumbering Enum ( arabicDbPeriod ).
///<para>When the item is serialized out as xml, its value is "arabicDbPeriod".</para>
///</summary>
[EnumString("arabicDbPeriod")]
ArabicDoubleBytePeriod,
///<summary>
///Autonumbering Enum ( arabicDbPlain ).
///<para>When the item is serialized out as xml, its value is "arabicDbPlain".</para>
///</summary>
[EnumString("arabicDbPlain")]
ArabicDoubleBytePlain,
///<summary>
///Autonumbering Enum ( ea1ChsPeriod ).
///<para>When the item is serialized out as xml, its value is "ea1ChsPeriod".</para>
///</summary>
[EnumString("ea1ChsPeriod")]
EastAsianSimplifiedChinesePeriod,
///<summary>
///Autonumbering Enum ( ea1ChsPlain ).
///<para>When the item is serialized out as xml, its value is "ea1ChsPlain".</para>
///</summary>
[EnumString("ea1ChsPlain")]
EastAsianSimplifiedChinesePlain,
///<summary>
///Autonumbering Enum ( ea1ChtPeriod ).
///<para>When the item is serialized out as xml, its value is "ea1ChtPeriod".</para>
///</summary>
[EnumString("ea1ChtPeriod")]
EastAsianTraditionalChinesePeriod,
///<summary>
///Autonumbering Enum ( ea1ChtPlain ).
///<para>When the item is serialized out as xml, its value is "ea1ChtPlain".</para>
///</summary>
[EnumString("ea1ChtPlain")]
EastAsianTraditionalChinesePlain,
///<summary>
///Autonumbering Enum ( ea1JpnChsDbPeriod ).
///<para>When the item is serialized out as xml, its value is "ea1JpnChsDbPeriod".</para>
///</summary>
[EnumString("ea1JpnChsDbPeriod")]
EastAsianJapaneseDoubleBytePeriod,
///<summary>
///Autonumbering Enum ( ea1JpnKorPlain ).
///<para>When the item is serialized out as xml, its value is "ea1JpnKorPlain".</para>
///</summary>
[EnumString("ea1JpnKorPlain")]
EastAsianJapaneseKoreanPlain,
///<summary>
///Autonumbering Enum ( ea1JpnKorPeriod ).
///<para>When the item is serialized out as xml, its value is "ea1JpnKorPeriod".</para>
///</summary>
[EnumString("ea1JpnKorPeriod")]
EastAsianJapaneseKoreanPeriod,
///<summary>
///Autonumbering Enum ( arabic1Minus ).
///<para>When the item is serialized out as xml, its value is "arabic1Minus".</para>
///</summary>
[EnumString("arabic1Minus")]
Arabic1Minus,
///<summary>
///Autonumbering Enum ( arabic2Minus ).
///<para>When the item is serialized out as xml, its value is "arabic2Minus".</para>
///</summary>
[EnumString("arabic2Minus")]
Arabic2Minus,
///<summary>
///Autonumbering Enum ( hebrew2Minus ).
///<para>When the item is serialized out as xml, its value is "hebrew2Minus".</para>
///</summary>
[EnumString("hebrew2Minus")]
Hebrew2Minus,
///<summary>
///Autonumbering Enum ( thaiAlphaPeriod ).
///<para>When the item is serialized out as xml, its value is "thaiAlphaPeriod".</para>
///</summary>
[EnumString("thaiAlphaPeriod")]
ThaiAlphaPeriod,
///<summary>
///Autonumbering Enum ( thaiAlphaParenR ).
///<para>When the item is serialized out as xml, its value is "thaiAlphaParenR".</para>
///</summary>
[EnumString("thaiAlphaParenR")]
ThaiAlphaParenthesisRight,
///<summary>
///Autonumbering Enum ( thaiAlphaParenBoth ).
///<para>When the item is serialized out as xml, its value is "thaiAlphaParenBoth".</para>
///</summary>
[EnumString("thaiAlphaParenBoth")]
ThaiAlphaParenthesisBoth,
///<summary>
///Autonumbering Enum ( thaiNumPeriod ).
///<para>When the item is serialized out as xml, its value is "thaiNumPeriod".</para>
///</summary>
[EnumString("thaiNumPeriod")]
ThaiNumberPeriod,
///<summary>
///Autonumbering Enum ( thaiNumParenR ).
///<para>When the item is serialized out as xml, its value is "thaiNumParenR".</para>
///</summary>
[EnumString("thaiNumParenR")]
ThaiNumberParenthesisRight,
///<summary>
///Autonumbering Enum ( thaiNumParenBoth ).
///<para>When the item is serialized out as xml, its value is "thaiNumParenBoth".</para>
///</summary>
[EnumString("thaiNumParenBoth")]
ThaiNumberParenthesisBoth,
///<summary>
///Autonumbering Enum ( hindiAlphaPeriod ).
///<para>When the item is serialized out as xml, its value is "hindiAlphaPeriod".</para>
///</summary>
[EnumString("hindiAlphaPeriod")]
HindiAlphaPeriod,
///<summary>
///Autonumbering Enum ( hindiNumPeriod ).
///<para>When the item is serialized out as xml, its value is "hindiNumPeriod".</para>
///</summary>
[EnumString("hindiNumPeriod")]
HindiNumPeriod,
///<summary>
///Autonumbering Enum ( hindiNumParenR ).
///<para>When the item is serialized out as xml, its value is "hindiNumParenR".</para>
///</summary>
[EnumString("hindiNumParenR")]
HindiNumberParenthesisRight,
///<summary>
///Autonumbering Enum ( hindiAlpha1Period ).
///<para>When the item is serialized out as xml, its value is "hindiAlpha1Period".</para>
///</summary>
[EnumString("hindiAlpha1Period")]
HindiAlpha1Period,
 
}
/// <summary>
/// Text Underline Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextUnderlineValues
{  
	///<summary>
///Text Underline Enum ( None ).
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Text Underline Enum ( Words ).
///<para>When the item is serialized out as xml, its value is "words".</para>
///</summary>
[EnumString("words")]
Words,
///<summary>
///Text Underline Enum ( Single ).
///<para>When the item is serialized out as xml, its value is "sng".</para>
///</summary>
[EnumString("sng")]
Single,
///<summary>
///Text Underline Enum ( Double ).
///<para>When the item is serialized out as xml, its value is "dbl".</para>
///</summary>
[EnumString("dbl")]
Double,
///<summary>
///Text Underline Enum ( Heavy ).
///<para>When the item is serialized out as xml, its value is "heavy".</para>
///</summary>
[EnumString("heavy")]
Heavy,
///<summary>
///Text Underline Enum ( Dotted ).
///<para>When the item is serialized out as xml, its value is "dotted".</para>
///</summary>
[EnumString("dotted")]
Dotted,
///<summary>
///Text Underline Enum ( Heavy Dotted  ).
///<para>When the item is serialized out as xml, its value is "dottedHeavy".</para>
///</summary>
[EnumString("dottedHeavy")]
HeavyDotted,
///<summary>
///Text Underline Enum ( Dashed ).
///<para>When the item is serialized out as xml, its value is "dash".</para>
///</summary>
[EnumString("dash")]
Dash,
///<summary>
///Text Underline Enum ( Heavy Dashed ).
///<para>When the item is serialized out as xml, its value is "dashHeavy".</para>
///</summary>
[EnumString("dashHeavy")]
DashHeavy,
///<summary>
///Text Underline Enum ( Long Dashed ).
///<para>When the item is serialized out as xml, its value is "dashLong".</para>
///</summary>
[EnumString("dashLong")]
DashLong,
///<summary>
///Text Underline Enum ( Heavy Long Dashed ).
///<para>When the item is serialized out as xml, its value is "dashLongHeavy".</para>
///</summary>
[EnumString("dashLongHeavy")]
DashLongHeavy,
///<summary>
///Text Underline Enum ( Dot Dash ).
///<para>When the item is serialized out as xml, its value is "dotDash".</para>
///</summary>
[EnumString("dotDash")]
DotDash,
///<summary>
///Text Underline Enum ( Heavy Dot Dash ).
///<para>When the item is serialized out as xml, its value is "dotDashHeavy".</para>
///</summary>
[EnumString("dotDashHeavy")]
DotDashHeavy,
///<summary>
///Text Underline Enum ( Dot Dot Dash ).
///<para>When the item is serialized out as xml, its value is "dotDotDash".</para>
///</summary>
[EnumString("dotDotDash")]
DotDotDash,
///<summary>
///Text Underline Enum ( Heavy Dot Dot Dash ).
///<para>When the item is serialized out as xml, its value is "dotDotDashHeavy".</para>
///</summary>
[EnumString("dotDotDashHeavy")]
DotDotDashHeavy,
///<summary>
///Text Underline Enum ( Wavy ).
///<para>When the item is serialized out as xml, its value is "wavy".</para>
///</summary>
[EnumString("wavy")]
Wavy,
///<summary>
///Text Underline Enum ( Heavy Wavy ).
///<para>When the item is serialized out as xml, its value is "wavyHeavy".</para>
///</summary>
[EnumString("wavyHeavy")]
WavyHeavy,
///<summary>
///Text Underline Enum ( Double Wavy ).
///<para>When the item is serialized out as xml, its value is "wavyDbl".</para>
///</summary>
[EnumString("wavyDbl")]
WavyDouble,
 
}
/// <summary>
/// Text Strike Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextStrikeValues
{  
	///<summary>
///Text Strike Enum ( No Strike ).
///<para>When the item is serialized out as xml, its value is "noStrike".</para>
///</summary>
[EnumString("noStrike")]
NoStrike,
///<summary>
///Text Strike Enum ( Single Strike ).
///<para>When the item is serialized out as xml, its value is "sngStrike".</para>
///</summary>
[EnumString("sngStrike")]
SingleStrike,
///<summary>
///Text Strike Enum ( Double Strike ).
///<para>When the item is serialized out as xml, its value is "dblStrike".</para>
///</summary>
[EnumString("dblStrike")]
DoubleStrike,
 
}
/// <summary>
/// Text Cap Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextCapsValues
{  
	///<summary>
///Text Caps Enum ( None ).
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Text Caps Enum ( Small ).
///<para>When the item is serialized out as xml, its value is "small".</para>
///</summary>
[EnumString("small")]
Small,
///<summary>
///Text Caps Enum ( All ).
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
 
}
/// <summary>
/// Text Tab Alignment Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextTabAlignmentValues
{  
	///<summary>
///Text Tab Alignment Enum ( Left).
///<para>When the item is serialized out as xml, its value is "l".</para>
///</summary>
[EnumString("l")]
Left,
///<summary>
///Text Tab Alignment Enum ( Center ).
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Text Tab Alignment Enum ( Right ).
///<para>When the item is serialized out as xml, its value is "r".</para>
///</summary>
[EnumString("r")]
Right,
///<summary>
///Text Tab Alignment Enum ( Decimal ).
///<para>When the item is serialized out as xml, its value is "dec".</para>
///</summary>
[EnumString("dec")]
Decimal,
 
}
/// <summary>
/// Text Alignment Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextAlignmentTypeValues
{  
	///<summary>
///Text Alignment Enum ( Left ).
///<para>When the item is serialized out as xml, its value is "l".</para>
///</summary>
[EnumString("l")]
Left,
///<summary>
///Text Alignment Enum ( Center ).
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Text Alignment Enum ( Right ).
///<para>When the item is serialized out as xml, its value is "r".</para>
///</summary>
[EnumString("r")]
Right,
///<summary>
///Text Alignment Enum ( Justified ).
///<para>When the item is serialized out as xml, its value is "just".</para>
///</summary>
[EnumString("just")]
Justified,
///<summary>
///Text Alignment Enum ( Justified Low ).
///<para>When the item is serialized out as xml, its value is "justLow".</para>
///</summary>
[EnumString("justLow")]
JustifiedLow,
///<summary>
///Text Alignment Enum ( Distributed ).
///<para>When the item is serialized out as xml, its value is "dist".</para>
///</summary>
[EnumString("dist")]
Distributed,
///<summary>
///Text Alignment Enum ( Thai Distributed ).
///<para>When the item is serialized out as xml, its value is "thaiDist".</para>
///</summary>
[EnumString("thaiDist")]
ThaiDistributed,
 
}
/// <summary>
/// Font Alignment Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextFontAlignmentValues
{  
	///<summary>
///Font Alignment Enum ( Automatic ).
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Automatic,
///<summary>
///Font Alignment Enum ( Top ).
///<para>When the item is serialized out as xml, its value is "t".</para>
///</summary>
[EnumString("t")]
Top,
///<summary>
///Font Alignment Enum ( Center ).
///<para>When the item is serialized out as xml, its value is "ctr".</para>
///</summary>
[EnumString("ctr")]
Center,
///<summary>
///Font Alignment Enum ( Baseline ).
///<para>When the item is serialized out as xml, its value is "base".</para>
///</summary>
[EnumString("base")]
Baseline,
///<summary>
///Font Alignment Enum ( Bottom ).
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Bottom,
 
}
/// <summary>
/// Preset Color Value 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetColorValues
{  
	///<summary>
///Alice Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "aliceBlue".</para>
///</summary>
[EnumString("aliceBlue")]
AliceBlue,
///<summary>
///Antique White Preset Color.
///<para>When the item is serialized out as xml, its value is "antiqueWhite".</para>
///</summary>
[EnumString("antiqueWhite")]
AntiqueWhite,
///<summary>
///Aqua Preset Color.
///<para>When the item is serialized out as xml, its value is "aqua".</para>
///</summary>
[EnumString("aqua")]
Aqua,
///<summary>
///Aquamarine Preset Color.
///<para>When the item is serialized out as xml, its value is "aquamarine".</para>
///</summary>
[EnumString("aquamarine")]
Aquamarine,
///<summary>
///Azure Preset Color.
///<para>When the item is serialized out as xml, its value is "azure".</para>
///</summary>
[EnumString("azure")]
Azure,
///<summary>
///Beige Preset Color.
///<para>When the item is serialized out as xml, its value is "beige".</para>
///</summary>
[EnumString("beige")]
Beige,
///<summary>
///Bisque Preset Color.
///<para>When the item is serialized out as xml, its value is "bisque".</para>
///</summary>
[EnumString("bisque")]
Bisque,
///<summary>
///Black Preset Color.
///<para>When the item is serialized out as xml, its value is "black".</para>
///</summary>
[EnumString("black")]
Black,
///<summary>
///Blanched Almond Preset Color.
///<para>When the item is serialized out as xml, its value is "blanchedAlmond".</para>
///</summary>
[EnumString("blanchedAlmond")]
BlanchedAlmond,
///<summary>
///Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "blue".</para>
///</summary>
[EnumString("blue")]
Blue,
///<summary>
///Blue Violet Preset Color.
///<para>When the item is serialized out as xml, its value is "blueViolet".</para>
///</summary>
[EnumString("blueViolet")]
BlueViolet,
///<summary>
///Brown Preset Color.
///<para>When the item is serialized out as xml, its value is "brown".</para>
///</summary>
[EnumString("brown")]
Brown,
///<summary>
///Burly Wood Preset Color.
///<para>When the item is serialized out as xml, its value is "burlyWood".</para>
///</summary>
[EnumString("burlyWood")]
BurlyWood,
///<summary>
///Cadet Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "cadetBlue".</para>
///</summary>
[EnumString("cadetBlue")]
CadetBlue,
///<summary>
///Chartreuse Preset Color.
///<para>When the item is serialized out as xml, its value is "chartreuse".</para>
///</summary>
[EnumString("chartreuse")]
Chartreuse,
///<summary>
///Chocolate Preset Color.
///<para>When the item is serialized out as xml, its value is "chocolate".</para>
///</summary>
[EnumString("chocolate")]
Chocolate,
///<summary>
///Coral Preset Color.
///<para>When the item is serialized out as xml, its value is "coral".</para>
///</summary>
[EnumString("coral")]
Coral,
///<summary>
///Cornflower Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "cornflowerBlue".</para>
///</summary>
[EnumString("cornflowerBlue")]
CornflowerBlue,
///<summary>
///Cornsilk Preset Color.
///<para>When the item is serialized out as xml, its value is "cornsilk".</para>
///</summary>
[EnumString("cornsilk")]
Cornsilk,
///<summary>
///Crimson Preset Color.
///<para>When the item is serialized out as xml, its value is "crimson".</para>
///</summary>
[EnumString("crimson")]
Crimson,
///<summary>
///Cyan Preset Color.
///<para>When the item is serialized out as xml, its value is "cyan".</para>
///</summary>
[EnumString("cyan")]
Cyan,
///<summary>
///Dark Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "dkBlue".</para>
///</summary>
[EnumString("dkBlue")]
DarkBlue,
///<summary>
///Dark Cyan Preset Color.
///<para>When the item is serialized out as xml, its value is "dkCyan".</para>
///</summary>
[EnumString("dkCyan")]
DarkCyan,
///<summary>
///Dark Goldenrod Preset Color.
///<para>When the item is serialized out as xml, its value is "dkGoldenrod".</para>
///</summary>
[EnumString("dkGoldenrod")]
DarkGoldenrod,
///<summary>
///Dark Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "dkGray".</para>
///</summary>
[EnumString("dkGray")]
DarkGray,
///<summary>
///Dark Green Preset Color.
///<para>When the item is serialized out as xml, its value is "dkGreen".</para>
///</summary>
[EnumString("dkGreen")]
DarkGreen,
///<summary>
///Dark Khaki Preset Color.
///<para>When the item is serialized out as xml, its value is "dkKhaki".</para>
///</summary>
[EnumString("dkKhaki")]
DarkKhaki,
///<summary>
///Dark Magenta Preset Color.
///<para>When the item is serialized out as xml, its value is "dkMagenta".</para>
///</summary>
[EnumString("dkMagenta")]
DarkMagenta,
///<summary>
///Dark Olive Green Preset Color.
///<para>When the item is serialized out as xml, its value is "dkOliveGreen".</para>
///</summary>
[EnumString("dkOliveGreen")]
DarkOliveGreen,
///<summary>
///Dark Orange Preset Color.
///<para>When the item is serialized out as xml, its value is "dkOrange".</para>
///</summary>
[EnumString("dkOrange")]
DarkOrange,
///<summary>
///Dark Orchid Preset Color.
///<para>When the item is serialized out as xml, its value is "dkOrchid".</para>
///</summary>
[EnumString("dkOrchid")]
DarkOrchid,
///<summary>
///Dark Red Preset Color.
///<para>When the item is serialized out as xml, its value is "dkRed".</para>
///</summary>
[EnumString("dkRed")]
DarkRed,
///<summary>
///Dark Salmon Preset Color.
///<para>When the item is serialized out as xml, its value is "dkSalmon".</para>
///</summary>
[EnumString("dkSalmon")]
DarkSalmon,
///<summary>
///Dark Sea Green Preset Color.
///<para>When the item is serialized out as xml, its value is "dkSeaGreen".</para>
///</summary>
[EnumString("dkSeaGreen")]
DarkSeaGreen,
///<summary>
///Dark Slate Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "dkSlateBlue".</para>
///</summary>
[EnumString("dkSlateBlue")]
DarkSlateBlue,
///<summary>
///Dark Slate Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "dkSlateGray".</para>
///</summary>
[EnumString("dkSlateGray")]
DarkSlateGray,
///<summary>
///Dark Turquoise Preset Color.
///<para>When the item is serialized out as xml, its value is "dkTurquoise".</para>
///</summary>
[EnumString("dkTurquoise")]
DarkTurquoise,
///<summary>
///Dark Violet Preset Color.
///<para>When the item is serialized out as xml, its value is "dkViolet".</para>
///</summary>
[EnumString("dkViolet")]
DarkViolet,
///<summary>
///Deep Pink Preset Color.
///<para>When the item is serialized out as xml, its value is "deepPink".</para>
///</summary>
[EnumString("deepPink")]
DeepPink,
///<summary>
///Deep Sky Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "deepSkyBlue".</para>
///</summary>
[EnumString("deepSkyBlue")]
DeepSkyBlue,
///<summary>
///Dim Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "dimGray".</para>
///</summary>
[EnumString("dimGray")]
DimGray,
///<summary>
///Dodger Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "dodgerBlue".</para>
///</summary>
[EnumString("dodgerBlue")]
DodgerBlue,
///<summary>
///Firebrick Preset Color.
///<para>When the item is serialized out as xml, its value is "firebrick".</para>
///</summary>
[EnumString("firebrick")]
Firebrick,
///<summary>
///Floral White Preset Color.
///<para>When the item is serialized out as xml, its value is "floralWhite".</para>
///</summary>
[EnumString("floralWhite")]
FloralWhite,
///<summary>
///Forest Green Preset Color.
///<para>When the item is serialized out as xml, its value is "forestGreen".</para>
///</summary>
[EnumString("forestGreen")]
ForestGreen,
///<summary>
///Fuchsia Preset Color.
///<para>When the item is serialized out as xml, its value is "fuchsia".</para>
///</summary>
[EnumString("fuchsia")]
Fuchsia,
///<summary>
///Gainsboro Preset Color.
///<para>When the item is serialized out as xml, its value is "gainsboro".</para>
///</summary>
[EnumString("gainsboro")]
Gainsboro,
///<summary>
///Ghost White Preset Color.
///<para>When the item is serialized out as xml, its value is "ghostWhite".</para>
///</summary>
[EnumString("ghostWhite")]
GhostWhite,
///<summary>
///Gold Preset Color.
///<para>When the item is serialized out as xml, its value is "gold".</para>
///</summary>
[EnumString("gold")]
Gold,
///<summary>
///Goldenrod Preset Color.
///<para>When the item is serialized out as xml, its value is "goldenrod".</para>
///</summary>
[EnumString("goldenrod")]
Goldenrod,
///<summary>
///Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "gray".</para>
///</summary>
[EnumString("gray")]
Gray,
///<summary>
///Green Preset Color.
///<para>When the item is serialized out as xml, its value is "green".</para>
///</summary>
[EnumString("green")]
Green,
///<summary>
///Green Yellow Preset Color.
///<para>When the item is serialized out as xml, its value is "greenYellow".</para>
///</summary>
[EnumString("greenYellow")]
GreenYellow,
///<summary>
///Honeydew Preset Color.
///<para>When the item is serialized out as xml, its value is "honeydew".</para>
///</summary>
[EnumString("honeydew")]
Honeydew,
///<summary>
///Hot Pink Preset Color.
///<para>When the item is serialized out as xml, its value is "hotPink".</para>
///</summary>
[EnumString("hotPink")]
HotPink,
///<summary>
///Indian Red Preset Color.
///<para>When the item is serialized out as xml, its value is "indianRed".</para>
///</summary>
[EnumString("indianRed")]
IndianRed,
///<summary>
///Indigo Preset Color.
///<para>When the item is serialized out as xml, its value is "indigo".</para>
///</summary>
[EnumString("indigo")]
Indigo,
///<summary>
///Ivory Preset Color.
///<para>When the item is serialized out as xml, its value is "ivory".</para>
///</summary>
[EnumString("ivory")]
Ivory,
///<summary>
///Khaki Preset Color.
///<para>When the item is serialized out as xml, its value is "khaki".</para>
///</summary>
[EnumString("khaki")]
Khaki,
///<summary>
///Lavender Preset Color.
///<para>When the item is serialized out as xml, its value is "lavender".</para>
///</summary>
[EnumString("lavender")]
Lavender,
///<summary>
///Lavender Blush Preset Color.
///<para>When the item is serialized out as xml, its value is "lavenderBlush".</para>
///</summary>
[EnumString("lavenderBlush")]
LavenderBlush,
///<summary>
///Lawn Green Preset Color.
///<para>When the item is serialized out as xml, its value is "lawnGreen".</para>
///</summary>
[EnumString("lawnGreen")]
LawnGreen,
///<summary>
///Lemon Chiffon Preset Color.
///<para>When the item is serialized out as xml, its value is "lemonChiffon".</para>
///</summary>
[EnumString("lemonChiffon")]
LemonChiffon,
///<summary>
///Light Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "ltBlue".</para>
///</summary>
[EnumString("ltBlue")]
LightBlue,
///<summary>
///Light Coral Preset Color.
///<para>When the item is serialized out as xml, its value is "ltCoral".</para>
///</summary>
[EnumString("ltCoral")]
LightCoral,
///<summary>
///Light Cyan Preset Color.
///<para>When the item is serialized out as xml, its value is "ltCyan".</para>
///</summary>
[EnumString("ltCyan")]
LightCyan,
///<summary>
///Light Goldenrod Yellow Preset Color.
///<para>When the item is serialized out as xml, its value is "ltGoldenrodYellow".</para>
///</summary>
[EnumString("ltGoldenrodYellow")]
LightGoldenrodYellow,
///<summary>
///Light Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "ltGray".</para>
///</summary>
[EnumString("ltGray")]
LightGray,
///<summary>
///Light Green Preset Color.
///<para>When the item is serialized out as xml, its value is "ltGreen".</para>
///</summary>
[EnumString("ltGreen")]
LightGreen,
///<summary>
///Light Pink Preset Color.
///<para>When the item is serialized out as xml, its value is "ltPink".</para>
///</summary>
[EnumString("ltPink")]
LightPink,
///<summary>
///Light Salmon Preset Color.
///<para>When the item is serialized out as xml, its value is "ltSalmon".</para>
///</summary>
[EnumString("ltSalmon")]
LightSalmon,
///<summary>
///Light Sea Green Preset Color.
///<para>When the item is serialized out as xml, its value is "ltSeaGreen".</para>
///</summary>
[EnumString("ltSeaGreen")]
LightSeaGreen,
///<summary>
///Light Sky Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "ltSkyBlue".</para>
///</summary>
[EnumString("ltSkyBlue")]
LightSkyBlue,
///<summary>
///Light Slate Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "ltSlateGray".</para>
///</summary>
[EnumString("ltSlateGray")]
LightSlateGray,
///<summary>
///Light Steel Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "ltSteelBlue".</para>
///</summary>
[EnumString("ltSteelBlue")]
LightSteelBlue,
///<summary>
///Light Yellow Preset Color.
///<para>When the item is serialized out as xml, its value is "ltYellow".</para>
///</summary>
[EnumString("ltYellow")]
LightYellow,
///<summary>
///Lime Preset Color.
///<para>When the item is serialized out as xml, its value is "lime".</para>
///</summary>
[EnumString("lime")]
Lime,
///<summary>
///Lime Green Preset Color.
///<para>When the item is serialized out as xml, its value is "limeGreen".</para>
///</summary>
[EnumString("limeGreen")]
LimeGreen,
///<summary>
///Linen Preset Color.
///<para>When the item is serialized out as xml, its value is "linen".</para>
///</summary>
[EnumString("linen")]
Linen,
///<summary>
///Magenta Preset Color.
///<para>When the item is serialized out as xml, its value is "magenta".</para>
///</summary>
[EnumString("magenta")]
Magenta,
///<summary>
///Maroon Preset Color.
///<para>When the item is serialized out as xml, its value is "maroon".</para>
///</summary>
[EnumString("maroon")]
Maroon,
///<summary>
///Medium Aquamarine Preset Color.
///<para>When the item is serialized out as xml, its value is "medAquamarine".</para>
///</summary>
[EnumString("medAquamarine")]
MedAquamarine,
///<summary>
///Medium Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "medBlue".</para>
///</summary>
[EnumString("medBlue")]
MediumBlue,
///<summary>
///Medium Orchid Preset Color.
///<para>When the item is serialized out as xml, its value is "medOrchid".</para>
///</summary>
[EnumString("medOrchid")]
MediumOrchid,
///<summary>
///Medium Purple Preset Color.
///<para>When the item is serialized out as xml, its value is "medPurple".</para>
///</summary>
[EnumString("medPurple")]
MediumPurple,
///<summary>
///Medium Sea Green Preset Color.
///<para>When the item is serialized out as xml, its value is "medSeaGreen".</para>
///</summary>
[EnumString("medSeaGreen")]
MediumSeaGreen,
///<summary>
///Medium Slate Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "medSlateBlue".</para>
///</summary>
[EnumString("medSlateBlue")]
MediumSlateBlue,
///<summary>
///Medium Spring Green Preset Color.
///<para>When the item is serialized out as xml, its value is "medSpringGreen".</para>
///</summary>
[EnumString("medSpringGreen")]
MediumSpringGreen,
///<summary>
///Medium Turquoise Preset Color.
///<para>When the item is serialized out as xml, its value is "medTurquoise".</para>
///</summary>
[EnumString("medTurquoise")]
MediumTurquoise,
///<summary>
///Medium Violet Red Preset Color.
///<para>When the item is serialized out as xml, its value is "medVioletRed".</para>
///</summary>
[EnumString("medVioletRed")]
MediumVioletRed,
///<summary>
///Midnight Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "midnightBlue".</para>
///</summary>
[EnumString("midnightBlue")]
MidnightBlue,
///<summary>
///Mint Cream Preset Color.
///<para>When the item is serialized out as xml, its value is "mintCream".</para>
///</summary>
[EnumString("mintCream")]
MintCream,
///<summary>
///Misty Rose Preset Color.
///<para>When the item is serialized out as xml, its value is "mistyRose".</para>
///</summary>
[EnumString("mistyRose")]
MistyRose,
///<summary>
///Moccasin Preset Color.
///<para>When the item is serialized out as xml, its value is "moccasin".</para>
///</summary>
[EnumString("moccasin")]
Moccasin,
///<summary>
///Navajo White Preset Color.
///<para>When the item is serialized out as xml, its value is "navajoWhite".</para>
///</summary>
[EnumString("navajoWhite")]
NavajoWhite,
///<summary>
///Navy Preset Color.
///<para>When the item is serialized out as xml, its value is "navy".</para>
///</summary>
[EnumString("navy")]
Navy,
///<summary>
///Old Lace Preset Color.
///<para>When the item is serialized out as xml, its value is "oldLace".</para>
///</summary>
[EnumString("oldLace")]
OldLace,
///<summary>
///Olive Preset Color.
///<para>When the item is serialized out as xml, its value is "olive".</para>
///</summary>
[EnumString("olive")]
Olive,
///<summary>
///Olive Drab Preset Color.
///<para>When the item is serialized out as xml, its value is "oliveDrab".</para>
///</summary>
[EnumString("oliveDrab")]
OliveDrab,
///<summary>
///Orange Preset Color.
///<para>When the item is serialized out as xml, its value is "orange".</para>
///</summary>
[EnumString("orange")]
Orange,
///<summary>
///Orange Red Preset Color.
///<para>When the item is serialized out as xml, its value is "orangeRed".</para>
///</summary>
[EnumString("orangeRed")]
OrangeRed,
///<summary>
///Orchid Preset Color.
///<para>When the item is serialized out as xml, its value is "orchid".</para>
///</summary>
[EnumString("orchid")]
Orchid,
///<summary>
///Pale Goldenrod Preset Color.
///<para>When the item is serialized out as xml, its value is "paleGoldenrod".</para>
///</summary>
[EnumString("paleGoldenrod")]
PaleGoldenrod,
///<summary>
///Pale Green Preset Color.
///<para>When the item is serialized out as xml, its value is "paleGreen".</para>
///</summary>
[EnumString("paleGreen")]
PaleGreen,
///<summary>
///Pale Turquoise Preset Color.
///<para>When the item is serialized out as xml, its value is "paleTurquoise".</para>
///</summary>
[EnumString("paleTurquoise")]
PaleTurquoise,
///<summary>
///Pale Violet Red Preset Color.
///<para>When the item is serialized out as xml, its value is "paleVioletRed".</para>
///</summary>
[EnumString("paleVioletRed")]
PaleVioletRed,
///<summary>
///Papaya Whip Preset Color.
///<para>When the item is serialized out as xml, its value is "papayaWhip".</para>
///</summary>
[EnumString("papayaWhip")]
PapayaWhip,
///<summary>
///Peach Puff Preset Color.
///<para>When the item is serialized out as xml, its value is "peachPuff".</para>
///</summary>
[EnumString("peachPuff")]
PeachPuff,
///<summary>
///Peru Preset Color.
///<para>When the item is serialized out as xml, its value is "peru".</para>
///</summary>
[EnumString("peru")]
Peru,
///<summary>
///Pink Preset Color.
///<para>When the item is serialized out as xml, its value is "pink".</para>
///</summary>
[EnumString("pink")]
Pink,
///<summary>
///Plum Preset Color.
///<para>When the item is serialized out as xml, its value is "plum".</para>
///</summary>
[EnumString("plum")]
Plum,
///<summary>
///Powder Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "powderBlue".</para>
///</summary>
[EnumString("powderBlue")]
PowderBlue,
///<summary>
///Purple Preset Color.
///<para>When the item is serialized out as xml, its value is "purple".</para>
///</summary>
[EnumString("purple")]
Purple,
///<summary>
///Red Preset Color.
///<para>When the item is serialized out as xml, its value is "red".</para>
///</summary>
[EnumString("red")]
Red,
///<summary>
///Rosy Brown Preset Color.
///<para>When the item is serialized out as xml, its value is "rosyBrown".</para>
///</summary>
[EnumString("rosyBrown")]
RosyBrown,
///<summary>
///Royal Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "royalBlue".</para>
///</summary>
[EnumString("royalBlue")]
RoyalBlue,
///<summary>
///Saddle Brown Preset Color.
///<para>When the item is serialized out as xml, its value is "saddleBrown".</para>
///</summary>
[EnumString("saddleBrown")]
SaddleBrown,
///<summary>
///Salmon Preset Color.
///<para>When the item is serialized out as xml, its value is "salmon".</para>
///</summary>
[EnumString("salmon")]
Salmon,
///<summary>
///Sandy Brown Preset Color.
///<para>When the item is serialized out as xml, its value is "sandyBrown".</para>
///</summary>
[EnumString("sandyBrown")]
SandyBrown,
///<summary>
///Sea Green Preset Color.
///<para>When the item is serialized out as xml, its value is "seaGreen".</para>
///</summary>
[EnumString("seaGreen")]
SeaGreen,
///<summary>
///Sea Shell Preset Color.
///<para>When the item is serialized out as xml, its value is "seaShell".</para>
///</summary>
[EnumString("seaShell")]
SeaShell,
///<summary>
///Sienna Preset Color.
///<para>When the item is serialized out as xml, its value is "sienna".</para>
///</summary>
[EnumString("sienna")]
Sienna,
///<summary>
///Silver Preset Color.
///<para>When the item is serialized out as xml, its value is "silver".</para>
///</summary>
[EnumString("silver")]
Silver,
///<summary>
///Sky Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "skyBlue".</para>
///</summary>
[EnumString("skyBlue")]
SkyBlue,
///<summary>
///Slate Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "slateBlue".</para>
///</summary>
[EnumString("slateBlue")]
SlateBlue,
///<summary>
///Slate Gray Preset Color.
///<para>When the item is serialized out as xml, its value is "slateGray".</para>
///</summary>
[EnumString("slateGray")]
SlateGray,
///<summary>
///Snow Preset Color.
///<para>When the item is serialized out as xml, its value is "snow".</para>
///</summary>
[EnumString("snow")]
Snow,
///<summary>
///Spring Green Preset Color.
///<para>When the item is serialized out as xml, its value is "springGreen".</para>
///</summary>
[EnumString("springGreen")]
SpringGreen,
///<summary>
///Steel Blue Preset Color.
///<para>When the item is serialized out as xml, its value is "steelBlue".</para>
///</summary>
[EnumString("steelBlue")]
SteelBlue,
///<summary>
///Tan Preset Color.
///<para>When the item is serialized out as xml, its value is "tan".</para>
///</summary>
[EnumString("tan")]
Tan,
///<summary>
///Teal Preset Color.
///<para>When the item is serialized out as xml, its value is "teal".</para>
///</summary>
[EnumString("teal")]
Teal,
///<summary>
///Thistle Preset Color.
///<para>When the item is serialized out as xml, its value is "thistle".</para>
///</summary>
[EnumString("thistle")]
Thistle,
///<summary>
///Tomato Preset Color.
///<para>When the item is serialized out as xml, its value is "tomato".</para>
///</summary>
[EnumString("tomato")]
Tomato,
///<summary>
///Turquoise Preset Color.
///<para>When the item is serialized out as xml, its value is "turquoise".</para>
///</summary>
[EnumString("turquoise")]
Turquoise,
///<summary>
///Violet Preset Color.
///<para>When the item is serialized out as xml, its value is "violet".</para>
///</summary>
[EnumString("violet")]
Violet,
///<summary>
///Wheat Preset Color.
///<para>When the item is serialized out as xml, its value is "wheat".</para>
///</summary>
[EnumString("wheat")]
Wheat,
///<summary>
///White Preset Color.
///<para>When the item is serialized out as xml, its value is "white".</para>
///</summary>
[EnumString("white")]
White,
///<summary>
///White Smoke Preset Color.
///<para>When the item is serialized out as xml, its value is "whiteSmoke".</para>
///</summary>
[EnumString("whiteSmoke")]
WhiteSmoke,
///<summary>
///Yellow Preset Color.
///<para>When the item is serialized out as xml, its value is "yellow".</para>
///</summary>
[EnumString("yellow")]
Yellow,
///<summary>
///Yellow Green Preset Color.
///<para>When the item is serialized out as xml, its value is "yellowGreen".</para>
///</summary>
[EnumString("yellowGreen")]
YellowGreen,
///<summary>
///darkBlue.
///<para>When the item is serialized out as xml, its value is "darkBlue".</para>
///</summary>
[EnumString("darkBlue")]
DarkBlue2010,
///<summary>
///darkCyan.
///<para>When the item is serialized out as xml, its value is "darkCyan".</para>
///</summary>
[EnumString("darkCyan")]
DarkCyan2010,
///<summary>
///darkGoldenrod.
///<para>When the item is serialized out as xml, its value is "darkGoldenrod".</para>
///</summary>
[EnumString("darkGoldenrod")]
DarkGoldenrod2010,
///<summary>
///darkGray.
///<para>When the item is serialized out as xml, its value is "darkGray".</para>
///</summary>
[EnumString("darkGray")]
DarkGray2010,
///<summary>
///darkGrey.
///<para>When the item is serialized out as xml, its value is "darkGrey".</para>
///</summary>
[EnumString("darkGrey")]
DarkGrey2010,
///<summary>
///darkGreen.
///<para>When the item is serialized out as xml, its value is "darkGreen".</para>
///</summary>
[EnumString("darkGreen")]
DarkGreen2010,
///<summary>
///darkKhaki.
///<para>When the item is serialized out as xml, its value is "darkKhaki".</para>
///</summary>
[EnumString("darkKhaki")]
DarkKhaki2010,
///<summary>
///darkMagenta.
///<para>When the item is serialized out as xml, its value is "darkMagenta".</para>
///</summary>
[EnumString("darkMagenta")]
DarkMagenta2010,
///<summary>
///darkOliveGreen.
///<para>When the item is serialized out as xml, its value is "darkOliveGreen".</para>
///</summary>
[EnumString("darkOliveGreen")]
DarkOliveGreen2010,
///<summary>
///darkOrange.
///<para>When the item is serialized out as xml, its value is "darkOrange".</para>
///</summary>
[EnumString("darkOrange")]
DarkOrange2010,
///<summary>
///darkOrchid.
///<para>When the item is serialized out as xml, its value is "darkOrchid".</para>
///</summary>
[EnumString("darkOrchid")]
DarkOrchid2010,
///<summary>
///darkRed.
///<para>When the item is serialized out as xml, its value is "darkRed".</para>
///</summary>
[EnumString("darkRed")]
DarkRed2010,
///<summary>
///darkSalmon.
///<para>When the item is serialized out as xml, its value is "darkSalmon".</para>
///</summary>
[EnumString("darkSalmon")]
DarkSalmon2010,
///<summary>
///darkSeaGreen.
///<para>When the item is serialized out as xml, its value is "darkSeaGreen".</para>
///</summary>
[EnumString("darkSeaGreen")]
DarkSeaGreen2010,
///<summary>
///darkSlateBlue.
///<para>When the item is serialized out as xml, its value is "darkSlateBlue".</para>
///</summary>
[EnumString("darkSlateBlue")]
DarkSlateBlue2010,
///<summary>
///darkSlateGray.
///<para>When the item is serialized out as xml, its value is "darkSlateGray".</para>
///</summary>
[EnumString("darkSlateGray")]
DarkSlateGray2010,
///<summary>
///darkSlateGrey.
///<para>When the item is serialized out as xml, its value is "darkSlateGrey".</para>
///</summary>
[EnumString("darkSlateGrey")]
DarkSlateGrey2010,
///<summary>
///darkTurquoise.
///<para>When the item is serialized out as xml, its value is "darkTurquoise".</para>
///</summary>
[EnumString("darkTurquoise")]
DarkTurquoise2010,
///<summary>
///darkViolet.
///<para>When the item is serialized out as xml, its value is "darkViolet".</para>
///</summary>
[EnumString("darkViolet")]
DarkViolet2010,
///<summary>
///lightBlue.
///<para>When the item is serialized out as xml, its value is "lightBlue".</para>
///</summary>
[EnumString("lightBlue")]
LightBlue2010,
///<summary>
///lightCoral.
///<para>When the item is serialized out as xml, its value is "lightCoral".</para>
///</summary>
[EnumString("lightCoral")]
LightCoral2010,
///<summary>
///lightCyan.
///<para>When the item is serialized out as xml, its value is "lightCyan".</para>
///</summary>
[EnumString("lightCyan")]
LightCyan2010,
///<summary>
///lightGoldenrodYellow.
///<para>When the item is serialized out as xml, its value is "lightGoldenrodYellow".</para>
///</summary>
[EnumString("lightGoldenrodYellow")]
LightGoldenrodYellow2010,
///<summary>
///lightGray.
///<para>When the item is serialized out as xml, its value is "lightGray".</para>
///</summary>
[EnumString("lightGray")]
LightGray2010,
///<summary>
///lightGrey.
///<para>When the item is serialized out as xml, its value is "lightGrey".</para>
///</summary>
[EnumString("lightGrey")]
LightGrey2010,
///<summary>
///lightGreen.
///<para>When the item is serialized out as xml, its value is "lightGreen".</para>
///</summary>
[EnumString("lightGreen")]
LightGreen2010,
///<summary>
///lightPink.
///<para>When the item is serialized out as xml, its value is "lightPink".</para>
///</summary>
[EnumString("lightPink")]
LightPink2010,
///<summary>
///lightSalmon.
///<para>When the item is serialized out as xml, its value is "lightSalmon".</para>
///</summary>
[EnumString("lightSalmon")]
LightSalmon2010,
///<summary>
///lightSeaGreen.
///<para>When the item is serialized out as xml, its value is "lightSeaGreen".</para>
///</summary>
[EnumString("lightSeaGreen")]
LightSeaGreen2010,
///<summary>
///lightSkyBlue.
///<para>When the item is serialized out as xml, its value is "lightSkyBlue".</para>
///</summary>
[EnumString("lightSkyBlue")]
LightSkyBlue2010,
///<summary>
///lightSlateGray.
///<para>When the item is serialized out as xml, its value is "lightSlateGray".</para>
///</summary>
[EnumString("lightSlateGray")]
LightSlateGray2010,
///<summary>
///lightSlateGrey.
///<para>When the item is serialized out as xml, its value is "lightSlateGrey".</para>
///</summary>
[EnumString("lightSlateGrey")]
LightSlateGrey2010,
///<summary>
///lightSteelBlue.
///<para>When the item is serialized out as xml, its value is "lightSteelBlue".</para>
///</summary>
[EnumString("lightSteelBlue")]
LightSteelBlue2010,
///<summary>
///lightYellow.
///<para>When the item is serialized out as xml, its value is "lightYellow".</para>
///</summary>
[EnumString("lightYellow")]
LightYellow2010,
///<summary>
///mediumAquamarine.
///<para>When the item is serialized out as xml, its value is "mediumAquamarine".</para>
///</summary>
[EnumString("mediumAquamarine")]
MediumAquamarine2010,
///<summary>
///mediumBlue.
///<para>When the item is serialized out as xml, its value is "mediumBlue".</para>
///</summary>
[EnumString("mediumBlue")]
MediumBlue2010,
///<summary>
///mediumOrchid.
///<para>When the item is serialized out as xml, its value is "mediumOrchid".</para>
///</summary>
[EnumString("mediumOrchid")]
MediumOrchid2010,
///<summary>
///mediumPurple.
///<para>When the item is serialized out as xml, its value is "mediumPurple".</para>
///</summary>
[EnumString("mediumPurple")]
MediumPurple2010,
///<summary>
///mediumSeaGreen.
///<para>When the item is serialized out as xml, its value is "mediumSeaGreen".</para>
///</summary>
[EnumString("mediumSeaGreen")]
MediumSeaGreen2010,
///<summary>
///mediumSlateBlue.
///<para>When the item is serialized out as xml, its value is "mediumSlateBlue".</para>
///</summary>
[EnumString("mediumSlateBlue")]
MediumSlateBlue2010,
///<summary>
///mediumSpringGreen.
///<para>When the item is serialized out as xml, its value is "mediumSpringGreen".</para>
///</summary>
[EnumString("mediumSpringGreen")]
MediumSpringGreen2010,
///<summary>
///mediumTurquoise.
///<para>When the item is serialized out as xml, its value is "mediumTurquoise".</para>
///</summary>
[EnumString("mediumTurquoise")]
MediumTurquoise2010,
///<summary>
///mediumVioletRed.
///<para>When the item is serialized out as xml, its value is "mediumVioletRed".</para>
///</summary>
[EnumString("mediumVioletRed")]
MediumVioletRed2010,
///<summary>
///dkGrey.
///<para>When the item is serialized out as xml, its value is "dkGrey".</para>
///</summary>
[EnumString("dkGrey")]
DarkGrey,
///<summary>
///dimGrey.
///<para>When the item is serialized out as xml, its value is "dimGrey".</para>
///</summary>
[EnumString("dimGrey")]
DimGrey,
///<summary>
///dkSlateGrey.
///<para>When the item is serialized out as xml, its value is "dkSlateGrey".</para>
///</summary>
[EnumString("dkSlateGrey")]
DarkSlateGrey,
///<summary>
///grey.
///<para>When the item is serialized out as xml, its value is "grey".</para>
///</summary>
[EnumString("grey")]
Grey,
///<summary>
///ltGrey.
///<para>When the item is serialized out as xml, its value is "ltGrey".</para>
///</summary>
[EnumString("ltGrey")]
LightGrey,
///<summary>
///ltSlateGrey.
///<para>When the item is serialized out as xml, its value is "ltSlateGrey".</para>
///</summary>
[EnumString("ltSlateGrey")]
LightSlateGrey,
///<summary>
///slateGrey.
///<para>When the item is serialized out as xml, its value is "slateGrey".</para>
///</summary>
[EnumString("slateGrey")]
SlateGrey,
 
}
}
 
 
