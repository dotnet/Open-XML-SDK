// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// This source file is machine generated.  Please do not change the code manually.
using System;
using System.Collections.Generic;
using System.IO.Packaging;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Office2013.Word;
using DocumentFormat.OpenXml.Office2010.Word;
using DocumentFormat.OpenXml.CustomXmlSchemaReferences;
using DocumentFormat.OpenXml.Math;
using DocumentFormat.OpenXml.Drawing.Wordprocessing;
using DocumentFormat.OpenXml.Vml;
using DocumentFormat.OpenXml.Vml.Office;

namespace DocumentFormat.OpenXml.Wordprocessing
{
/// <summary>
/// <para>Table Cell Insertion.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cellIns.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellInsertion : TrackChangeType
{
    private const string tagName = "cellIns";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11537;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CellInsertion class.
    /// </summary>
    public CellInsertion():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellInsertion>(deep);
    }

}
/// <summary>
/// <para>Table Cell Deletion.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cellDel.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellDeletion : TrackChangeType
{
    private const string tagName = "cellDel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11538;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CellDeletion class.
    /// </summary>
    public CellDeletion():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellDeletion>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlInsRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlInsRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlInsRangeStart : TrackChangeType
{
    private const string tagName = "customXmlInsRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11548;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlInsRangeStart class.
    /// </summary>
    public CustomXmlInsRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlInsRangeStart>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlDelRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlDelRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlDelRangeStart : TrackChangeType
{
    private const string tagName = "customXmlDelRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11550;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlDelRangeStart class.
    /// </summary>
    public CustomXmlDelRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlDelRangeStart>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlMoveFromRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlMoveFromRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlMoveFromRangeStart : TrackChangeType
{
    private const string tagName = "customXmlMoveFromRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11552;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlMoveFromRangeStart class.
    /// </summary>
    public CustomXmlMoveFromRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlMoveFromRangeStart>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlMoveToRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlMoveToRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlMoveToRangeStart : TrackChangeType
{
    private const string tagName = "customXmlMoveToRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11554;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlMoveToRangeStart class.
    /// </summary>
    public CustomXmlMoveToRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlMoveToRangeStart>(deep);
    }

}
/// <summary>
/// <para>Inserted Paragraph.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ins.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Inserted : TrackChangeType
{
    private const string tagName = "ins";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11732;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Inserted class.
    /// </summary>
    public Inserted():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Inserted>(deep);
    }

}
/// <summary>
/// <para>Deleted Paragraph.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:del.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Deleted : TrackChangeType
{
    private const string tagName = "del";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11733;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Deleted class.
    /// </summary>
    public Deleted():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Deleted>(deep);
    }

}
/// <summary>
/// <para>Move Source Paragraph.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveFrom.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveFrom : TrackChangeType
{
    private const string tagName = "moveFrom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11734;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveFrom class.
    /// </summary>
    public MoveFrom():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveFrom>(deep);
    }

}
/// <summary>
/// <para>Move Destination Paragraph.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveTo.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveTo : TrackChangeType
{
    private const string tagName = "moveTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11735;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveTo class.
    /// </summary>
    public MoveTo():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveTo>(deep);
    }

}
/// <summary>
/// Defines the TrackChangeType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TrackChangeType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TrackChangeType class.
    /// </summary>
    protected TrackChangeType(){}
    
    
    
}
/// <summary>
/// <para>Vertically Merged/Split Table Cells.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cellMerge.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellMerge : OpenXmlLeafElement
{
    private const string tagName = "cellMerge";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11539;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "vMerge","vMergeOrig","author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> vMerge.</para>
    /// <para>Represents the following attribute in the schema: w:vMerge </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vMerge")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues> VerticalMerge
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> vMergeOrig.</para>
    /// <para>Represents the following attribute in the schema: w:vMergeOrig </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vMergeOrig")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues> VerticalMergeOriginal
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellMerge class.
    /// </summary>
    public CellMerge():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "vMerge" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues>();
    
if( 23 == namespaceId && "vMergeOrig" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalMergeRevisionValues>();
    
if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellMerge>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BookmarkStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bookmarkStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookmarkStart : OpenXmlLeafElement
{
    private const string tagName = "bookmarkStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11540;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","colFirst","colLast","displacedByCustomXml","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> colFirst.</para>
    /// <para>Represents the following attribute in the schema: w:colFirst </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colFirst")]
    public Int32Value ColumnFirst
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> colLast.</para>
    /// <para>Represents the following attribute in the schema: w:colLast </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colLast")]
    public Int32Value ColumnLast
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> displacedByCustomXml.</para>
    /// <para>Represents the following attribute in the schema: w:displacedByCustomXml </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displacedByCustomXml")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues> DisplacedByCustomXml
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BookmarkStart class.
    /// </summary>
    public BookmarkStart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "colFirst" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "colLast" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "displacedByCustomXml" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookmarkStart>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BookmarkEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bookmarkEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookmarkEnd : MarkupRangeType
{
    private const string tagName = "bookmarkEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11541;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BookmarkEnd class.
    /// </summary>
    public BookmarkEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookmarkEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the CommentRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:commentRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CommentRangeStart : MarkupRangeType
{
    private const string tagName = "commentRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11542;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CommentRangeStart class.
    /// </summary>
    public CommentRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentRangeStart>(deep);
    }

}
/// <summary>
/// <para>Defines the CommentRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:commentRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CommentRangeEnd : MarkupRangeType
{
    private const string tagName = "commentRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11543;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CommentRangeEnd class.
    /// </summary>
    public CommentRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the MoveFromRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveFromRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveFromRangeEnd : MarkupRangeType
{
    private const string tagName = "moveFromRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11545;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveFromRangeEnd class.
    /// </summary>
    public MoveFromRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveFromRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the MoveToRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveToRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveToRangeEnd : MarkupRangeType
{
    private const string tagName = "moveToRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11547;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveToRangeEnd class.
    /// </summary>
    public MoveToRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveToRangeEnd>(deep);
    }

}
/// <summary>
/// Defines the MarkupRangeType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MarkupRangeType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "displacedByCustomXml","id" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> displacedByCustomXml.</para>
    /// <para>Represents the following attribute in the schema: w:displacedByCustomXml </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displacedByCustomXml")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues> DisplacedByCustomXml
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "displacedByCustomXml" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MarkupRangeType class.
    /// </summary>
    protected MarkupRangeType(){}
    
    
    
}
/// <summary>
/// <para>Defines the MoveFromRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveFromRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveFromRangeStart : MoveBookmarkType
{
    private const string tagName = "moveFromRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11544;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveFromRangeStart class.
    /// </summary>
    public MoveFromRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveFromRangeStart>(deep);
    }

}
/// <summary>
/// <para>Defines the MoveToRangeStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveToRangeStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveToRangeStart : MoveBookmarkType
{
    private const string tagName = "moveToRangeStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11546;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveToRangeStart class.
    /// </summary>
    public MoveToRangeStart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveToRangeStart>(deep);
    }

}
/// <summary>
/// Defines the MoveBookmarkType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MoveBookmarkType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "author","date","name","colFirst","colLast","displacedByCustomXml","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> colFirst.</para>
    /// <para>Represents the following attribute in the schema: w:colFirst </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colFirst")]
    public Int32Value ColumnFirst
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> colLast.</para>
    /// <para>Represents the following attribute in the schema: w:colLast </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colLast")]
    public Int32Value ColumnLast
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> displacedByCustomXml.</para>
    /// <para>Represents the following attribute in the schema: w:displacedByCustomXml </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displacedByCustomXml")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues> DisplacedByCustomXml
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "colFirst" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "colLast" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "displacedByCustomXml" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MoveBookmarkType class.
    /// </summary>
    protected MoveBookmarkType(){}
    
    
    
}
/// <summary>
/// <para>Defines the CustomXmlInsRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlInsRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlInsRangeEnd : MarkupType
{
    private const string tagName = "customXmlInsRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11549;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlInsRangeEnd class.
    /// </summary>
    public CustomXmlInsRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlInsRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlDelRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlDelRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlDelRangeEnd : MarkupType
{
    private const string tagName = "customXmlDelRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11551;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlDelRangeEnd class.
    /// </summary>
    public CustomXmlDelRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlDelRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlMoveFromRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlMoveFromRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlMoveFromRangeEnd : MarkupType
{
    private const string tagName = "customXmlMoveFromRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11553;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlMoveFromRangeEnd class.
    /// </summary>
    public CustomXmlMoveFromRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlMoveFromRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Defines the CustomXmlMoveToRangeEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlMoveToRangeEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlMoveToRangeEnd : MarkupType
{
    private const string tagName = "customXmlMoveToRangeEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11555;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlMoveToRangeEnd class.
    /// </summary>
    public CustomXmlMoveToRangeEnd():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlMoveToRangeEnd>(deep);
    }

}
/// <summary>
/// <para>Comment Content Reference Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:commentReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CommentReference : MarkupType
{
    private const string tagName = "commentReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11618;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CommentReference class.
    /// </summary>
    public CommentReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentReference>(deep);
    }

}
/// <summary>
/// Defines the MarkupType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MarkupType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MarkupType class.
    /// </summary>
    protected MarkupType(){}
    
    
    
}
/// <summary>
/// <para>Defines the ParagraphStyleId Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphStyleId : StringType
{
    private const string tagName = "pStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11556;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ParagraphStyleId class.
    /// </summary>
    public ParagraphStyleId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphStyleId>(deep);
    }

}
/// <summary>
/// <para>Date Display Mask.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dateFormat.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DateFormat : StringType
{
    private const string tagName = "dateFormat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11824;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DateFormat class.
    /// </summary>
    public DateFormat():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DateFormat>(deep);
    }

}
/// <summary>
/// <para>Document Part Gallery Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartGallery.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartGallery : StringType
{
    private const string tagName = "docPartGallery";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11828;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartGallery class.
    /// </summary>
    public DocPartGallery():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartGallery>(deep);
    }

}
/// <summary>
/// <para>Document Part Category Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartCategory.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartCategory : StringType
{
    private const string tagName = "docPartCategory";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11829;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartCategory class.
    /// </summary>
    public DocPartCategory():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartCategory>(deep);
    }

}
/// <summary>
/// <para>Document Part Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartReference : StringType
{
    private const string tagName = "docPart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11831;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartReference class.
    /// </summary>
    public DocPartReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartReference>(deep);
    }

}
/// <summary>
/// <para>Custom XML Element Placeholder Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:placeholder.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlPlaceholder : StringType
{
    private const string tagName = "placeholder";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11840;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlPlaceholder class.
    /// </summary>
    public CustomXmlPlaceholder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlPlaceholder>(deep);
    }

}
/// <summary>
/// <para>Defines the TableCaption Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblCaption.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class TableCaption : StringType
{
    private const string tagName = "tblCaption";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11846;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCaption class.
    /// </summary>
    public TableCaption():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCaption>(deep);
    }

}
/// <summary>
/// <para>Defines the TableDescription Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblDescription.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class TableDescription : StringType
{
    private const string tagName = "tblDescription";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11847;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableDescription class.
    /// </summary>
    public TableDescription():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableDescription>(deep);
    }

}
/// <summary>
/// <para>Data Source Name for Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Name : StringType
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11862;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Name class.
    /// </summary>
    public Name():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Name>(deep);
    }

}
/// <summary>
/// <para>Predefined Merge Field Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mappedName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MappedName : StringType
{
    private const string tagName = "mappedName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11863;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MappedName class.
    /// </summary>
    public MappedName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MappedName>(deep);
    }

}
/// <summary>
/// <para>UDL Connection String.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:udl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UdlConnectionString : StringType
{
    private const string tagName = "udl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11865;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UdlConnectionString class.
    /// </summary>
    public UdlConnectionString():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UdlConnectionString>(deep);
    }

}
/// <summary>
/// <para>Data Source Table Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:table.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataSourceTableName : StringType
{
    private const string tagName = "table";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11866;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DataSourceTableName class.
    /// </summary>
    public DataSourceTableName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataSourceTableName>(deep);
    }

}
/// <summary>
/// <para>Data Source Connection String.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:connectString.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectString : StringType
{
    private const string tagName = "connectString";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11876;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ConnectString class.
    /// </summary>
    public ConnectString():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectString>(deep);
    }

}
/// <summary>
/// <para>Query For Data Source Records To Merge.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:query.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Query : StringType
{
    private const string tagName = "query";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11877;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Query class.
    /// </summary>
    public Query():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Query>(deep);
    }

}
/// <summary>
/// <para>Column Containing E-mail Address.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:addressFieldName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AddressFieldName : StringType
{
    private const string tagName = "addressFieldName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11882;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AddressFieldName class.
    /// </summary>
    public AddressFieldName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AddressFieldName>(deep);
    }

}
/// <summary>
/// <para>Merged E-mail or Fax Subject Line.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mailSubject.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MailSubject : StringType
{
    private const string tagName = "mailSubject";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11883;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MailSubject class.
    /// </summary>
    public MailSubject():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MailSubject>(deep);
    }

}
/// <summary>
/// <para>Frame Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sz.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FrameSize : StringType
{
    private const string tagName = "sz";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11896;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FrameSize class.
    /// </summary>
    public FrameSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FrameSize>(deep);
    }

}
/// <summary>
/// <para>Associated Paragraph Style Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:style.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleId : StringType
{
    private const string tagName = "style";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11985;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleId class.
    /// </summary>
    public StyleId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleId>(deep);
    }

}
/// <summary>
/// <para>Description for Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:description.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Description : StringType
{
    private const string tagName = "description";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11989;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Description class.
    /// </summary>
    public Description():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Description>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtAlias Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:alias.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtAlias : StringType
{
    private const string tagName = "alias";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12083;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtAlias class.
    /// </summary>
    public SdtAlias():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtAlias>(deep);
    }

}
/// <summary>
/// <para>Defines the Tag Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tag.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tag : StringType
{
    private const string tagName = "tag";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12090;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Tag class.
    /// </summary>
    public Tag():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tag>(deep);
    }

}
/// <summary>
/// <para>Attached Custom XML Schema.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:attachedSchema.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AttachedSchema : StringType
{
    private const string tagName = "attachedSchema";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12187;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AttachedSchema class.
    /// </summary>
    public AttachedSchema():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AttachedSchema>(deep);
    }

}
/// <summary>
/// <para>Radix Point for Field Code Evaluation.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:decimalSymbol.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DecimalSymbol : StringType
{
    private const string tagName = "decimalSymbol";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12196;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DecimalSymbol class.
    /// </summary>
    public DecimalSymbol():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DecimalSymbol>(deep);
    }

}
/// <summary>
/// <para>List Separator for Field Code Evaluation.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:listSeparator.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ListSeparator : StringType
{
    private const string tagName = "listSeparator";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12197;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ListSeparator class.
    /// </summary>
    public ListSeparator():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ListSeparator>(deep);
    }

}
/// <summary>
/// <para>Defines the WebPageEncoding Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:encoding.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPageEncoding : StringType
{
    private const string tagName = "encoding";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12199;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPageEncoding class.
    /// </summary>
    public WebPageEncoding():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPageEncoding>(deep);
    }

}
/// <summary>
/// <para>Defines the AltName Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:altName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AltName : StringType
{
    private const string tagName = "altName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12210;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AltName class.
    /// </summary>
    public AltName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AltName>(deep);
    }

}
/// <summary>
/// Defines the StringType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class StringType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> String Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the StringType class.
    /// </summary>
    protected StringType(){}
    
    
    
}
/// <summary>
/// <para>Defines the KeepNext Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:keepNext.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class KeepNext : OnOffType
{
    private const string tagName = "keepNext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11557;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the KeepNext class.
    /// </summary>
    public KeepNext():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<KeepNext>(deep);
    }

}
/// <summary>
/// <para>Defines the KeepLines Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:keepLines.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class KeepLines : OnOffType
{
    private const string tagName = "keepLines";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11558;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the KeepLines class.
    /// </summary>
    public KeepLines():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<KeepLines>(deep);
    }

}
/// <summary>
/// <para>Defines the PageBreakBefore Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pageBreakBefore.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageBreakBefore : OnOffType
{
    private const string tagName = "pageBreakBefore";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11559;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PageBreakBefore class.
    /// </summary>
    public PageBreakBefore():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageBreakBefore>(deep);
    }

}
/// <summary>
/// <para>Defines the WidowControl Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:widowControl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WidowControl : OnOffType
{
    private const string tagName = "widowControl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11561;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WidowControl class.
    /// </summary>
    public WidowControl():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WidowControl>(deep);
    }

}
/// <summary>
/// <para>Defines the SuppressLineNumbers Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressLineNumbers.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressLineNumbers : OnOffType
{
    private const string tagName = "suppressLineNumbers";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11563;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressLineNumbers class.
    /// </summary>
    public SuppressLineNumbers():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressLineNumbers>(deep);
    }

}
/// <summary>
/// <para>Defines the SuppressAutoHyphens Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressAutoHyphens.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressAutoHyphens : OnOffType
{
    private const string tagName = "suppressAutoHyphens";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11567;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressAutoHyphens class.
    /// </summary>
    public SuppressAutoHyphens():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressAutoHyphens>(deep);
    }

}
/// <summary>
/// <para>Defines the Kinsoku Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:kinsoku.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Kinsoku : OnOffType
{
    private const string tagName = "kinsoku";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11568;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Kinsoku class.
    /// </summary>
    public Kinsoku():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Kinsoku>(deep);
    }

}
/// <summary>
/// <para>Defines the WordWrap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wordWrap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WordWrap : OnOffType
{
    private const string tagName = "wordWrap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11569;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WordWrap class.
    /// </summary>
    public WordWrap():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WordWrap>(deep);
    }

}
/// <summary>
/// <para>Defines the OverflowPunctuation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:overflowPunct.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OverflowPunctuation : OnOffType
{
    private const string tagName = "overflowPunct";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11570;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OverflowPunctuation class.
    /// </summary>
    public OverflowPunctuation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OverflowPunctuation>(deep);
    }

}
/// <summary>
/// <para>Defines the TopLinePunctuation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:topLinePunct.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopLinePunctuation : OnOffType
{
    private const string tagName = "topLinePunct";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11571;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopLinePunctuation class.
    /// </summary>
    public TopLinePunctuation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopLinePunctuation>(deep);
    }

}
/// <summary>
/// <para>Defines the AutoSpaceDE Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoSpaceDE.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoSpaceDE : OnOffType
{
    private const string tagName = "autoSpaceDE";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11572;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoSpaceDE class.
    /// </summary>
    public AutoSpaceDE():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoSpaceDE>(deep);
    }

}
/// <summary>
/// <para>Defines the AutoSpaceDN Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoSpaceDN.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoSpaceDN : OnOffType
{
    private const string tagName = "autoSpaceDN";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11573;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoSpaceDN class.
    /// </summary>
    public AutoSpaceDN():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoSpaceDN>(deep);
    }

}
/// <summary>
/// <para>Defines the BiDi Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bidi.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BiDi : OnOffType
{
    private const string tagName = "bidi";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11574;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BiDi class.
    /// </summary>
    public BiDi():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BiDi>(deep);
    }

}
/// <summary>
/// <para>Defines the AdjustRightIndent Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:adjustRightInd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustRightIndent : OnOffType
{
    private const string tagName = "adjustRightInd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11575;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AdjustRightIndent class.
    /// </summary>
    public AdjustRightIndent():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustRightIndent>(deep);
    }

}
/// <summary>
/// <para>Defines the SnapToGrid Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:snapToGrid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SnapToGrid : OnOffType
{
    private const string tagName = "snapToGrid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11576;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SnapToGrid class.
    /// </summary>
    public SnapToGrid():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SnapToGrid>(deep);
    }

}
/// <summary>
/// <para>Defines the ContextualSpacing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:contextualSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ContextualSpacing : OnOffType
{
    private const string tagName = "contextualSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11579;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ContextualSpacing class.
    /// </summary>
    public ContextualSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ContextualSpacing>(deep);
    }

}
/// <summary>
/// <para>Defines the MirrorIndents Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mirrorIndents.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MirrorIndents : OnOffType
{
    private const string tagName = "mirrorIndents";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11580;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MirrorIndents class.
    /// </summary>
    public MirrorIndents():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MirrorIndents>(deep);
    }

}
/// <summary>
/// <para>Defines the SuppressOverlap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressOverlap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressOverlap : OnOffType
{
    private const string tagName = "suppressOverlap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11581;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressOverlap class.
    /// </summary>
    public SuppressOverlap():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressOverlap>(deep);
    }

}
/// <summary>
/// <para>Defines the Bold Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:b.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Bold : OnOffType
{
    private const string tagName = "b";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11624;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Bold class.
    /// </summary>
    public Bold():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Bold>(deep);
    }

}
/// <summary>
/// <para>Defines the BoldComplexScript Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bCs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BoldComplexScript : OnOffType
{
    private const string tagName = "bCs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11625;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BoldComplexScript class.
    /// </summary>
    public BoldComplexScript():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BoldComplexScript>(deep);
    }

}
/// <summary>
/// <para>Defines the Italic Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:i.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Italic : OnOffType
{
    private const string tagName = "i";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11626;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Italic class.
    /// </summary>
    public Italic():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Italic>(deep);
    }

}
/// <summary>
/// <para>Defines the ItalicComplexScript Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:iCs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ItalicComplexScript : OnOffType
{
    private const string tagName = "iCs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11627;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ItalicComplexScript class.
    /// </summary>
    public ItalicComplexScript():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ItalicComplexScript>(deep);
    }

}
/// <summary>
/// <para>Defines the Caps Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:caps.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Caps : OnOffType
{
    private const string tagName = "caps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11628;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Caps class.
    /// </summary>
    public Caps():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Caps>(deep);
    }

}
/// <summary>
/// <para>Defines the SmallCaps Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:smallCaps.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SmallCaps : OnOffType
{
    private const string tagName = "smallCaps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11629;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SmallCaps class.
    /// </summary>
    public SmallCaps():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SmallCaps>(deep);
    }

}
/// <summary>
/// <para>Defines the Strike Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:strike.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Strike : OnOffType
{
    private const string tagName = "strike";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11630;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Strike class.
    /// </summary>
    public Strike():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Strike>(deep);
    }

}
/// <summary>
/// <para>Defines the DoubleStrike Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dstrike.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoubleStrike : OnOffType
{
    private const string tagName = "dstrike";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11631;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoubleStrike class.
    /// </summary>
    public DoubleStrike():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoubleStrike>(deep);
    }

}
/// <summary>
/// <para>Defines the Outline Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:outline.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Outline : OnOffType
{
    private const string tagName = "outline";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11632;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Outline class.
    /// </summary>
    public Outline():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Outline>(deep);
    }

}
/// <summary>
/// <para>Defines the Shadow Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:shadow.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shadow : OnOffType
{
    private const string tagName = "shadow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11633;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Shadow class.
    /// </summary>
    public Shadow():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shadow>(deep);
    }

}
/// <summary>
/// <para>Defines the Emboss Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:emboss.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Emboss : OnOffType
{
    private const string tagName = "emboss";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11634;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Emboss class.
    /// </summary>
    public Emboss():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Emboss>(deep);
    }

}
/// <summary>
/// <para>Defines the Imprint Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:imprint.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Imprint : OnOffType
{
    private const string tagName = "imprint";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11635;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Imprint class.
    /// </summary>
    public Imprint():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Imprint>(deep);
    }

}
/// <summary>
/// <para>Defines the NoProof Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noProof.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoProof : OnOffType
{
    private const string tagName = "noProof";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11636;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoProof class.
    /// </summary>
    public NoProof():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoProof>(deep);
    }

}
/// <summary>
/// <para>Defines the Vanish Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:vanish.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Vanish : OnOffType
{
    private const string tagName = "vanish";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11637;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Vanish class.
    /// </summary>
    public Vanish():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Vanish>(deep);
    }

}
/// <summary>
/// <para>Defines the WebHidden Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:webHidden.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebHidden : OnOffType
{
    private const string tagName = "webHidden";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11638;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WebHidden class.
    /// </summary>
    public WebHidden():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebHidden>(deep);
    }

}
/// <summary>
/// <para>Defines the RightToLeftText Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rtl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightToLeftText : OnOffType
{
    private const string tagName = "rtl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11652;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightToLeftText class.
    /// </summary>
    public RightToLeftText():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightToLeftText>(deep);
    }

}
/// <summary>
/// <para>Defines the ComplexScript Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ComplexScript : OnOffType
{
    private const string tagName = "cs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11653;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ComplexScript class.
    /// </summary>
    public ComplexScript():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ComplexScript>(deep);
    }

}
/// <summary>
/// <para>Defines the SpecVanish Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:specVanish.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpecVanish : OnOffType
{
    private const string tagName = "specVanish";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11657;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SpecVanish class.
    /// </summary>
    public SpecVanish():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpecVanish>(deep);
    }

}
/// <summary>
/// <para>Defines the OfficeMath Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:oMath.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OfficeMath : OnOffType
{
    private const string tagName = "oMath";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11658;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OfficeMath class.
    /// </summary>
    public OfficeMath():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OfficeMath>(deep);
    }

}
/// <summary>
/// <para>Defines the Hidden Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hidden.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hidden : OnOffType
{
    private const string tagName = "hidden";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11712;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Hidden class.
    /// </summary>
    public Hidden():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hidden>(deep);
    }

}
/// <summary>
/// <para>Defines the FormProtection Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:formProt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormProtection : OnOffType
{
    private const string tagName = "formProt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11746;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FormProtection class.
    /// </summary>
    public FormProtection():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormProtection>(deep);
    }

}
/// <summary>
/// <para>Defines the NoEndnote Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noEndnote.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoEndnote : OnOffType
{
    private const string tagName = "noEndnote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11748;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoEndnote class.
    /// </summary>
    public NoEndnote():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoEndnote>(deep);
    }

}
/// <summary>
/// <para>Defines the TitlePage Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:titlePg.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TitlePage : OnOffType
{
    private const string tagName = "titlePg";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11749;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TitlePage class.
    /// </summary>
    public TitlePage():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TitlePage>(deep);
    }

}
/// <summary>
/// <para>Defines the GutterOnRight Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rtlGutter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GutterOnRight : OnOffType
{
    private const string tagName = "rtlGutter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11750;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GutterOnRight class.
    /// </summary>
    public GutterOnRight():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GutterOnRight>(deep);
    }

}
/// <summary>
/// <para>Form Field Enabled.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:enabled.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Enabled : OnOffType
{
    private const string tagName = "enabled";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11790;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Enabled class.
    /// </summary>
    public Enabled():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Enabled>(deep);
    }

}
/// <summary>
/// <para>Recalculate Fields When Current Field Is Modified.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:calcOnExit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculateOnExit : OnOffType
{
    private const string tagName = "calcOnExit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11791;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculateOnExit class.
    /// </summary>
    public CalculateOnExit():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculateOnExit>(deep);
    }

}
/// <summary>
/// <para>Automatically Size Form Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sizeAuto.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutomaticallySizeFormField : OnOffType
{
    private const string tagName = "sizeAuto";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11800;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutomaticallySizeFormField class.
    /// </summary>
    public AutomaticallySizeFormField():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutomaticallySizeFormField>(deep);
    }

}
/// <summary>
/// <para>Default Checkbox Form Field State.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:default.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultCheckBoxFormFieldState : OnOffType
{
    private const string tagName = "default";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11801;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultCheckBoxFormFieldState class.
    /// </summary>
    public DefaultCheckBoxFormFieldState():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultCheckBoxFormFieldState>(deep);
    }

}
/// <summary>
/// <para>Checkbox Form Field State.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:checked.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Checked : OnOffType
{
    private const string tagName = "checked";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11802;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Checked class.
    /// </summary>
    public Checked():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Checked>(deep);
    }

}
/// <summary>
/// <para>Keep Source Formatting on Import.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:matchSrc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MatchSource : OnOffType
{
    private const string tagName = "matchSrc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11814;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MatchSource class.
    /// </summary>
    public MatchSource():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MatchSource>(deep);
    }

}
/// <summary>
/// <para>Invalidated Field Cache.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dirty.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Dirty : OnOffType
{
    private const string tagName = "dirty";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11820;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Dirty class.
    /// </summary>
    public Dirty():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Dirty>(deep);
    }

}
/// <summary>
/// <para>Built-In Document Part.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartUnique.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartUnique : OnOffType
{
    private const string tagName = "docPartUnique";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11830;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartUnique class.
    /// </summary>
    public DocPartUnique():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartUnique>(deep);
    }

}
/// <summary>
/// <para>Record Is Included in Mail Merge.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:active.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Active : OnOffType
{
    private const string tagName = "active";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11857;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Active class.
    /// </summary>
    public Active():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Active>(deep);
    }

}
/// <summary>
/// <para>Use Country/Region-Based Address Field Ordering.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dynamicAddress.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DynamicAddress : OnOffType
{
    private const string tagName = "dynamicAddress";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11864;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DynamicAddress class.
    /// </summary>
    public DynamicAddress():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DynamicAddress>(deep);
    }

}
/// <summary>
/// <para>First Row of Data Source Contains Column Names.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fHdr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FirstRowHeader : OnOffType
{
    private const string tagName = "fHdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11870;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FirstRowHeader class.
    /// </summary>
    public FirstRowHeader():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FirstRowHeader>(deep);
    }

}
/// <summary>
/// <para>Query Contains Link to External Query File.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:linkToQuery.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LinkToQuery : OnOffType
{
    private const string tagName = "linkToQuery";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11874;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LinkToQuery class.
    /// </summary>
    public LinkToQuery():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LinkToQuery>(deep);
    }

}
/// <summary>
/// <para>Remove Blank Lines from Merged Documents.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotSuppressBlankLines.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotSuppressBlankLines : OnOffType
{
    private const string tagName = "doNotSuppressBlankLines";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11880;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotSuppressBlankLines class.
    /// </summary>
    public DoNotSuppressBlankLines():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotSuppressBlankLines>(deep);
    }

}
/// <summary>
/// <para>Merged Document To E-Mail Attachment.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mailAsAttachment.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MailAsAttachment : OnOffType
{
    private const string tagName = "mailAsAttachment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11884;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MailAsAttachment class.
    /// </summary>
    public MailAsAttachment():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MailAsAttachment>(deep);
    }

}
/// <summary>
/// <para>View Merged Data Within Document.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:viewMergedData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ViewMergedData : OnOffType
{
    private const string tagName = "viewMergedData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11885;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ViewMergedData class.
    /// </summary>
    public ViewMergedData():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ViewMergedData>(deep);
    }

}
/// <summary>
/// <para>Display All Levels Using Arabic Numerals.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:isLgl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IsLegalNumberingStyle : OnOffType
{
    private const string tagName = "isLgl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11914;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the IsLegalNumberingStyle class.
    /// </summary>
    public IsLegalNumberingStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IsLegalNumberingStyle>(deep);
    }

}
/// <summary>
/// <para>Data for HTML blockquote Element.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:blockQuote.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BlockQuote : OnOffType
{
    private const string tagName = "blockQuote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11964;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BlockQuote class.
    /// </summary>
    public BlockQuote():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BlockQuote>(deep);
    }

}
/// <summary>
/// <para>Data for HTML body Element.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bodyDiv.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BodyDiv : OnOffType
{
    private const string tagName = "bodyDiv";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11965;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BodyDiv class.
    /// </summary>
    public BodyDiv():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BodyDiv>(deep);
    }

}
/// <summary>
/// <para>Use Simplified Rules For Table Border Conflicts.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useSingleBorderforContiguousCells.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseSingleBorderForContiguousCells : OnOffType
{
    private const string tagName = "useSingleBorderforContiguousCells";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11994;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseSingleBorderForContiguousCells class.
    /// </summary>
    public UseSingleBorderForContiguousCells():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseSingleBorderForContiguousCells>(deep);
    }

}
/// <summary>
/// <para>Emulate WordPerfect 6.x Paragraph Justification.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wpJustification.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WordPerfectJustification : OnOffType
{
    private const string tagName = "wpJustification";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11995;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WordPerfectJustification class.
    /// </summary>
    public WordPerfectJustification():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WordPerfectJustification>(deep);
    }

}
/// <summary>
/// <para>Do Not Create Custom Tab Stop for Hanging Indent.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noTabHangInd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoTabHangIndent : OnOffType
{
    private const string tagName = "noTabHangInd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11996;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoTabHangIndent class.
    /// </summary>
    public NoTabHangIndent():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoTabHangIndent>(deep);
    }

}
/// <summary>
/// <para>Do Not Add Leading Between Lines of Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noLeading.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoLeading : OnOffType
{
    private const string tagName = "noLeading";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11997;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoLeading class.
    /// </summary>
    public NoLeading():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoLeading>(deep);
    }

}
/// <summary>
/// <para>Add Additional Space Below Baseline For Underlined East Asian Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:spaceForUL.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpaceForUnderline : OnOffType
{
    private const string tagName = "spaceForUL";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11998;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SpaceForUnderline class.
    /// </summary>
    public SpaceForUnderline():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpaceForUnderline>(deep);
    }

}
/// <summary>
/// <para>Do Not Balance Text Columns within a Section.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noColumnBalance.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoColumnBalance : OnOffType
{
    private const string tagName = "noColumnBalance";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11999;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoColumnBalance class.
    /// </summary>
    public NoColumnBalance():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoColumnBalance>(deep);
    }

}
/// <summary>
/// <para>Balance Single Byte and Double Byte Characters.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:balanceSingleByteDoubleByteWidth.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BalanceSingleByteDoubleByteWidth : OnOffType
{
    private const string tagName = "balanceSingleByteDoubleByteWidth";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12000;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BalanceSingleByteDoubleByteWidth class.
    /// </summary>
    public BalanceSingleByteDoubleByteWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BalanceSingleByteDoubleByteWidth>(deep);
    }

}
/// <summary>
/// <para>Do Not Center Content on Lines With Exact Line Height.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noExtraLineSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoExtraLineSpacing : OnOffType
{
    private const string tagName = "noExtraLineSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12001;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoExtraLineSpacing class.
    /// </summary>
    public NoExtraLineSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoExtraLineSpacing>(deep);
    }

}
/// <summary>
/// <para>Convert Backslash To Yen Sign When Entered.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotLeaveBackslashAlone.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotLeaveBackslashAlone : OnOffType
{
    private const string tagName = "doNotLeaveBackslashAlone";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12002;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotLeaveBackslashAlone class.
    /// </summary>
    public DoNotLeaveBackslashAlone():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotLeaveBackslashAlone>(deep);
    }

}
/// <summary>
/// <para>Underline All Trailing Spaces.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ulTrailSpace.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnderlineTrailingSpaces : OnOffType
{
    private const string tagName = "ulTrailSpace";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12003;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UnderlineTrailingSpaces class.
    /// </summary>
    public UnderlineTrailingSpaces():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnderlineTrailingSpaces>(deep);
    }

}
/// <summary>
/// <para>Don't Justify Lines Ending in Soft Line Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotExpandShiftReturn.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotExpandShiftReturn : OnOffType
{
    private const string tagName = "doNotExpandShiftReturn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12004;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotExpandShiftReturn class.
    /// </summary>
    public DoNotExpandShiftReturn():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotExpandShiftReturn>(deep);
    }

}
/// <summary>
/// <para>Only Expand/Condense Text By Whole Points.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:spacingInWholePoints.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpacingInWholePoints : OnOffType
{
    private const string tagName = "spacingInWholePoints";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12005;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SpacingInWholePoints class.
    /// </summary>
    public SpacingInWholePoints():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpacingInWholePoints>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 6.0 Line Wrapping for East Asian Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lineWrapLikeWord6.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineWrapLikeWord6 : OnOffType
{
    private const string tagName = "lineWrapLikeWord6";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12006;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LineWrapLikeWord6 class.
    /// </summary>
    public LineWrapLikeWord6():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineWrapLikeWord6>(deep);
    }

}
/// <summary>
/// <para>Print Body Text before Header/Footer Contents.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printBodyTextBeforeHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintBodyTextBeforeHeader : OnOffType
{
    private const string tagName = "printBodyTextBeforeHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12007;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintBodyTextBeforeHeader class.
    /// </summary>
    public PrintBodyTextBeforeHeader():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintBodyTextBeforeHeader>(deep);
    }

}
/// <summary>
/// <para>Print Colors as Black And White without Dithering.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printColBlack.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintColorBlackWhite : OnOffType
{
    private const string tagName = "printColBlack";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12008;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintColorBlackWhite class.
    /// </summary>
    public PrintColorBlackWhite():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintColorBlackWhite>(deep);
    }

}
/// <summary>
/// <para>Space width.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wpSpaceWidth.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WordPerfectSpaceWidth : OnOffType
{
    private const string tagName = "wpSpaceWidth";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12009;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WordPerfectSpaceWidth class.
    /// </summary>
    public WordPerfectSpaceWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WordPerfectSpaceWidth>(deep);
    }

}
/// <summary>
/// <para>Display Page/Column Breaks Present in Frames.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:showBreaksInFrames.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShowBreaksInFrames : OnOffType
{
    private const string tagName = "showBreaksInFrames";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12010;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShowBreaksInFrames class.
    /// </summary>
    public ShowBreaksInFrames():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShowBreaksInFrames>(deep);
    }

}
/// <summary>
/// <para>Increase Priority Of Font Size During Font Substitution.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:subFontBySize.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SubFontBySize : OnOffType
{
    private const string tagName = "subFontBySize";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12011;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SubFontBySize class.
    /// </summary>
    public SubFontBySize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SubFontBySize>(deep);
    }

}
/// <summary>
/// <para>Ignore Exact Line Height for Last Line on Page.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressBottomSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressBottomSpacing : OnOffType
{
    private const string tagName = "suppressBottomSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12012;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressBottomSpacing class.
    /// </summary>
    public SuppressBottomSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressBottomSpacing>(deep);
    }

}
/// <summary>
/// <para>Ignore Minimum and Exact Line Height for First Line on Page.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressTopSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressTopSpacing : OnOffType
{
    private const string tagName = "suppressTopSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12013;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressTopSpacing class.
    /// </summary>
    public SuppressTopSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressTopSpacing>(deep);
    }

}
/// <summary>
/// <para>Ignore Minimum Line Height for First Line on Page.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressSpacingAtTopOfPage.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressSpacingAtTopOfPage : OnOffType
{
    private const string tagName = "suppressSpacingAtTopOfPage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12014;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressSpacingAtTopOfPage class.
    /// </summary>
    public SuppressSpacingAtTopOfPage():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressSpacingAtTopOfPage>(deep);
    }

}
/// <summary>
/// <para>Emulate WordPerfect 5.x Line Spacing.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressTopSpacingWP.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressTopSpacingWordPerfect : OnOffType
{
    private const string tagName = "suppressTopSpacingWP";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12015;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressTopSpacingWordPerfect class.
    /// </summary>
    public SuppressTopSpacingWordPerfect():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressTopSpacingWordPerfect>(deep);
    }

}
/// <summary>
/// <para>Do Not Use Space Before On First Line After a Page Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suppressSpBfAfterPgBrk.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SuppressSpacingBeforeAfterPageBreak : OnOffType
{
    private const string tagName = "suppressSpBfAfterPgBrk";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12016;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SuppressSpacingBeforeAfterPageBreak class.
    /// </summary>
    public SuppressSpacingBeforeAfterPageBreak():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SuppressSpacingBeforeAfterPageBreak>(deep);
    }

}
/// <summary>
/// <para>Swap Paragraph Borders on Odd Numbered Pages.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:swapBordersFacingPages.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SwapBordersFacingPages : OnOffType
{
    private const string tagName = "swapBordersFacingPages";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12017;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SwapBordersFacingPages class.
    /// </summary>
    public SwapBordersFacingPages():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SwapBordersFacingPages>(deep);
    }

}
/// <summary>
/// <para>Treat Backslash Quotation Delimiter as Two Quotation Marks.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:convMailMergeEsc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConvertMailMergeEscape : OnOffType
{
    private const string tagName = "convMailMergeEsc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12018;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ConvertMailMergeEscape class.
    /// </summary>
    public ConvertMailMergeEscape():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConvertMailMergeEscape>(deep);
    }

}
/// <summary>
/// <para>Emulate WordPerfect 6.x Font Height Calculation.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:truncateFontHeightsLikeWP6.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TruncateFontHeightsLikeWordPerfect : OnOffType
{
    private const string tagName = "truncateFontHeightsLikeWP6";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12019;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TruncateFontHeightsLikeWordPerfect class.
    /// </summary>
    public TruncateFontHeightsLikeWordPerfect():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TruncateFontHeightsLikeWordPerfect>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 5.x for the Macintosh Small Caps Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mwSmallCaps.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MacWordSmallCaps : OnOffType
{
    private const string tagName = "mwSmallCaps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12020;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MacWordSmallCaps class.
    /// </summary>
    public MacWordSmallCaps():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MacWordSmallCaps>(deep);
    }

}
/// <summary>
/// <para>Use Printer Metrics To Display Documents.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:usePrinterMetrics.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UsePrinterMetrics : OnOffType
{
    private const string tagName = "usePrinterMetrics";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12021;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UsePrinterMetrics class.
    /// </summary>
    public UsePrinterMetrics():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UsePrinterMetrics>(deep);
    }

}
/// <summary>
/// <para>Do Not Suppress Paragraph Borders Next To Frames.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotSuppressParagraphBorders.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotSuppressParagraphBorders : OnOffType
{
    private const string tagName = "doNotSuppressParagraphBorders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12022;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotSuppressParagraphBorders class.
    /// </summary>
    public DoNotSuppressParagraphBorders():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotSuppressParagraphBorders>(deep);
    }

}
/// <summary>
/// <para>Line Wrap Trailing Spaces.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wrapTrailSpaces.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WrapTrailSpaces : OnOffType
{
    private const string tagName = "wrapTrailSpaces";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12023;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WrapTrailSpaces class.
    /// </summary>
    public WrapTrailSpaces():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WrapTrailSpaces>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 6.x/95/97 Footnote Placement.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnoteLayoutLikeWW8.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteLayoutLikeWord8 : OnOffType
{
    private const string tagName = "footnoteLayoutLikeWW8";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12024;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FootnoteLayoutLikeWord8 class.
    /// </summary>
    public FootnoteLayoutLikeWord8():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteLayoutLikeWord8>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 97 Text Wrapping Around Floating Objects.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:shapeLayoutLikeWW8.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeLayoutLikeWord8 : OnOffType
{
    private const string tagName = "shapeLayoutLikeWW8";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12025;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeLayoutLikeWord8 class.
    /// </summary>
    public ShapeLayoutLikeWord8():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeLayoutLikeWord8>(deep);
    }

}
/// <summary>
/// <para>Align Table Rows Independently.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:alignTablesRowByRow.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlignTablesRowByRow : OnOffType
{
    private const string tagName = "alignTablesRowByRow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12026;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AlignTablesRowByRow class.
    /// </summary>
    public AlignTablesRowByRow():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlignTablesRowByRow>(deep);
    }

}
/// <summary>
/// <para>Ignore Width of Last Tab Stop When Aligning Paragraph If It Is Not Left Aligned.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:forgetLastTabAlignment.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ForgetLastTabAlignment : OnOffType
{
    private const string tagName = "forgetLastTabAlignment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12027;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ForgetLastTabAlignment class.
    /// </summary>
    public ForgetLastTabAlignment():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ForgetLastTabAlignment>(deep);
    }

}
/// <summary>
/// <para>Add Document Grid Line Pitch To Lines in Table Cells.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:adjustLineHeightInTable.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AdjustLineHeightInTable : OnOffType
{
    private const string tagName = "adjustLineHeightInTable";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12028;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AdjustLineHeightInTable class.
    /// </summary>
    public AdjustLineHeightInTable():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AdjustLineHeightInTable>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 95 Full-Width Character Spacing.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoSpaceLikeWord95.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoSpaceLikeWord95 : OnOffType
{
    private const string tagName = "autoSpaceLikeWord95";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12029;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoSpaceLikeWord95 class.
    /// </summary>
    public AutoSpaceLikeWord95():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoSpaceLikeWord95>(deep);
    }

}
/// <summary>
/// <para>Do Not Increase Line Height for Raised/Lowered Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noSpaceRaiseLower.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoSpaceRaiseLower : OnOffType
{
    private const string tagName = "noSpaceRaiseLower";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12030;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoSpaceRaiseLower class.
    /// </summary>
    public NoSpaceRaiseLower():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoSpaceRaiseLower>(deep);
    }

}
/// <summary>
/// <para>Use Fixed Paragraph Spacing for HTML Auto Setting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotUseHTMLParagraphAutoSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotUseHTMLParagraphAutoSpacing : OnOffType
{
    private const string tagName = "doNotUseHTMLParagraphAutoSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12031;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotUseHTMLParagraphAutoSpacing class.
    /// </summary>
    public DoNotUseHTMLParagraphAutoSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotUseHTMLParagraphAutoSpacing>(deep);
    }

}
/// <summary>
/// <para>Ignore Space Before Table When Deciding If Table Should Wrap Floating Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:layoutRawTableWidth.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LayoutRawTableWidth : OnOffType
{
    private const string tagName = "layoutRawTableWidth";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12032;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LayoutRawTableWidth class.
    /// </summary>
    public LayoutRawTableWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LayoutRawTableWidth>(deep);
    }

}
/// <summary>
/// <para>Allow Table Rows to Wrap Inline Objects Independently.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:layoutTableRowsApart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LayoutTableRowsApart : OnOffType
{
    private const string tagName = "layoutTableRowsApart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12033;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LayoutTableRowsApart class.
    /// </summary>
    public LayoutTableRowsApart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LayoutTableRowsApart>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 97 East Asian Line Breaking.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useWord97LineBreakRules.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseWord97LineBreakRules : OnOffType
{
    private const string tagName = "useWord97LineBreakRules";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12034;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseWord97LineBreakRules class.
    /// </summary>
    public UseWord97LineBreakRules():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseWord97LineBreakRules>(deep);
    }

}
/// <summary>
/// <para>Do Not Allow Floating Tables To Break Across Pages.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotBreakWrappedTables.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotBreakWrappedTables : OnOffType
{
    private const string tagName = "doNotBreakWrappedTables";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12035;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotBreakWrappedTables class.
    /// </summary>
    public DoNotBreakWrappedTables():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotBreakWrappedTables>(deep);
    }

}
/// <summary>
/// <para>Do Not Snap to Document Grid in Table Cells with Objects.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotSnapToGridInCell.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotSnapToGridInCell : OnOffType
{
    private const string tagName = "doNotSnapToGridInCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12036;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotSnapToGridInCell class.
    /// </summary>
    public DoNotSnapToGridInCell():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotSnapToGridInCell>(deep);
    }

}
/// <summary>
/// <para>Select Field When First or Last Character Is Selected.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:selectFldWithFirstOrLastChar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SelectFieldWithFirstOrLastChar : OnOffType
{
    private const string tagName = "selectFldWithFirstOrLastChar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12037;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SelectFieldWithFirstOrLastChar class.
    /// </summary>
    public SelectFieldWithFirstOrLastChar():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SelectFieldWithFirstOrLastChar>(deep);
    }

}
/// <summary>
/// <para>Use Legacy Ethiopic and Amharic Line Breaking Rules.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:applyBreakingRules.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ApplyBreakingRules : OnOffType
{
    private const string tagName = "applyBreakingRules";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12038;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ApplyBreakingRules class.
    /// </summary>
    public ApplyBreakingRules():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ApplyBreakingRules>(deep);
    }

}
/// <summary>
/// <para>Do Not Allow Hanging Punctuation With Character Grid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotWrapTextWithPunct.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotWrapTextWithPunctuation : OnOffType
{
    private const string tagName = "doNotWrapTextWithPunct";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12039;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotWrapTextWithPunctuation class.
    /// </summary>
    public DoNotWrapTextWithPunctuation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotWrapTextWithPunctuation>(deep);
    }

}
/// <summary>
/// <para>Do Not Compress Compressible Characters When Using Document Grid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotUseEastAsianBreakRules.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotUseEastAsianBreakRules : OnOffType
{
    private const string tagName = "doNotUseEastAsianBreakRules";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12040;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotUseEastAsianBreakRules class.
    /// </summary>
    public DoNotUseEastAsianBreakRules():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotUseEastAsianBreakRules>(deep);
    }

}
/// <summary>
/// <para>Emulate Word 2002 Table Style Rules.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useWord2002TableStyleRules.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseWord2002TableStyleRules : OnOffType
{
    private const string tagName = "useWord2002TableStyleRules";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12041;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseWord2002TableStyleRules class.
    /// </summary>
    public UseWord2002TableStyleRules():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseWord2002TableStyleRules>(deep);
    }

}
/// <summary>
/// <para>Allow Tables to AutoFit Into Page Margins.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:growAutofit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GrowAutofit : OnOffType
{
    private const string tagName = "growAutofit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12042;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GrowAutofit class.
    /// </summary>
    public GrowAutofit():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GrowAutofit>(deep);
    }

}
/// <summary>
/// <para>Do Not Bypass East Asian/Complex Script Layout Code.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useFELayout.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseFarEastLayout : OnOffType
{
    private const string tagName = "useFELayout";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12043;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseFarEastLayout class.
    /// </summary>
    public UseFarEastLayout():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseFarEastLayout>(deep);
    }

}
/// <summary>
/// <para>Do Not Automatically Apply List Paragraph Style To Bulleted/Numbered Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useNormalStyleForList.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseNormalStyleForList : OnOffType
{
    private const string tagName = "useNormalStyleForList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12044;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseNormalStyleForList class.
    /// </summary>
    public UseNormalStyleForList():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseNormalStyleForList>(deep);
    }

}
/// <summary>
/// <para>Ignore Hanging Indent When Creating Tab Stop After Numbering.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotUseIndentAsNumberingTabStop.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotUseIndentAsNumberingTabStop : OnOffType
{
    private const string tagName = "doNotUseIndentAsNumberingTabStop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12045;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotUseIndentAsNumberingTabStop class.
    /// </summary>
    public DoNotUseIndentAsNumberingTabStop():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotUseIndentAsNumberingTabStop>(deep);
    }

}
/// <summary>
/// <para>Use Alternate Set of East Asian Line Breaking Rules.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useAltKinsokuLineBreakRules.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseAltKinsokuLineBreakRules : OnOffType
{
    private const string tagName = "useAltKinsokuLineBreakRules";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12046;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseAltKinsokuLineBreakRules class.
    /// </summary>
    public UseAltKinsokuLineBreakRules():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseAltKinsokuLineBreakRules>(deep);
    }

}
/// <summary>
/// <para>Allow Contextual Spacing of Paragraphs in Tables.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:allowSpaceOfSameStyleInTable.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AllowSpaceOfSameStyleInTable : OnOffType
{
    private const string tagName = "allowSpaceOfSameStyleInTable";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12047;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AllowSpaceOfSameStyleInTable class.
    /// </summary>
    public AllowSpaceOfSameStyleInTable():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AllowSpaceOfSameStyleInTable>(deep);
    }

}
/// <summary>
/// <para>Do Not Ignore Floating Objects When Calculating Paragraph Indentation.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotSuppressIndentation.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotSuppressIndentation : OnOffType
{
    private const string tagName = "doNotSuppressIndentation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12048;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotSuppressIndentation class.
    /// </summary>
    public DoNotSuppressIndentation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotSuppressIndentation>(deep);
    }

}
/// <summary>
/// <para>Do Not AutoFit Tables To Fit Next To Wrapped Objects.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotAutofitConstrainedTables.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotAutofitConstrainedTables : OnOffType
{
    private const string tagName = "doNotAutofitConstrainedTables";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12049;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotAutofitConstrainedTables class.
    /// </summary>
    public DoNotAutofitConstrainedTables():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotAutofitConstrainedTables>(deep);
    }

}
/// <summary>
/// <para>Allow Table Columns To Exceed Preferred Widths of Constituent Cells.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autofitToFirstFixedWidthCell.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutofitToFirstFixedWidthCell : OnOffType
{
    private const string tagName = "autofitToFirstFixedWidthCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12050;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutofitToFirstFixedWidthCell class.
    /// </summary>
    public AutofitToFirstFixedWidthCell():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutofitToFirstFixedWidthCell>(deep);
    }

}
/// <summary>
/// <para>Underline Following Character Following Numbering.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:underlineTabInNumList.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnderlineTabInNumberingList : OnOffType
{
    private const string tagName = "underlineTabInNumList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12051;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UnderlineTabInNumberingList class.
    /// </summary>
    public UnderlineTabInNumberingList():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnderlineTabInNumberingList>(deep);
    }

}
/// <summary>
/// <para>Always Use Fixed Width for Hangul Characters.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:displayHangulFixedWidth.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DisplayHangulFixedWidth : OnOffType
{
    private const string tagName = "displayHangulFixedWidth";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12052;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DisplayHangulFixedWidth class.
    /// </summary>
    public DisplayHangulFixedWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DisplayHangulFixedWidth>(deep);
    }

}
/// <summary>
/// <para>Always Move Paragraph Mark to Page after a Page Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:splitPgBreakAndParaMark.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SplitPageBreakAndParagraphMark : OnOffType
{
    private const string tagName = "splitPgBreakAndParaMark";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12053;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SplitPageBreakAndParagraphMark class.
    /// </summary>
    public SplitPageBreakAndParagraphMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SplitPageBreakAndParagraphMark>(deep);
    }

}
/// <summary>
/// <para>Don't Vertically Align Cells Containing Floating Objects.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotVertAlignCellWithSp.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotVerticallyAlignCellWithShape : OnOffType
{
    private const string tagName = "doNotVertAlignCellWithSp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12054;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotVerticallyAlignCellWithShape class.
    /// </summary>
    public DoNotVerticallyAlignCellWithShape():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotVerticallyAlignCellWithShape>(deep);
    }

}
/// <summary>
/// <para>Don't Break Table Rows Around Floating Tables.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotBreakConstrainedForcedTable.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotBreakConstrainedForcedTable : OnOffType
{
    private const string tagName = "doNotBreakConstrainedForcedTable";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12055;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotBreakConstrainedForcedTable class.
    /// </summary>
    public DoNotBreakConstrainedForcedTable():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotBreakConstrainedForcedTable>(deep);
    }

}
/// <summary>
/// <para>Ignore Vertical Alignment in Textboxes.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotVertAlignInTxbx.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotVerticallyAlignInTextBox : OnOffType
{
    private const string tagName = "doNotVertAlignInTxbx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12056;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotVerticallyAlignInTextBox class.
    /// </summary>
    public DoNotVerticallyAlignInTextBox():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotVerticallyAlignInTextBox>(deep);
    }

}
/// <summary>
/// <para>Use ANSI Kerning Pairs from Fonts.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useAnsiKerningPairs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseAnsiKerningPairs : OnOffType
{
    private const string tagName = "useAnsiKerningPairs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12057;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseAnsiKerningPairs class.
    /// </summary>
    public UseAnsiKerningPairs():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseAnsiKerningPairs>(deep);
    }

}
/// <summary>
/// <para>Use Cached Paragraph Information for Column Balancing.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cachedColBalance.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CachedColumnBalance : OnOffType
{
    private const string tagName = "cachedColBalance";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12058;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CachedColumnBalance class.
    /// </summary>
    public CachedColumnBalance():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CachedColumnBalance>(deep);
    }

}
/// <summary>
/// <para>Defines the ShowingPlaceholder Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:showingPlcHdr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShowingPlaceholder : OnOffType
{
    private const string tagName = "showingPlcHdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12086;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShowingPlaceholder class.
    /// </summary>
    public ShowingPlaceholder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShowingPlaceholder>(deep);
    }

}
/// <summary>
/// <para>Defines the TemporarySdt Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:temporary.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TemporarySdt : OnOffType
{
    private const string tagName = "temporary";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12088;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TemporarySdt class.
    /// </summary>
    public TemporarySdt():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TemporarySdt>(deep);
    }

}
/// <summary>
/// <para>Remove Personal Information from Document Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:removePersonalInformation.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RemovePersonalInformation : OnOffType
{
    private const string tagName = "removePersonalInformation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12106;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RemovePersonalInformation class.
    /// </summary>
    public RemovePersonalInformation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RemovePersonalInformation>(deep);
    }

}
/// <summary>
/// <para>Remove Date and Time from Annotations.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:removeDateAndTime.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RemoveDateAndTime : OnOffType
{
    private const string tagName = "removeDateAndTime";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12107;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RemoveDateAndTime class.
    /// </summary>
    public RemoveDateAndTime():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RemoveDateAndTime>(deep);
    }

}
/// <summary>
/// <para>Do Not Display Visual Boundary For Header/Footer or Between Pages.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotDisplayPageBoundaries.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotDisplayPageBoundaries : OnOffType
{
    private const string tagName = "doNotDisplayPageBoundaries";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12108;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotDisplayPageBoundaries class.
    /// </summary>
    public DoNotDisplayPageBoundaries():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotDisplayPageBoundaries>(deep);
    }

}
/// <summary>
/// <para>Display Background Objects When Displaying Document.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:displayBackgroundShape.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DisplayBackgroundShape : OnOffType
{
    private const string tagName = "displayBackgroundShape";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12109;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DisplayBackgroundShape class.
    /// </summary>
    public DisplayBackgroundShape():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DisplayBackgroundShape>(deep);
    }

}
/// <summary>
/// <para>Print PostScript Codes With Document Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printPostScriptOverText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintPostScriptOverText : OnOffType
{
    private const string tagName = "printPostScriptOverText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12110;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintPostScriptOverText class.
    /// </summary>
    public PrintPostScriptOverText():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintPostScriptOverText>(deep);
    }

}
/// <summary>
/// <para>Print Fractional Character Widths.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printFractionalCharacterWidth.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintFractionalCharacterWidth : OnOffType
{
    private const string tagName = "printFractionalCharacterWidth";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12111;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintFractionalCharacterWidth class.
    /// </summary>
    public PrintFractionalCharacterWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintFractionalCharacterWidth>(deep);
    }

}
/// <summary>
/// <para>Only Print Form Field Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printFormsData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintFormsData : OnOffType
{
    private const string tagName = "printFormsData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12112;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintFormsData class.
    /// </summary>
    public PrintFormsData():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintFormsData>(deep);
    }

}
/// <summary>
/// <para>Embed TrueType Fonts.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedTrueTypeFonts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedTrueTypeFonts : OnOffType
{
    private const string tagName = "embedTrueTypeFonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12113;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedTrueTypeFonts class.
    /// </summary>
    public EmbedTrueTypeFonts():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedTrueTypeFonts>(deep);
    }

}
/// <summary>
/// <para>Embed Common System Fonts.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedSystemFonts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedSystemFonts : OnOffType
{
    private const string tagName = "embedSystemFonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12114;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedSystemFonts class.
    /// </summary>
    public EmbedSystemFonts():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedSystemFonts>(deep);
    }

}
/// <summary>
/// <para>Subset Fonts When Embedding.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:saveSubsetFonts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaveSubsetFonts : OnOffType
{
    private const string tagName = "saveSubsetFonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12115;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaveSubsetFonts class.
    /// </summary>
    public SaveSubsetFonts():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaveSubsetFonts>(deep);
    }

}
/// <summary>
/// <para>Only Save Form Field Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:saveFormsData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaveFormsData : OnOffType
{
    private const string tagName = "saveFormsData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12116;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaveFormsData class.
    /// </summary>
    public SaveFormsData():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaveFormsData>(deep);
    }

}
/// <summary>
/// <para>Mirror Page Margins.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mirrorMargins.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MirrorMargins : OnOffType
{
    private const string tagName = "mirrorMargins";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12117;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MirrorMargins class.
    /// </summary>
    public MirrorMargins():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MirrorMargins>(deep);
    }

}
/// <summary>
/// <para>Align Paragraph and Table Borders with Page Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:alignBordersAndEdges.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlignBorderAndEdges : OnOffType
{
    private const string tagName = "alignBordersAndEdges";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12118;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AlignBorderAndEdges class.
    /// </summary>
    public AlignBorderAndEdges():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlignBorderAndEdges>(deep);
    }

}
/// <summary>
/// <para>Page Border Excludes Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bordersDoNotSurroundHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BordersDoNotSurroundHeader : OnOffType
{
    private const string tagName = "bordersDoNotSurroundHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12119;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BordersDoNotSurroundHeader class.
    /// </summary>
    public BordersDoNotSurroundHeader():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BordersDoNotSurroundHeader>(deep);
    }

}
/// <summary>
/// <para>Page Border Excludes Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bordersDoNotSurroundFooter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BordersDoNotSurroundFooter : OnOffType
{
    private const string tagName = "bordersDoNotSurroundFooter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12120;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BordersDoNotSurroundFooter class.
    /// </summary>
    public BordersDoNotSurroundFooter():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BordersDoNotSurroundFooter>(deep);
    }

}
/// <summary>
/// <para>Position Gutter At Top of Page.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gutterAtTop.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GutterAtTop : OnOffType
{
    private const string tagName = "gutterAtTop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12121;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GutterAtTop class.
    /// </summary>
    public GutterAtTop():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GutterAtTop>(deep);
    }

}
/// <summary>
/// <para>Do Not Display Visual Indication of Spelling Errors.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hideSpellingErrors.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HideSpellingErrors : OnOffType
{
    private const string tagName = "hideSpellingErrors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12122;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HideSpellingErrors class.
    /// </summary>
    public HideSpellingErrors():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HideSpellingErrors>(deep);
    }

}
/// <summary>
/// <para>Do Not Display Visual Indication of Grammatical Errors.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hideGrammaticalErrors.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HideGrammaticalErrors : OnOffType
{
    private const string tagName = "hideGrammaticalErrors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12123;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HideGrammaticalErrors class.
    /// </summary>
    public HideGrammaticalErrors():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HideGrammaticalErrors>(deep);
    }

}
/// <summary>
/// <para>Structured Document Tag Placeholder Text Should be Resaved.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:formsDesign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormsDesign : OnOffType
{
    private const string tagName = "formsDesign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12126;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FormsDesign class.
    /// </summary>
    public FormsDesign():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormsDesign>(deep);
    }

}
/// <summary>
/// <para>Automatically Update Styles From Document Template.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:linkStyles.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LinkStyles : OnOffType
{
    private const string tagName = "linkStyles";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12128;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LinkStyles class.
    /// </summary>
    public LinkStyles():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LinkStyles>(deep);
    }

}
/// <summary>
/// <para>Track Revisions to Document.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trackRevisions.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TrackRevisions : OnOffType
{
    private const string tagName = "trackRevisions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12134;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TrackRevisions class.
    /// </summary>
    public TrackRevisions():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TrackRevisions>(deep);
    }

}
/// <summary>
/// <para>Do Not Use Move Syntax When Tracking Revisions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotTrackMoves.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotTrackMoves : OnOffType
{
    private const string tagName = "doNotTrackMoves";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12135;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotTrackMoves class.
    /// </summary>
    public DoNotTrackMoves():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotTrackMoves>(deep);
    }

}
/// <summary>
/// <para>Do Not Track Formatting Revisions When Tracking Revisions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotTrackFormatting.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotTrackFormatting : OnOffType
{
    private const string tagName = "doNotTrackFormatting";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12136;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotTrackFormatting class.
    /// </summary>
    public DoNotTrackFormatting():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotTrackFormatting>(deep);
    }

}
/// <summary>
/// <para>Allow Automatic Formatting to Override Formatting Protection Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoFormatOverride.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoFormatOverride : OnOffType
{
    private const string tagName = "autoFormatOverride";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12138;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoFormatOverride class.
    /// </summary>
    public AutoFormatOverride():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoFormatOverride>(deep);
    }

}
/// <summary>
/// <para>Prevent Modification of Themes Part.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:styleLockTheme.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleLockThemesPart : OnOffType
{
    private const string tagName = "styleLockTheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12139;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleLockThemesPart class.
    /// </summary>
    public StyleLockThemesPart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleLockThemesPart>(deep);
    }

}
/// <summary>
/// <para>Prevent Replacement of Styles Part.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:styleLockQFSet.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleLockStylesPart : OnOffType
{
    private const string tagName = "styleLockQFSet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12140;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleLockStylesPart class.
    /// </summary>
    public StyleLockStylesPart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleLockStylesPart>(deep);
    }

}
/// <summary>
/// <para>Automatically Hyphenate Document Contents When Displayed.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoHyphenation.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoHyphenation : OnOffType
{
    private const string tagName = "autoHyphenation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12142;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoHyphenation class.
    /// </summary>
    public AutoHyphenation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoHyphenation>(deep);
    }

}
/// <summary>
/// <para>Do Not Hyphenate Words in ALL CAPITAL LETTERS.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotHyphenateCaps.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotHyphenateCaps : OnOffType
{
    private const string tagName = "doNotHyphenateCaps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12145;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotHyphenateCaps class.
    /// </summary>
    public DoNotHyphenateCaps():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotHyphenateCaps>(deep);
    }

}
/// <summary>
/// <para>Show E-Mail Message Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:showEnvelope.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShowEnvelope : OnOffType
{
    private const string tagName = "showEnvelope";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12146;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShowEnvelope class.
    /// </summary>
    public ShowEnvelope():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShowEnvelope>(deep);
    }

}
/// <summary>
/// <para>Different Even/Odd Page Headers and Footers.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:evenAndOddHeaders.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EvenAndOddHeaders : OnOffType
{
    private const string tagName = "evenAndOddHeaders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12150;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EvenAndOddHeaders class.
    /// </summary>
    public EvenAndOddHeaders():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EvenAndOddHeaders>(deep);
    }

}
/// <summary>
/// <para>Reverse Book Fold Printing.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bookFoldRevPrinting.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookFoldReversePrinting : OnOffType
{
    private const string tagName = "bookFoldRevPrinting";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12151;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BookFoldReversePrinting class.
    /// </summary>
    public BookFoldReversePrinting():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookFoldReversePrinting>(deep);
    }

}
/// <summary>
/// <para>Book Fold Printing.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bookFoldPrinting.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookFoldPrinting : OnOffType
{
    private const string tagName = "bookFoldPrinting";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12152;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BookFoldPrinting class.
    /// </summary>
    public BookFoldPrinting():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookFoldPrinting>(deep);
    }

}
/// <summary>
/// <para>Do Not Use Margins for Drawing Grid Origin.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotUseMarginsForDrawingGridOrigin.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotUseMarginsForDrawingGridOrigin : OnOffType
{
    private const string tagName = "doNotUseMarginsForDrawingGridOrigin";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12158;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotUseMarginsForDrawingGridOrigin class.
    /// </summary>
    public DoNotUseMarginsForDrawingGridOrigin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotUseMarginsForDrawingGridOrigin>(deep);
    }

}
/// <summary>
/// <para>Do Not Show Visual Indicator For Form Fields.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotShadeFormData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotShadeFormData : OnOffType
{
    private const string tagName = "doNotShadeFormData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12161;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotShadeFormData class.
    /// </summary>
    public DoNotShadeFormData():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotShadeFormData>(deep);
    }

}
/// <summary>
/// <para>Never Kern Punctuation Characters.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noPunctuationKerning.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoPunctuationKerning : OnOffType
{
    private const string tagName = "noPunctuationKerning";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12162;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoPunctuationKerning class.
    /// </summary>
    public NoPunctuationKerning():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoPunctuationKerning>(deep);
    }

}
/// <summary>
/// <para>Print Two Pages Per Sheet.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printTwoOnOne.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintTwoOnOne : OnOffType
{
    private const string tagName = "printTwoOnOne";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12164;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintTwoOnOne class.
    /// </summary>
    public PrintTwoOnOne():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintTwoOnOne>(deep);
    }

}
/// <summary>
/// <para>Use Strict Kinsoku Rules for Japanese Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:strictFirstAndLastChars.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StrictFirstAndLastChars : OnOffType
{
    private const string tagName = "strictFirstAndLastChars";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12165;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StrictFirstAndLastChars class.
    /// </summary>
    public StrictFirstAndLastChars():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StrictFirstAndLastChars>(deep);
    }

}
/// <summary>
/// <para>Generate Thumbnail For Document On Save.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:savePreviewPicture.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SavePreviewPicture : OnOffType
{
    private const string tagName = "savePreviewPicture";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12168;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SavePreviewPicture class.
    /// </summary>
    public SavePreviewPicture():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SavePreviewPicture>(deep);
    }

}
/// <summary>
/// <para>Do Not Validate Custom XML Markup Against Schemas.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotValidateAgainstSchema.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotValidateAgainstSchema : OnOffType
{
    private const string tagName = "doNotValidateAgainstSchema";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12169;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotValidateAgainstSchema class.
    /// </summary>
    public DoNotValidateAgainstSchema():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotValidateAgainstSchema>(deep);
    }

}
/// <summary>
/// <para>Allow Saving Document As XML File When Custom XML Markup Is Invalid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:saveInvalidXml.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaveInvalidXml : OnOffType
{
    private const string tagName = "saveInvalidXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12170;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaveInvalidXml class.
    /// </summary>
    public SaveInvalidXml():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaveInvalidXml>(deep);
    }

}
/// <summary>
/// <para>Ignore Mixed Content When Validating Custom XML Markup.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ignoreMixedContent.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IgnoreMixedContent : OnOffType
{
    private const string tagName = "ignoreMixedContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12171;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the IgnoreMixedContent class.
    /// </summary>
    public IgnoreMixedContent():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IgnoreMixedContent>(deep);
    }

}
/// <summary>
/// <para>Use Custom XML Element Names as Default Placeholder Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:alwaysShowPlaceholderText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlwaysShowPlaceholderText : OnOffType
{
    private const string tagName = "alwaysShowPlaceholderText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12172;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AlwaysShowPlaceholderText class.
    /// </summary>
    public AlwaysShowPlaceholderText():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlwaysShowPlaceholderText>(deep);
    }

}
/// <summary>
/// <para>Do Not Show Visual Indicator For Invalid Custom XML Markup.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotDemarcateInvalidXml.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotDemarcateInvalidXml : OnOffType
{
    private const string tagName = "doNotDemarcateInvalidXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12173;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotDemarcateInvalidXml class.
    /// </summary>
    public DoNotDemarcateInvalidXml():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotDemarcateInvalidXml>(deep);
    }

}
/// <summary>
/// <para>Only Save Custom XML Markup.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:saveXmlDataOnly.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaveXmlDataOnly : OnOffType
{
    private const string tagName = "saveXmlDataOnly";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12174;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SaveXmlDataOnly class.
    /// </summary>
    public SaveXmlDataOnly():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaveXmlDataOnly>(deep);
    }

}
/// <summary>
/// <para>Save Document as XML File through Custom XSL Transform.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:useXSLTWhenSaving.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UseXsltWhenSaving : OnOffType
{
    private const string tagName = "useXSLTWhenSaving";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12175;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UseXsltWhenSaving class.
    /// </summary>
    public UseXsltWhenSaving():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UseXsltWhenSaving>(deep);
    }

}
/// <summary>
/// <para>Show Visual Indicators for Custom XML Markup Start/End Locations.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:showXMLTags.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShowXmlTags : OnOffType
{
    private const string tagName = "showXMLTags";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12177;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShowXmlTags class.
    /// </summary>
    public ShowXmlTags():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShowXmlTags>(deep);
    }

}
/// <summary>
/// <para>Do Not Mark Custom XML Elements With No Namespace As Invalid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:alwaysMergeEmptyNamespace.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AlwaysMergeEmptyNamespace : OnOffType
{
    private const string tagName = "alwaysMergeEmptyNamespace";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12178;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AlwaysMergeEmptyNamespace class.
    /// </summary>
    public AlwaysMergeEmptyNamespace():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AlwaysMergeEmptyNamespace>(deep);
    }

}
/// <summary>
/// <para>Automatically Recalculate Fields on Open.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:updateFields.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UpdateFieldsOnOpen : OnOffType
{
    private const string tagName = "updateFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12179;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UpdateFieldsOnOpen class.
    /// </summary>
    public UpdateFieldsOnOpen():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UpdateFieldsOnOpen>(deep);
    }

}
/// <summary>
/// <para>Disable Features Incompatible With Earlier Word Processing Formats.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:uiCompat97To2003.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UICompatibleWith97To2003 : OnOffType
{
    private const string tagName = "uiCompat97To2003";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12186;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UICompatibleWith97To2003 class.
    /// </summary>
    public UICompatibleWith97To2003():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UICompatibleWith97To2003>(deep);
    }

}
/// <summary>
/// <para>Do Not Include Content in Text Boxes, Footnotes, and Endnotes in Document Statistics.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotIncludeSubdocsInStats.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotIncludeSubdocsInStats : OnOffType
{
    private const string tagName = "doNotIncludeSubdocsInStats";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12190;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotIncludeSubdocsInStats class.
    /// </summary>
    public DoNotIncludeSubdocsInStats():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotIncludeSubdocsInStats>(deep);
    }

}
/// <summary>
/// <para>Do Not Automatically Compress Images.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotAutoCompressPictures.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotAutoCompressPictures : OnOffType
{
    private const string tagName = "doNotAutoCompressPictures";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12191;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotAutoCompressPictures class.
    /// </summary>
    public DoNotAutoCompressPictures():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotAutoCompressPictures>(deep);
    }

}
/// <summary>
/// <para>Defines the OptimizeForBrowser Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:optimizeForBrowser.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OptimizeForBrowser : OnOffType
{
    private const string tagName = "optimizeForBrowser";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12200;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OptimizeForBrowser class.
    /// </summary>
    public OptimizeForBrowser():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OptimizeForBrowser>(deep);
    }

}
/// <summary>
/// <para>Defines the RelyOnVML Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:relyOnVML.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RelyOnVML : OnOffType
{
    private const string tagName = "relyOnVML";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12201;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RelyOnVML class.
    /// </summary>
    public RelyOnVML():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RelyOnVML>(deep);
    }

}
/// <summary>
/// <para>Defines the AllowPNG Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:allowPNG.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AllowPNG : OnOffType
{
    private const string tagName = "allowPNG";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12202;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AllowPNG class.
    /// </summary>
    public AllowPNG():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AllowPNG>(deep);
    }

}
/// <summary>
/// <para>Defines the DoNotRelyOnCSS Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotRelyOnCSS.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotRelyOnCSS : OnOffType
{
    private const string tagName = "doNotRelyOnCSS";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12203;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotRelyOnCSS class.
    /// </summary>
    public DoNotRelyOnCSS():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotRelyOnCSS>(deep);
    }

}
/// <summary>
/// <para>Defines the DoNotSaveAsSingleFile Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotSaveAsSingleFile.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotSaveAsSingleFile : OnOffType
{
    private const string tagName = "doNotSaveAsSingleFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12204;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotSaveAsSingleFile class.
    /// </summary>
    public DoNotSaveAsSingleFile():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotSaveAsSingleFile>(deep);
    }

}
/// <summary>
/// <para>Defines the DoNotOrganizeInFolder Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotOrganizeInFolder.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotOrganizeInFolder : OnOffType
{
    private const string tagName = "doNotOrganizeInFolder";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12205;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotOrganizeInFolder class.
    /// </summary>
    public DoNotOrganizeInFolder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotOrganizeInFolder>(deep);
    }

}
/// <summary>
/// <para>Defines the DoNotUseLongFileNames Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:doNotUseLongFileNames.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DoNotUseLongFileNames : OnOffType
{
    private const string tagName = "doNotUseLongFileNames";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12206;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DoNotUseLongFileNames class.
    /// </summary>
    public DoNotUseLongFileNames():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DoNotUseLongFileNames>(deep);
    }

}
/// <summary>
/// <para>Defines the NotTrueType Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:notTrueType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NotTrueType : OnOffType
{
    private const string tagName = "notTrueType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12214;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NotTrueType class.
    /// </summary>
    public NotTrueType():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NotTrueType>(deep);
    }

}
/// <summary>
/// Defines the OnOffType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class OnOffType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> On/Off Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public OnOffValue Val
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the OnOffType class.
    /// </summary>
    protected OnOffType(){}
    
    
    
}
/// <summary>
/// <para>Defines the FrameProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:framePr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FrameProperties : OpenXmlLeafElement
{
    private const string tagName = "framePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11560;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "dropCap","lines","w","h","vSpace","hSpace","wrap","hAnchor","vAnchor","x","xAlign","y","yAlign","hRule","anchorLock" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Drop Cap Frame.</para>
    /// <para>Represents the following attribute in the schema: w:dropCap </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dropCap")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DropCapLocationValues> DropCap
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DropCapLocationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Drop Cap Vertical Height in Lines.</para>
    /// <para>Represents the following attribute in the schema: w:lines </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lines")]
    public Int32Value Lines
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Frame Width.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public StringValue Width
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Frame Height.</para>
    /// <para>Represents the following attribute in the schema: w:h </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "h")]
    public UInt32Value Height
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Frame Padding.</para>
    /// <para>Represents the following attribute in the schema: w:vSpace </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vSpace")]
    public StringValue VerticalSpace
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal Frame Padding.</para>
    /// <para>Represents the following attribute in the schema: w:hSpace </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hSpace")]
    public StringValue HorizontalSpace
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Text Wrapping Around Frame.</para>
    /// <para>Represents the following attribute in the schema: w:wrap </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "wrap")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextWrappingValues> Wrap
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextWrappingValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Frame Horizontal Positioning Base.</para>
    /// <para>Represents the following attribute in the schema: w:hAnchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hAnchor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues> HorizontalPosition
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Frame Vertical Positioning Base.</para>
    /// <para>Represents the following attribute in the schema: w:vAnchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vAnchor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues> VerticalPosition
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Absolute Horizontal Position.</para>
    /// <para>Represents the following attribute in the schema: w:x </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "x")]
    public StringValue X
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Relative Horizontal Position.</para>
    /// <para>Represents the following attribute in the schema: w:xAlign </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "xAlign")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues> XAlign
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues>)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Absolute Vertical Position.</para>
    /// <para>Represents the following attribute in the schema: w:y </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "y")]
    public StringValue Y
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Relative Vertical Position.</para>
    /// <para>Represents the following attribute in the schema: w:yAlign </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "yAlign")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues> YAlign
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues>)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Frame Height Type.</para>
    /// <para>Represents the following attribute in the schema: w:hRule </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hRule")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues> HeightType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues>)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Lock Frame Anchor to Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:anchorLock </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "anchorLock")]
    public OnOffValue AnchorLock
    {
        get { return (OnOffValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FrameProperties class.
    /// </summary>
    public FrameProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "dropCap" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DropCapLocationValues>();
    
if( 23 == namespaceId && "lines" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "w" == name)
    return new StringValue();
    
if( 23 == namespaceId && "h" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "vSpace" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hSpace" == name)
    return new StringValue();
    
if( 23 == namespaceId && "wrap" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextWrappingValues>();
    
if( 23 == namespaceId && "hAnchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues>();
    
if( 23 == namespaceId && "vAnchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues>();
    
if( 23 == namespaceId && "x" == name)
    return new StringValue();
    
if( 23 == namespaceId && "xAlign" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues>();
    
if( 23 == namespaceId && "y" == name)
    return new StringValue();
    
if( 23 == namespaceId && "yAlign" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues>();
    
if( 23 == namespaceId && "hRule" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues>();
    
if( 23 == namespaceId && "anchorLock" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FrameProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NumberingProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NumberingLevelReference &lt;w:ilvl></description></item>
///<item><description>NumberingId &lt;w:numId></description></item>
///<item><description>NumberingChange &lt;w:numberingChange></description></item>
///<item><description>Inserted &lt;w:ins></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NumberingLevelReference))]
    [ChildElementInfo(typeof(NumberingId))]
    [ChildElementInfo(typeof(NumberingChange))]
    [ChildElementInfo(typeof(Inserted))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingProperties : OpenXmlCompositeElement
{
    private const string tagName = "numPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11562;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NumberingProperties class.
    /// </summary>
    public NumberingProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberingProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "ilvl" == name)
    return new NumberingLevelReference();
    
if( 23 == namespaceId && "numId" == name)
    return new NumberingId();
    
if( 23 == namespaceId && "numberingChange" == name)
    return new NumberingChange();
    
if( 23 == namespaceId && "ins" == name)
    return new Inserted();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ilvl","numId","numberingChange","ins" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Numbering Level Reference.</para>
    /// <para> Represents the following element tag in the schema: w:ilvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingLevelReference NumberingLevelReference
    {
        get 
        {
            return GetElement<NumberingLevelReference>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Numbering Definition Instance Reference.</para>
    /// <para> Represents the following element tag in the schema: w:numId </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingId NumberingId
    {
        get 
        {
            return GetElement<NumberingId>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Previous Paragraph Numbering Properties.</para>
    /// <para> Represents the following element tag in the schema: w:numberingChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingChange NumberingChange
    {
        get 
        {
            return GetElement<NumberingChange>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Inserted Numbering Properties.</para>
    /// <para> Represents the following element tag in the schema: w:ins </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Inserted Inserted
    {
        get 
        {
            return GetElement<Inserted>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ParagraphBorders Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pBdr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopBorder &lt;w:top></description></item>
///<item><description>LeftBorder &lt;w:left></description></item>
///<item><description>BottomBorder &lt;w:bottom></description></item>
///<item><description>RightBorder &lt;w:right></description></item>
///<item><description>BetweenBorder &lt;w:between></description></item>
///<item><description>BarBorder &lt;w:bar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(RightBorder))]
    [ChildElementInfo(typeof(BetweenBorder))]
    [ChildElementInfo(typeof(BarBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphBorders : OpenXmlCompositeElement
{
    private const string tagName = "pBdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11564;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphBorders class.
    /// </summary>
    public ParagraphBorders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphBorders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphBorders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphBorders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphBorders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 23 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 23 == namespaceId && "right" == name)
    return new RightBorder();
    
if( 23 == namespaceId && "between" == name)
    return new BetweenBorder();
    
if( 23 == namespaceId && "bar" == name)
    return new BarBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","bottom","right","between","bar" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Paragraph Border Above Identical Paragraphs.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Left Paragraph Border.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Paragraph Border Between Identical Paragraphs.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Right Paragraph Border.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Paragraph Border Between Identical Paragraphs.</para>
    /// <para> Represents the following element tag in the schema: w:between </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BetweenBorder BetweenBorder
    {
        get 
        {
            return GetElement<BetweenBorder>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Paragraph Border Between Facing Pages.</para>
    /// <para> Represents the following element tag in the schema: w:bar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BarBorder BarBorder
    {
        get 
        {
            return GetElement<BarBorder>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphBorders>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Shading Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:shd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shading : OpenXmlLeafElement
{
    private const string tagName = "shd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11565;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","color","themeColor","themeTint","themeShade","fill","themeFill","themeFillTint","themeFillShade" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shading Pattern.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ShadingPatternValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ShadingPatternValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Shading Pattern Color.</para>
    /// <para>Represents the following attribute in the schema: w:color </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "color")]
    public StringValue Color
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Shading Pattern Theme Color.</para>
    /// <para>Represents the following attribute in the schema: w:themeColor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeColor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeColor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Shading Pattern Theme Color Tint.</para>
    /// <para>Represents the following attribute in the schema: w:themeTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeTint")]
    public StringValue ThemeTint
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Shading Pattern Theme Color Shade.</para>
    /// <para>Represents the following attribute in the schema: w:themeShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeShade")]
    public StringValue ThemeShade
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Shading Background Color.</para>
    /// <para>Represents the following attribute in the schema: w:fill </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fill")]
    public StringValue Fill
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Shading Background Theme Color.</para>
    /// <para>Represents the following attribute in the schema: w:themeFill </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeFill")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeFill
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Shading Background Theme Color Tint.</para>
    /// <para>Represents the following attribute in the schema: w:themeFillTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeFillTint")]
    public StringValue ThemeFillTint
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Shading Background Theme Color Shade.</para>
    /// <para>Represents the following attribute in the schema: w:themeFillShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeFillShade")]
    public StringValue ThemeFillShade
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Shading class.
    /// </summary>
    public Shading():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ShadingPatternValues>();
    
if( 23 == namespaceId && "color" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeColor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeShade" == name)
    return new StringValue();
    
if( 23 == namespaceId && "fill" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeFill" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeFillTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeFillShade" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shading>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Tabs Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tabs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TabStop &lt;w:tab></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TabStop))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tabs : OpenXmlCompositeElement
{
    private const string tagName = "tabs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11566;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Tabs class.
    /// </summary>
    public Tabs():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Tabs class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tabs(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Tabs class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tabs(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Tabs class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Tabs(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tab" == name)
    return new TabStop();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tabs>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SpacingBetweenLines Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:spacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SpacingBetweenLines : OpenXmlLeafElement
{
    private const string tagName = "spacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11577;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "before","beforeLines","beforeAutospacing","after","afterLines","afterAutospacing","line","lineRule" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Spacing Above Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:before </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "before")]
    public StringValue Before
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Spacing Above Paragraph IN Line Units.</para>
    /// <para>Represents the following attribute in the schema: w:beforeLines </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "beforeLines")]
    public Int32Value BeforeLines
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Automatically Determine Spacing Above Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:beforeAutospacing </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "beforeAutospacing")]
    public OnOffValue BeforeAutoSpacing
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Spacing Below Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:after </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "after")]
    public StringValue After
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Spacing Below Paragraph in Line Units.</para>
    /// <para>Represents the following attribute in the schema: w:afterLines </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "afterLines")]
    public Int32Value AfterLines
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Automatically Determine Spacing Below Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:afterAutospacing </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "afterAutospacing")]
    public OnOffValue AfterAutoSpacing
    {
        get { return (OnOffValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Spacing Between Lines in Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:line </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "line")]
    public StringValue Line
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Type of Spacing Between Lines.</para>
    /// <para>Represents the following attribute in the schema: w:lineRule </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lineRule")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineSpacingRuleValues> LineRule
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineSpacingRuleValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SpacingBetweenLines class.
    /// </summary>
    public SpacingBetweenLines():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "before" == name)
    return new StringValue();
    
if( 23 == namespaceId && "beforeLines" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "beforeAutospacing" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "after" == name)
    return new StringValue();
    
if( 23 == namespaceId && "afterLines" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "afterAutospacing" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "line" == name)
    return new StringValue();
    
if( 23 == namespaceId && "lineRule" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineSpacingRuleValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SpacingBetweenLines>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Indentation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ind.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Indentation : OpenXmlLeafElement
{
    private const string tagName = "ind";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11578;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "left","start","leftChars","startChars","right","end","rightChars","endChars","hanging","hangingChars","firstLine","firstLineChars" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Left Indentation.</para>
    /// <para>Represents the following attribute in the schema: w:left </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "left")]
    public StringValue Left
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> start.</para>
    /// <para>Represents the following attribute in the schema: w:start </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "start")]
    public StringValue Start
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Left Indentation in Character Units.</para>
    /// <para>Represents the following attribute in the schema: w:leftChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "leftChars")]
    public Int32Value LeftChars
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> startChars.</para>
    /// <para>Represents the following attribute in the schema: w:startChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "startChars")]
    public Int32Value StartCharacters
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Right Indentation.</para>
    /// <para>Represents the following attribute in the schema: w:right </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "right")]
    public StringValue Right
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> end.</para>
    /// <para>Represents the following attribute in the schema: w:end </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "end")]
    public StringValue End
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Right Indentation in Character Units.</para>
    /// <para>Represents the following attribute in the schema: w:rightChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rightChars")]
    public Int32Value RightChars
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> endChars.</para>
    /// <para>Represents the following attribute in the schema: w:endChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "endChars")]
    public Int32Value EndCharacters
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Indentation Removed from First Line.</para>
    /// <para>Represents the following attribute in the schema: w:hanging </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hanging")]
    public StringValue Hanging
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Indentation Removed From First Line in Character Units.</para>
    /// <para>Represents the following attribute in the schema: w:hangingChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hangingChars")]
    public Int32Value HangingChars
    {
        get { return (Int32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Additional First Line Indentation.</para>
    /// <para>Represents the following attribute in the schema: w:firstLine </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstLine")]
    public StringValue FirstLine
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Additional First Line Indentation in Character Units.</para>
    /// <para>Represents the following attribute in the schema: w:firstLineChars </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstLineChars")]
    public Int32Value FirstLineChars
    {
        get { return (Int32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Indentation class.
    /// </summary>
    public Indentation():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "left" == name)
    return new StringValue();
    
if( 23 == namespaceId && "start" == name)
    return new StringValue();
    
if( 23 == namespaceId && "leftChars" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "startChars" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "right" == name)
    return new StringValue();
    
if( 23 == namespaceId && "end" == name)
    return new StringValue();
    
if( 23 == namespaceId && "rightChars" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "endChars" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "hanging" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hangingChars" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "firstLine" == name)
    return new StringValue();
    
if( 23 == namespaceId && "firstLineChars" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Indentation>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Justification Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:jc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Justification : OpenXmlLeafElement
{
    private const string tagName = "jc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11582;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Alignment Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.JustificationValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.JustificationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Justification class.
    /// </summary>
    public Justification():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.JustificationValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Justification>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextDirection Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:textDirection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextDirection : OpenXmlLeafElement
{
    private const string tagName = "textDirection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11583;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Direction of Text Flow.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextDirectionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextDirectionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextDirection class.
    /// </summary>
    public TextDirection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextDirectionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextDirection>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextAlignment Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:textAlignment.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextAlignment : OpenXmlLeafElement
{
    private const string tagName = "textAlignment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11584;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Vertical Character Alignment Position.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalTextAlignmentValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalTextAlignmentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextAlignment class.
    /// </summary>
    public TextAlignment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalTextAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextAlignment>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextBoxTightWrap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:textboxTightWrap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextBoxTightWrap : OpenXmlLeafElement
{
    private const string tagName = "textboxTightWrap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11585;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Lines to Tight Wrap to Paragraph Extents.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxTightWrapValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxTightWrapValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextBoxTightWrap class.
    /// </summary>
    public TextBoxTightWrap():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxTightWrapValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextBoxTightWrap>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OutlineLevel Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:outlineLvl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OutlineLevel : DecimalNumberType
{
    private const string tagName = "outlineLvl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11586;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OutlineLevel class.
    /// </summary>
    public OutlineLevel():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OutlineLevel>(deep);
    }

}
/// <summary>
/// <para>Defines the GridSpan Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gridSpan.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GridSpan : DecimalNumberType
{
    private const string tagName = "gridSpan";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11697;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GridSpan class.
    /// </summary>
    public GridSpan():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GridSpan>(deep);
    }

}
/// <summary>
/// <para>Defines the GridBefore Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gridBefore.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GridBefore : DecimalNumberType
{
    private const string tagName = "gridBefore";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11707;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GridBefore class.
    /// </summary>
    public GridBefore():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GridBefore>(deep);
    }

}
/// <summary>
/// <para>Defines the GridAfter Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gridAfter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GridAfter : DecimalNumberType
{
    private const string tagName = "gridAfter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11708;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the GridAfter class.
    /// </summary>
    public GridAfter():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GridAfter>(deep);
    }

}
/// <summary>
/// <para>Drop-Down List Selection.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:result.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DropDownListSelection : DecimalNumberType
{
    private const string tagName = "result";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11803;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DropDownListSelection class.
    /// </summary>
    public DropDownListSelection():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DropDownListSelection>(deep);
    }

}
/// <summary>
/// <para>Record Currently Displayed In Merged Document.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:activeRecord.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ActiveRecord : DecimalNumberType
{
    private const string tagName = "activeRecord";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11886;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ActiveRecord class.
    /// </summary>
    public ActiveRecord():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ActiveRecord>(deep);
    }

}
/// <summary>
/// <para>Mail Merge Error Reporting Setting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:checkErrors.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CheckErrors : DecimalNumberType
{
    private const string tagName = "checkErrors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11887;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CheckErrors class.
    /// </summary>
    public CheckErrors():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CheckErrors>(deep);
    }

}
/// <summary>
/// <para>Restart Numbering Level Symbol.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvlRestart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelRestart : DecimalNumberType
{
    private const string tagName = "lvlRestart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11912;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelRestart class.
    /// </summary>
    public LevelRestart():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelRestart>(deep);
    }

}
/// <summary>
/// <para>Picture Numbering Symbol Definition Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvlPicBulletId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelPictureBulletId : DecimalNumberType
{
    private const string tagName = "lvlPicBulletId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11917;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelPictureBulletId class.
    /// </summary>
    public LevelPictureBulletId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelPictureBulletId>(deep);
    }

}
/// <summary>
/// <para>Numbering Level Starting Value Override.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:startOverride.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StartOverrideNumberingValue : DecimalNumberType
{
    private const string tagName = "startOverride";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11929;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartOverrideNumberingValue class.
    /// </summary>
    public StartOverrideNumberingValue():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartOverrideNumberingValue>(deep);
    }

}
/// <summary>
/// <para>Last Reviewed Abstract Numbering Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numIdMacAtCleanup.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingIdMacAtCleanup : DecimalNumberType
{
    private const string tagName = "numIdMacAtCleanup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11935;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingIdMacAtCleanup class.
    /// </summary>
    public NumberingIdMacAtCleanup():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingIdMacAtCleanup>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtId Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:id.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtId : DecimalNumberType
{
    private const string tagName = "id";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12089;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtId class.
    /// </summary>
    public SdtId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtId>(deep);
    }

}
/// <summary>
/// <para>Defines the PixelsPerInch Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pixelsPerInch.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PixelsPerInch : DecimalNumberType
{
    private const string tagName = "pixelsPerInch";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12207;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PixelsPerInch class.
    /// </summary>
    public PixelsPerInch():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PixelsPerInch>(deep);
    }

}
/// <summary>
/// Defines the DecimalNumberType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class DecimalNumberType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Decimal Number Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the DecimalNumberType class.
    /// </summary>
    protected DecimalNumberType(){}
    
    
    
}
/// <summary>
/// <para>Defines the ParagraphPropertiesChange Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphPropertiesExtended &lt;w:pPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphPropertiesExtended))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "pPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11587;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesChange class.
    /// </summary>
    public ParagraphPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pPr" == name)
    return new ParagraphPropertiesExtended();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphPropertiesExtended ParagraphPropertiesExtended
    {
        get 
        {
            return GetElement<ParagraphPropertiesExtended>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Header Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:headerReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HeaderReference : HeaderFooterReferenceType
{
    private const string tagName = "headerReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11588;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HeaderReference class.
    /// </summary>
    public HeaderReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HeaderReference>(deep);
    }

}
/// <summary>
/// <para>Footer Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footerReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FooterReference : HeaderFooterReferenceType
{
    private const string tagName = "footerReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11589;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FooterReference class.
    /// </summary>
    public FooterReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FooterReference>(deep);
    }

}
/// <summary>
/// Defines the HeaderFooterReferenceType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class HeaderFooterReferenceType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "type","id" };
    private static byte[] attributeNamespaceIds = { 23,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeaderFooterValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeaderFooterValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Relationship to Part.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeaderFooterValues>();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the HeaderFooterReferenceType class.
    /// </summary>
    protected HeaderFooterReferenceType(){}
    
    
    
}
/// <summary>
/// <para>Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:br.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Break : OpenXmlLeafElement
{
    private const string tagName = "br";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11590;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","clear" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Break Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Restart Location For Text Wrapping Break.</para>
    /// <para>Represents the following attribute in the schema: w:clear </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "clear")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakTextRestartLocationValues> Clear
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakTextRestartLocationValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Break class.
    /// </summary>
    public Break():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakValues>();
    
if( 23 == namespaceId && "clear" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.BreakTextRestartLocationValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Break>(deep);
    }

   
}
/// <summary>
/// <para>Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:t.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Text : TextType
{
    private const string tagName = "t";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11591;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Text class.
    /// </summary>
    public Text():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Text class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Text(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Text>(deep);
    }

}
/// <summary>
/// <para>Deleted Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:delText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DeletedText : TextType
{
    private const string tagName = "delText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11592;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DeletedText class.
    /// </summary>
    public DeletedText():base(){}
    
           /// <summary>
    /// Initializes a new instance of the DeletedText class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public DeletedText(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DeletedText>(deep);
    }

}
/// <summary>
/// <para>Field Code.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:instrText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldCode : TextType
{
    private const string tagName = "instrText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11593;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldCode class.
    /// </summary>
    public FieldCode():base(){}
    
           /// <summary>
    /// Initializes a new instance of the FieldCode class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public FieldCode(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldCode>(deep);
    }

}
/// <summary>
/// <para>Deleted Field Code.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:delInstrText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DeletedFieldCode : TextType
{
    private const string tagName = "delInstrText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11594;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DeletedFieldCode class.
    /// </summary>
    public DeletedFieldCode():base(){}
    
           /// <summary>
    /// Initializes a new instance of the DeletedFieldCode class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public DeletedFieldCode(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DeletedFieldCode>(deep);
    }

}
/// <summary>
/// Defines the TextType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TextType : OpenXmlLeafTextElement
{
    private static string[] attributeTagNames = { "space" };
    private static byte[] attributeNamespaceIds = { 1 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> space.</para>
    /// <para>Represents the following attribute in the schema: xml:space </para>
    /// </summary>
///<remark> xmlns:xml=http://www.w3.org/XML/1998/namespace
///</remark>
    [SchemaAttr(1, "space")]
    public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues> Space
    {
        get { return (EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 1 == namespaceId && "space" == name)
    return new EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TextType class.
    /// </summary>
    protected TextType(){}
    
    
           /// <summary>
    /// Initializes a new instance of the TextType class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    protected TextType(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

}
/// <summary>
/// <para>Non Breaking Hyphen Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noBreakHyphen.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoBreakHyphen : EmptyType
{
    private const string tagName = "noBreakHyphen";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11595;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoBreakHyphen class.
    /// </summary>
    public NoBreakHyphen():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoBreakHyphen>(deep);
    }

}
/// <summary>
/// <para>Optional Hyphen Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:softHyphen.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SoftHyphen : EmptyType
{
    private const string tagName = "softHyphen";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11596;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SoftHyphen class.
    /// </summary>
    public SoftHyphen():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SoftHyphen>(deep);
    }

}
/// <summary>
/// <para>Date Block - Short Day Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dayShort.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DayShort : EmptyType
{
    private const string tagName = "dayShort";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11597;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DayShort class.
    /// </summary>
    public DayShort():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DayShort>(deep);
    }

}
/// <summary>
/// <para>Date Block - Short Month Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:monthShort.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MonthShort : EmptyType
{
    private const string tagName = "monthShort";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11598;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MonthShort class.
    /// </summary>
    public MonthShort():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MonthShort>(deep);
    }

}
/// <summary>
/// <para>Date Block - Short Year Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:yearShort.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class YearShort : EmptyType
{
    private const string tagName = "yearShort";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11599;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the YearShort class.
    /// </summary>
    public YearShort():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<YearShort>(deep);
    }

}
/// <summary>
/// <para>Date Block - Long Day Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dayLong.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DayLong : EmptyType
{
    private const string tagName = "dayLong";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11600;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DayLong class.
    /// </summary>
    public DayLong():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DayLong>(deep);
    }

}
/// <summary>
/// <para>Date Block - Long Month Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:monthLong.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MonthLong : EmptyType
{
    private const string tagName = "monthLong";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11601;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MonthLong class.
    /// </summary>
    public MonthLong():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MonthLong>(deep);
    }

}
/// <summary>
/// <para>Date Block - Long Year Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:yearLong.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class YearLong : EmptyType
{
    private const string tagName = "yearLong";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11602;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the YearLong class.
    /// </summary>
    public YearLong():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<YearLong>(deep);
    }

}
/// <summary>
/// <para>Comment Information Block.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:annotationRef.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AnnotationReferenceMark : EmptyType
{
    private const string tagName = "annotationRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11603;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AnnotationReferenceMark class.
    /// </summary>
    public AnnotationReferenceMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AnnotationReferenceMark>(deep);
    }

}
/// <summary>
/// <para>Footnote Reference Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnoteRef.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteReferenceMark : EmptyType
{
    private const string tagName = "footnoteRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11604;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FootnoteReferenceMark class.
    /// </summary>
    public FootnoteReferenceMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteReferenceMark>(deep);
    }

}
/// <summary>
/// <para>Endnote Reference Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnoteRef.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnoteReferenceMark : EmptyType
{
    private const string tagName = "endnoteRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11605;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndnoteReferenceMark class.
    /// </summary>
    public EndnoteReferenceMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnoteReferenceMark>(deep);
    }

}
/// <summary>
/// <para>Footnote/Endnote Separator Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:separator.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SeparatorMark : EmptyType
{
    private const string tagName = "separator";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11606;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SeparatorMark class.
    /// </summary>
    public SeparatorMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SeparatorMark>(deep);
    }

}
/// <summary>
/// <para>Continuation Separator Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:continuationSeparator.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ContinuationSeparatorMark : EmptyType
{
    private const string tagName = "continuationSeparator";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11607;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ContinuationSeparatorMark class.
    /// </summary>
    public ContinuationSeparatorMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ContinuationSeparatorMark>(deep);
    }

}
/// <summary>
/// <para>Page Number Block.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pgNum.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageNumber : EmptyType
{
    private const string tagName = "pgNum";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11609;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PageNumber class.
    /// </summary>
    public PageNumber():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageNumber>(deep);
    }

}
/// <summary>
/// <para>Carriage Return.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CarriageReturn : EmptyType
{
    private const string tagName = "cr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11610;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CarriageReturn class.
    /// </summary>
    public CarriageReturn():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CarriageReturn>(deep);
    }

}
/// <summary>
/// <para>Tab Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tab.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TabChar : EmptyType
{
    private const string tagName = "tab";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11611;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TabChar class.
    /// </summary>
    public TabChar():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TabChar>(deep);
    }

}
/// <summary>
/// <para>Position of Last Calculated Page Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lastRenderedPageBreak.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LastRenderedPageBreak : EmptyType
{
    private const string tagName = "lastRenderedPageBreak";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11621;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LastRenderedPageBreak class.
    /// </summary>
    public LastRenderedPageBreak():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LastRenderedPageBreak>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentEquation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:equation.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentEquation : EmptyType
{
    private const string tagName = "equation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12091;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentEquation class.
    /// </summary>
    public SdtContentEquation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentEquation>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentPicture Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:picture.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentPicture : EmptyType
{
    private const string tagName = "picture";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12097;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentPicture class.
    /// </summary>
    public SdtContentPicture():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentPicture>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentRichText Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:richText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentRichText : EmptyType
{
    private const string tagName = "richText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12098;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentRichText class.
    /// </summary>
    public SdtContentRichText():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentRichText>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentCitation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:citation.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentCitation : EmptyType
{
    private const string tagName = "citation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12100;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentCitation class.
    /// </summary>
    public SdtContentCitation():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentCitation>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentGroup Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:group.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentGroup : EmptyType
{
    private const string tagName = "group";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12101;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentGroup class.
    /// </summary>
    public SdtContentGroup():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentGroup>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentBibliography Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bibliography.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentBibliography : EmptyType
{
    private const string tagName = "bibliography";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12102;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentBibliography class.
    /// </summary>
    public SdtContentBibliography():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentBibliography>(deep);
    }

}
/// <summary>
/// <para>Upgrade Document on Open.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:forceUpgrade.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ForceUpgrade : EmptyType
{
    private const string tagName = "forceUpgrade";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12192;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ForceUpgrade class.
    /// </summary>
    public ForceUpgrade():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ForceUpgrade>(deep);
    }

}
/// <summary>
/// Defines the EmptyType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class EmptyType : OpenXmlLeafElement
{
        
    
    
    
    
    
    /// <summary>
    /// Initializes a new instance of the EmptyType class.
    /// </summary>
    protected EmptyType(){}
    
    
    
}
/// <summary>
/// <para>Symbol Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sym.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SymbolChar : OpenXmlLeafElement
{
    private const string tagName = "sym";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11608;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "font","char" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Symbol Character Font.</para>
    /// <para>Represents the following attribute in the schema: w:font </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "font")]
    public StringValue Font
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Symbol Character Code.</para>
    /// <para>Represents the following attribute in the schema: w:char </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "char")]
    public HexBinaryValue Char
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SymbolChar class.
    /// </summary>
    public SymbolChar():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "font" == name)
    return new StringValue();
    
if( 23 == namespaceId && "char" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SymbolChar>(deep);
    }

   
}
/// <summary>
/// <para>Inline Embedded Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:object.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Group &lt;v:group></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ImageFile &lt;v:image></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Line &lt;v:line></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Oval &lt;v:oval></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.PolyLine &lt;v:polyline></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Rectangle &lt;v:rect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.RoundRectangle &lt;v:roundrect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shape &lt;v:shape></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shapetype &lt;v:shapetype></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Arc &lt;v:arc></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Curve &lt;v:curve></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.OleObject &lt;o:OLEObject></description></item>
///<item><description>Drawing &lt;w:drawing></description></item>
///<item><description>Control &lt;w:control></description></item>
///<item><description>ObjectEmbed &lt;w:objectEmbed></description></item>
///<item><description>ObjectLink &lt;w:objectLink></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Group))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ImageFile))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Line))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Oval))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.PolyLine))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Rectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.RoundRectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shape))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shapetype))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Arc))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Curve))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.OleObject))]
    [ChildElementInfo(typeof(Drawing))]
    [ChildElementInfo(typeof(Control))]
    [ChildElementInfo(typeof(ObjectEmbed))]
    [ChildElementInfo(typeof(ObjectLink))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbeddedObject : OpenXmlCompositeElement
{
    private const string tagName = "object";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11612;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "dxaOrig","dyaOrig","anchorId" };
    private static byte[] attributeNamespaceIds = { 23,23,52 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> dxaOrig.</para>
    /// <para>Represents the following attribute in the schema: w:dxaOrig </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dxaOrig")]
    public StringValue DxaOriginal
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> dyaOrig.</para>
    /// <para>Represents the following attribute in the schema: w:dyaOrig </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dyaOrig")]
    public StringValue DyaOriginal
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> anchorId.</para>
    /// <para>Represents the following attribute in the schema: w14:anchorId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "anchorId")]
    public HexBinaryValue AnchorId
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbeddedObject class.
    /// </summary>
    public EmbeddedObject():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EmbeddedObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EmbeddedObject(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EmbeddedObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EmbeddedObject(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EmbeddedObject class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EmbeddedObject(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 26 == namespaceId && "group" == name)
    return new DocumentFormat.OpenXml.Vml.Group();
    
if( 26 == namespaceId && "image" == name)
    return new DocumentFormat.OpenXml.Vml.ImageFile();
    
if( 26 == namespaceId && "line" == name)
    return new DocumentFormat.OpenXml.Vml.Line();
    
if( 26 == namespaceId && "oval" == name)
    return new DocumentFormat.OpenXml.Vml.Oval();
    
if( 26 == namespaceId && "polyline" == name)
    return new DocumentFormat.OpenXml.Vml.PolyLine();
    
if( 26 == namespaceId && "rect" == name)
    return new DocumentFormat.OpenXml.Vml.Rectangle();
    
if( 26 == namespaceId && "roundrect" == name)
    return new DocumentFormat.OpenXml.Vml.RoundRectangle();
    
if( 26 == namespaceId && "shape" == name)
    return new DocumentFormat.OpenXml.Vml.Shape();
    
if( 26 == namespaceId && "shapetype" == name)
    return new DocumentFormat.OpenXml.Vml.Shapetype();
    
if( 26 == namespaceId && "arc" == name)
    return new DocumentFormat.OpenXml.Vml.Arc();
    
if( 26 == namespaceId && "curve" == name)
    return new DocumentFormat.OpenXml.Vml.Curve();
    
if( 27 == namespaceId && "OLEObject" == name)
    return new DocumentFormat.OpenXml.Vml.Office.OleObject();
    
if( 23 == namespaceId && "drawing" == name)
    return new Drawing();
    
if( 23 == namespaceId && "control" == name)
    return new Control();
    
if( 23 == namespaceId && "objectEmbed" == name)
    return new ObjectEmbed();
    
if( 23 == namespaceId && "objectLink" == name)
    return new ObjectLink();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "dxaOrig" == name)
    return new StringValue();
    
if( 23 == namespaceId && "dyaOrig" == name)
    return new StringValue();
    
if( 52 == namespaceId && "anchorId" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbeddedObject>(deep);
    }

   
}
/// <summary>
/// <para>VML Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pict.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Group &lt;v:group></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ImageFile &lt;v:image></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Line &lt;v:line></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Oval &lt;v:oval></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.PolyLine &lt;v:polyline></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Rectangle &lt;v:rect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.RoundRectangle &lt;v:roundrect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shape &lt;v:shape></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shapetype &lt;v:shapetype></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Arc &lt;v:arc></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Curve &lt;v:curve></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.OleObject &lt;o:OLEObject></description></item>
///<item><description>MovieReference &lt;w:movie></description></item>
///<item><description>Control &lt;w:control></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Group))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ImageFile))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Line))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Oval))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.PolyLine))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Rectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.RoundRectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shape))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shapetype))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Arc))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Curve))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.OleObject))]
    [ChildElementInfo(typeof(MovieReference))]
    [ChildElementInfo(typeof(Control))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Picture : OpenXmlCompositeElement
{
    private const string tagName = "pict";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11613;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "anchorId" };
    private static byte[] attributeNamespaceIds = { 52 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> anchorId.</para>
    /// <para>Represents the following attribute in the schema: w14:anchorId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "anchorId")]
    public HexBinaryValue AnchorId
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Picture class.
    /// </summary>
    public Picture():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Picture class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Picture(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Picture class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Picture(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Picture class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Picture(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 26 == namespaceId && "group" == name)
    return new DocumentFormat.OpenXml.Vml.Group();
    
if( 26 == namespaceId && "image" == name)
    return new DocumentFormat.OpenXml.Vml.ImageFile();
    
if( 26 == namespaceId && "line" == name)
    return new DocumentFormat.OpenXml.Vml.Line();
    
if( 26 == namespaceId && "oval" == name)
    return new DocumentFormat.OpenXml.Vml.Oval();
    
if( 26 == namespaceId && "polyline" == name)
    return new DocumentFormat.OpenXml.Vml.PolyLine();
    
if( 26 == namespaceId && "rect" == name)
    return new DocumentFormat.OpenXml.Vml.Rectangle();
    
if( 26 == namespaceId && "roundrect" == name)
    return new DocumentFormat.OpenXml.Vml.RoundRectangle();
    
if( 26 == namespaceId && "shape" == name)
    return new DocumentFormat.OpenXml.Vml.Shape();
    
if( 26 == namespaceId && "shapetype" == name)
    return new DocumentFormat.OpenXml.Vml.Shapetype();
    
if( 26 == namespaceId && "arc" == name)
    return new DocumentFormat.OpenXml.Vml.Arc();
    
if( 26 == namespaceId && "curve" == name)
    return new DocumentFormat.OpenXml.Vml.Curve();
    
if( 27 == namespaceId && "OLEObject" == name)
    return new DocumentFormat.OpenXml.Vml.Office.OleObject();
    
if( 23 == namespaceId && "movie" == name)
    return new MovieReference();
    
if( 23 == namespaceId && "control" == name)
    return new Control();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 52 == namespaceId && "anchorId" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Picture>(deep);
    }

   
}
/// <summary>
/// <para>Complex Field Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fldChar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldData &lt;w:fldData></description></item>
///<item><description>FormFieldData &lt;w:ffData></description></item>
///<item><description>NumberingChange &lt;w:numberingChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldData))]
    [ChildElementInfo(typeof(FormFieldData))]
    [ChildElementInfo(typeof(NumberingChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldChar : OpenXmlCompositeElement
{
    private const string tagName = "fldChar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11614;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fldCharType","fldLock","dirty" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Character Type.</para>
    /// <para>Represents the following attribute in the schema: w:fldCharType </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fldCharType")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FieldCharValues> FieldCharType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FieldCharValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field Should Not Be Recalculated.</para>
    /// <para>Represents the following attribute in the schema: w:fldLock </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fldLock")]
    public OnOffValue FieldLock
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Field Result Invalidated.</para>
    /// <para>Represents the following attribute in the schema: w:dirty </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dirty")]
    public OnOffValue Dirty
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldChar class.
    /// </summary>
    public FieldChar():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FieldChar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldChar(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldChar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldChar(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldChar class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FieldChar(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fldData" == name)
    return new FieldData();
    
if( 23 == namespaceId && "ffData" == name)
    return new FormFieldData();
    
if( 23 == namespaceId && "numberingChange" == name)
    return new NumberingChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fldData","ffData","numberingChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Custom Field Data.</para>
    /// <para> Represents the following element tag in the schema: w:fldData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FieldData FieldData
    {
        get 
        {
            return GetElement<FieldData>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Form Field Properties.</para>
    /// <para> Represents the following element tag in the schema: w:ffData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FormFieldData FormFieldData
    {
        get 
        {
            return GetElement<FormFieldData>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Previous Numbering Field Properties.</para>
    /// <para> Represents the following element tag in the schema: w:numberingChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingChange NumberingChange
    {
        get 
        {
            return GetElement<NumberingChange>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fldCharType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FieldCharValues>();
    
if( 23 == namespaceId && "fldLock" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "dirty" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldChar>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Guide.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ruby.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RubyProperties &lt;w:rubyPr></description></item>
///<item><description>RubyContent &lt;w:rt></description></item>
///<item><description>RubyBase &lt;w:rubyBase></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RubyProperties))]
    [ChildElementInfo(typeof(RubyContent))]
    [ChildElementInfo(typeof(RubyBase))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Ruby : OpenXmlCompositeElement
{
    private const string tagName = "ruby";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11615;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Ruby class.
    /// </summary>
    public Ruby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Ruby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Ruby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Ruby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Ruby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Ruby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Ruby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rubyPr" == name)
    return new RubyProperties();
    
if( 23 == namespaceId && "rt" == name)
    return new RubyContent();
    
if( 23 == namespaceId && "rubyBase" == name)
    return new RubyBase();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rubyPr","rt","rubyBase" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Phonetic Guide Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rubyPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RubyProperties RubyProperties
    {
        get 
        {
            return GetElement<RubyProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Phonetic Guide Text.</para>
    /// <para> Represents the following element tag in the schema: w:rt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RubyContent RubyContent
    {
        get 
        {
            return GetElement<RubyContent>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Phonetic Guide Base Text.</para>
    /// <para> Represents the following element tag in the schema: w:rubyBase </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RubyBase RubyBase
    {
        get 
        {
            return GetElement<RubyBase>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Ruby>(deep);
    }

   
}
/// <summary>
/// <para>Footnote Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnoteReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteReference : FootnoteEndnoteReferenceType
{
    private const string tagName = "footnoteReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11616;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FootnoteReference class.
    /// </summary>
    public FootnoteReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteReference>(deep);
    }

}
/// <summary>
/// <para>Endnote Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnoteReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnoteReference : FootnoteEndnoteReferenceType
{
    private const string tagName = "endnoteReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11617;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndnoteReference class.
    /// </summary>
    public EndnoteReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnoteReference>(deep);
    }

}
/// <summary>
/// Defines the FootnoteEndnoteReferenceType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class FootnoteEndnoteReferenceType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "customMarkFollows","id" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Suppress Footnote/Endnote Reference Mark.</para>
    /// <para>Represents the following attribute in the schema: w:customMarkFollows </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "customMarkFollows")]
    public OnOffValue CustomMarkFollows
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Footnote/Endnote ID Reference.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public IntegerValue Id
    {
        get { return (IntegerValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customMarkFollows" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "id" == name)
    return new IntegerValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the FootnoteEndnoteReferenceType class.
    /// </summary>
    protected FootnoteEndnoteReferenceType(){}
    
    
    
}
/// <summary>
/// <para>DrawingML Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:drawing.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor &lt;wp:anchor></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline &lt;wp:inline></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Drawing : OpenXmlCompositeElement
{
    private const string tagName = "drawing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11619;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Drawing class.
    /// </summary>
    public Drawing():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Drawing class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Drawing(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Drawing class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Drawing(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Drawing class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Drawing(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 16 == namespaceId && "anchor" == name)
    return new DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor();
    
if( 16 == namespaceId && "inline" == name)
    return new DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline();
    

    return null;
}

        private static readonly string[] eleTagNames = { "anchor","inline" };
    private static readonly byte[] eleNamespaceIds = { 16,16 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Drawing Element Anchor.</para>
    /// <para> Represents the following element tag in the schema: wp:anchor </para>
    /// </summary>
    /// <remark>
    /// xmlns:wp = http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor Anchor
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Wordprocessing.Anchor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Inline Drawing Object.</para>
    /// <para> Represents the following element tag in the schema: wp:inline </para>
    /// </summary>
    /// <remark>
    /// xmlns:wp = http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline Inline
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Wordprocessing.Inline>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Drawing>(deep);
    }

   
}
/// <summary>
/// <para>Absolute Position Tab Character.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ptab.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PositionalTab : OpenXmlLeafElement
{
    private const string tagName = "ptab";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11620;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "alignment","relativeTo","leader" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Positional Tab Stop Alignment.</para>
    /// <para>Represents the following attribute in the schema: w:alignment </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "alignment")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabAlignmentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Positional Tab Base.</para>
    /// <para>Represents the following attribute in the schema: w:relativeTo </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "relativeTo")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabPositioningBaseValues> RelativeTo
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabPositioningBaseValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Tab Leader Character.</para>
    /// <para>Represents the following attribute in the schema: w:leader </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "leader")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabLeaderCharValues> Leader
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabLeaderCharValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PositionalTab class.
    /// </summary>
    public PositionalTab():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "alignment" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabAlignmentValues>();
    
if( 23 == namespaceId && "relativeTo" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabPositioningBaseValues>();
    
if( 23 == namespaceId && "leader" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.AbsolutePositionTabLeaderCharValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PositionalTab>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RunStyle Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunStyle : String253Type
{
    private const string tagName = "rStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11622;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RunStyle class.
    /// </summary>
    public RunStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunStyle>(deep);
    }

}
/// <summary>
/// <para>Defines the TableStyle Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyle : String253Type
{
    private const string tagName = "tblStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11717;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyle class.
    /// </summary>
    public TableStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyle>(deep);
    }

}
/// <summary>
/// <para>Paragraph Style's Associated Numbering Level.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphStyleIdInLevel : String253Type
{
    private const string tagName = "pStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11913;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ParagraphStyleIdInLevel class.
    /// </summary>
    public ParagraphStyleIdInLevel():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphStyleIdInLevel>(deep);
    }

}
/// <summary>
/// <para>Abstract Numbering Definition Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AbstractNumDefinitionName : String253Type
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11925;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AbstractNumDefinitionName class.
    /// </summary>
    public AbstractNumDefinitionName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AbstractNumDefinitionName>(deep);
    }

}
/// <summary>
/// <para>Numbering Style Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:styleLink.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleLink : String253Type
{
    private const string tagName = "styleLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11926;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleLink class.
    /// </summary>
    public StyleLink():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleLink>(deep);
    }

}
/// <summary>
/// <para>Numbering Style Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numStyleLink.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingStyleLink : String253Type
{
    private const string tagName = "numStyleLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11927;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingStyleLink class.
    /// </summary>
    public NumberingStyleLink():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingStyleLink>(deep);
    }

}
/// <summary>
/// <para>Alternate Style Names.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:aliases.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Aliases : String253Type
{
    private const string tagName = "aliases";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11941;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Aliases class.
    /// </summary>
    public Aliases():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Aliases>(deep);
    }

}
/// <summary>
/// <para>Parent Style ID.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:basedOn.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BasedOn : String253Type
{
    private const string tagName = "basedOn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11942;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BasedOn class.
    /// </summary>
    public BasedOn():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BasedOn>(deep);
    }

}
/// <summary>
/// <para>Style For Next Paragraph.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:next.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NextParagraphStyle : String253Type
{
    private const string tagName = "next";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11943;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NextParagraphStyle class.
    /// </summary>
    public NextParagraphStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NextParagraphStyle>(deep);
    }

}
/// <summary>
/// <para>Linked Style Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:link.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LinkedStyle : String253Type
{
    private const string tagName = "link";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11944;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LinkedStyle class.
    /// </summary>
    public LinkedStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LinkedStyle>(deep);
    }

}
/// <summary>
/// <para>Paragraph Style Applied to Automatically Generated Paragraphs.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:clickAndTypeStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ClickAndTypeStyle : String253Type
{
    private const string tagName = "clickAndTypeStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12148;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ClickAndTypeStyle class.
    /// </summary>
    public ClickAndTypeStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ClickAndTypeStyle>(deep);
    }

}
/// <summary>
/// <para>Default Table Style for Newly Inserted Tables.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:defaultTableStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultTableStyle : String253Type
{
    private const string tagName = "defaultTableStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12149;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultTableStyle class.
    /// </summary>
    public DefaultTableStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultTableStyle>(deep);
    }

}
/// <summary>
/// Defines the String253Type class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class String253Type : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the String253Type class.
    /// </summary>
    protected String253Type(){}
    
    
    
}
/// <summary>
/// <para>Defines the RunFonts Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rFonts.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunFonts : OpenXmlLeafElement
{
    private const string tagName = "rFonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11623;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "hint","ascii","hAnsi","eastAsia","cs","asciiTheme","hAnsiTheme","eastAsiaTheme","cstheme" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Content Type.</para>
    /// <para>Represents the following attribute in the schema: w:hint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hint")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontTypeHintValues> Hint
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontTypeHintValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> ASCII Font.</para>
    /// <para>Represents the following attribute in the schema: w:ascii </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "ascii")]
    public StringValue Ascii
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> High ANSI Font.</para>
    /// <para>Represents the following attribute in the schema: w:hAnsi </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hAnsi")]
    public StringValue HighAnsi
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> East Asian Font.</para>
    /// <para>Represents the following attribute in the schema: w:eastAsia </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "eastAsia")]
    public StringValue EastAsia
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Complex Script Font.</para>
    /// <para>Represents the following attribute in the schema: w:cs </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cs")]
    public StringValue ComplexScript
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> ASCII Theme Font.</para>
    /// <para>Represents the following attribute in the schema: w:asciiTheme </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "asciiTheme")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues> AsciiTheme
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> High ANSI Theme Font.</para>
    /// <para>Represents the following attribute in the schema: w:hAnsiTheme </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hAnsiTheme")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues> HighAnsiTheme
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> East Asian Theme Font.</para>
    /// <para>Represents the following attribute in the schema: w:eastAsiaTheme </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "eastAsiaTheme")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues> EastAsiaTheme
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Complex Script Theme Font.</para>
    /// <para>Represents the following attribute in the schema: w:cstheme </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cstheme")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues> ComplexScriptTheme
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RunFonts class.
    /// </summary>
    public RunFonts():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "hint" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontTypeHintValues>();
    
if( 23 == namespaceId && "ascii" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hAnsi" == name)
    return new StringValue();
    
if( 23 == namespaceId && "eastAsia" == name)
    return new StringValue();
    
if( 23 == namespaceId && "cs" == name)
    return new StringValue();
    
if( 23 == namespaceId && "asciiTheme" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>();
    
if( 23 == namespaceId && "hAnsiTheme" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>();
    
if( 23 == namespaceId && "eastAsiaTheme" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>();
    
if( 23 == namespaceId && "cstheme" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeFontValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunFonts>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Color Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:color.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Color : OpenXmlLeafElement
{
    private const string tagName = "color";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11639;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","themeColor","themeTint","themeShade" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Run Content Color.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Run Content Theme Color.</para>
    /// <para>Represents the following attribute in the schema: w:themeColor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeColor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeColor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Run Content Theme Color Tint.</para>
    /// <para>Represents the following attribute in the schema: w:themeTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeTint")]
    public StringValue ThemeTint
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Run Content Theme Color Shade.</para>
    /// <para>Represents the following attribute in the schema: w:themeShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeShade")]
    public StringValue ThemeShade
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Color class.
    /// </summary>
    public Color():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeColor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeShade" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Color>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Spacing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:spacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Spacing : OpenXmlLeafElement
{
    private const string tagName = "spacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11640;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Spacing class.
    /// </summary>
    public Spacing():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Spacing>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CharacterScale Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:w.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CharacterScale : OpenXmlLeafElement
{
    private const string tagName = "w";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11641;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Text Expansion/Compression Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public IntegerValue Val
    {
        get { return (IntegerValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CharacterScale class.
    /// </summary>
    public CharacterScale():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new IntegerValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CharacterScale>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Kern Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:kern.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Kern : OpenXmlLeafElement
{
    private const string tagName = "kern";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11642;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Kern class.
    /// </summary>
    public Kern():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Kern>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Position Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:position.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Position : OpenXmlLeafElement
{
    private const string tagName = "position";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11643;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Signed Half-Point Measurement.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Position class.
    /// </summary>
    public Position():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Position>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FontSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sz.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontSize : HpsMeasureType
{
    private const string tagName = "sz";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11644;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FontSize class.
    /// </summary>
    public FontSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontSize>(deep);
    }

}
/// <summary>
/// <para>Defines the FontSizeComplexScript Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:szCs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontSizeComplexScript : HpsMeasureType
{
    private const string tagName = "szCs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11645;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FontSizeComplexScript class.
    /// </summary>
    public FontSizeComplexScript():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontSizeComplexScript>(deep);
    }

}
/// <summary>
/// <para>Checkbox Form Field Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:size.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormFieldSize : HpsMeasureType
{
    private const string tagName = "size";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11799;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FormFieldSize class.
    /// </summary>
    public FormFieldSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormFieldSize>(deep);
    }

}
/// <summary>
/// <para>Phonetic Guide Text Font Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hps.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PhoneticGuideTextFontSize : HpsMeasureType
{
    private const string tagName = "hps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11816;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PhoneticGuideTextFontSize class.
    /// </summary>
    public PhoneticGuideTextFontSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PhoneticGuideTextFontSize>(deep);
    }

}
/// <summary>
/// <para>Phonetic Guide Base Text Font Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hpsBaseText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PhoneticGuideBaseTextSize : HpsMeasureType
{
    private const string tagName = "hpsBaseText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11818;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PhoneticGuideBaseTextSize class.
    /// </summary>
    public PhoneticGuideBaseTextSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PhoneticGuideBaseTextSize>(deep);
    }

}
/// <summary>
/// Defines the HpsMeasureType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class HpsMeasureType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Half Point Measurement.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the HpsMeasureType class.
    /// </summary>
    protected HpsMeasureType(){}
    
    
    
}
/// <summary>
/// <para>Defines the Highlight Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:highlight.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Highlight : OpenXmlLeafElement
{
    private const string tagName = "highlight";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11646;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Highlighting Color.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HighlightColorValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HighlightColorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Highlight class.
    /// </summary>
    public Highlight():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HighlightColorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Highlight>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Underline Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:u.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Underline : OpenXmlLeafElement
{
    private const string tagName = "u";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11647;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","color","themeColor","themeTint","themeShade" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Underline Style.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.UnderlineValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.UnderlineValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Underline Color.</para>
    /// <para>Represents the following attribute in the schema: w:color </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "color")]
    public StringValue Color
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Underline Theme Color.</para>
    /// <para>Represents the following attribute in the schema: w:themeColor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeColor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeColor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Underline Theme Color Tint.</para>
    /// <para>Represents the following attribute in the schema: w:themeTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeTint")]
    public StringValue ThemeTint
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Underline Theme Color Shade.</para>
    /// <para>Represents the following attribute in the schema: w:themeShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeShade")]
    public StringValue ThemeShade
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Underline class.
    /// </summary>
    public Underline():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.UnderlineValues>();
    
if( 23 == namespaceId && "color" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeColor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeShade" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Underline>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextEffect Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:effect.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextEffect : OpenXmlLeafElement
{
    private const string tagName = "effect";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11648;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Animated Text Effect Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextEffectValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextEffectValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextEffect class.
    /// </summary>
    public TextEffect():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextEffectValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextEffect>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Border Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bdr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Border : BorderType
{
    private const string tagName = "bdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11649;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Border class.
    /// </summary>
    public Border():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Border>(deep);
    }

}
/// <summary>
/// <para>Paragraph Border Above Identical Paragraphs.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:top.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopBorder : BorderType
{
    private const string tagName = "top";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11778;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopBorder class.
    /// </summary>
    public TopBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopBorder>(deep);
    }

}
/// <summary>
/// <para>Left Paragraph Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:left.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftBorder : BorderType
{
    private const string tagName = "left";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11779;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftBorder class.
    /// </summary>
    public LeftBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftBorder>(deep);
    }

}
/// <summary>
/// <para>Paragraph Border Between Identical Paragraphs.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bottom.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomBorder : BorderType
{
    private const string tagName = "bottom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11780;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomBorder class.
    /// </summary>
    public BottomBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomBorder>(deep);
    }

}
/// <summary>
/// <para>Right Paragraph Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:right.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightBorder : BorderType
{
    private const string tagName = "right";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11781;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightBorder class.
    /// </summary>
    public RightBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightBorder>(deep);
    }

}
/// <summary>
/// <para>Paragraph Border Between Identical Paragraphs.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:between.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BetweenBorder : BorderType
{
    private const string tagName = "between";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11782;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BetweenBorder class.
    /// </summary>
    public BetweenBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BetweenBorder>(deep);
    }

}
/// <summary>
/// <para>Paragraph Border Between Facing Pages.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BarBorder : BorderType
{
    private const string tagName = "bar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11783;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BarBorder class.
    /// </summary>
    public BarBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BarBorder>(deep);
    }

}
/// <summary>
/// <para>Defines the StartBorder Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:start.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class StartBorder : BorderType
{
    private const string tagName = "start";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12060;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartBorder class.
    /// </summary>
    public StartBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartBorder>(deep);
    }

}
/// <summary>
/// <para>Defines the EndBorder Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:end.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class EndBorder : BorderType
{
    private const string tagName = "end";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12061;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndBorder class.
    /// </summary>
    public EndBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndBorder>(deep);
    }

}
/// <summary>
/// <para>Table Inside Horizontal Edges Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:insideH.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsideHorizontalBorder : BorderType
{
    private const string tagName = "insideH";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12062;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InsideHorizontalBorder class.
    /// </summary>
    public InsideHorizontalBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsideHorizontalBorder>(deep);
    }

}
/// <summary>
/// <para>Table Inside Vertical Edges Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:insideV.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsideVerticalBorder : BorderType
{
    private const string tagName = "insideV";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12063;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InsideVerticalBorder class.
    /// </summary>
    public InsideVerticalBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsideVerticalBorder>(deep);
    }

}
/// <summary>
/// <para>Table Cell Top Left to Bottom Right Diagonal Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tl2br.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopLeftToBottomRightCellBorder : BorderType
{
    private const string tagName = "tl2br";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12075;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopLeftToBottomRightCellBorder class.
    /// </summary>
    public TopLeftToBottomRightCellBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopLeftToBottomRightCellBorder>(deep);
    }

}
/// <summary>
/// <para>Table Cell Top Right to Bottom Left Diagonal Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tr2bl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopRightToBottomLeftCellBorder : BorderType
{
    private const string tagName = "tr2bl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12076;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopRightToBottomLeftCellBorder class.
    /// </summary>
    public TopRightToBottomLeftCellBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopRightToBottomLeftCellBorder>(deep);
    }

}
/// <summary>
/// Defines the BorderType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class BorderType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val","color","themeColor","themeTint","themeShade","sz","space","shadow","frame" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Border Style.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.BorderValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.BorderValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Border Color.</para>
    /// <para>Represents the following attribute in the schema: w:color </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "color")]
    public StringValue Color
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Border Theme Color.</para>
    /// <para>Represents the following attribute in the schema: w:themeColor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeColor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeColor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Border Theme Color Tint.</para>
    /// <para>Represents the following attribute in the schema: w:themeTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeTint")]
    public StringValue ThemeTint
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Border Theme Color Shade.</para>
    /// <para>Represents the following attribute in the schema: w:themeShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeShade")]
    public StringValue ThemeShade
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Border Width.</para>
    /// <para>Represents the following attribute in the schema: w:sz </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "sz")]
    public UInt32Value Size
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Border Spacing Measurement.</para>
    /// <para>Represents the following attribute in the schema: w:space </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "space")]
    public UInt32Value Space
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Border Shadow.</para>
    /// <para>Represents the following attribute in the schema: w:shadow </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "shadow")]
    public OnOffValue Shadow
    {
        get { return (OnOffValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Create Frame Effect.</para>
    /// <para>Represents the following attribute in the schema: w:frame </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "frame")]
    public OnOffValue Frame
    {
        get { return (OnOffValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.BorderValues>();
    
if( 23 == namespaceId && "color" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeColor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeShade" == name)
    return new StringValue();
    
if( 23 == namespaceId && "sz" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "space" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "shadow" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "frame" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the BorderType class.
    /// </summary>
    protected BorderType(){}
    
    
    
}
/// <summary>
/// <para>Defines the FitText Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fitText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FitText : OpenXmlLeafElement
{
    private const string tagName = "fitText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11650;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","id" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Fit Text Run ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FitText class.
    /// </summary>
    public FitText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "id" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FitText>(deep);
    }

   
}
/// <summary>
/// <para>Defines the VerticalTextAlignment Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:vertAlign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VerticalTextAlignment : OpenXmlLeafElement
{
    private const string tagName = "vertAlign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11651;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Subscript/Superscript Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalPositionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalPositionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VerticalTextAlignment class.
    /// </summary>
    public VerticalTextAlignment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalPositionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VerticalTextAlignment>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Emphasis Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:em.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Emphasis : OpenXmlLeafElement
{
    private const string tagName = "em";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11654;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Emphasis Mark Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.EmphasisMarkValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.EmphasisMarkValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Emphasis class.
    /// </summary>
    public Emphasis():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.EmphasisMarkValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Emphasis>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Languages Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lang.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Languages : LanguageType
{
    private const string tagName = "lang";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11655;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Languages class.
    /// </summary>
    public Languages():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Languages>(deep);
    }

}
/// <summary>
/// <para>Theme Font Languages.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:themeFontLang.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ThemeFontLanguages : LanguageType
{
    private const string tagName = "themeFontLang";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12188;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ThemeFontLanguages class.
    /// </summary>
    public ThemeFontLanguages():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ThemeFontLanguages>(deep);
    }

}
/// <summary>
/// Defines the LanguageType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class LanguageType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val","eastAsia","bidi" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Latin Language.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> East Asian Language.</para>
    /// <para>Represents the following attribute in the schema: w:eastAsia </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "eastAsia")]
    public StringValue EastAsia
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Complex Script Language.</para>
    /// <para>Represents the following attribute in the schema: w:bidi </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "bidi")]
    public StringValue Bidi
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "eastAsia" == name)
    return new StringValue();
    
if( 23 == namespaceId && "bidi" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the LanguageType class.
    /// </summary>
    protected LanguageType(){}
    
    
    
}
/// <summary>
/// <para>Defines the EastAsianLayout Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:eastAsianLayout.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EastAsianLayout : OpenXmlLeafElement
{
    private const string tagName = "eastAsianLayout";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11656;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","combine","combineBrackets","vert","vertCompress" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> East Asian Typography Run ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Two Lines in One.</para>
    /// <para>Represents the following attribute in the schema: w:combine </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "combine")]
    public OnOffValue Combine
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Display Brackets Around Two Lines in One.</para>
    /// <para>Represents the following attribute in the schema: w:combineBrackets </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "combineBrackets")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CombineBracketValues> CombineBrackets
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CombineBracketValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal in Vertical (Rotate Text).</para>
    /// <para>Represents the following attribute in the schema: w:vert </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vert")]
    public OnOffValue Vertical
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Compress Rotated Text to Line Height.</para>
    /// <para>Represents the following attribute in the schema: w:vertCompress </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vertCompress")]
    public OnOffValue VerticalCompress
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the EastAsianLayout class.
    /// </summary>
    public EastAsianLayout():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "combine" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "combineBrackets" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CombineBracketValues>();
    
if( 23 == namespaceId && "vert" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "vertCompress" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EastAsianLayout>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RunPropertiesChange Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousRunProperties &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousRunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "rPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11659;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RunPropertiesChange class.
    /// </summary>
    public RunPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RunPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new PreviousRunProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousRunProperties PreviousRunProperties
    {
        get 
        {
            return GetElement<PreviousRunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunStyle &lt;w:rStyle></description></item>
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Highlight &lt;w:highlight></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>RightToLeftText &lt;w:rtl></description></item>
///<item><description>ComplexScript &lt;w:cs></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Glow &lt;w14:glow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Shadow &lt;w14:shadow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Reflection &lt;w14:reflection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect &lt;w14:textOutline></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.FillTextEffect &lt;w14:textFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Scene3D &lt;w14:scene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Properties3D &lt;w14:props3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Ligatures &lt;w14:ligatures></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberingFormat &lt;w14:numForm></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberSpacing &lt;w14:numSpacing></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.StylisticSets &lt;w14:stylisticSets></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives &lt;w14:cntxtAlts></description></item>
///<item><description>RunPropertiesChange &lt;w:rPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunStyle))]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Highlight))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(RightToLeftText))]
    [ChildElementInfo(typeof(ComplexScript))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Glow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Shadow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Reflection),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.FillTextEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Scene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Properties3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Ligatures),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberingFormat),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberSpacing),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.StylisticSets),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(RunPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11660;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class.
    /// </summary>
    public RunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rStyle" == name)
    return new RunStyle();
    
if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "highlight" == name)
    return new Highlight();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "rtl" == name)
    return new RightToLeftText();
    
if( 23 == namespaceId && "cs" == name)
    return new ComplexScript();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    
if( 52 == namespaceId && "glow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Glow();
    
if( 52 == namespaceId && "shadow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Shadow();
    
if( 52 == namespaceId && "reflection" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Reflection();
    
if( 52 == namespaceId && "textOutline" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect();
    
if( 52 == namespaceId && "textFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.FillTextEffect();
    
if( 52 == namespaceId && "scene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Scene3D();
    
if( 52 == namespaceId && "props3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Properties3D();
    
if( 52 == namespaceId && "ligatures" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Ligatures();
    
if( 52 == namespaceId && "numForm" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberingFormat();
    
if( 52 == namespaceId && "numSpacing" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberSpacing();
    
if( 52 == namespaceId && "stylisticSets" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.StylisticSets();
    
if( 52 == namespaceId && "cntxtAlts" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives();
    
if( 23 == namespaceId && "rPrChange" == name)
    return new RunPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rStyle","rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","highlight","u","effect","bdr","shd","fitText","vertAlign","rtl","cs","em","lang","eastAsianLayout","specVanish","glow","shadow","reflection","textOutline","textFill","scene3d","props3d","ligatures","numForm","numSpacing","stylisticSets","cntxtAlts","rPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,52,52,52,52,52,52,52,52,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> RunStyle.</para>
    /// <para> Represents the following element tag in the schema: w:rStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunStyle RunStyle
    {
        get 
        {
            return GetElement<RunStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> RunFonts.</para>
    /// <para> Represents the following element tag in the schema: w:rFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunFonts RunFonts
    {
        get 
        {
            return GetElement<RunFonts>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Bold.</para>
    /// <para> Represents the following element tag in the schema: w:b </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Bold Bold
    {
        get 
        {
            return GetElement<Bold>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BoldComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:bCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BoldComplexScript BoldComplexScript
    {
        get 
        {
            return GetElement<BoldComplexScript>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Italic.</para>
    /// <para> Represents the following element tag in the schema: w:i </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Italic Italic
    {
        get 
        {
            return GetElement<Italic>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> ItalicComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:iCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ItalicComplexScript ItalicComplexScript
    {
        get 
        {
            return GetElement<ItalicComplexScript>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Caps.</para>
    /// <para> Represents the following element tag in the schema: w:caps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Caps Caps
    {
        get 
        {
            return GetElement<Caps>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> SmallCaps.</para>
    /// <para> Represents the following element tag in the schema: w:smallCaps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SmallCaps SmallCaps
    {
        get 
        {
            return GetElement<SmallCaps>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Strike.</para>
    /// <para> Represents the following element tag in the schema: w:strike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Strike Strike
    {
        get 
        {
            return GetElement<Strike>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> DoubleStrike.</para>
    /// <para> Represents the following element tag in the schema: w:dstrike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoubleStrike DoubleStrike
    {
        get 
        {
            return GetElement<DoubleStrike>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: w:outline </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Shadow.</para>
    /// <para> Represents the following element tag in the schema: w:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shadow Shadow
    {
        get 
        {
            return GetElement<Shadow>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Emboss.</para>
    /// <para> Represents the following element tag in the schema: w:emboss </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emboss Emboss
    {
        get 
        {
            return GetElement<Emboss>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Imprint.</para>
    /// <para> Represents the following element tag in the schema: w:imprint </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Imprint Imprint
    {
        get 
        {
            return GetElement<Imprint>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> NoProof.</para>
    /// <para> Represents the following element tag in the schema: w:noProof </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoProof NoProof
    {
        get 
        {
            return GetElement<NoProof>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> Vanish.</para>
    /// <para> Represents the following element tag in the schema: w:vanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Vanish Vanish
    {
        get 
        {
            return GetElement<Vanish>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> WebHidden.</para>
    /// <para> Represents the following element tag in the schema: w:webHidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WebHidden WebHidden
    {
        get 
        {
            return GetElement<WebHidden>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: w:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Spacing Spacing
    {
        get 
        {
            return GetElement<Spacing>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> CharacterScale.</para>
    /// <para> Represents the following element tag in the schema: w:w </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CharacterScale CharacterScale
    {
        get 
        {
            return GetElement<CharacterScale>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Kern.</para>
    /// <para> Represents the following element tag in the schema: w:kern </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kern Kern
    {
        get 
        {
            return GetElement<Kern>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: w:position </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> FontSize.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSize FontSize
    {
        get 
        {
            return GetElement<FontSize>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> FontSizeComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:szCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSizeComplexScript FontSizeComplexScript
    {
        get 
        {
            return GetElement<FontSizeComplexScript>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> Highlight.</para>
    /// <para> Represents the following element tag in the schema: w:highlight </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Highlight Highlight
    {
        get 
        {
            return GetElement<Highlight>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Underline.</para>
    /// <para> Represents the following element tag in the schema: w:u </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Underline Underline
    {
        get 
        {
            return GetElement<Underline>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextEffect.</para>
    /// <para> Represents the following element tag in the schema: w:effect </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextEffect TextEffect
    {
        get 
        {
            return GetElement<TextEffect>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> Border.</para>
    /// <para> Represents the following element tag in the schema: w:bdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Border Border
    {
        get 
        {
            return GetElement<Border>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> FitText.</para>
    /// <para> Represents the following element tag in the schema: w:fitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FitText FitText
    {
        get 
        {
            return GetElement<FitText>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> VerticalTextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vertAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalTextAlignment VerticalTextAlignment
    {
        get 
        {
            return GetElement<VerticalTextAlignment>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> RightToLeftText.</para>
    /// <para> Represents the following element tag in the schema: w:rtl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightToLeftText RightToLeftText
    {
        get 
        {
            return GetElement<RightToLeftText>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> ComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:cs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ComplexScript ComplexScript
    {
        get 
        {
            return GetElement<ComplexScript>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }
    /// <summary>
    /// <para> Emphasis.</para>
    /// <para> Represents the following element tag in the schema: w:em </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emphasis Emphasis
    {
        get 
        {
            return GetElement<Emphasis>(34);
        }
        set
        {
            SetElement(34, value);
        }
    }
    /// <summary>
    /// <para> Languages.</para>
    /// <para> Represents the following element tag in the schema: w:lang </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Languages Languages
    {
        get 
        {
            return GetElement<Languages>(35);
        }
        set
        {
            SetElement(35, value);
        }
    }
    /// <summary>
    /// <para> EastAsianLayout.</para>
    /// <para> Represents the following element tag in the schema: w:eastAsianLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EastAsianLayout EastAsianLayout
    {
        get 
        {
            return GetElement<EastAsianLayout>(36);
        }
        set
        {
            SetElement(36, value);
        }
    }
    /// <summary>
    /// <para> SpecVanish.</para>
    /// <para> Represents the following element tag in the schema: w:specVanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpecVanish SpecVanish
    {
        get 
        {
            return GetElement<SpecVanish>(37);
        }
        set
        {
            SetElement(37, value);
        }
    }
    /// <summary>
    /// <para> Glow.</para>
    /// <para> Represents the following element tag in the schema: w14:glow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Glow Glow
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Glow>(38);
        }
        set
        {
            SetElement(38, value);
        }
    }
    /// <summary>
    /// <para> Shadow14.</para>
    /// <para> Represents the following element tag in the schema: w14:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Shadow Shadow14
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Shadow>(39);
        }
        set
        {
            SetElement(39, value);
        }
    }
    /// <summary>
    /// <para> Reflection.</para>
    /// <para> Represents the following element tag in the schema: w14:reflection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Reflection Reflection
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Reflection>(40);
        }
        set
        {
            SetElement(40, value);
        }
    }
    /// <summary>
    /// <para> TextOutlineEffect.</para>
    /// <para> Represents the following element tag in the schema: w14:textOutline </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect TextOutlineEffect
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect>(41);
        }
        set
        {
            SetElement(41, value);
        }
    }
    /// <summary>
    /// <para> FillTextEffect.</para>
    /// <para> Represents the following element tag in the schema: w14:textFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.FillTextEffect FillTextEffect
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.FillTextEffect>(42);
        }
        set
        {
            SetElement(42, value);
        }
    }
    /// <summary>
    /// <para> Scene3D.</para>
    /// <para> Represents the following element tag in the schema: w14:scene3d </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Scene3D Scene3D
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Scene3D>(43);
        }
        set
        {
            SetElement(43, value);
        }
    }
    /// <summary>
    /// <para> Properties3D.</para>
    /// <para> Represents the following element tag in the schema: w14:props3d </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Properties3D Properties3D
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Properties3D>(44);
        }
        set
        {
            SetElement(44, value);
        }
    }
    /// <summary>
    /// <para> Ligatures.</para>
    /// <para> Represents the following element tag in the schema: w14:ligatures </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.Ligatures Ligatures
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.Ligatures>(45);
        }
        set
        {
            SetElement(45, value);
        }
    }
    /// <summary>
    /// <para> NumberingFormat.</para>
    /// <para> Represents the following element tag in the schema: w14:numForm </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.NumberingFormat>(46);
        }
        set
        {
            SetElement(46, value);
        }
    }
    /// <summary>
    /// <para> NumberSpacing.</para>
    /// <para> Represents the following element tag in the schema: w14:numSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.NumberSpacing NumberSpacing
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.NumberSpacing>(47);
        }
        set
        {
            SetElement(47, value);
        }
    }
    /// <summary>
    /// <para> StylisticSets.</para>
    /// <para> Represents the following element tag in the schema: w14:stylisticSets </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.StylisticSets StylisticSets
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.StylisticSets>(48);
        }
        set
        {
            SetElement(48, value);
        }
    }
    /// <summary>
    /// <para> ContextualAlternatives.</para>
    /// <para> Represents the following element tag in the schema: w14:cntxtAlts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w14 = http://schemas.microsoft.com/office/word/2010/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives ContextualAlternatives
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives>(49);
        }
        set
        {
            SetElement(49, value);
        }
    }
    /// <summary>
    /// <para> RunPropertiesChange.</para>
    /// <para> Represents the following element tag in the schema: w:rPrChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunPropertiesChange RunPropertiesChange
    {
        get 
        {
            return GetElement<RunPropertiesChange>(50);
        }
        set
        {
            SetElement(50, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the InsertedMathControl Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ins.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>DeletedMathControl &lt;w:del></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(DeletedMathControl))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsertedMathControl : OpenXmlCompositeElement
{
    private const string tagName = "ins";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11661;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the InsertedMathControl class.
    /// </summary>
    public InsertedMathControl():base(){}
    
            /// <summary>
    ///Initializes a new instance of the InsertedMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsertedMathControl(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InsertedMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsertedMathControl(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InsertedMathControl class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InsertedMathControl(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedMathControl();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsertedMathControl>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DeletedMathControl Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:del.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DeletedMathControl : OpenXmlCompositeElement
{
    private const string tagName = "del";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11662;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DeletedMathControl class.
    /// </summary>
    public DeletedMathControl():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DeletedMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DeletedMathControl(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DeletedMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DeletedMathControl(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DeletedMathControl class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DeletedMathControl(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DeletedMathControl>(deep);
    }

   
}
/// <summary>
/// <para>Defines the MoveFromMathControl Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveFrom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>InsertedMathControl &lt;w:ins></description></item>
///<item><description>DeletedMathControl &lt;w:del></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveFromMathControl : MathControlMoveType
{
    private const string tagName = "moveFrom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11663;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveFromMathControl class.
    /// </summary>
    public MoveFromMathControl():base(){}
            /// <summary>
    ///Initializes a new instance of the MoveFromMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveFromMathControl(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveFromMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveFromMathControl(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveFromMathControl class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MoveFromMathControl(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveFromMathControl>(deep);
    }

}
/// <summary>
/// <para>Defines the MoveToMathControl Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>InsertedMathControl &lt;w:ins></description></item>
///<item><description>DeletedMathControl &lt;w:del></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveToMathControl : MathControlMoveType
{
    private const string tagName = "moveTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11664;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveToMathControl class.
    /// </summary>
    public MoveToMathControl():base(){}
            /// <summary>
    ///Initializes a new instance of the MoveToMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveToMathControl(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveToMathControl class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveToMathControl(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveToMathControl class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MoveToMathControl(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveToMathControl>(deep);
    }

}
/// <summary>
/// Defines the MathControlMoveType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>InsertedMathControl &lt;w:ins></description></item>
///<item><description>DeletedMathControl &lt;w:del></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(InsertedMathControl))]
    [ChildElementInfo(typeof(DeletedMathControl))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MathControlMoveType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedMathControl();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedMathControl();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MathControlMoveType class.
    /// </summary>
    protected MathControlMoveType(){}
    
            /// <summary>
    ///Initializes a new instance of the MathControlMoveType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MathControlMoveType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MathControlMoveType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MathControlMoveType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MathControlMoveType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected MathControlMoveType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the CustomXmlRuby Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXml.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlProperties &lt;w:customXmlPr></description></item>
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlProperties))]
    [ChildElementInfo(typeof(CustomXmlRuby))]
    [ChildElementInfo(typeof(SimpleFieldRuby))]
    [ChildElementInfo(typeof(HyperlinkRuby))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(SdtRunRuby))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlRuby : CustomXmlElement
{
    private const string tagName = "customXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11665;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","element" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRuby class.
    /// </summary>
    public CustomXmlRuby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRuby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRuby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRuby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlRuby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXmlPr" == name)
    return new CustomXmlProperties();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRuby();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleFieldRuby();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new HyperlinkRuby();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRunRuby();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    

    return null;
}

        private static readonly string[] eleTagNames = { "customXmlPr","customXml","fldSimple","hyperlink","r","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel","oMathPara","oMath","acc","bar","box","borderBox","d","eqArr","f","func","groupChr","limLow","limUpp","m","nary","phant","rad","sPre","sSub","sSubSup","sSup","r" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
    

    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "element" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlRuby>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SimpleFieldRuby Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fldSimple.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldData &lt;w:fldData></description></item>
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldData))]
    [ChildElementInfo(typeof(CustomXmlRuby))]
    [ChildElementInfo(typeof(SimpleFieldRuby))]
    [ChildElementInfo(typeof(HyperlinkRuby))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(SdtRunRuby))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SimpleFieldRuby : OpenXmlCompositeElement
{
    private const string tagName = "fldSimple";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11666;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "instr","fldLock","dirty" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> instr.</para>
    /// <para>Represents the following attribute in the schema: w:instr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "instr")]
    public StringValue Instruction
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> fldLock.</para>
    /// <para>Represents the following attribute in the schema: w:fldLock </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fldLock")]
    public OnOffValue FieldLock
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> dirty.</para>
    /// <para>Represents the following attribute in the schema: w:dirty </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dirty")]
    public OnOffValue Dirty
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SimpleFieldRuby class.
    /// </summary>
    public SimpleFieldRuby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SimpleFieldRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SimpleFieldRuby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SimpleFieldRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SimpleFieldRuby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SimpleFieldRuby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SimpleFieldRuby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fldData" == name)
    return new FieldData();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRuby();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleFieldRuby();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new HyperlinkRuby();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRunRuby();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fldData","customXml","fldSimple","hyperlink","r","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel","oMathPara","oMath","acc","bar","box","borderBox","d","eqArr","f","func","groupChr","limLow","limUpp","m","nary","phant","rad","sPre","sSub","sSubSup","sSup","r" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> FieldData.</para>
    /// <para> Represents the following element tag in the schema: w:fldData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FieldData FieldData
    {
        get 
        {
            return GetElement<FieldData>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "instr" == name)
    return new StringValue();
    
if( 23 == namespaceId && "fldLock" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "dirty" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SimpleFieldRuby>(deep);
    }

   
}
/// <summary>
/// <para>Defines the HyperlinkRuby Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hyperlink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRuby))]
    [ChildElementInfo(typeof(SimpleFieldRuby))]
    [ChildElementInfo(typeof(HyperlinkRuby))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(SdtRunRuby))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyperlinkRuby : OpenXmlCompositeElement
{
    private const string tagName = "hyperlink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11667;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "tgtFrame","tooltip","docLocation","history","anchor","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> tgtFrame.</para>
    /// <para>Represents the following attribute in the schema: w:tgtFrame </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tgtFrame")]
    public StringValue TargetFrame
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> tooltip.</para>
    /// <para>Represents the following attribute in the schema: w:tooltip </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tooltip")]
    public StringValue Tooltip
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> docLocation.</para>
    /// <para>Represents the following attribute in the schema: w:docLocation </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "docLocation")]
    public StringValue DocLocation
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> history.</para>
    /// <para>Represents the following attribute in the schema: w:history </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "history")]
    public OnOffValue History
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> anchor.</para>
    /// <para>Represents the following attribute in the schema: w:anchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "anchor")]
    public StringValue Anchor
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HyperlinkRuby class.
    /// </summary>
    public HyperlinkRuby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the HyperlinkRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkRuby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HyperlinkRuby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HyperlinkRuby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HyperlinkRuby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRuby();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleFieldRuby();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new HyperlinkRuby();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRunRuby();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tgtFrame" == name)
    return new StringValue();
    
if( 23 == namespaceId && "tooltip" == name)
    return new StringValue();
    
if( 23 == namespaceId && "docLocation" == name)
    return new StringValue();
    
if( 23 == namespaceId && "history" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "anchor" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyperlinkRuby>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Guide Text Run.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:r.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>Break &lt;w:br></description></item>
///<item><description>Text &lt;w:t></description></item>
///<item><description>DeletedText &lt;w:delText></description></item>
///<item><description>FieldCode &lt;w:instrText></description></item>
///<item><description>DeletedFieldCode &lt;w:delInstrText></description></item>
///<item><description>NoBreakHyphen &lt;w:noBreakHyphen></description></item>
///<item><description>SoftHyphen &lt;w:softHyphen></description></item>
///<item><description>DayShort &lt;w:dayShort></description></item>
///<item><description>MonthShort &lt;w:monthShort></description></item>
///<item><description>YearShort &lt;w:yearShort></description></item>
///<item><description>DayLong &lt;w:dayLong></description></item>
///<item><description>MonthLong &lt;w:monthLong></description></item>
///<item><description>YearLong &lt;w:yearLong></description></item>
///<item><description>AnnotationReferenceMark &lt;w:annotationRef></description></item>
///<item><description>FootnoteReferenceMark &lt;w:footnoteRef></description></item>
///<item><description>EndnoteReferenceMark &lt;w:endnoteRef></description></item>
///<item><description>SeparatorMark &lt;w:separator></description></item>
///<item><description>ContinuationSeparatorMark &lt;w:continuationSeparator></description></item>
///<item><description>SymbolChar &lt;w:sym></description></item>
///<item><description>PageNumber &lt;w:pgNum></description></item>
///<item><description>CarriageReturn &lt;w:cr></description></item>
///<item><description>TabChar &lt;w:tab></description></item>
///<item><description>EmbeddedObject &lt;w:object></description></item>
///<item><description>Picture &lt;w:pict></description></item>
///<item><description>FieldChar &lt;w:fldChar></description></item>
///<item><description>Ruby &lt;w:ruby></description></item>
///<item><description>FootnoteReference &lt;w:footnoteReference></description></item>
///<item><description>EndnoteReference &lt;w:endnoteReference></description></item>
///<item><description>CommentReference &lt;w:commentReference></description></item>
///<item><description>Drawing &lt;w:drawing></description></item>
///<item><description>PositionalTab &lt;w:ptab></description></item>
///<item><description>LastRenderedPageBreak &lt;w:lastRenderedPageBreak></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(Break))]
    [ChildElementInfo(typeof(Text))]
    [ChildElementInfo(typeof(DeletedText))]
    [ChildElementInfo(typeof(FieldCode))]
    [ChildElementInfo(typeof(DeletedFieldCode))]
    [ChildElementInfo(typeof(NoBreakHyphen))]
    [ChildElementInfo(typeof(SoftHyphen))]
    [ChildElementInfo(typeof(DayShort))]
    [ChildElementInfo(typeof(MonthShort))]
    [ChildElementInfo(typeof(YearShort))]
    [ChildElementInfo(typeof(DayLong))]
    [ChildElementInfo(typeof(MonthLong))]
    [ChildElementInfo(typeof(YearLong))]
    [ChildElementInfo(typeof(AnnotationReferenceMark))]
    [ChildElementInfo(typeof(FootnoteReferenceMark))]
    [ChildElementInfo(typeof(EndnoteReferenceMark))]
    [ChildElementInfo(typeof(SeparatorMark))]
    [ChildElementInfo(typeof(ContinuationSeparatorMark))]
    [ChildElementInfo(typeof(SymbolChar))]
    [ChildElementInfo(typeof(PageNumber))]
    [ChildElementInfo(typeof(CarriageReturn))]
    [ChildElementInfo(typeof(TabChar))]
    [ChildElementInfo(typeof(EmbeddedObject))]
    [ChildElementInfo(typeof(Picture))]
    [ChildElementInfo(typeof(FieldChar))]
    [ChildElementInfo(typeof(Ruby))]
    [ChildElementInfo(typeof(FootnoteReference))]
    [ChildElementInfo(typeof(EndnoteReference))]
    [ChildElementInfo(typeof(CommentReference))]
    [ChildElementInfo(typeof(Drawing))]
    [ChildElementInfo(typeof(PositionalTab))]
    [ChildElementInfo(typeof(LastRenderedPageBreak))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Run : OpenXmlCompositeElement
{
    private const string tagName = "r";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11668;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rsidRPr","rsidDel","rsidR" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Identifier for Run Properties.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRPr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRPr")]
    public HexBinaryValue RsidRunProperties
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Run Deletion.</para>
    /// <para>Represents the following attribute in the schema: w:rsidDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidDel")]
    public HexBinaryValue RsidRunDeletion
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Run.</para>
    /// <para>Represents the following attribute in the schema: w:rsidR </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidR")]
    public HexBinaryValue RsidRunAddition
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Run class.
    /// </summary>
    public Run():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Run(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 23 == namespaceId && "br" == name)
    return new Break();
    
if( 23 == namespaceId && "t" == name)
    return new Text();
    
if( 23 == namespaceId && "delText" == name)
    return new DeletedText();
    
if( 23 == namespaceId && "instrText" == name)
    return new FieldCode();
    
if( 23 == namespaceId && "delInstrText" == name)
    return new DeletedFieldCode();
    
if( 23 == namespaceId && "noBreakHyphen" == name)
    return new NoBreakHyphen();
    
if( 23 == namespaceId && "softHyphen" == name)
    return new SoftHyphen();
    
if( 23 == namespaceId && "dayShort" == name)
    return new DayShort();
    
if( 23 == namespaceId && "monthShort" == name)
    return new MonthShort();
    
if( 23 == namespaceId && "yearShort" == name)
    return new YearShort();
    
if( 23 == namespaceId && "dayLong" == name)
    return new DayLong();
    
if( 23 == namespaceId && "monthLong" == name)
    return new MonthLong();
    
if( 23 == namespaceId && "yearLong" == name)
    return new YearLong();
    
if( 23 == namespaceId && "annotationRef" == name)
    return new AnnotationReferenceMark();
    
if( 23 == namespaceId && "footnoteRef" == name)
    return new FootnoteReferenceMark();
    
if( 23 == namespaceId && "endnoteRef" == name)
    return new EndnoteReferenceMark();
    
if( 23 == namespaceId && "separator" == name)
    return new SeparatorMark();
    
if( 23 == namespaceId && "continuationSeparator" == name)
    return new ContinuationSeparatorMark();
    
if( 23 == namespaceId && "sym" == name)
    return new SymbolChar();
    
if( 23 == namespaceId && "pgNum" == name)
    return new PageNumber();
    
if( 23 == namespaceId && "cr" == name)
    return new CarriageReturn();
    
if( 23 == namespaceId && "tab" == name)
    return new TabChar();
    
if( 23 == namespaceId && "object" == name)
    return new EmbeddedObject();
    
if( 23 == namespaceId && "pict" == name)
    return new Picture();
    
if( 23 == namespaceId && "fldChar" == name)
    return new FieldChar();
    
if( 23 == namespaceId && "ruby" == name)
    return new Ruby();
    
if( 23 == namespaceId && "footnoteReference" == name)
    return new FootnoteReference();
    
if( 23 == namespaceId && "endnoteReference" == name)
    return new EndnoteReference();
    
if( 23 == namespaceId && "commentReference" == name)
    return new CommentReference();
    
if( 23 == namespaceId && "drawing" == name)
    return new Drawing();
    
if( 23 == namespaceId && "ptab" == name)
    return new PositionalTab();
    
if( 23 == namespaceId && "lastRenderedPageBreak" == name)
    return new LastRenderedPageBreak();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr","br","t","delText","instrText","delInstrText","noBreakHyphen","softHyphen","dayShort","monthShort","yearShort","dayLong","monthLong","yearLong","annotationRef","footnoteRef","endnoteRef","separator","continuationSeparator","sym","pgNum","cr","tab","object","pict","fldChar","ruby","footnoteReference","endnoteReference","commentReference","drawing","ptab","lastRenderedPageBreak" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunProperties RunProperties
    {
        get 
        {
            return GetElement<RunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRPr" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidDel" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidR" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Run>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtRunRuby Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtProperties &lt;w:sdtPr></description></item>
///<item><description>SdtEndCharProperties &lt;w:sdtEndPr></description></item>
///<item><description>SdtContentRunRuby &lt;w:sdtContent></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtProperties))]
    [ChildElementInfo(typeof(SdtEndCharProperties))]
    [ChildElementInfo(typeof(SdtContentRunRuby))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtRunRuby : SdtElement
{
    private const string tagName = "sdt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11669;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtRunRuby class.
    /// </summary>
    public SdtRunRuby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtRunRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRunRuby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRunRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRunRuby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRunRuby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtRunRuby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdtPr" == name)
    return new SdtProperties();
    
if( 23 == namespaceId && "sdtEndPr" == name)
    return new SdtEndCharProperties();
    
if( 23 == namespaceId && "sdtContent" == name)
    return new SdtContentRunRuby();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sdtPr","sdtEndPr","sdtContent","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> SdtContentRunRuby.</para>
    /// <para> Represents the following element tag in the schema: w:sdtContent </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtContentRunRuby SdtContentRunRuby
    {
        get 
        {
            return GetElement<SdtContentRunRuby>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtRunRuby>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ProofError Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:proofErr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ProofError : OpenXmlLeafElement
{
    private const string tagName = "proofErr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11670;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Proofing Error Anchor Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingErrorValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingErrorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ProofError class.
    /// </summary>
    public ProofError():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingErrorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ProofError>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PermStart Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:permStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PermStart : OpenXmlLeafElement
{
    private const string tagName = "permStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11671;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "edGrp","ed","colFirst","colLast","id","displacedByCustomXml" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> edGrp.</para>
    /// <para>Represents the following attribute in the schema: w:edGrp </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "edGrp")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.RangePermissionEditingGroupValues> EditorGroup
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.RangePermissionEditingGroupValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> ed.</para>
    /// <para>Represents the following attribute in the schema: w:ed </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "ed")]
    public StringValue Ed
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> colFirst.</para>
    /// <para>Represents the following attribute in the schema: w:colFirst </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colFirst")]
    public Int32Value ColumnFirst
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> colLast.</para>
    /// <para>Represents the following attribute in the schema: w:colLast </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "colLast")]
    public Int32Value ColumnLast
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Annotation ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Displaced By Custom XML Markup.</para>
    /// <para>Represents the following attribute in the schema: w:displacedByCustomXml </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displacedByCustomXml")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues> DisplacedByCustomXml
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PermStart class.
    /// </summary>
    public PermStart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "edGrp" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.RangePermissionEditingGroupValues>();
    
if( 23 == namespaceId && "ed" == name)
    return new StringValue();
    
if( 23 == namespaceId && "colFirst" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "colLast" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "id" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "displacedByCustomXml" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PermStart>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PermEnd Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:permEnd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PermEnd : OpenXmlLeafElement
{
    private const string tagName = "permEnd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11672;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","displacedByCustomXml" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Annotation ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Displaced By Custom XML Markup.</para>
    /// <para>Represents the following attribute in the schema: w:displacedByCustomXml </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displacedByCustomXml")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues> DisplacedByCustomXml
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PermEnd class.
    /// </summary>
    public PermEnd():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "displacedByCustomXml" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DisplacedByCustomXmlValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PermEnd>(deep);
    }

   
}
/// <summary>
/// <para>Inserted Run Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ins.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InsertedRun : RunTrackChangeType
{
    private const string tagName = "ins";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11673;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InsertedRun class.
    /// </summary>
    public InsertedRun():base(){}
            /// <summary>
    ///Initializes a new instance of the InsertedRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsertedRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InsertedRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InsertedRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InsertedRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InsertedRun(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InsertedRun>(deep);
    }

}
/// <summary>
/// <para>Deleted Run Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:del.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DeletedRun : RunTrackChangeType
{
    private const string tagName = "del";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11674;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DeletedRun class.
    /// </summary>
    public DeletedRun():base(){}
            /// <summary>
    ///Initializes a new instance of the DeletedRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DeletedRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DeletedRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DeletedRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DeletedRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DeletedRun(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DeletedRun>(deep);
    }

}
/// <summary>
/// <para>Move Source Run Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveFrom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveFromRun : RunTrackChangeType
{
    private const string tagName = "moveFrom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11675;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveFromRun class.
    /// </summary>
    public MoveFromRun():base(){}
            /// <summary>
    ///Initializes a new instance of the MoveFromRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveFromRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveFromRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveFromRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveFromRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MoveFromRun(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveFromRun>(deep);
    }

}
/// <summary>
/// <para>Move Destination Run Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:moveTo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MoveToRun : RunTrackChangeType
{
    private const string tagName = "moveTo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11676;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MoveToRun class.
    /// </summary>
    public MoveToRun():base(){}
            /// <summary>
    ///Initializes a new instance of the MoveToRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveToRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveToRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MoveToRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MoveToRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MoveToRun(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MoveToRun>(deep);
    }

}
/// <summary>
/// Defines the RunTrackChangeType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RunTrackChangeType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the RunTrackChangeType class.
    /// </summary>
    protected RunTrackChangeType(){}
    
            /// <summary>
    ///Initializes a new instance of the RunTrackChangeType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RunTrackChangeType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunTrackChangeType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RunTrackChangeType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunTrackChangeType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected RunTrackChangeType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the ContentPart Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:contentPart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class ContentPart : OpenXmlLeafElement
{
    private const string tagName = "contentPart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11677;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ContentPart class.
    /// </summary>
    public ContentPart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ContentPart>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtRun Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtProperties &lt;w:sdtPr></description></item>
///<item><description>SdtEndCharProperties &lt;w:sdtEndPr></description></item>
///<item><description>SdtContentRun &lt;w:sdtContent></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtProperties))]
    [ChildElementInfo(typeof(SdtEndCharProperties))]
    [ChildElementInfo(typeof(SdtContentRun))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtRun : SdtElement
{
    private const string tagName = "sdt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11678;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtRun class.
    /// </summary>
    public SdtRun():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtRun(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdtPr" == name)
    return new SdtProperties();
    
if( 23 == namespaceId && "sdtEndPr" == name)
    return new SdtEndCharProperties();
    
if( 23 == namespaceId && "sdtContent" == name)
    return new SdtContentRun();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sdtPr","sdtEndPr","sdtContent","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Inline-Level Structured Document Tag Content.</para>
    /// <para> Represents the following element tag in the schema: w:sdtContent </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtContentRun SdtContentRun
    {
        get 
        {
            return GetElement<SdtContentRun>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtRun>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CustomXmlBlock Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXml.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlProperties &lt;w:customXmlPr></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlProperties))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlBlock : CustomXmlElement
{
    private const string tagName = "customXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11679;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","element" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlBlock class.
    /// </summary>
    public CustomXmlBlock():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlBlock(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlBlock(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlBlock class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlBlock(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXmlPr" == name)
    return new CustomXmlProperties();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

        private static readonly string[] eleTagNames = { "customXmlPr","customXml","sdt","p","tbl","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
    

    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "element" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlBlock>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtBlock Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtProperties &lt;w:sdtPr></description></item>
///<item><description>SdtEndCharProperties &lt;w:sdtEndPr></description></item>
///<item><description>SdtContentBlock &lt;w:sdtContent></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtProperties))]
    [ChildElementInfo(typeof(SdtEndCharProperties))]
    [ChildElementInfo(typeof(SdtContentBlock))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtBlock : SdtElement
{
    private const string tagName = "sdt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11680;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtBlock class.
    /// </summary>
    public SdtBlock():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtBlock(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtBlock(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtBlock class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtBlock(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdtPr" == name)
    return new SdtProperties();
    
if( 23 == namespaceId && "sdtEndPr" == name)
    return new SdtEndCharProperties();
    
if( 23 == namespaceId && "sdtContent" == name)
    return new SdtContentBlock();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sdtPr","sdtEndPr","sdtContent","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Block-Level Structured Document Tag Content.</para>
    /// <para> Represents the following element tag in the schema: w:sdtContent </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtContentBlock SdtContentBlock
    {
        get 
        {
            return GetElement<SdtContentBlock>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtBlock>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Paragraph Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:p.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphProperties &lt;w:pPr></description></item>
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphProperties))]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Paragraph : OpenXmlCompositeElement
{
    private const string tagName = "p";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11681;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rsidRPr","rsidR","rsidDel","rsidP","rsidRDefault","paraId","textId","noSpellErr" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,52,52,52 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Identifier for Paragraph Glyph Formatting.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRPr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRPr")]
    public HexBinaryValue RsidParagraphMarkRevision
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Paragraph.</para>
    /// <para>Represents the following attribute in the schema: w:rsidR </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidR")]
    public HexBinaryValue RsidParagraphAddition
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Paragraph Deletion.</para>
    /// <para>Represents the following attribute in the schema: w:rsidDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidDel")]
    public HexBinaryValue RsidParagraphDeletion
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Paragraph Properties.</para>
    /// <para>Represents the following attribute in the schema: w:rsidP </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidP")]
    public HexBinaryValue RsidParagraphProperties
    {
        get { return (HexBinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Default Revision Identifier for Runs.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRDefault </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRDefault")]
    public HexBinaryValue RsidRunAdditionDefault
    {
        get { return (HexBinaryValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> paraId.</para>
    /// <para>Represents the following attribute in the schema: w14:paraId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "paraId")]
    public HexBinaryValue ParagraphId
    {
        get { return (HexBinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> textId.</para>
    /// <para>Represents the following attribute in the schema: w14:textId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "textId")]
    public HexBinaryValue TextId
    {
        get { return (HexBinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> noSpellErr.</para>
    /// <para>Represents the following attribute in the schema: w14:noSpellErr </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "noSpellErr")]
    public OnOffValue NoSpellError
    {
        get { return (OnOffValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Paragraph class.
    /// </summary>
    public Paragraph():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Paragraph class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Paragraph(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Paragraph class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Paragraph(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Paragraph class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Paragraph(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pPr" == name)
    return new ParagraphProperties();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pPr","customXml","fldSimple","hyperlink","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel","oMathPara","oMath","acc","bar","box","borderBox","d","eqArr","f","func","groupChr","limLow","limUpp","m","nary","phant","rad","sPre","sSub","sSubSup","sSup","r","r","bdo","dir","subDoc" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphProperties ParagraphProperties
    {
        get 
        {
            return GetElement<ParagraphProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRPr" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidR" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidDel" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidP" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidRDefault" == name)
    return new HexBinaryValue();
    
if( 52 == namespaceId && "paraId" == name)
    return new HexBinaryValue();
    
if( 52 == namespaceId && "textId" == name)
    return new HexBinaryValue();
    
if( 52 == namespaceId && "noSpellErr" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Paragraph>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Table Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tbl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>TableProperties &lt;w:tblPr></description></item>
///<item><description>TableGrid &lt;w:tblGrid></description></item>
///<item><description>TableRow &lt;w:tr></description></item>
///<item><description>CustomXmlRow &lt;w:customXml></description></item>
///<item><description>SdtRow &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(TableProperties))]
    [ChildElementInfo(typeof(TableGrid))]
    [ChildElementInfo(typeof(TableRow))]
    [ChildElementInfo(typeof(CustomXmlRow))]
    [ChildElementInfo(typeof(SdtRow))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Table : OpenXmlCompositeElement
{
    private const string tagName = "tbl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11682;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Table class.
    /// </summary>
    public Table():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Table(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "tblPr" == name)
    return new TableProperties();
    
if( 23 == namespaceId && "tblGrid" == name)
    return new TableGrid();
    
if( 23 == namespaceId && "tr" == name)
    return new TableRow();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRow();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRow();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Table>(deep);
    }

   
}
/// <summary>
/// <para>Table Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TablePropertyExceptions &lt;w:tblPrEx></description></item>
///<item><description>TableRowProperties &lt;w:trPr></description></item>
///<item><description>TableCell &lt;w:tc></description></item>
///<item><description>CustomXmlCell &lt;w:customXml></description></item>
///<item><description>SdtCell &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TablePropertyExceptions))]
    [ChildElementInfo(typeof(TableRowProperties))]
    [ChildElementInfo(typeof(TableCell))]
    [ChildElementInfo(typeof(CustomXmlCell))]
    [ChildElementInfo(typeof(SdtCell))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableRow : OpenXmlCompositeElement
{
    private const string tagName = "tr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11683;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rsidRPr","rsidR","rsidDel","rsidTr","paraId","textId" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,52,52 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Identifier for Table Row Glyph Formatting.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRPr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRPr")]
    public HexBinaryValue RsidTableRowMarkRevision
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Table Row.</para>
    /// <para>Represents the following attribute in the schema: w:rsidR </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidR")]
    public HexBinaryValue RsidTableRowAddition
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Table Row Deletion.</para>
    /// <para>Represents the following attribute in the schema: w:rsidDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidDel")]
    public HexBinaryValue RsidTableRowDeletion
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Revision Identifier for Table Row Properties.</para>
    /// <para>Represents the following attribute in the schema: w:rsidTr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidTr")]
    public HexBinaryValue RsidTableRowProperties
    {
        get { return (HexBinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> paraId.</para>
    /// <para>Represents the following attribute in the schema: w14:paraId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "paraId")]
    public HexBinaryValue ParagraphId
    {
        get { return (HexBinaryValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> textId.</para>
    /// <para>Represents the following attribute in the schema: w14:textId </para>
    /// </summary>
///<remark> xmlns:w14=http://schemas.microsoft.com/office/word/2010/wordml
///</remark>
    [SchemaAttr(52, "textId")]
    public HexBinaryValue TextId
    {
        get { return (HexBinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableRow class.
    /// </summary>
    public TableRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblPrEx" == name)
    return new TablePropertyExceptions();
    
if( 23 == namespaceId && "trPr" == name)
    return new TableRowProperties();
    
if( 23 == namespaceId && "tc" == name)
    return new TableCell();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlCell();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtCell();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblPrEx","trPr","tc","customXml","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table-Level Property Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblPrEx </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TablePropertyExceptions TablePropertyExceptions
    {
        get 
        {
            return GetElement<TablePropertyExceptions>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Row Properties.</para>
    /// <para> Represents the following element tag in the schema: w:trPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableRowProperties TableRowProperties
    {
        get 
        {
            return GetElement<TableRowProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRPr" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidR" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidDel" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidTr" == name)
    return new HexBinaryValue();
    
if( 52 == namespaceId && "paraId" == name)
    return new HexBinaryValue();
    
if( 52 == namespaceId && "textId" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableRow>(deep);
    }

   
}
/// <summary>
/// <para>Row-Level Custom XML Element.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXml.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlProperties &lt;w:customXmlPr></description></item>
///<item><description>TableRow &lt;w:tr></description></item>
///<item><description>CustomXmlRow &lt;w:customXml></description></item>
///<item><description>SdtRow &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlProperties))]
    [ChildElementInfo(typeof(TableRow))]
    [ChildElementInfo(typeof(CustomXmlRow))]
    [ChildElementInfo(typeof(SdtRow))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlRow : CustomXmlElement
{
    private const string tagName = "customXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11684;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","element" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRow class.
    /// </summary>
    public CustomXmlRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXmlPr" == name)
    return new CustomXmlProperties();
    
if( 23 == namespaceId && "tr" == name)
    return new TableRow();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRow();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRow();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

        private static readonly string[] eleTagNames = { "customXmlPr","tr","customXml","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
    

    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "element" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlRow>(deep);
    }

   
}
/// <summary>
/// <para>Row-Level Structured Document Tag.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtProperties &lt;w:sdtPr></description></item>
///<item><description>SdtEndCharProperties &lt;w:sdtEndPr></description></item>
///<item><description>SdtContentRow &lt;w:sdtContent></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtProperties))]
    [ChildElementInfo(typeof(SdtEndCharProperties))]
    [ChildElementInfo(typeof(SdtContentRow))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtRow : SdtElement
{
    private const string tagName = "sdt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11685;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtRow class.
    /// </summary>
    public SdtRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdtPr" == name)
    return new SdtProperties();
    
if( 23 == namespaceId && "sdtEndPr" == name)
    return new SdtEndCharProperties();
    
if( 23 == namespaceId && "sdtContent" == name)
    return new SdtContentRow();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sdtPr","sdtEndPr","sdtContent","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Row-Level Structured Document Tag Content.</para>
    /// <para> Represents the following element tag in the schema: w:sdtContent </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtContentRow SdtContentRow
    {
        get 
        {
            return GetElement<SdtContentRow>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtRow>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellProperties &lt;w:tcPr></description></item>
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCellProperties))]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCell : OpenXmlCompositeElement
{
    private const string tagName = "tc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11686;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCell class.
    /// </summary>
    public TableCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tcPr" == name)
    return new TableCellProperties();
    
if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tcPr","altChunk","customXml","sdt","p","tbl","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellProperties TableCellProperties
    {
        get 
        {
            return GetElement<TableCellProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCell>(deep);
    }

   
}
/// <summary>
/// <para>Cell-Level Custom XML Element.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXml.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlProperties &lt;w:customXmlPr></description></item>
///<item><description>TableCell &lt;w:tc></description></item>
///<item><description>CustomXmlCell &lt;w:customXml></description></item>
///<item><description>SdtCell &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlProperties))]
    [ChildElementInfo(typeof(TableCell))]
    [ChildElementInfo(typeof(CustomXmlCell))]
    [ChildElementInfo(typeof(SdtCell))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlCell : CustomXmlElement
{
    private const string tagName = "customXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11687;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","element" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlCell class.
    /// </summary>
    public CustomXmlCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXmlPr" == name)
    return new CustomXmlProperties();
    
if( 23 == namespaceId && "tc" == name)
    return new TableCell();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlCell();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtCell();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

        private static readonly string[] eleTagNames = { "customXmlPr","tc","customXml","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
    

    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "element" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlCell>(deep);
    }

   
}
/// <summary>
/// <para>Cell-Level Structured Document Tag.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SdtProperties &lt;w:sdtPr></description></item>
///<item><description>SdtEndCharProperties &lt;w:sdtEndPr></description></item>
///<item><description>SdtContentCell &lt;w:sdtContent></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SdtProperties))]
    [ChildElementInfo(typeof(SdtEndCharProperties))]
    [ChildElementInfo(typeof(SdtContentCell))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtCell : SdtElement
{
    private const string tagName = "sdt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11688;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtCell class.
    /// </summary>
    public SdtCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sdtPr" == name)
    return new SdtProperties();
    
if( 23 == namespaceId && "sdtEndPr" == name)
    return new SdtEndCharProperties();
    
if( 23 == namespaceId && "sdtContent" == name)
    return new SdtContentCell();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sdtPr","sdtEndPr","sdtContent","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Cell-Level Structured Document Tag Content.</para>
    /// <para> Represents the following element tag in the schema: w:sdtContent </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtContentCell SdtContentCell
    {
        get 
        {
            return GetElement<SdtContentCell>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtCell>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CustomXmlRun Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXml.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlProperties &lt;w:customXmlPr></description></item>
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlProperties))]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlRun : CustomXmlElement
{
    private const string tagName = "customXml";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11689;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","element" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRun class.
    /// </summary>
    public CustomXmlRun():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlRun(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXmlPr" == name)
    return new CustomXmlProperties();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "customXmlPr","customXml","fldSimple","hyperlink","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel","oMathPara","oMath","acc","bar","box","borderBox","d","eqArr","f","func","groupChr","limLow","limUpp","m","nary","phant","rad","sPre","sSub","sSubSup","sSup","r","r","bdo","dir","subDoc" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
    

    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "element" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlRun>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SimpleField Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fldSimple.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldData &lt;w:fldData></description></item>
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldData))]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SimpleField : OpenXmlCompositeElement
{
    private const string tagName = "fldSimple";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11690;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "instr","fldLock","dirty" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Codes.</para>
    /// <para>Represents the following attribute in the schema: w:instr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "instr")]
    public StringValue Instruction
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field Should Not Be Recalculated.</para>
    /// <para>Represents the following attribute in the schema: w:fldLock </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fldLock")]
    public OnOffValue FieldLock
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Field Result Invalidated.</para>
    /// <para>Represents the following attribute in the schema: w:dirty </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dirty")]
    public OnOffValue Dirty
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SimpleField class.
    /// </summary>
    public SimpleField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SimpleField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SimpleField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SimpleField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SimpleField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SimpleField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SimpleField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fldData" == name)
    return new FieldData();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fldData","customXml","fldSimple","hyperlink","sdt","proofErr","permStart","permEnd","bookmarkStart","bookmarkEnd","commentRangeStart","commentRangeEnd","moveFromRangeStart","moveFromRangeEnd","moveToRangeStart","moveToRangeEnd","customXmlInsRangeStart","customXmlInsRangeEnd","customXmlDelRangeStart","customXmlDelRangeEnd","customXmlMoveFromRangeStart","customXmlMoveFromRangeEnd","customXmlMoveToRangeStart","customXmlMoveToRangeEnd","customXmlConflictInsRangeStart","customXmlConflictInsRangeEnd","customXmlConflictDelRangeStart","customXmlConflictDelRangeEnd","ins","del","moveFrom","moveTo","contentPart","conflictIns","conflictDel","oMathPara","oMath","acc","bar","box","borderBox","d","eqArr","f","func","groupChr","limLow","limUpp","m","nary","phant","rad","sPre","sSub","sSubSup","sSup","r","r","bdo","dir","subDoc" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,23,23,23,23,23,52,52,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Custom Field Data.</para>
    /// <para> Represents the following element tag in the schema: w:fldData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FieldData FieldData
    {
        get 
        {
            return GetElement<FieldData>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "instr" == name)
    return new StringValue();
    
if( 23 == namespaceId && "fldLock" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "dirty" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SimpleField>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Hyperlink Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hyperlink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hyperlink : OpenXmlCompositeElement
{
    private const string tagName = "hyperlink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11691;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "tgtFrame","tooltip","docLocation","history","anchor","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hyperlink Target Frame.</para>
    /// <para>Represents the following attribute in the schema: w:tgtFrame </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tgtFrame")]
    public StringValue TargetFrame
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Associated String.</para>
    /// <para>Represents the following attribute in the schema: w:tooltip </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tooltip")]
    public StringValue Tooltip
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Location in Target Document.</para>
    /// <para>Represents the following attribute in the schema: w:docLocation </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "docLocation")]
    public StringValue DocLocation
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Add To Viewed Hyperlinks.</para>
    /// <para>Represents the following attribute in the schema: w:history </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "history")]
    public OnOffValue History
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hyperlink Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:anchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "anchor")]
    public StringValue Anchor
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Hyperlink Target.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Hyperlink class.
    /// </summary>
    public Hyperlink():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Hyperlink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlink(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlink(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlink class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Hyperlink(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tgtFrame" == name)
    return new StringValue();
    
if( 23 == namespaceId && "tooltip" == name)
    return new StringValue();
    
if( 23 == namespaceId && "docLocation" == name)
    return new StringValue();
    
if( 23 == namespaceId && "history" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "anchor" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hyperlink>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BidirectionalOverride Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bdo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class BidirectionalOverride : OpenXmlCompositeElement
{
    private const string tagName = "bdo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11692;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BidirectionalOverride class.
    /// </summary>
    public BidirectionalOverride():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BidirectionalOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BidirectionalOverride(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BidirectionalOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BidirectionalOverride(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BidirectionalOverride class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BidirectionalOverride(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BidirectionalOverride>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BidirectionalEmbedding Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dir.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class BidirectionalEmbedding : OpenXmlCompositeElement
{
    private const string tagName = "dir";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11693;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BidirectionalEmbedding class.
    /// </summary>
    public BidirectionalEmbedding():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BidirectionalEmbedding class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BidirectionalEmbedding(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BidirectionalEmbedding class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BidirectionalEmbedding(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BidirectionalEmbedding class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BidirectionalEmbedding(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DirectionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BidirectionalEmbedding>(deep);
    }

   
}
/// <summary>
/// <para>Anchor for Subdocument Location.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:subDoc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SubDocumentReference : RelationshipType
{
    private const string tagName = "subDoc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11694;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SubDocumentReference class.
    /// </summary>
    public SubDocumentReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SubDocumentReference>(deep);
    }

}
/// <summary>
/// <para>Defines the PrinterSettingsReference Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:printerSettings.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrinterSettingsReference : RelationshipType
{
    private const string tagName = "printerSettings";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11752;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrinterSettingsReference class.
    /// </summary>
    public PrinterSettingsReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrinterSettingsReference>(deep);
    }

}
/// <summary>
/// <para>ODSO Data Source File Path.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:src.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SourceReference : RelationshipType
{
    private const string tagName = "src";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11867;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SourceReference class.
    /// </summary>
    public SourceReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SourceReference>(deep);
    }

}
/// <summary>
/// <para>Reference to Inclusion/Exclusion Data for Data Source.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:recipientData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RecipientDataReference : RelationshipType
{
    private const string tagName = "recipientData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11872;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RecipientDataReference class.
    /// </summary>
    public RecipientDataReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RecipientDataReference>(deep);
    }

}
/// <summary>
/// <para>Data Source File Path.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dataSource.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataSourceReference : RelationshipType
{
    private const string tagName = "dataSource";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11878;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DataSourceReference class.
    /// </summary>
    public DataSourceReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataSourceReference>(deep);
    }

}
/// <summary>
/// <para>Header Definition File Path.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:headerSource.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HeaderSource : RelationshipType
{
    private const string tagName = "headerSource";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11879;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HeaderSource class.
    /// </summary>
    public HeaderSource():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HeaderSource>(deep);
    }

}
/// <summary>
/// <para>Source File for Frame.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sourceFileName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SourceFileReference : RelationshipType
{
    private const string tagName = "sourceFileName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11898;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SourceFileReference class.
    /// </summary>
    public SourceFileReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SourceFileReference>(deep);
    }

}
/// <summary>
/// <para>Defines the MovieReference Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:movie.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MovieReference : RelationshipType
{
    private const string tagName = "movie";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12078;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MovieReference class.
    /// </summary>
    public MovieReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MovieReference>(deep);
    }

}
/// <summary>
/// <para>Attached Document Template.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:attachedTemplate.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AttachedTemplate : RelationshipType
{
    private const string tagName = "attachedTemplate";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12127;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AttachedTemplate class.
    /// </summary>
    public AttachedTemplate():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AttachedTemplate>(deep);
    }

}
/// <summary>
/// Defines the RelationshipType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RelationshipType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Relationship to Part.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the RelationshipType class.
    /// </summary>
    protected RelationshipType(){}
    
    
    
}
/// <summary>
/// <para>Defines the ConditionalFormatStyle Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cnfStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormatStyle : OpenXmlLeafElement
{
    private const string tagName = "cnfStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11695;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","firstRow","lastRow","firstColumn","lastColumn","oddVBand","evenVBand","oddHBand","evenHBand","firstRowFirstColumn","firstRowLastColumn","lastRowFirstColumn","lastRowLastColumn" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Conditional Formatting Bit Mask.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> firstRow.</para>
    /// <para>Represents the following attribute in the schema: w:firstRow </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstRow")]
    public OnOffValue FirstRow
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> lastRow.</para>
    /// <para>Represents the following attribute in the schema: w:lastRow </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastRow")]
    public OnOffValue LastRow
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> firstColumn.</para>
    /// <para>Represents the following attribute in the schema: w:firstColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstColumn")]
    public OnOffValue FirstColumn
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> lastColumn.</para>
    /// <para>Represents the following attribute in the schema: w:lastColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastColumn")]
    public OnOffValue LastColumn
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> oddVBand.</para>
    /// <para>Represents the following attribute in the schema: w:oddVBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "oddVBand")]
    public OnOffValue OddVerticalBand
    {
        get { return (OnOffValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> evenVBand.</para>
    /// <para>Represents the following attribute in the schema: w:evenVBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "evenVBand")]
    public OnOffValue EvenVerticalBand
    {
        get { return (OnOffValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> oddHBand.</para>
    /// <para>Represents the following attribute in the schema: w:oddHBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "oddHBand")]
    public OnOffValue OddHorizontalBand
    {
        get { return (OnOffValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> evenHBand.</para>
    /// <para>Represents the following attribute in the schema: w:evenHBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "evenHBand")]
    public OnOffValue EvenHorizontalBand
    {
        get { return (OnOffValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> firstRowFirstColumn.</para>
    /// <para>Represents the following attribute in the schema: w:firstRowFirstColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstRowFirstColumn")]
    public OnOffValue FirstRowFirstColumn
    {
        get { return (OnOffValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> firstRowLastColumn.</para>
    /// <para>Represents the following attribute in the schema: w:firstRowLastColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstRowLastColumn")]
    public OnOffValue FirstRowLastColumn
    {
        get { return (OnOffValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> lastRowFirstColumn.</para>
    /// <para>Represents the following attribute in the schema: w:lastRowFirstColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastRowFirstColumn")]
    public OnOffValue LastRowFirstColumn
    {
        get { return (OnOffValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> lastRowLastColumn.</para>
    /// <para>Represents the following attribute in the schema: w:lastRowLastColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastRowLastColumn")]
    public OnOffValue LastRowLastColumn
    {
        get { return (OnOffValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormatStyle class.
    /// </summary>
    public ConditionalFormatStyle():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "firstRow" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastRow" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "firstColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "oddVBand" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "evenVBand" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "oddHBand" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "evenHBand" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "firstRowFirstColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "firstRowLastColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastRowFirstColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastRowLastColumn" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormatStyle>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableCellWidth Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcW.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellWidth : TableWidthType
{
    private const string tagName = "tcW";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11696;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellWidth class.
    /// </summary>
    public TableCellWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellWidth>(deep);
    }

}
/// <summary>
/// <para>Defines the WidthBeforeTableRow Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wBefore.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WidthBeforeTableRow : TableWidthType
{
    private const string tagName = "wBefore";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11709;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WidthBeforeTableRow class.
    /// </summary>
    public WidthBeforeTableRow():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WidthBeforeTableRow>(deep);
    }

}
/// <summary>
/// <para>Defines the WidthAfterTableRow Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:wAfter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WidthAfterTableRow : TableWidthType
{
    private const string tagName = "wAfter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11710;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the WidthAfterTableRow class.
    /// </summary>
    public WidthAfterTableRow():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WidthAfterTableRow>(deep);
    }

}
/// <summary>
/// <para>Defines the TableCellSpacing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblCellSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellSpacing : TableWidthType
{
    private const string tagName = "tblCellSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11715;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellSpacing class.
    /// </summary>
    public TableCellSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellSpacing>(deep);
    }

}
/// <summary>
/// <para>Defines the TableWidth Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblW.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableWidth : TableWidthType
{
    private const string tagName = "tblW";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11723;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableWidth class.
    /// </summary>
    public TableWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableWidth>(deep);
    }

}
/// <summary>
/// <para>Table Cell Top Margin Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:top.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopMargin : TableWidthType
{
    private const string tagName = "top";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12064;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopMargin class.
    /// </summary>
    public TopMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopMargin>(deep);
    }

}
/// <summary>
/// <para>Defines the StartMargin Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:start.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class StartMargin : TableWidthType
{
    private const string tagName = "start";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12066;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartMargin class.
    /// </summary>
    public StartMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartMargin>(deep);
    }

}
/// <summary>
/// <para>Table Cell Bottom Margin Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bottom.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomMargin : TableWidthType
{
    private const string tagName = "bottom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12067;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomMargin class.
    /// </summary>
    public BottomMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomMargin>(deep);
    }

}
/// <summary>
/// <para>Defines the EndMargin Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:end.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class EndMargin : TableWidthType
{
    private const string tagName = "end";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12069;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndMargin class.
    /// </summary>
    public EndMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndMargin>(deep);
    }

}
/// <summary>
/// <para>Table Cell Left Margin Exception.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:left.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftMargin : TableWidthType
{
    private const string tagName = "left";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12073;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftMargin class.
    /// </summary>
    public LeftMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftMargin>(deep);
    }

}
/// <summary>
/// <para>Table Cell Right Margin Exception.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:right.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightMargin : TableWidthType
{
    private const string tagName = "right";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12074;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightMargin class.
    /// </summary>
    public RightMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightMargin>(deep);
    }

}
/// <summary>
/// Defines the TableWidthType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TableWidthType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "w","type" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Table Width Value.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public StringValue Width
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Table Width Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new StringValue();
    
if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TableWidthType class.
    /// </summary>
    protected TableWidthType(){}
    
    
    
}
/// <summary>
/// <para>Defines the HorizontalMerge Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hMerge.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HorizontalMerge : OpenXmlLeafElement
{
    private const string tagName = "hMerge";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11698;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Merge Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HorizontalMerge class.
    /// </summary>
    public HorizontalMerge():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HorizontalMerge>(deep);
    }

   
}
/// <summary>
/// <para>Defines the VerticalMerge Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:vMerge.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VerticalMerge : OpenXmlLeafElement
{
    private const string tagName = "vMerge";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11699;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Vertical Merge Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VerticalMerge class.
    /// </summary>
    public VerticalMerge():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MergedCellValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VerticalMerge>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableCellBorders Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcBorders.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopBorder &lt;w:top></description></item>
///<item><description>LeftBorder &lt;w:left></description></item>
///<item><description>StartBorder &lt;w:start></description></item>
///<item><description>BottomBorder &lt;w:bottom></description></item>
///<item><description>RightBorder &lt;w:right></description></item>
///<item><description>EndBorder &lt;w:end></description></item>
///<item><description>InsideHorizontalBorder &lt;w:insideH></description></item>
///<item><description>InsideVerticalBorder &lt;w:insideV></description></item>
///<item><description>TopLeftToBottomRightCellBorder &lt;w:tl2br></description></item>
///<item><description>TopRightToBottomLeftCellBorder &lt;w:tr2bl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(StartBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(RightBorder))]
    [ChildElementInfo(typeof(EndBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsideHorizontalBorder))]
    [ChildElementInfo(typeof(InsideVerticalBorder))]
    [ChildElementInfo(typeof(TopLeftToBottomRightCellBorder))]
    [ChildElementInfo(typeof(TopRightToBottomLeftCellBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellBorders : OpenXmlCompositeElement
{
    private const string tagName = "tcBorders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11700;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class.
    /// </summary>
    public TableCellBorders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellBorders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellBorders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellBorders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellBorders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 23 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 23 == namespaceId && "start" == name)
    return new StartBorder();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 23 == namespaceId && "right" == name)
    return new RightBorder();
    
if( 23 == namespaceId && "end" == name)
    return new EndBorder();
    
if( 23 == namespaceId && "insideH" == name)
    return new InsideHorizontalBorder();
    
if( 23 == namespaceId && "insideV" == name)
    return new InsideVerticalBorder();
    
if( 23 == namespaceId && "tl2br" == name)
    return new TopLeftToBottomRightCellBorder();
    
if( 23 == namespaceId && "tr2bl" == name)
    return new TopRightToBottomLeftCellBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","start","bottom","right","end","insideH","insideV","tl2br","tr2bl" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Top Border.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Left Border.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> StartBorder.</para>
    /// <para> Represents the following element tag in the schema: w:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartBorder StartBorder
    {
        get 
        {
            return GetElement<StartBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Bottom Border.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Right Border.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> EndBorder.</para>
    /// <para> Represents the following element tag in the schema: w:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndBorder EndBorder
    {
        get 
        {
            return GetElement<EndBorder>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Inside Horizontal Edges Border.</para>
    /// <para> Represents the following element tag in the schema: w:insideH </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public InsideHorizontalBorder InsideHorizontalBorder
    {
        get 
        {
            return GetElement<InsideHorizontalBorder>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Inside Vertical Edges Border.</para>
    /// <para> Represents the following element tag in the schema: w:insideV </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public InsideVerticalBorder InsideVerticalBorder
    {
        get 
        {
            return GetElement<InsideVerticalBorder>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Top Left to Bottom Right Diagonal Border.</para>
    /// <para> Represents the following element tag in the schema: w:tl2br </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLeftToBottomRightCellBorder TopLeftToBottomRightCellBorder
    {
        get 
        {
            return GetElement<TopLeftToBottomRightCellBorder>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Top Right to Bottom Left Diagonal Border.</para>
    /// <para> Represents the following element tag in the schema: w:tr2bl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopRightToBottomLeftCellBorder TopRightToBottomLeftCellBorder
    {
        get 
        {
            return GetElement<TopRightToBottomLeftCellBorder>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellBorders>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NoWrap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noWrap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoWrap : OnOffOnlyType
{
    private const string tagName = "noWrap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11701;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoWrap class.
    /// </summary>
    public NoWrap():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoWrap>(deep);
    }

}
/// <summary>
/// <para>Defines the TableCellFitText Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcFitText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellFitText : OnOffOnlyType
{
    private const string tagName = "tcFitText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11703;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellFitText class.
    /// </summary>
    public TableCellFitText():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellFitText>(deep);
    }

}
/// <summary>
/// <para>Defines the HideMark Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hideMark.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HideMark : OnOffOnlyType
{
    private const string tagName = "hideMark";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11705;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HideMark class.
    /// </summary>
    public HideMark():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HideMark>(deep);
    }

}
/// <summary>
/// <para>Defines the CantSplit Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cantSplit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CantSplit : OnOffOnlyType
{
    private const string tagName = "cantSplit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11713;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CantSplit class.
    /// </summary>
    public CantSplit():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CantSplit>(deep);
    }

}
/// <summary>
/// <para>Defines the TableHeader Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableHeader : OnOffOnlyType
{
    private const string tagName = "tblHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11714;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableHeader class.
    /// </summary>
    public TableHeader():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableHeader>(deep);
    }

}
/// <summary>
/// <para>Defines the BiDiVisual Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bidiVisual.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BiDiVisual : OnOffOnlyType
{
    private const string tagName = "bidiVisual";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11720;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BiDiVisual class.
    /// </summary>
    public BiDiVisual():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BiDiVisual>(deep);
    }

}
/// <summary>
/// <para>Frame Cannot Be Resized.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noResizeAllowed.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoResizeAllowed : OnOffOnlyType
{
    private const string tagName = "noResizeAllowed";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11902;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoResizeAllowed class.
    /// </summary>
    public NoResizeAllowed():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoResizeAllowed>(deep);
    }

}
/// <summary>
/// <para>Maintain Link to Existing File.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:linkedToFile.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LinkedToFile : OnOffOnlyType
{
    private const string tagName = "linkedToFile";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11903;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LinkedToFile class.
    /// </summary>
    public LinkedToFile():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LinkedToFile>(deep);
    }

}
/// <summary>
/// <para>Do Not Display Frameset Splitters.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noBorder.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoBorder : OnOffOnlyType
{
    private const string tagName = "noBorder";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11905;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NoBorder class.
    /// </summary>
    public NoBorder():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoBorder>(deep);
    }

}
/// <summary>
/// <para>Frameset Splitter Border Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:flatBorders.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FlatBorders : OnOffOnlyType
{
    private const string tagName = "flatBorders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11906;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FlatBorders class.
    /// </summary>
    public FlatBorders():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FlatBorders>(deep);
    }

}
/// <summary>
/// <para>Automatically Merge User Formatting Into Style Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoRedefine.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoRedefine : OnOffOnlyType
{
    private const string tagName = "autoRedefine";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11945;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoRedefine class.
    /// </summary>
    public AutoRedefine():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoRedefine>(deep);
    }

}
/// <summary>
/// <para>Hide Style From User Interface.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hidden.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleHidden : OnOffOnlyType
{
    private const string tagName = "hidden";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11946;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleHidden class.
    /// </summary>
    public StyleHidden():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleHidden>(deep);
    }

}
/// <summary>
/// <para>Hide Style From Main User Interface.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:semiHidden.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SemiHidden : OnOffOnlyType
{
    private const string tagName = "semiHidden";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11948;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SemiHidden class.
    /// </summary>
    public SemiHidden():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SemiHidden>(deep);
    }

}
/// <summary>
/// <para>Remove Semi-Hidden Property When Style Is Used.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:unhideWhenUsed.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UnhideWhenUsed : OnOffOnlyType
{
    private const string tagName = "unhideWhenUsed";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11949;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the UnhideWhenUsed class.
    /// </summary>
    public UnhideWhenUsed():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UnhideWhenUsed>(deep);
    }

}
/// <summary>
/// <para>Primary Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:qFormat.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrimaryStyle : OnOffOnlyType
{
    private const string tagName = "qFormat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11950;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PrimaryStyle class.
    /// </summary>
    public PrimaryStyle():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrimaryStyle>(deep);
    }

}
/// <summary>
/// <para>Style Cannot Be Applied.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:locked.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Locked : OnOffOnlyType
{
    private const string tagName = "locked";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11951;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Locked class.
    /// </summary>
    public Locked():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Locked>(deep);
    }

}
/// <summary>
/// <para>E-Mail Message Text Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:personal.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Personal : OnOffOnlyType
{
    private const string tagName = "personal";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11952;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Personal class.
    /// </summary>
    public Personal():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Personal>(deep);
    }

}
/// <summary>
/// <para>E-Mail Message Composition Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:personalCompose.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PersonalCompose : OnOffOnlyType
{
    private const string tagName = "personalCompose";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11953;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PersonalCompose class.
    /// </summary>
    public PersonalCompose():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PersonalCompose>(deep);
    }

}
/// <summary>
/// <para>E-Mail Message Reply Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:personalReply.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PersonalReply : OnOffOnlyType
{
    private const string tagName = "personalReply";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11954;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the PersonalReply class.
    /// </summary>
    public PersonalReply():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PersonalReply>(deep);
    }

}
/// <summary>
/// Defines the OnOffOnlyType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class OnOffOnlyType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.OnOffOnlyValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.OnOffOnlyValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.OnOffOnlyValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the OnOffOnlyType class.
    /// </summary>
    protected OnOffOnlyType(){}
    
    
    
}
/// <summary>
/// <para>Defines the TableCellMargin Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcMar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopMargin &lt;w:top></description></item>
///<item><description>LeftMargin &lt;w:left></description></item>
///<item><description>StartMargin &lt;w:start></description></item>
///<item><description>BottomMargin &lt;w:bottom></description></item>
///<item><description>RightMargin &lt;w:right></description></item>
///<item><description>EndMargin &lt;w:end></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopMargin))]
    [ChildElementInfo(typeof(LeftMargin))]
    [ChildElementInfo(typeof(StartMargin),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BottomMargin))]
    [ChildElementInfo(typeof(RightMargin))]
    [ChildElementInfo(typeof(EndMargin),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellMargin : OpenXmlCompositeElement
{
    private const string tagName = "tcMar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11702;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellMargin class.
    /// </summary>
    public TableCellMargin():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellMargin class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellMargin(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellMargin class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellMargin(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellMargin class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellMargin(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopMargin();
    
if( 23 == namespaceId && "left" == name)
    return new LeftMargin();
    
if( 23 == namespaceId && "start" == name)
    return new StartMargin();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomMargin();
    
if( 23 == namespaceId && "right" == name)
    return new RightMargin();
    
if( 23 == namespaceId && "end" == name)
    return new EndMargin();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","start","bottom","right","end" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Top Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopMargin TopMargin
    {
        get 
        {
            return GetElement<TopMargin>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Left Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftMargin LeftMargin
    {
        get 
        {
            return GetElement<LeftMargin>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> StartMargin.</para>
    /// <para> Represents the following element tag in the schema: w:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartMargin StartMargin
    {
        get 
        {
            return GetElement<StartMargin>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Bottom Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomMargin BottomMargin
    {
        get 
        {
            return GetElement<BottomMargin>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Right Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightMargin RightMargin
    {
        get 
        {
            return GetElement<RightMargin>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> EndMargin.</para>
    /// <para> Represents the following element tag in the schema: w:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndMargin EndMargin
    {
        get 
        {
            return GetElement<EndMargin>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellMargin>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableCellVerticalAlignment Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:vAlign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellVerticalAlignment : OpenXmlLeafElement
{
    private const string tagName = "vAlign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11704;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableVerticalAlignmentValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableVerticalAlignmentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellVerticalAlignment class.
    /// </summary>
    public TableCellVerticalAlignment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableVerticalAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellVerticalAlignment>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DivId Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:divId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DivId : OpenXmlLeafElement
{
    private const string tagName = "divId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11706;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DivId class.
    /// </summary>
    public DivId():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DivId>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableRowHeight Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trHeight.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableRowHeight : OpenXmlLeafElement
{
    private const string tagName = "trHeight";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11711;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","hRule" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Row Height.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Table Row Height Type.</para>
    /// <para>Represents the following attribute in the schema: w:hRule </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hRule")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues> HeightType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableRowHeight class.
    /// </summary>
    public TableRowHeight():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "hRule" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HeightRuleValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableRowHeight>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableJustification Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:jc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableJustification : OpenXmlLeafElement
{
    private const string tagName = "jc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11716;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableRowAlignmentValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableRowAlignmentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableJustification class.
    /// </summary>
    public TableJustification():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableRowAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableJustification>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TablePositionProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblpPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TablePositionProperties : OpenXmlLeafElement
{
    private const string tagName = "tblpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11718;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "leftFromText","rightFromText","topFromText","bottomFromText","vertAnchor","horzAnchor","tblpXSpec","tblpX","tblpYSpec","tblpY" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Distance From Left of Table to Text.</para>
    /// <para>Represents the following attribute in the schema: w:leftFromText </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "leftFromText")]
    public Int16Value LeftFromText
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> (Distance From Right of Table to Text.</para>
    /// <para>Represents the following attribute in the schema: w:rightFromText </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rightFromText")]
    public Int16Value RightFromText
    {
        get { return (Int16Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Distance From Top of Table to Text.</para>
    /// <para>Represents the following attribute in the schema: w:topFromText </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "topFromText")]
    public Int16Value TopFromText
    {
        get { return (Int16Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Distance From Bottom of Table to Text.</para>
    /// <para>Represents the following attribute in the schema: w:bottomFromText </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "bottomFromText")]
    public Int16Value BottomFromText
    {
        get { return (Int16Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Table Vertical Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:vertAnchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vertAnchor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues> VerticalAnchor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Table Horizontal Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:horzAnchor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "horzAnchor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues> HorizontalAnchor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Relative Horizontal Alignment From Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:tblpXSpec </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tblpXSpec")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues> TablePositionXAlignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Absolute Horizontal Distance From Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:tblpX </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tblpX")]
    public Int32Value TablePositionX
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Relative Vertical Alignment from Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:tblpYSpec </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tblpYSpec")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues> TablePositionYAlignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Absolute Vertical Distance From Anchor.</para>
    /// <para>Represents the following attribute in the schema: w:tblpY </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tblpY")]
    public Int32Value TablePositionY
    {
        get { return (Int32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TablePositionProperties class.
    /// </summary>
    public TablePositionProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "leftFromText" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "rightFromText" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "topFromText" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "bottomFromText" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "vertAnchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAnchorValues>();
    
if( 23 == namespaceId && "horzAnchor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAnchorValues>();
    
if( 23 == namespaceId && "tblpXSpec" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.HorizontalAlignmentValues>();
    
if( 23 == namespaceId && "tblpX" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "tblpYSpec" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalAlignmentValues>();
    
if( 23 == namespaceId && "tblpY" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TablePositionProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableOverlap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblOverlap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableOverlap : OpenXmlLeafElement
{
    private const string tagName = "tblOverlap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11719;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Floating Table Overlap Setting.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableOverlapValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableOverlapValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableOverlap class.
    /// </summary>
    public TableOverlap():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableOverlapValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableOverlap>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableStyleRowBandSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblStyleRowBandSize.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleRowBandSize : UnsignedDecimalNumberMax3Type
{
    private const string tagName = "tblStyleRowBandSize";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11721;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleRowBandSize class.
    /// </summary>
    public TableStyleRowBandSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleRowBandSize>(deep);
    }

}
/// <summary>
/// <para>Defines the TableStyleColumnBandSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblStyleColBandSize.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleColumnBandSize : UnsignedDecimalNumberMax3Type
{
    private const string tagName = "tblStyleColBandSize";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11722;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleColumnBandSize class.
    /// </summary>
    public TableStyleColumnBandSize():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleColumnBandSize>(deep);
    }

}
/// <summary>
/// Defines the UnsignedDecimalNumberMax3Type class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class UnsignedDecimalNumberMax3Type : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the UnsignedDecimalNumberMax3Type class.
    /// </summary>
    protected UnsignedDecimalNumberMax3Type(){}
    
    
    
}
/// <summary>
/// <para>Defines the TableIndentation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblInd.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableIndentation : OpenXmlLeafElement
{
    private const string tagName = "tblInd";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11724;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w","type" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> w.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public Int32Value Width
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableIndentation class.
    /// </summary>
    public TableIndentation():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthUnitValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableIndentation>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableBorders Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblBorders.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopBorder &lt;w:top></description></item>
///<item><description>LeftBorder &lt;w:left></description></item>
///<item><description>StartBorder &lt;w:start></description></item>
///<item><description>BottomBorder &lt;w:bottom></description></item>
///<item><description>RightBorder &lt;w:right></description></item>
///<item><description>EndBorder &lt;w:end></description></item>
///<item><description>InsideHorizontalBorder &lt;w:insideH></description></item>
///<item><description>InsideVerticalBorder &lt;w:insideV></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(StartBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(RightBorder))]
    [ChildElementInfo(typeof(EndBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsideHorizontalBorder))]
    [ChildElementInfo(typeof(InsideVerticalBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableBorders : OpenXmlCompositeElement
{
    private const string tagName = "tblBorders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11725;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableBorders class.
    /// </summary>
    public TableBorders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableBorders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableBorders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableBorders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableBorders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 23 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 23 == namespaceId && "start" == name)
    return new StartBorder();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 23 == namespaceId && "right" == name)
    return new RightBorder();
    
if( 23 == namespaceId && "end" == name)
    return new EndBorder();
    
if( 23 == namespaceId && "insideH" == name)
    return new InsideHorizontalBorder();
    
if( 23 == namespaceId && "insideV" == name)
    return new InsideVerticalBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","start","bottom","right","end","insideH","insideV" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Top Border.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Left Border.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> StartBorder.</para>
    /// <para> Represents the following element tag in the schema: w:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartBorder StartBorder
    {
        get 
        {
            return GetElement<StartBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Bottom Border.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Right Border.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> EndBorder.</para>
    /// <para> Represents the following element tag in the schema: w:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndBorder EndBorder
    {
        get 
        {
            return GetElement<EndBorder>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Table Inside Horizontal Edges Border.</para>
    /// <para> Represents the following element tag in the schema: w:insideH </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public InsideHorizontalBorder InsideHorizontalBorder
    {
        get 
        {
            return GetElement<InsideHorizontalBorder>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Table Inside Vertical Edges Border.</para>
    /// <para> Represents the following element tag in the schema: w:insideV </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public InsideVerticalBorder InsideVerticalBorder
    {
        get 
        {
            return GetElement<InsideVerticalBorder>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableBorders>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableLayout Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblLayout.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableLayout : OpenXmlLeafElement
{
    private const string tagName = "tblLayout";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11726;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Layout Setting.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableLayoutValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableLayoutValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableLayout class.
    /// </summary>
    public TableLayout():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableLayoutValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableLayout>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableCellMarginDefault Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblCellMar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopMargin &lt;w:top></description></item>
///<item><description>TableCellLeftMargin &lt;w:left></description></item>
///<item><description>StartMargin &lt;w:start></description></item>
///<item><description>BottomMargin &lt;w:bottom></description></item>
///<item><description>TableCellRightMargin &lt;w:right></description></item>
///<item><description>EndMargin &lt;w:end></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopMargin))]
    [ChildElementInfo(typeof(TableCellLeftMargin))]
    [ChildElementInfo(typeof(StartMargin),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BottomMargin))]
    [ChildElementInfo(typeof(TableCellRightMargin))]
    [ChildElementInfo(typeof(EndMargin),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellMarginDefault : OpenXmlCompositeElement
{
    private const string tagName = "tblCellMar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11727;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellMarginDefault class.
    /// </summary>
    public TableCellMarginDefault():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellMarginDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellMarginDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellMarginDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellMarginDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellMarginDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellMarginDefault(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopMargin();
    
if( 23 == namespaceId && "left" == name)
    return new TableCellLeftMargin();
    
if( 23 == namespaceId && "start" == name)
    return new StartMargin();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomMargin();
    
if( 23 == namespaceId && "right" == name)
    return new TableCellRightMargin();
    
if( 23 == namespaceId && "end" == name)
    return new EndMargin();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","start","bottom","right","end" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Cell Top Margin Default.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopMargin TopMargin
    {
        get 
        {
            return GetElement<TopMargin>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Left Margin Default.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellLeftMargin TableCellLeftMargin
    {
        get 
        {
            return GetElement<TableCellLeftMargin>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> StartMargin.</para>
    /// <para> Represents the following element tag in the schema: w:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartMargin StartMargin
    {
        get 
        {
            return GetElement<StartMargin>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Bottom Margin Default.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomMargin BottomMargin
    {
        get 
        {
            return GetElement<BottomMargin>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Right Margin Default.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellRightMargin TableCellRightMargin
    {
        get 
        {
            return GetElement<TableCellRightMargin>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> EndMargin.</para>
    /// <para> Represents the following element tag in the schema: w:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndMargin EndMargin
    {
        get 
        {
            return GetElement<EndMargin>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellMarginDefault>(deep);
    }

   
}
/// <summary>
/// <para>Footnote and Endnote Numbering Starting Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numStart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingStart : OpenXmlLeafElement
{
    private const string tagName = "numStart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11728;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt16Value Val
    {
        get { return (UInt16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingStart class.
    /// </summary>
    public NumberingStart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingStart>(deep);
    }

   
}
/// <summary>
/// <para>Footnote and Endnote Numbering Restart Location.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numRestart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingRestart : OpenXmlLeafElement
{
    private const string tagName = "numRestart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11729;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Automatic Numbering Restart Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.RestartNumberValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.RestartNumberValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingRestart class.
    /// </summary>
    public NumberingRestart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.RestartNumberValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingRestart>(deep);
    }

   
}
/// <summary>
/// <para>Defines the AltChunk Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:altChunk.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunkProperties &lt;w:altChunkPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunkProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AltChunk : OpenXmlCompositeElement
{
    private const string tagName = "altChunk";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11730;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship to Part.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AltChunk class.
    /// </summary>
    public AltChunk():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AltChunk class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AltChunk(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AltChunk class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AltChunk(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AltChunk class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AltChunk(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunkPr" == name)
    return new AltChunkProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "altChunkPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> External Content Import Properties.</para>
    /// <para> Represents the following element tag in the schema: w:altChunkPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AltChunkProperties AltChunkProperties
    {
        get 
        {
            return GetElement<AltChunkProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AltChunk>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableLook Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblLook.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableLook : OpenXmlLeafElement
{
    private const string tagName = "tblLook";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11731;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","firstRow","lastRow","firstColumn","lastColumn","noHBand","noVBand" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public HexBinaryValue Val
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> firstRow.</para>
    /// <para>Represents the following attribute in the schema: w:firstRow </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstRow")]
    public OnOffValue FirstRow
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> lastRow.</para>
    /// <para>Represents the following attribute in the schema: w:lastRow </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastRow")]
    public OnOffValue LastRow
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> firstColumn.</para>
    /// <para>Represents the following attribute in the schema: w:firstColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "firstColumn")]
    public OnOffValue FirstColumn
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> lastColumn.</para>
    /// <para>Represents the following attribute in the schema: w:lastColumn </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastColumn")]
    public OnOffValue LastColumn
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> noHBand.</para>
    /// <para>Represents the following attribute in the schema: w:noHBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "noHBand")]
    public OnOffValue NoHorizontalBand
    {
        get { return (OnOffValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> noVBand.</para>
    /// <para>Represents the following attribute in the schema: w:noVBand </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "noVBand")]
    public OnOffValue NoVerticalBand
    {
        get { return (OnOffValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableLook class.
    /// </summary>
    public TableLook():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "firstRow" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastRow" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "firstColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "lastColumn" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "noHBand" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "noVBand" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableLook>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FootnoteProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnotePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FootnotePosition &lt;w:pos></description></item>
///<item><description>NumberingFormat &lt;w:numFmt></description></item>
///<item><description>NumberingStart &lt;w:numStart></description></item>
///<item><description>NumberingRestart &lt;w:numRestart></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FootnotePosition))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(NumberingStart))]
    [ChildElementInfo(typeof(NumberingRestart))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteProperties : OpenXmlCompositeElement
{
    private const string tagName = "footnotePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11736;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FootnoteProperties class.
    /// </summary>
    public FootnoteProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FootnoteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FootnoteProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FootnoteProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FootnoteProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pos" == name)
    return new FootnotePosition();
    
if( 23 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 23 == namespaceId && "numStart" == name)
    return new NumberingStart();
    
if( 23 == namespaceId && "numRestart" == name)
    return new NumberingRestart();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos","numFmt","numStart","numRestart" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Footnote Placement.</para>
    /// <para> Represents the following element tag in the schema: w:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FootnotePosition FootnotePosition
    {
        get 
        {
            return GetElement<FootnotePosition>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Footnote Numbering Format.</para>
    /// <para> Represents the following element tag in the schema: w:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Starting Value.</para>
    /// <para> Represents the following element tag in the schema: w:numStart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingStart NumberingStart
    {
        get 
        {
            return GetElement<NumberingStart>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Restart Location.</para>
    /// <para> Represents the following element tag in the schema: w:numRestart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingRestart NumberingRestart
    {
        get 
        {
            return GetElement<NumberingRestart>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the EndnoteProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnotePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EndnotePosition &lt;w:pos></description></item>
///<item><description>NumberingFormat &lt;w:numFmt></description></item>
///<item><description>NumberingStart &lt;w:numStart></description></item>
///<item><description>NumberingRestart &lt;w:numRestart></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EndnotePosition))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(NumberingStart))]
    [ChildElementInfo(typeof(NumberingRestart))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnoteProperties : OpenXmlCompositeElement
{
    private const string tagName = "endnotePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11737;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EndnoteProperties class.
    /// </summary>
    public EndnoteProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EndnoteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndnoteProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EndnoteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndnoteProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EndnoteProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EndnoteProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pos" == name)
    return new EndnotePosition();
    
if( 23 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 23 == namespaceId && "numStart" == name)
    return new NumberingStart();
    
if( 23 == namespaceId && "numRestart" == name)
    return new NumberingRestart();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos","numFmt","numStart","numRestart" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Endnote Placement.</para>
    /// <para> Represents the following element tag in the schema: w:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndnotePosition EndnotePosition
    {
        get 
        {
            return GetElement<EndnotePosition>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Endnote Numbering Format.</para>
    /// <para> Represents the following element tag in the schema: w:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Starting Value.</para>
    /// <para> Represents the following element tag in the schema: w:numStart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingStart NumberingStart
    {
        get 
        {
            return GetElement<NumberingStart>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Restart Location.</para>
    /// <para> Represents the following element tag in the schema: w:numRestart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingRestart NumberingRestart
    {
        get 
        {
            return GetElement<NumberingRestart>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnoteProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SectionType Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:type.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SectionType : OpenXmlLeafElement
{
    private const string tagName = "type";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11738;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Section Type Setting.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.SectionMarkValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.SectionMarkValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SectionType class.
    /// </summary>
    public SectionType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.SectionMarkValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SectionType>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PageSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pgSz.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageSize : OpenXmlLeafElement
{
    private const string tagName = "pgSz";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11739;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w","h","orient","code" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Width.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public UInt32Value Width
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Page Height.</para>
    /// <para>Represents the following attribute in the schema: w:h </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "h")]
    public UInt32Value Height
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Page Orientation.</para>
    /// <para>Represents the following attribute in the schema: w:orient </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "orient")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageOrientationValues> Orient
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageOrientationValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Printer Paper Code.</para>
    /// <para>Represents the following attribute in the schema: w:code </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "code")]
    public UInt16Value Code
    {
        get { return (UInt16Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageSize class.
    /// </summary>
    public PageSize():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "h" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "orient" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageOrientationValues>();
    
if( 23 == namespaceId && "code" == name)
    return new UInt16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageSize>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PageMargin Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pgMar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageMargin : OpenXmlLeafElement
{
    private const string tagName = "pgMar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11740;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "top","right","bottom","left","header","footer","gutter" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Top Margin Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:top </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "top")]
    public Int32Value Top
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Right Margin Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:right </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "right")]
    public UInt32Value Right
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Page Bottom Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:bottom </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "bottom")]
    public Int32Value Bottom
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Left Margin Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:left </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "left")]
    public UInt32Value Left
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Spacing to Top of Header.</para>
    /// <para>Represents the following attribute in the schema: w:header </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "header")]
    public UInt32Value Header
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Spacing to Bottom of Footer.</para>
    /// <para>Represents the following attribute in the schema: w:footer </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "footer")]
    public UInt32Value Footer
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Page Gutter Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:gutter </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "gutter")]
    public UInt32Value Gutter
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageMargin class.
    /// </summary>
    public PageMargin():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "right" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "bottom" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "left" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "header" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "footer" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "gutter" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageMargin>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PaperSource Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:paperSrc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PaperSource : OpenXmlLeafElement
{
    private const string tagName = "paperSrc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11741;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "first","other" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> First Page Printer Tray Code.</para>
    /// <para>Represents the following attribute in the schema: w:first </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "first")]
    public UInt16Value First
    {
        get { return (UInt16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Non-First Page Printer Tray Code.</para>
    /// <para>Represents the following attribute in the schema: w:other </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "other")]
    public UInt16Value Other
    {
        get { return (UInt16Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PaperSource class.
    /// </summary>
    public PaperSource():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "first" == name)
    return new UInt16Value();
    
if( 23 == namespaceId && "other" == name)
    return new UInt16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PaperSource>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PageBorders Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pgBorders.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopBorder &lt;w:top></description></item>
///<item><description>LeftBorder &lt;w:left></description></item>
///<item><description>BottomBorder &lt;w:bottom></description></item>
///<item><description>RightBorder &lt;w:right></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(RightBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageBorders : OpenXmlCompositeElement
{
    private const string tagName = "pgBorders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11742;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "zOrder","display","offsetFrom" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Z-Ordering of Page Border.</para>
    /// <para>Represents the following attribute in the schema: w:zOrder </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "zOrder")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderZOrderValues> ZOrder
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderZOrderValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Pages to Display Page Borders.</para>
    /// <para>Represents the following attribute in the schema: w:display </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "display")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderDisplayValues> Display
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderDisplayValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Page Border Positioning.</para>
    /// <para>Represents the following attribute in the schema: w:offsetFrom </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "offsetFrom")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderOffsetValues> OffsetFrom
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderOffsetValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageBorders class.
    /// </summary>
    public PageBorders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PageBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageBorders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PageBorders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageBorders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PageBorders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PageBorders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 23 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 23 == namespaceId && "right" == name)
    return new RightBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","bottom","right" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Top Border.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Left Border.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Bottom Border.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Right Border.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "zOrder" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderZOrderValues>();
    
if( 23 == namespaceId && "display" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderDisplayValues>();
    
if( 23 == namespaceId && "offsetFrom" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.PageBorderOffsetValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageBorders>(deep);
    }

   
}
/// <summary>
/// <para>Defines the LineNumberType Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lnNumType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LineNumberType : OpenXmlLeafElement
{
    private const string tagName = "lnNumType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11743;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "countBy","start","distance","restart" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Line Number Increments to Display.</para>
    /// <para>Represents the following attribute in the schema: w:countBy </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "countBy")]
    public Int16Value CountBy
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Line Numbering Starting Value.</para>
    /// <para>Represents the following attribute in the schema: w:start </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "start")]
    public Int16Value Start
    {
        get { return (Int16Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Distance Between Text and Line Numbering.</para>
    /// <para>Represents the following attribute in the schema: w:distance </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "distance")]
    public StringValue Distance
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Line Numbering Restart Setting.</para>
    /// <para>Represents the following attribute in the schema: w:restart </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "restart")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineNumberRestartValues> Restart
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineNumberRestartValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LineNumberType class.
    /// </summary>
    public LineNumberType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "countBy" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "start" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "distance" == name)
    return new StringValue();
    
if( 23 == namespaceId && "restart" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.LineNumberRestartValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LineNumberType>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PageNumberType Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pgNumType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageNumberType : OpenXmlLeafElement
{
    private const string tagName = "pgNumType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11744;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fmt","start","chapStyle","chapSep" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Number Format.</para>
    /// <para>Represents the following attribute in the schema: w:fmt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fmt")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues> Format
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Starting Page Number.</para>
    /// <para>Represents the following attribute in the schema: w:start </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "start")]
    public Int32Value Start
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Chapter Heading Style.</para>
    /// <para>Represents the following attribute in the schema: w:chapStyle </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "chapStyle")]
    public ByteValue ChapterStyle
    {
        get { return (ByteValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Chapter Separator Character.</para>
    /// <para>Represents the following attribute in the schema: w:chapSep </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "chapSep")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues> ChapterSeparator
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageNumberType class.
    /// </summary>
    public PageNumberType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fmt" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>();
    
if( 23 == namespaceId && "start" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "chapStyle" == name)
    return new ByteValue();
    
if( 23 == namespaceId && "chapSep" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageNumberType>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Columns Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:cols.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Column &lt;w:col></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Column))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Columns : OpenXmlCompositeElement
{
    private const string tagName = "cols";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11745;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "equalWidth","space","num","sep" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Equal Column Widths.</para>
    /// <para>Represents the following attribute in the schema: w:equalWidth </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "equalWidth")]
    public OnOffValue EqualWidth
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Spacing Between Equal Width Columns.</para>
    /// <para>Represents the following attribute in the schema: w:space </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "space")]
    public StringValue Space
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Number of Equal Width Columns.</para>
    /// <para>Represents the following attribute in the schema: w:num </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "num")]
    public Int16Value ColumnCount
    {
        get { return (Int16Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Draw Line Between Columns.</para>
    /// <para>Represents the following attribute in the schema: w:sep </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "sep")]
    public OnOffValue Separator
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Columns class.
    /// </summary>
    public Columns():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Columns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Columns(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Columns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Columns(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Columns class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Columns(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "col" == name)
    return new Column();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "equalWidth" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "space" == name)
    return new StringValue();
    
if( 23 == namespaceId && "num" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "sep" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Columns>(deep);
    }

   
}
/// <summary>
/// <para>Defines the VerticalTextAlignmentOnPage Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:vAlign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VerticalTextAlignmentOnPage : OpenXmlLeafElement
{
    private const string tagName = "vAlign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11747;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Vertical Alignment Setting.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalJustificationValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalJustificationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VerticalTextAlignmentOnPage class.
    /// </summary>
    public VerticalTextAlignmentOnPage():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.VerticalJustificationValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VerticalTextAlignmentOnPage>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DocGrid Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docGrid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocGrid : OpenXmlLeafElement
{
    private const string tagName = "docGrid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11751;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","linePitch","charSpace" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Document Grid Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocGridValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocGridValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Document Grid Line Pitch.</para>
    /// <para>Represents the following attribute in the schema: w:linePitch </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "linePitch")]
    public Int32Value LinePitch
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Document Grid Character Pitch.</para>
    /// <para>Represents the following attribute in the schema: w:charSpace </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "charSpace")]
    public Int32Value CharacterSpace
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocGrid class.
    /// </summary>
    public DocGrid():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocGridValues>();
    
if( 23 == namespaceId && "linePitch" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "charSpace" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocGrid>(deep);
    }

   
}
/// <summary>
/// <para>Inclusion/Exclusion Data for Data Source.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:recipients.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RecipientData &lt;w:recipientData></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RecipientData))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Recipients : OpenXmlPartRootElement
{
    private const string tagName = "recipients";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11753;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Recipients class.
    /// </summary>
    public Recipients():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Recipients class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Recipients(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Recipients class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Recipients(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Recipients class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Recipients(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "recipientData" == name)
    return new RecipientData();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Recipients>(deep);
    }

   
}
/// <summary>
/// <para>Rich Text Box Content Container.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:txbxContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextBoxContent : OpenXmlCompositeElement
{
    private const string tagName = "txbxContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11754;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TextBoxContent class.
    /// </summary>
    public TextBoxContent():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextBoxContent class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextBoxContent(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextBoxContent class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextBoxContent(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextBoxContent class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextBoxContent(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextBoxContent>(deep);
    }

   
}
/// <summary>
/// <para>Comments Collection. The root element of WordprocessingCommentsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:comments.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Comment &lt;w:comment></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Comment))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Comments : OpenXmlPartRootElement
{
    private const string tagName = "comments";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11755;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Comments constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Comments.</param>
    internal Comments(WordprocessingCommentsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WordprocessingCommentsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WordprocessingCommentsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WordprocessingCommentsPart associated with this element.
    /// </summary>
    public WordprocessingCommentsPart WordprocessingCommentsPart
    {
		get
		{
			return OpenXmlPart as WordprocessingCommentsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Comments class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comments(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Comments class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comments(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Comments class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Comments(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Comments class.
    /// </summary>
    public Comments() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WordprocessingCommentsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WordprocessingCommentsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "comment" == name)
    return new Comment();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Comments>(deep);
    }

}
/// <summary>
/// <para>Document Footnotes. The root element of FootnotesPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnotes.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Footnote &lt;w:footnote></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Footnote))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Footnotes : OpenXmlPartRootElement
{
    private const string tagName = "footnotes";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11756;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Footnotes constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Footnotes.</param>
    internal Footnotes(FootnotesPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the FootnotesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(FootnotesPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the FootnotesPart associated with this element.
    /// </summary>
    public FootnotesPart FootnotesPart
    {
		get
		{
			return OpenXmlPart as FootnotesPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Footnotes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footnotes(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Footnotes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footnotes(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Footnotes class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Footnotes(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Footnotes class.
    /// </summary>
    public Footnotes() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the FootnotesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(FootnotesPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "footnote" == name)
    return new Footnote();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Footnotes>(deep);
    }

}
/// <summary>
/// <para>Document Endnotes. The root element of EndnotesPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnotes.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Endnote &lt;w:endnote></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Endnote))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Endnotes : OpenXmlPartRootElement
{
    private const string tagName = "endnotes";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11757;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Endnotes constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Endnotes.</param>
    internal Endnotes(EndnotesPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the EndnotesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(EndnotesPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the EndnotesPart associated with this element.
    /// </summary>
    public EndnotesPart EndnotesPart
    {
		get
		{
			return OpenXmlPart as EndnotesPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Endnotes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Endnotes(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Endnotes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Endnotes(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Endnotes class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Endnotes(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Endnotes class.
    /// </summary>
    public Endnotes() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the EndnotesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(EndnotesPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "endnote" == name)
    return new Endnote();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Endnotes>(deep);
    }

}
/// <summary>
/// <para>Header. The root element of HeaderPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hdr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Header : OpenXmlPartRootElement
{
    private const string tagName = "hdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11758;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Header constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Header.</param>
    internal Header(HeaderPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the HeaderPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(HeaderPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the HeaderPart associated with this element.
    /// </summary>
    public HeaderPart HeaderPart
    {
		get
		{
			return OpenXmlPart as HeaderPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Header class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Header(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Header class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Header(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Header class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Header(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Header class.
    /// </summary>
    public Header() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the HeaderPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(HeaderPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Header>(deep);
    }

}
/// <summary>
/// <para>Footer. The root element of FooterPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ftr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Footer : OpenXmlPartRootElement
{
    private const string tagName = "ftr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11759;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Footer constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Footer.</param>
    internal Footer(FooterPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the FooterPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(FooterPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the FooterPart associated with this element.
    /// </summary>
    public FooterPart FooterPart
    {
		get
		{
			return OpenXmlPart as FooterPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Footer class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footer(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Footer class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footer(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Footer class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Footer(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Footer class.
    /// </summary>
    public Footer() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the FooterPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(FooterPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Footer>(deep);
    }

}
/// <summary>
/// Defines the HeaderFooterType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class HeaderFooterType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the HeaderFooterType class.
    /// </summary>
    protected HeaderFooterType(){}
    
            /// <summary>
    ///Initializes a new instance of the HeaderFooterType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected HeaderFooterType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderFooterType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected HeaderFooterType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderFooterType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected HeaderFooterType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Document Settings. The root element of DocumentSettingsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:settings.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WriteProtection &lt;w:writeProtection></description></item>
///<item><description>View &lt;w:view></description></item>
///<item><description>Zoom &lt;w:zoom></description></item>
///<item><description>RemovePersonalInformation &lt;w:removePersonalInformation></description></item>
///<item><description>RemoveDateAndTime &lt;w:removeDateAndTime></description></item>
///<item><description>DoNotDisplayPageBoundaries &lt;w:doNotDisplayPageBoundaries></description></item>
///<item><description>DisplayBackgroundShape &lt;w:displayBackgroundShape></description></item>
///<item><description>PrintPostScriptOverText &lt;w:printPostScriptOverText></description></item>
///<item><description>PrintFractionalCharacterWidth &lt;w:printFractionalCharacterWidth></description></item>
///<item><description>PrintFormsData &lt;w:printFormsData></description></item>
///<item><description>EmbedTrueTypeFonts &lt;w:embedTrueTypeFonts></description></item>
///<item><description>EmbedSystemFonts &lt;w:embedSystemFonts></description></item>
///<item><description>SaveSubsetFonts &lt;w:saveSubsetFonts></description></item>
///<item><description>SaveFormsData &lt;w:saveFormsData></description></item>
///<item><description>MirrorMargins &lt;w:mirrorMargins></description></item>
///<item><description>AlignBorderAndEdges &lt;w:alignBordersAndEdges></description></item>
///<item><description>BordersDoNotSurroundHeader &lt;w:bordersDoNotSurroundHeader></description></item>
///<item><description>BordersDoNotSurroundFooter &lt;w:bordersDoNotSurroundFooter></description></item>
///<item><description>GutterAtTop &lt;w:gutterAtTop></description></item>
///<item><description>HideSpellingErrors &lt;w:hideSpellingErrors></description></item>
///<item><description>HideGrammaticalErrors &lt;w:hideGrammaticalErrors></description></item>
///<item><description>ActiveWritingStyle &lt;w:activeWritingStyle></description></item>
///<item><description>ProofState &lt;w:proofState></description></item>
///<item><description>FormsDesign &lt;w:formsDesign></description></item>
///<item><description>AttachedTemplate &lt;w:attachedTemplate></description></item>
///<item><description>LinkStyles &lt;w:linkStyles></description></item>
///<item><description>StylePaneFormatFilter &lt;w:stylePaneFormatFilter></description></item>
///<item><description>StylePaneSortMethods &lt;w:stylePaneSortMethod></description></item>
///<item><description>DocumentType &lt;w:documentType></description></item>
///<item><description>MailMerge &lt;w:mailMerge></description></item>
///<item><description>RevisionView &lt;w:revisionView></description></item>
///<item><description>TrackRevisions &lt;w:trackRevisions></description></item>
///<item><description>DoNotTrackMoves &lt;w:doNotTrackMoves></description></item>
///<item><description>DoNotTrackFormatting &lt;w:doNotTrackFormatting></description></item>
///<item><description>DocumentProtection &lt;w:documentProtection></description></item>
///<item><description>AutoFormatOverride &lt;w:autoFormatOverride></description></item>
///<item><description>StyleLockThemesPart &lt;w:styleLockTheme></description></item>
///<item><description>StyleLockStylesPart &lt;w:styleLockQFSet></description></item>
///<item><description>DefaultTabStop &lt;w:defaultTabStop></description></item>
///<item><description>AutoHyphenation &lt;w:autoHyphenation></description></item>
///<item><description>ConsecutiveHyphenLimit &lt;w:consecutiveHyphenLimit></description></item>
///<item><description>HyphenationZone &lt;w:hyphenationZone></description></item>
///<item><description>DoNotHyphenateCaps &lt;w:doNotHyphenateCaps></description></item>
///<item><description>ShowEnvelope &lt;w:showEnvelope></description></item>
///<item><description>SummaryLength &lt;w:summaryLength></description></item>
///<item><description>ClickAndTypeStyle &lt;w:clickAndTypeStyle></description></item>
///<item><description>DefaultTableStyle &lt;w:defaultTableStyle></description></item>
///<item><description>EvenAndOddHeaders &lt;w:evenAndOddHeaders></description></item>
///<item><description>BookFoldReversePrinting &lt;w:bookFoldRevPrinting></description></item>
///<item><description>BookFoldPrinting &lt;w:bookFoldPrinting></description></item>
///<item><description>BookFoldPrintingSheets &lt;w:bookFoldPrintingSheets></description></item>
///<item><description>DrawingGridHorizontalSpacing &lt;w:drawingGridHorizontalSpacing></description></item>
///<item><description>DrawingGridVerticalSpacing &lt;w:drawingGridVerticalSpacing></description></item>
///<item><description>DisplayHorizontalDrawingGrid &lt;w:displayHorizontalDrawingGridEvery></description></item>
///<item><description>DisplayVerticalDrawingGrid &lt;w:displayVerticalDrawingGridEvery></description></item>
///<item><description>DoNotUseMarginsForDrawingGridOrigin &lt;w:doNotUseMarginsForDrawingGridOrigin></description></item>
///<item><description>DrawingGridHorizontalOrigin &lt;w:drawingGridHorizontalOrigin></description></item>
///<item><description>DrawingGridVerticalOrigin &lt;w:drawingGridVerticalOrigin></description></item>
///<item><description>DoNotShadeFormData &lt;w:doNotShadeFormData></description></item>
///<item><description>NoPunctuationKerning &lt;w:noPunctuationKerning></description></item>
///<item><description>CharacterSpacingControl &lt;w:characterSpacingControl></description></item>
///<item><description>PrintTwoOnOne &lt;w:printTwoOnOne></description></item>
///<item><description>StrictFirstAndLastChars &lt;w:strictFirstAndLastChars></description></item>
///<item><description>NoLineBreaksAfterKinsoku &lt;w:noLineBreaksAfter></description></item>
///<item><description>NoLineBreaksBeforeKinsoku &lt;w:noLineBreaksBefore></description></item>
///<item><description>SavePreviewPicture &lt;w:savePreviewPicture></description></item>
///<item><description>DoNotValidateAgainstSchema &lt;w:doNotValidateAgainstSchema></description></item>
///<item><description>SaveInvalidXml &lt;w:saveInvalidXml></description></item>
///<item><description>IgnoreMixedContent &lt;w:ignoreMixedContent></description></item>
///<item><description>AlwaysShowPlaceholderText &lt;w:alwaysShowPlaceholderText></description></item>
///<item><description>DoNotDemarcateInvalidXml &lt;w:doNotDemarcateInvalidXml></description></item>
///<item><description>SaveXmlDataOnly &lt;w:saveXmlDataOnly></description></item>
///<item><description>UseXsltWhenSaving &lt;w:useXSLTWhenSaving></description></item>
///<item><description>SaveThroughXslt &lt;w:saveThroughXslt></description></item>
///<item><description>ShowXmlTags &lt;w:showXMLTags></description></item>
///<item><description>AlwaysMergeEmptyNamespace &lt;w:alwaysMergeEmptyNamespace></description></item>
///<item><description>UpdateFieldsOnOpen &lt;w:updateFields></description></item>
///<item><description>HeaderShapeDefaults &lt;w:hdrShapeDefaults></description></item>
///<item><description>FootnoteDocumentWideProperties &lt;w:footnotePr></description></item>
///<item><description>EndnoteDocumentWideProperties &lt;w:endnotePr></description></item>
///<item><description>Compatibility &lt;w:compat></description></item>
///<item><description>DocumentVariables &lt;w:docVars></description></item>
///<item><description>Rsids &lt;w:rsids></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathProperties &lt;m:mathPr></description></item>
///<item><description>UICompatibleWith97To2003 &lt;w:uiCompat97To2003></description></item>
///<item><description>AttachedSchema &lt;w:attachedSchema></description></item>
///<item><description>ThemeFontLanguages &lt;w:themeFontLang></description></item>
///<item><description>ColorSchemeMapping &lt;w:clrSchemeMapping></description></item>
///<item><description>DoNotIncludeSubdocsInStats &lt;w:doNotIncludeSubdocsInStats></description></item>
///<item><description>DoNotAutoCompressPictures &lt;w:doNotAutoCompressPictures></description></item>
///<item><description>ForceUpgrade &lt;w:forceUpgrade></description></item>
///<item><description>Captions &lt;w:captions></description></item>
///<item><description>ReadModeInkLockDown &lt;w:readModeInkLockDown></description></item>
///<item><description>DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary &lt;sl:schemaLibrary></description></item>
///<item><description>ShapeDefaults &lt;w:shapeDefaults></description></item>
///<item><description>DecimalSymbol &lt;w:decimalSymbol></description></item>
///<item><description>ListSeparator &lt;w:listSeparator></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DocumentId &lt;w14:docId></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData &lt;w14:discardImageEditingData></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi &lt;w14:defaultImageDpi></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictMode &lt;w14:conflictMode></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased &lt;w15:chartTrackingRefBased></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId &lt;w15:docId></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WriteProtection))]
    [ChildElementInfo(typeof(View))]
    [ChildElementInfo(typeof(Zoom))]
    [ChildElementInfo(typeof(RemovePersonalInformation))]
    [ChildElementInfo(typeof(RemoveDateAndTime))]
    [ChildElementInfo(typeof(DoNotDisplayPageBoundaries))]
    [ChildElementInfo(typeof(DisplayBackgroundShape))]
    [ChildElementInfo(typeof(PrintPostScriptOverText))]
    [ChildElementInfo(typeof(PrintFractionalCharacterWidth))]
    [ChildElementInfo(typeof(PrintFormsData))]
    [ChildElementInfo(typeof(EmbedTrueTypeFonts))]
    [ChildElementInfo(typeof(EmbedSystemFonts))]
    [ChildElementInfo(typeof(SaveSubsetFonts))]
    [ChildElementInfo(typeof(SaveFormsData))]
    [ChildElementInfo(typeof(MirrorMargins))]
    [ChildElementInfo(typeof(AlignBorderAndEdges))]
    [ChildElementInfo(typeof(BordersDoNotSurroundHeader))]
    [ChildElementInfo(typeof(BordersDoNotSurroundFooter))]
    [ChildElementInfo(typeof(GutterAtTop))]
    [ChildElementInfo(typeof(HideSpellingErrors))]
    [ChildElementInfo(typeof(HideGrammaticalErrors))]
    [ChildElementInfo(typeof(ActiveWritingStyle))]
    [ChildElementInfo(typeof(ProofState))]
    [ChildElementInfo(typeof(FormsDesign))]
    [ChildElementInfo(typeof(AttachedTemplate))]
    [ChildElementInfo(typeof(LinkStyles))]
    [ChildElementInfo(typeof(StylePaneFormatFilter))]
    [ChildElementInfo(typeof(StylePaneSortMethods))]
    [ChildElementInfo(typeof(DocumentType))]
    [ChildElementInfo(typeof(MailMerge))]
    [ChildElementInfo(typeof(RevisionView))]
    [ChildElementInfo(typeof(TrackRevisions))]
    [ChildElementInfo(typeof(DoNotTrackMoves))]
    [ChildElementInfo(typeof(DoNotTrackFormatting))]
    [ChildElementInfo(typeof(DocumentProtection))]
    [ChildElementInfo(typeof(AutoFormatOverride))]
    [ChildElementInfo(typeof(StyleLockThemesPart))]
    [ChildElementInfo(typeof(StyleLockStylesPart))]
    [ChildElementInfo(typeof(DefaultTabStop))]
    [ChildElementInfo(typeof(AutoHyphenation))]
    [ChildElementInfo(typeof(ConsecutiveHyphenLimit))]
    [ChildElementInfo(typeof(HyphenationZone))]
    [ChildElementInfo(typeof(DoNotHyphenateCaps))]
    [ChildElementInfo(typeof(ShowEnvelope))]
    [ChildElementInfo(typeof(SummaryLength))]
    [ChildElementInfo(typeof(ClickAndTypeStyle))]
    [ChildElementInfo(typeof(DefaultTableStyle))]
    [ChildElementInfo(typeof(EvenAndOddHeaders))]
    [ChildElementInfo(typeof(BookFoldReversePrinting))]
    [ChildElementInfo(typeof(BookFoldPrinting))]
    [ChildElementInfo(typeof(BookFoldPrintingSheets))]
    [ChildElementInfo(typeof(DrawingGridHorizontalSpacing))]
    [ChildElementInfo(typeof(DrawingGridVerticalSpacing))]
    [ChildElementInfo(typeof(DisplayHorizontalDrawingGrid))]
    [ChildElementInfo(typeof(DisplayVerticalDrawingGrid))]
    [ChildElementInfo(typeof(DoNotUseMarginsForDrawingGridOrigin))]
    [ChildElementInfo(typeof(DrawingGridHorizontalOrigin))]
    [ChildElementInfo(typeof(DrawingGridVerticalOrigin))]
    [ChildElementInfo(typeof(DoNotShadeFormData))]
    [ChildElementInfo(typeof(NoPunctuationKerning))]
    [ChildElementInfo(typeof(CharacterSpacingControl))]
    [ChildElementInfo(typeof(PrintTwoOnOne))]
    [ChildElementInfo(typeof(StrictFirstAndLastChars))]
    [ChildElementInfo(typeof(NoLineBreaksAfterKinsoku))]
    [ChildElementInfo(typeof(NoLineBreaksBeforeKinsoku))]
    [ChildElementInfo(typeof(SavePreviewPicture))]
    [ChildElementInfo(typeof(DoNotValidateAgainstSchema))]
    [ChildElementInfo(typeof(SaveInvalidXml))]
    [ChildElementInfo(typeof(IgnoreMixedContent))]
    [ChildElementInfo(typeof(AlwaysShowPlaceholderText))]
    [ChildElementInfo(typeof(DoNotDemarcateInvalidXml))]
    [ChildElementInfo(typeof(SaveXmlDataOnly))]
    [ChildElementInfo(typeof(UseXsltWhenSaving))]
    [ChildElementInfo(typeof(SaveThroughXslt))]
    [ChildElementInfo(typeof(ShowXmlTags))]
    [ChildElementInfo(typeof(AlwaysMergeEmptyNamespace))]
    [ChildElementInfo(typeof(UpdateFieldsOnOpen))]
    [ChildElementInfo(typeof(HeaderShapeDefaults))]
    [ChildElementInfo(typeof(FootnoteDocumentWideProperties))]
    [ChildElementInfo(typeof(EndnoteDocumentWideProperties))]
    [ChildElementInfo(typeof(Compatibility))]
    [ChildElementInfo(typeof(DocumentVariables))]
    [ChildElementInfo(typeof(Rsids))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathProperties))]
    [ChildElementInfo(typeof(UICompatibleWith97To2003))]
    [ChildElementInfo(typeof(AttachedSchema))]
    [ChildElementInfo(typeof(ThemeFontLanguages))]
    [ChildElementInfo(typeof(ColorSchemeMapping))]
    [ChildElementInfo(typeof(DoNotIncludeSubdocsInStats))]
    [ChildElementInfo(typeof(DoNotAutoCompressPictures))]
    [ChildElementInfo(typeof(ForceUpgrade))]
    [ChildElementInfo(typeof(Captions))]
    [ChildElementInfo(typeof(ReadModeInkLockDown))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary))]
    [ChildElementInfo(typeof(ShapeDefaults))]
    [ChildElementInfo(typeof(DecimalSymbol))]
    [ChildElementInfo(typeof(ListSeparator))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DocumentId),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictMode),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Settings : OpenXmlPartRootElement
{
    private const string tagName = "settings";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11760;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Settings constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Settings.</param>
    internal Settings(DocumentSettingsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the DocumentSettingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(DocumentSettingsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the DocumentSettingsPart associated with this element.
    /// </summary>
    public DocumentSettingsPart DocumentSettingsPart
    {
		get
		{
			return OpenXmlPart as DocumentSettingsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Settings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Settings(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Settings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Settings(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Settings class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Settings(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Settings class.
    /// </summary>
    public Settings() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the DocumentSettingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(DocumentSettingsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "writeProtection" == name)
    return new WriteProtection();
    
if( 23 == namespaceId && "view" == name)
    return new View();
    
if( 23 == namespaceId && "zoom" == name)
    return new Zoom();
    
if( 23 == namespaceId && "removePersonalInformation" == name)
    return new RemovePersonalInformation();
    
if( 23 == namespaceId && "removeDateAndTime" == name)
    return new RemoveDateAndTime();
    
if( 23 == namespaceId && "doNotDisplayPageBoundaries" == name)
    return new DoNotDisplayPageBoundaries();
    
if( 23 == namespaceId && "displayBackgroundShape" == name)
    return new DisplayBackgroundShape();
    
if( 23 == namespaceId && "printPostScriptOverText" == name)
    return new PrintPostScriptOverText();
    
if( 23 == namespaceId && "printFractionalCharacterWidth" == name)
    return new PrintFractionalCharacterWidth();
    
if( 23 == namespaceId && "printFormsData" == name)
    return new PrintFormsData();
    
if( 23 == namespaceId && "embedTrueTypeFonts" == name)
    return new EmbedTrueTypeFonts();
    
if( 23 == namespaceId && "embedSystemFonts" == name)
    return new EmbedSystemFonts();
    
if( 23 == namespaceId && "saveSubsetFonts" == name)
    return new SaveSubsetFonts();
    
if( 23 == namespaceId && "saveFormsData" == name)
    return new SaveFormsData();
    
if( 23 == namespaceId && "mirrorMargins" == name)
    return new MirrorMargins();
    
if( 23 == namespaceId && "alignBordersAndEdges" == name)
    return new AlignBorderAndEdges();
    
if( 23 == namespaceId && "bordersDoNotSurroundHeader" == name)
    return new BordersDoNotSurroundHeader();
    
if( 23 == namespaceId && "bordersDoNotSurroundFooter" == name)
    return new BordersDoNotSurroundFooter();
    
if( 23 == namespaceId && "gutterAtTop" == name)
    return new GutterAtTop();
    
if( 23 == namespaceId && "hideSpellingErrors" == name)
    return new HideSpellingErrors();
    
if( 23 == namespaceId && "hideGrammaticalErrors" == name)
    return new HideGrammaticalErrors();
    
if( 23 == namespaceId && "activeWritingStyle" == name)
    return new ActiveWritingStyle();
    
if( 23 == namespaceId && "proofState" == name)
    return new ProofState();
    
if( 23 == namespaceId && "formsDesign" == name)
    return new FormsDesign();
    
if( 23 == namespaceId && "attachedTemplate" == name)
    return new AttachedTemplate();
    
if( 23 == namespaceId && "linkStyles" == name)
    return new LinkStyles();
    
if( 23 == namespaceId && "stylePaneFormatFilter" == name)
    return new StylePaneFormatFilter();
    
if( 23 == namespaceId && "stylePaneSortMethod" == name)
    return new StylePaneSortMethods();
    
if( 23 == namespaceId && "documentType" == name)
    return new DocumentType();
    
if( 23 == namespaceId && "mailMerge" == name)
    return new MailMerge();
    
if( 23 == namespaceId && "revisionView" == name)
    return new RevisionView();
    
if( 23 == namespaceId && "trackRevisions" == name)
    return new TrackRevisions();
    
if( 23 == namespaceId && "doNotTrackMoves" == name)
    return new DoNotTrackMoves();
    
if( 23 == namespaceId && "doNotTrackFormatting" == name)
    return new DoNotTrackFormatting();
    
if( 23 == namespaceId && "documentProtection" == name)
    return new DocumentProtection();
    
if( 23 == namespaceId && "autoFormatOverride" == name)
    return new AutoFormatOverride();
    
if( 23 == namespaceId && "styleLockTheme" == name)
    return new StyleLockThemesPart();
    
if( 23 == namespaceId && "styleLockQFSet" == name)
    return new StyleLockStylesPart();
    
if( 23 == namespaceId && "defaultTabStop" == name)
    return new DefaultTabStop();
    
if( 23 == namespaceId && "autoHyphenation" == name)
    return new AutoHyphenation();
    
if( 23 == namespaceId && "consecutiveHyphenLimit" == name)
    return new ConsecutiveHyphenLimit();
    
if( 23 == namespaceId && "hyphenationZone" == name)
    return new HyphenationZone();
    
if( 23 == namespaceId && "doNotHyphenateCaps" == name)
    return new DoNotHyphenateCaps();
    
if( 23 == namespaceId && "showEnvelope" == name)
    return new ShowEnvelope();
    
if( 23 == namespaceId && "summaryLength" == name)
    return new SummaryLength();
    
if( 23 == namespaceId && "clickAndTypeStyle" == name)
    return new ClickAndTypeStyle();
    
if( 23 == namespaceId && "defaultTableStyle" == name)
    return new DefaultTableStyle();
    
if( 23 == namespaceId && "evenAndOddHeaders" == name)
    return new EvenAndOddHeaders();
    
if( 23 == namespaceId && "bookFoldRevPrinting" == name)
    return new BookFoldReversePrinting();
    
if( 23 == namespaceId && "bookFoldPrinting" == name)
    return new BookFoldPrinting();
    
if( 23 == namespaceId && "bookFoldPrintingSheets" == name)
    return new BookFoldPrintingSheets();
    
if( 23 == namespaceId && "drawingGridHorizontalSpacing" == name)
    return new DrawingGridHorizontalSpacing();
    
if( 23 == namespaceId && "drawingGridVerticalSpacing" == name)
    return new DrawingGridVerticalSpacing();
    
if( 23 == namespaceId && "displayHorizontalDrawingGridEvery" == name)
    return new DisplayHorizontalDrawingGrid();
    
if( 23 == namespaceId && "displayVerticalDrawingGridEvery" == name)
    return new DisplayVerticalDrawingGrid();
    
if( 23 == namespaceId && "doNotUseMarginsForDrawingGridOrigin" == name)
    return new DoNotUseMarginsForDrawingGridOrigin();
    
if( 23 == namespaceId && "drawingGridHorizontalOrigin" == name)
    return new DrawingGridHorizontalOrigin();
    
if( 23 == namespaceId && "drawingGridVerticalOrigin" == name)
    return new DrawingGridVerticalOrigin();
    
if( 23 == namespaceId && "doNotShadeFormData" == name)
    return new DoNotShadeFormData();
    
if( 23 == namespaceId && "noPunctuationKerning" == name)
    return new NoPunctuationKerning();
    
if( 23 == namespaceId && "characterSpacingControl" == name)
    return new CharacterSpacingControl();
    
if( 23 == namespaceId && "printTwoOnOne" == name)
    return new PrintTwoOnOne();
    
if( 23 == namespaceId && "strictFirstAndLastChars" == name)
    return new StrictFirstAndLastChars();
    
if( 23 == namespaceId && "noLineBreaksAfter" == name)
    return new NoLineBreaksAfterKinsoku();
    
if( 23 == namespaceId && "noLineBreaksBefore" == name)
    return new NoLineBreaksBeforeKinsoku();
    
if( 23 == namespaceId && "savePreviewPicture" == name)
    return new SavePreviewPicture();
    
if( 23 == namespaceId && "doNotValidateAgainstSchema" == name)
    return new DoNotValidateAgainstSchema();
    
if( 23 == namespaceId && "saveInvalidXml" == name)
    return new SaveInvalidXml();
    
if( 23 == namespaceId && "ignoreMixedContent" == name)
    return new IgnoreMixedContent();
    
if( 23 == namespaceId && "alwaysShowPlaceholderText" == name)
    return new AlwaysShowPlaceholderText();
    
if( 23 == namespaceId && "doNotDemarcateInvalidXml" == name)
    return new DoNotDemarcateInvalidXml();
    
if( 23 == namespaceId && "saveXmlDataOnly" == name)
    return new SaveXmlDataOnly();
    
if( 23 == namespaceId && "useXSLTWhenSaving" == name)
    return new UseXsltWhenSaving();
    
if( 23 == namespaceId && "saveThroughXslt" == name)
    return new SaveThroughXslt();
    
if( 23 == namespaceId && "showXMLTags" == name)
    return new ShowXmlTags();
    
if( 23 == namespaceId && "alwaysMergeEmptyNamespace" == name)
    return new AlwaysMergeEmptyNamespace();
    
if( 23 == namespaceId && "updateFields" == name)
    return new UpdateFieldsOnOpen();
    
if( 23 == namespaceId && "hdrShapeDefaults" == name)
    return new HeaderShapeDefaults();
    
if( 23 == namespaceId && "footnotePr" == name)
    return new FootnoteDocumentWideProperties();
    
if( 23 == namespaceId && "endnotePr" == name)
    return new EndnoteDocumentWideProperties();
    
if( 23 == namespaceId && "compat" == name)
    return new Compatibility();
    
if( 23 == namespaceId && "docVars" == name)
    return new DocumentVariables();
    
if( 23 == namespaceId && "rsids" == name)
    return new Rsids();
    
if( 21 == namespaceId && "mathPr" == name)
    return new DocumentFormat.OpenXml.Math.MathProperties();
    
if( 23 == namespaceId && "uiCompat97To2003" == name)
    return new UICompatibleWith97To2003();
    
if( 23 == namespaceId && "attachedSchema" == name)
    return new AttachedSchema();
    
if( 23 == namespaceId && "themeFontLang" == name)
    return new ThemeFontLanguages();
    
if( 23 == namespaceId && "clrSchemeMapping" == name)
    return new ColorSchemeMapping();
    
if( 23 == namespaceId && "doNotIncludeSubdocsInStats" == name)
    return new DoNotIncludeSubdocsInStats();
    
if( 23 == namespaceId && "doNotAutoCompressPictures" == name)
    return new DoNotAutoCompressPictures();
    
if( 23 == namespaceId && "forceUpgrade" == name)
    return new ForceUpgrade();
    
if( 23 == namespaceId && "captions" == name)
    return new Captions();
    
if( 23 == namespaceId && "readModeInkLockDown" == name)
    return new ReadModeInkLockDown();
    
if( 25 == namespaceId && "schemaLibrary" == name)
    return new DocumentFormat.OpenXml.CustomXmlSchemaReferences.SchemaLibrary();
    
if( 23 == namespaceId && "shapeDefaults" == name)
    return new ShapeDefaults();
    
if( 23 == namespaceId && "decimalSymbol" == name)
    return new DecimalSymbol();
    
if( 23 == namespaceId && "listSeparator" == name)
    return new ListSeparator();
    
if( 52 == namespaceId && "docId" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DocumentId();
    
if( 52 == namespaceId && "discardImageEditingData" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DiscardImageEditingData();
    
if( 52 == namespaceId && "defaultImageDpi" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.DefaultImageDpi();
    
if( 52 == namespaceId && "conflictMode" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictMode();
    
if( 69 == namespaceId && "chartTrackingRefBased" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.ChartTrackingRefBased();
    
if( 69 == namespaceId && "docId" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.PersistentDocumentId();
    

    return null;
}

        private static readonly string[] eleTagNames = { "writeProtection","view","zoom","removePersonalInformation","removeDateAndTime","doNotDisplayPageBoundaries","displayBackgroundShape","printPostScriptOverText","printFractionalCharacterWidth","printFormsData","embedTrueTypeFonts","embedSystemFonts","saveSubsetFonts","saveFormsData","mirrorMargins","alignBordersAndEdges","bordersDoNotSurroundHeader","bordersDoNotSurroundFooter","gutterAtTop","hideSpellingErrors","hideGrammaticalErrors","activeWritingStyle","proofState","formsDesign","attachedTemplate","linkStyles","stylePaneFormatFilter","stylePaneSortMethod","documentType","mailMerge","revisionView","trackRevisions","doNotTrackMoves","doNotTrackFormatting","documentProtection","autoFormatOverride","styleLockTheme","styleLockQFSet","defaultTabStop","autoHyphenation","consecutiveHyphenLimit","hyphenationZone","doNotHyphenateCaps","showEnvelope","summaryLength","clickAndTypeStyle","defaultTableStyle","evenAndOddHeaders","bookFoldRevPrinting","bookFoldPrinting","bookFoldPrintingSheets","drawingGridHorizontalSpacing","drawingGridVerticalSpacing","displayHorizontalDrawingGridEvery","displayVerticalDrawingGridEvery","doNotUseMarginsForDrawingGridOrigin","drawingGridHorizontalOrigin","drawingGridVerticalOrigin","doNotShadeFormData","noPunctuationKerning","characterSpacingControl","printTwoOnOne","strictFirstAndLastChars","noLineBreaksAfter","noLineBreaksBefore","savePreviewPicture","doNotValidateAgainstSchema","saveInvalidXml","ignoreMixedContent","alwaysShowPlaceholderText","doNotDemarcateInvalidXml","saveXmlDataOnly","useXSLTWhenSaving","saveThroughXslt","showXMLTags","alwaysMergeEmptyNamespace","updateFields","hdrShapeDefaults","footnotePr","endnotePr","compat","docVars","rsids","mathPr","uiCompat97To2003","attachedSchema","themeFontLang","clrSchemeMapping","doNotIncludeSubdocsInStats","doNotAutoCompressPictures","forceUpgrade","captions","readModeInkLockDown","schemaLibrary","shapeDefaults","decimalSymbol","listSeparator","docId","discardImageEditingData","defaultImageDpi","conflictMode","chartTrackingRefBased","docId" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,21,23,23,23,23,23,23,23,23,23,25,23,23,23,52,52,52,52,69,69 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Write Protection.</para>
    /// <para> Represents the following element tag in the schema: w:writeProtection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WriteProtection WriteProtection
    {
        get 
        {
            return GetElement<WriteProtection>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Document View Setting.</para>
    /// <para> Represents the following element tag in the schema: w:view </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public View View
    {
        get 
        {
            return GetElement<View>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Magnification Setting.</para>
    /// <para> Represents the following element tag in the schema: w:zoom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Zoom Zoom
    {
        get 
        {
            return GetElement<Zoom>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Remove Personal Information from Document Properties.</para>
    /// <para> Represents the following element tag in the schema: w:removePersonalInformation </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RemovePersonalInformation RemovePersonalInformation
    {
        get 
        {
            return GetElement<RemovePersonalInformation>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Remove Date and Time from Annotations.</para>
    /// <para> Represents the following element tag in the schema: w:removeDateAndTime </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RemoveDateAndTime RemoveDateAndTime
    {
        get 
        {
            return GetElement<RemoveDateAndTime>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Do Not Display Visual Boundary For Header/Footer or Between Pages.</para>
    /// <para> Represents the following element tag in the schema: w:doNotDisplayPageBoundaries </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotDisplayPageBoundaries DoNotDisplayPageBoundaries
    {
        get 
        {
            return GetElement<DoNotDisplayPageBoundaries>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Display Background Objects When Displaying Document.</para>
    /// <para> Represents the following element tag in the schema: w:displayBackgroundShape </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DisplayBackgroundShape DisplayBackgroundShape
    {
        get 
        {
            return GetElement<DisplayBackgroundShape>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Print PostScript Codes With Document Text.</para>
    /// <para> Represents the following element tag in the schema: w:printPostScriptOverText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrintPostScriptOverText PrintPostScriptOverText
    {
        get 
        {
            return GetElement<PrintPostScriptOverText>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Print Fractional Character Widths.</para>
    /// <para> Represents the following element tag in the schema: w:printFractionalCharacterWidth </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrintFractionalCharacterWidth PrintFractionalCharacterWidth
    {
        get 
        {
            return GetElement<PrintFractionalCharacterWidth>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Only Print Form Field Content.</para>
    /// <para> Represents the following element tag in the schema: w:printFormsData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrintFormsData PrintFormsData
    {
        get 
        {
            return GetElement<PrintFormsData>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Embed TrueType Fonts.</para>
    /// <para> Represents the following element tag in the schema: w:embedTrueTypeFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedTrueTypeFonts EmbedTrueTypeFonts
    {
        get 
        {
            return GetElement<EmbedTrueTypeFonts>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Embed Common System Fonts.</para>
    /// <para> Represents the following element tag in the schema: w:embedSystemFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedSystemFonts EmbedSystemFonts
    {
        get 
        {
            return GetElement<EmbedSystemFonts>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Subset Fonts When Embedding.</para>
    /// <para> Represents the following element tag in the schema: w:saveSubsetFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SaveSubsetFonts SaveSubsetFonts
    {
        get 
        {
            return GetElement<SaveSubsetFonts>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Only Save Form Field Content.</para>
    /// <para> Represents the following element tag in the schema: w:saveFormsData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SaveFormsData SaveFormsData
    {
        get 
        {
            return GetElement<SaveFormsData>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> Mirror Page Margins.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorMargins </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorMargins MirrorMargins
    {
        get 
        {
            return GetElement<MirrorMargins>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Align Paragraph and Table Borders with Page Border.</para>
    /// <para> Represents the following element tag in the schema: w:alignBordersAndEdges </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AlignBorderAndEdges AlignBorderAndEdges
    {
        get 
        {
            return GetElement<AlignBorderAndEdges>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> Page Border Excludes Header.</para>
    /// <para> Represents the following element tag in the schema: w:bordersDoNotSurroundHeader </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BordersDoNotSurroundHeader BordersDoNotSurroundHeader
    {
        get 
        {
            return GetElement<BordersDoNotSurroundHeader>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Page Border Excludes Footer.</para>
    /// <para> Represents the following element tag in the schema: w:bordersDoNotSurroundFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BordersDoNotSurroundFooter BordersDoNotSurroundFooter
    {
        get 
        {
            return GetElement<BordersDoNotSurroundFooter>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Position Gutter At Top of Page.</para>
    /// <para> Represents the following element tag in the schema: w:gutterAtTop </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public GutterAtTop GutterAtTop
    {
        get 
        {
            return GetElement<GutterAtTop>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> Do Not Display Visual Indication of Spelling Errors.</para>
    /// <para> Represents the following element tag in the schema: w:hideSpellingErrors </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HideSpellingErrors HideSpellingErrors
    {
        get 
        {
            return GetElement<HideSpellingErrors>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Do Not Display Visual Indication of Grammatical Errors.</para>
    /// <para> Represents the following element tag in the schema: w:hideGrammaticalErrors </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HideGrammaticalErrors HideGrammaticalErrors
    {
        get 
        {
            return GetElement<HideGrammaticalErrors>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Settings>(deep);
    }

}
/// <summary>
/// <para>Web Page Settings. The root element of WebSettingsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:webSettings.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Frameset &lt;w:frameset></description></item>
///<item><description>Divs &lt;w:divs></description></item>
///<item><description>WebPageEncoding &lt;w:encoding></description></item>
///<item><description>OptimizeForBrowser &lt;w:optimizeForBrowser></description></item>
///<item><description>RelyOnVML &lt;w:relyOnVML></description></item>
///<item><description>AllowPNG &lt;w:allowPNG></description></item>
///<item><description>DoNotRelyOnCSS &lt;w:doNotRelyOnCSS></description></item>
///<item><description>DoNotSaveAsSingleFile &lt;w:doNotSaveAsSingleFile></description></item>
///<item><description>DoNotOrganizeInFolder &lt;w:doNotOrganizeInFolder></description></item>
///<item><description>DoNotUseLongFileNames &lt;w:doNotUseLongFileNames></description></item>
///<item><description>PixelsPerInch &lt;w:pixelsPerInch></description></item>
///<item><description>TargetScreenSize &lt;w:targetScreenSz></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Frameset))]
    [ChildElementInfo(typeof(Divs))]
    [ChildElementInfo(typeof(WebPageEncoding))]
    [ChildElementInfo(typeof(OptimizeForBrowser))]
    [ChildElementInfo(typeof(RelyOnVML))]
    [ChildElementInfo(typeof(AllowPNG))]
    [ChildElementInfo(typeof(DoNotRelyOnCSS))]
    [ChildElementInfo(typeof(DoNotSaveAsSingleFile))]
    [ChildElementInfo(typeof(DoNotOrganizeInFolder))]
    [ChildElementInfo(typeof(DoNotUseLongFileNames))]
    [ChildElementInfo(typeof(PixelsPerInch))]
    [ChildElementInfo(typeof(TargetScreenSize))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebSettings : OpenXmlPartRootElement
{
    private const string tagName = "webSettings";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11761;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// WebSettings constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the WebSettings.</param>
    internal WebSettings(WebSettingsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WebSettingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WebSettingsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WebSettingsPart associated with this element.
    /// </summary>
    public WebSettingsPart WebSettingsPart
    {
		get
		{
			return OpenXmlPart as WebSettingsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the WebSettings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebSettings(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WebSettings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebSettings(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WebSettings class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WebSettings(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the WebSettings class.
    /// </summary>
    public WebSettings() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WebSettingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WebSettingsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "frameset" == name)
    return new Frameset();
    
if( 23 == namespaceId && "divs" == name)
    return new Divs();
    
if( 23 == namespaceId && "encoding" == name)
    return new WebPageEncoding();
    
if( 23 == namespaceId && "optimizeForBrowser" == name)
    return new OptimizeForBrowser();
    
if( 23 == namespaceId && "relyOnVML" == name)
    return new RelyOnVML();
    
if( 23 == namespaceId && "allowPNG" == name)
    return new AllowPNG();
    
if( 23 == namespaceId && "doNotRelyOnCSS" == name)
    return new DoNotRelyOnCSS();
    
if( 23 == namespaceId && "doNotSaveAsSingleFile" == name)
    return new DoNotSaveAsSingleFile();
    
if( 23 == namespaceId && "doNotOrganizeInFolder" == name)
    return new DoNotOrganizeInFolder();
    
if( 23 == namespaceId && "doNotUseLongFileNames" == name)
    return new DoNotUseLongFileNames();
    
if( 23 == namespaceId && "pixelsPerInch" == name)
    return new PixelsPerInch();
    
if( 23 == namespaceId && "targetScreenSz" == name)
    return new TargetScreenSize();
    

    return null;
}

        private static readonly string[] eleTagNames = { "frameset","divs","encoding","optimizeForBrowser","relyOnVML","allowPNG","doNotRelyOnCSS","doNotSaveAsSingleFile","doNotOrganizeInFolder","doNotUseLongFileNames","pixelsPerInch","targetScreenSz" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Frameset.</para>
    /// <para> Represents the following element tag in the schema: w:frameset </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Frameset Frameset
    {
        get 
        {
            return GetElement<Frameset>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Divs.</para>
    /// <para> Represents the following element tag in the schema: w:divs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Divs Divs
    {
        get 
        {
            return GetElement<Divs>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> WebPageEncoding.</para>
    /// <para> Represents the following element tag in the schema: w:encoding </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WebPageEncoding WebPageEncoding
    {
        get 
        {
            return GetElement<WebPageEncoding>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> OptimizeForBrowser.</para>
    /// <para> Represents the following element tag in the schema: w:optimizeForBrowser </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OptimizeForBrowser OptimizeForBrowser
    {
        get 
        {
            return GetElement<OptimizeForBrowser>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> RelyOnVML.</para>
    /// <para> Represents the following element tag in the schema: w:relyOnVML </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RelyOnVML RelyOnVML
    {
        get 
        {
            return GetElement<RelyOnVML>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> AllowPNG.</para>
    /// <para> Represents the following element tag in the schema: w:allowPNG </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AllowPNG AllowPNG
    {
        get 
        {
            return GetElement<AllowPNG>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> DoNotRelyOnCSS.</para>
    /// <para> Represents the following element tag in the schema: w:doNotRelyOnCSS </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotRelyOnCSS DoNotRelyOnCSS
    {
        get 
        {
            return GetElement<DoNotRelyOnCSS>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> DoNotSaveAsSingleFile.</para>
    /// <para> Represents the following element tag in the schema: w:doNotSaveAsSingleFile </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotSaveAsSingleFile DoNotSaveAsSingleFile
    {
        get 
        {
            return GetElement<DoNotSaveAsSingleFile>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> DoNotOrganizeInFolder.</para>
    /// <para> Represents the following element tag in the schema: w:doNotOrganizeInFolder </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotOrganizeInFolder DoNotOrganizeInFolder
    {
        get 
        {
            return GetElement<DoNotOrganizeInFolder>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> DoNotUseLongFileNames.</para>
    /// <para> Represents the following element tag in the schema: w:doNotUseLongFileNames </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotUseLongFileNames DoNotUseLongFileNames
    {
        get 
        {
            return GetElement<DoNotUseLongFileNames>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> PixelsPerInch.</para>
    /// <para> Represents the following element tag in the schema: w:pixelsPerInch </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PixelsPerInch PixelsPerInch
    {
        get 
        {
            return GetElement<PixelsPerInch>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> TargetScreenSize.</para>
    /// <para> Represents the following element tag in the schema: w:targetScreenSz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TargetScreenSize TargetScreenSize
    {
        get 
        {
            return GetElement<TargetScreenSize>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebSettings>(deep);
    }

}
/// <summary>
/// <para>Font Table Root Element. The root element of FontTablePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fonts.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;w:font></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Font))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fonts : OpenXmlPartRootElement
{
    private const string tagName = "fonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11762;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Fonts constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Fonts.</param>
    internal Fonts(FontTablePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the FontTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(FontTablePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the FontTablePart associated with this element.
    /// </summary>
    public FontTablePart FontTablePart
    {
		get
		{
			return OpenXmlPart as FontTablePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fonts(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Fonts class.
    /// </summary>
    public Fonts() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the FontTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(FontTablePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "font" == name)
    return new Font();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fonts>(deep);
    }

}
/// <summary>
/// <para>Numbering Definitions. The root element of NumberingDefinitionsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numbering.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NumberingPictureBullet &lt;w:numPicBullet></description></item>
///<item><description>AbstractNum &lt;w:abstractNum></description></item>
///<item><description>NumberingInstance &lt;w:num></description></item>
///<item><description>NumberingIdMacAtCleanup &lt;w:numIdMacAtCleanup></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NumberingPictureBullet))]
    [ChildElementInfo(typeof(AbstractNum))]
    [ChildElementInfo(typeof(NumberingInstance))]
    [ChildElementInfo(typeof(NumberingIdMacAtCleanup))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Numbering : OpenXmlPartRootElement
{
    private const string tagName = "numbering";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11763;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Numbering constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Numbering.</param>
    internal Numbering(NumberingDefinitionsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the NumberingDefinitionsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(NumberingDefinitionsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the NumberingDefinitionsPart associated with this element.
    /// </summary>
    public NumberingDefinitionsPart NumberingDefinitionsPart
    {
		get
		{
			return OpenXmlPart as NumberingDefinitionsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Numbering class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Numbering(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Numbering class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Numbering(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Numbering class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Numbering(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Numbering class.
    /// </summary>
    public Numbering() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the NumberingDefinitionsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(NumberingDefinitionsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "numPicBullet" == name)
    return new NumberingPictureBullet();
    
if( 23 == namespaceId && "abstractNum" == name)
    return new AbstractNum();
    
if( 23 == namespaceId && "num" == name)
    return new NumberingInstance();
    
if( 23 == namespaceId && "numIdMacAtCleanup" == name)
    return new NumberingIdMacAtCleanup();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Numbering>(deep);
    }

}
/// <summary>
/// <para>Style Definitions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:styles.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocDefaults &lt;w:docDefaults></description></item>
///<item><description>LatentStyles &lt;w:latentStyles></description></item>
///<item><description>Style &lt;w:style></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocDefaults))]
    [ChildElementInfo(typeof(LatentStyles))]
    [ChildElementInfo(typeof(Style))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Styles : OpenXmlPartRootElement
{
    private const string tagName = "styles";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11764;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Styles class.
    /// </summary>
    public Styles():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Styles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Styles(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Styles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Styles(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Styles class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Styles(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docDefaults" == name)
    return new DocDefaults();
    
if( 23 == namespaceId && "latentStyles" == name)
    return new LatentStyles();
    
if( 23 == namespaceId && "style" == name)
    return new Style();
    

    return null;
}

        private static readonly string[] eleTagNames = { "docDefaults","latentStyles","style" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Document Default Paragraph and Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:docDefaults </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocDefaults DocDefaults
    {
        get 
        {
            return GetElement<DocDefaults>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Latent Style Information.</para>
    /// <para> Represents the following element tag in the schema: w:latentStyles </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LatentStyles LatentStyles
    {
        get 
        {
            return GetElement<LatentStyles>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Styles>(deep);
    }

   
}
/// <summary>
/// <para>Document. The root element of MainDocumentPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:document.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentBackground &lt;w:background></description></item>
///<item><description>Body &lt;w:body></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentBackground))]
    [ChildElementInfo(typeof(Body))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Document : OpenXmlPartRootElement
{
    private const string tagName = "document";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11765;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "conformance" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> conformance.</para>
    /// <para>Represents the following attribute in the schema: w:conformance </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "conformance")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentConformance> Conformance
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentConformance>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// Document constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Document.</param>
    internal Document(MainDocumentPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the MainDocumentPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(MainDocumentPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the MainDocumentPart associated with this element.
    /// </summary>
    public MainDocumentPart MainDocumentPart
    {
		get
		{
			return OpenXmlPart as MainDocumentPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Document class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Document(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Document class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Document(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Document class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Document(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Document class.
    /// </summary>
    public Document() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the MainDocumentPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(MainDocumentPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "background" == name)
    return new DocumentBackground();
    
if( 23 == namespaceId && "body" == name)
    return new Body();
    

    return null;
}

        private static readonly string[] eleTagNames = { "background","body" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Document Background.</para>
    /// <para> Represents the following element tag in the schema: w:background </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocumentBackground DocumentBackground
    {
        get 
        {
            return GetElement<DocumentBackground>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Body.</para>
    /// <para> Represents the following element tag in the schema: w:body </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Body Body
    {
        get 
        {
            return GetElement<Body>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "conformance" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentConformance>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Document>(deep);
    }

}
/// <summary>
/// <para>Glossary Document Root Element. The root element of GlossaryDocumentPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:glossaryDocument.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentBackground &lt;w:background></description></item>
///<item><description>DocParts &lt;w:docParts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentBackground))]
    [ChildElementInfo(typeof(DocParts))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GlossaryDocument : OpenXmlPartRootElement
{
    private const string tagName = "glossaryDocument";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11766;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// GlossaryDocument constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the GlossaryDocument.</param>
    internal GlossaryDocument(GlossaryDocumentPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the GlossaryDocumentPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(GlossaryDocumentPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the GlossaryDocumentPart associated with this element.
    /// </summary>
    public GlossaryDocumentPart GlossaryDocumentPart
    {
		get
		{
			return OpenXmlPart as GlossaryDocumentPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the GlossaryDocument class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GlossaryDocument(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GlossaryDocument class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GlossaryDocument(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GlossaryDocument class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GlossaryDocument(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the GlossaryDocument class.
    /// </summary>
    public GlossaryDocument() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the GlossaryDocumentPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(GlossaryDocumentPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "background" == name)
    return new DocumentBackground();
    
if( 23 == namespaceId && "docParts" == name)
    return new DocParts();
    

    return null;
}

        private static readonly string[] eleTagNames = { "background","docParts" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Document Background.</para>
    /// <para> Represents the following element tag in the schema: w:background </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocumentBackground DocumentBackground
    {
        get 
        {
            return GetElement<DocumentBackground>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> List of Glossary Document Entries.</para>
    /// <para> Represents the following element tag in the schema: w:docParts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocParts DocParts
    {
        get 
        {
            return GetElement<DocParts>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GlossaryDocument>(deep);
    }

}
/// <summary>
/// <para>Previous Table-Level Property Exceptions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPrEx.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableWidth &lt;w:tblW></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableLayout &lt;w:tblLayout></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
///<item><description>TableLook &lt;w:tblLook></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableWidth))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableLayout))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
    [ChildElementInfo(typeof(TableLook))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousTablePropertyExceptions : OpenXmlCompositeElement
{
    private const string tagName = "tblPrEx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11767;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousTablePropertyExceptions class.
    /// </summary>
    public PreviousTablePropertyExceptions():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousTablePropertyExceptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTablePropertyExceptions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTablePropertyExceptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTablePropertyExceptions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTablePropertyExceptions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousTablePropertyExceptions(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblW" == name)
    return new TableWidth();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblLayout" == name)
    return new TableLayout();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    
if( 23 == namespaceId && "tblLook" == name)
    return new TableLook();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblW","jc","tblCellSpacing","tblInd","tblBorders","shd","tblLayout","tblCellMar","tblLook" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Preferred Table Width Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableWidth TableWidth
    {
        get 
        {
            return GetElement<TableWidth>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Alignment Exception.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Spacing Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Indent from Leading Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Borders Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Table Shading Exception.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Table Layout Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLayout TableLayout
    {
        get 
        {
            return GetElement<TableLayout>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Margin Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Settings Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblLook </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLook TableLook
    {
        get 
        {
            return GetElement<TableLook>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousTablePropertyExceptions>(deep);
    }

   
}
/// <summary>
/// <para>Previous Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
///<item><description>TableCellWidth &lt;w:tcW></description></item>
///<item><description>GridSpan &lt;w:gridSpan></description></item>
///<item><description>HorizontalMerge &lt;w:hMerge></description></item>
///<item><description>VerticalMerge &lt;w:vMerge></description></item>
///<item><description>TableCellBorders &lt;w:tcBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>NoWrap &lt;w:noWrap></description></item>
///<item><description>TableCellMargin &lt;w:tcMar></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TableCellFitText &lt;w:tcFitText></description></item>
///<item><description>TableCellVerticalAlignment &lt;w:vAlign></description></item>
///<item><description>HideMark &lt;w:hideMark></description></item>
///<item><description>CellInsertion &lt;w:cellIns></description></item>
///<item><description>CellDeletion &lt;w:cellDel></description></item>
///<item><description>CellMerge &lt;w:cellMerge></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
    [ChildElementInfo(typeof(TableCellWidth))]
    [ChildElementInfo(typeof(GridSpan))]
    [ChildElementInfo(typeof(HorizontalMerge))]
    [ChildElementInfo(typeof(VerticalMerge))]
    [ChildElementInfo(typeof(TableCellBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(NoWrap))]
    [ChildElementInfo(typeof(TableCellMargin))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TableCellFitText))]
    [ChildElementInfo(typeof(TableCellVerticalAlignment))]
    [ChildElementInfo(typeof(HideMark))]
    [ChildElementInfo(typeof(CellInsertion))]
    [ChildElementInfo(typeof(CellDeletion))]
    [ChildElementInfo(typeof(CellMerge))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousTableCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "tcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11768;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableCellProperties class.
    /// </summary>
    public PreviousTableCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousTableCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    
if( 23 == namespaceId && "tcW" == name)
    return new TableCellWidth();
    
if( 23 == namespaceId && "gridSpan" == name)
    return new GridSpan();
    
if( 23 == namespaceId && "hMerge" == name)
    return new HorizontalMerge();
    
if( 23 == namespaceId && "vMerge" == name)
    return new VerticalMerge();
    
if( 23 == namespaceId && "tcBorders" == name)
    return new TableCellBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "noWrap" == name)
    return new NoWrap();
    
if( 23 == namespaceId && "tcMar" == name)
    return new TableCellMargin();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "tcFitText" == name)
    return new TableCellFitText();
    
if( 23 == namespaceId && "vAlign" == name)
    return new TableCellVerticalAlignment();
    
if( 23 == namespaceId && "hideMark" == name)
    return new HideMark();
    
if( 23 == namespaceId && "cellIns" == name)
    return new CellInsertion();
    
if( 23 == namespaceId && "cellDel" == name)
    return new CellDeletion();
    
if( 23 == namespaceId && "cellMerge" == name)
    return new CellMerge();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cnfStyle","tcW","gridSpan","hMerge","vMerge","tcBorders","shd","noWrap","tcMar","textDirection","tcFitText","vAlign","hideMark","cellIns","cellDel","cellMerge" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ConditionalFormatStyle.</para>
    /// <para> Represents the following element tag in the schema: w:cnfStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConditionalFormatStyle ConditionalFormatStyle
    {
        get 
        {
            return GetElement<ConditionalFormatStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TableCellWidth.</para>
    /// <para> Represents the following element tag in the schema: w:tcW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellWidth TableCellWidth
    {
        get 
        {
            return GetElement<TableCellWidth>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GridSpan.</para>
    /// <para> Represents the following element tag in the schema: w:gridSpan </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public GridSpan GridSpan
    {
        get 
        {
            return GetElement<GridSpan>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> HorizontalMerge.</para>
    /// <para> Represents the following element tag in the schema: w:hMerge </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HorizontalMerge HorizontalMerge
    {
        get 
        {
            return GetElement<HorizontalMerge>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> VerticalMerge.</para>
    /// <para> Represents the following element tag in the schema: w:vMerge </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalMerge VerticalMerge
    {
        get 
        {
            return GetElement<VerticalMerge>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableCellBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tcBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellBorders TableCellBorders
    {
        get 
        {
            return GetElement<TableCellBorders>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> NoWrap.</para>
    /// <para> Represents the following element tag in the schema: w:noWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoWrap NoWrap
    {
        get 
        {
            return GetElement<NoWrap>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> TableCellMargin.</para>
    /// <para> Represents the following element tag in the schema: w:tcMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMargin TableCellMargin
    {
        get 
        {
            return GetElement<TableCellMargin>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> TableCellFitText.</para>
    /// <para> Represents the following element tag in the schema: w:tcFitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellFitText TableCellFitText
    {
        get 
        {
            return GetElement<TableCellFitText>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> TableCellVerticalAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellVerticalAlignment TableCellVerticalAlignment
    {
        get 
        {
            return GetElement<TableCellVerticalAlignment>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> HideMark.</para>
    /// <para> Represents the following element tag in the schema: w:hideMark </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HideMark HideMark
    {
        get 
        {
            return GetElement<HideMark>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousTableCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Previous Table Row Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
///<item><description>DivId &lt;w:divId></description></item>
///<item><description>GridBefore &lt;w:gridBefore></description></item>
///<item><description>GridAfter &lt;w:gridAfter></description></item>
///<item><description>WidthBeforeTableRow &lt;w:wBefore></description></item>
///<item><description>WidthAfterTableRow &lt;w:wAfter></description></item>
///<item><description>TableRowHeight &lt;w:trHeight></description></item>
///<item><description>Hidden &lt;w:hidden></description></item>
///<item><description>CantSplit &lt;w:cantSplit></description></item>
///<item><description>TableHeader &lt;w:tblHeader></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
    [ChildElementInfo(typeof(DivId))]
    [ChildElementInfo(typeof(GridBefore))]
    [ChildElementInfo(typeof(GridAfter))]
    [ChildElementInfo(typeof(WidthBeforeTableRow))]
    [ChildElementInfo(typeof(WidthAfterTableRow))]
    [ChildElementInfo(typeof(TableRowHeight))]
    [ChildElementInfo(typeof(Hidden))]
    [ChildElementInfo(typeof(CantSplit))]
    [ChildElementInfo(typeof(TableHeader))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableJustification))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousTableRowProperties : OpenXmlCompositeElement
{
    private const string tagName = "trPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11769;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableRowProperties class.
    /// </summary>
    public PreviousTableRowProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousTableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableRowProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableRowProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableRowProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousTableRowProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    
if( 23 == namespaceId && "divId" == name)
    return new DivId();
    
if( 23 == namespaceId && "gridBefore" == name)
    return new GridBefore();
    
if( 23 == namespaceId && "gridAfter" == name)
    return new GridAfter();
    
if( 23 == namespaceId && "wBefore" == name)
    return new WidthBeforeTableRow();
    
if( 23 == namespaceId && "wAfter" == name)
    return new WidthAfterTableRow();
    
if( 23 == namespaceId && "trHeight" == name)
    return new TableRowHeight();
    
if( 23 == namespaceId && "hidden" == name)
    return new Hidden();
    
if( 23 == namespaceId && "cantSplit" == name)
    return new CantSplit();
    
if( 23 == namespaceId && "tblHeader" == name)
    return new TableHeader();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousTableRowProperties>(deep);
    }

   
}
/// <summary>
/// <para>Previous Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyle &lt;w:tblStyle></description></item>
///<item><description>TablePositionProperties &lt;w:tblpPr></description></item>
///<item><description>TableOverlap &lt;w:tblOverlap></description></item>
///<item><description>BiDiVisual &lt;w:bidiVisual></description></item>
///<item><description>TableWidth &lt;w:tblW></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableLayout &lt;w:tblLayout></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
///<item><description>TableLook &lt;w:tblLook></description></item>
///<item><description>TableCaption &lt;w:tblCaption></description></item>
///<item><description>TableDescription &lt;w:tblDescription></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyle))]
    [ChildElementInfo(typeof(TablePositionProperties))]
    [ChildElementInfo(typeof(TableOverlap))]
    [ChildElementInfo(typeof(BiDiVisual))]
    [ChildElementInfo(typeof(TableWidth))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableLayout))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
    [ChildElementInfo(typeof(TableLook))]
    [ChildElementInfo(typeof(TableCaption),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(TableDescription),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousTableProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11770;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableProperties class.
    /// </summary>
    public PreviousTableProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousTableProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblStyle" == name)
    return new TableStyle();
    
if( 23 == namespaceId && "tblpPr" == name)
    return new TablePositionProperties();
    
if( 23 == namespaceId && "tblOverlap" == name)
    return new TableOverlap();
    
if( 23 == namespaceId && "bidiVisual" == name)
    return new BiDiVisual();
    
if( 23 == namespaceId && "tblW" == name)
    return new TableWidth();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblLayout" == name)
    return new TableLayout();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    
if( 23 == namespaceId && "tblLook" == name)
    return new TableLook();
    
if( 23 == namespaceId && "tblCaption" == name)
    return new TableCaption();
    
if( 23 == namespaceId && "tblDescription" == name)
    return new TableDescription();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblStyle","tblpPr","tblOverlap","bidiVisual","tblW","jc","tblCellSpacing","tblInd","tblBorders","shd","tblLayout","tblCellMar","tblLook","tblCaption","tblDescription" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TableStyle.</para>
    /// <para> Represents the following element tag in the schema: w:tblStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyle TableStyle
    {
        get 
        {
            return GetElement<TableStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TablePositionProperties.</para>
    /// <para> Represents the following element tag in the schema: w:tblpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TablePositionProperties TablePositionProperties
    {
        get 
        {
            return GetElement<TablePositionProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> TableOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:tblOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableOverlap TableOverlap
    {
        get 
        {
            return GetElement<TableOverlap>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BiDiVisual.</para>
    /// <para> Represents the following element tag in the schema: w:bidiVisual </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDiVisual BiDiVisual
    {
        get 
        {
            return GetElement<BiDiVisual>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> TableWidth.</para>
    /// <para> Represents the following element tag in the schema: w:tblW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableWidth TableWidth
    {
        get 
        {
            return GetElement<TableWidth>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableJustification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> TableCellSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> TableIndentation.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> TableBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> TableLayout.</para>
    /// <para> Represents the following element tag in the schema: w:tblLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLayout TableLayout
    {
        get 
        {
            return GetElement<TableLayout>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> TableCellMarginDefault.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> TableLook.</para>
    /// <para> Represents the following element tag in the schema: w:tblLook </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLook TableLook
    {
        get 
        {
            return GetElement<TableLook>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> TableCaption.</para>
    /// <para> Represents the following element tag in the schema: w:tblCaption </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCaption TableCaption
    {
        get 
        {
            return GetElement<TableCaption>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> TableDescription.</para>
    /// <para> Represents the following element tag in the schema: w:tblDescription </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableDescription TableDescription
    {
        get 
        {
            return GetElement<TableDescription>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousTableProperties>(deep);
    }

   
}
/// <summary>
/// <para>Previous Section Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sectPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FootnoteProperties &lt;w:footnotePr></description></item>
///<item><description>EndnoteProperties &lt;w:endnotePr></description></item>
///<item><description>SectionType &lt;w:type></description></item>
///<item><description>PageSize &lt;w:pgSz></description></item>
///<item><description>PageMargin &lt;w:pgMar></description></item>
///<item><description>PaperSource &lt;w:paperSrc></description></item>
///<item><description>PageBorders &lt;w:pgBorders></description></item>
///<item><description>LineNumberType &lt;w:lnNumType></description></item>
///<item><description>PageNumberType &lt;w:pgNumType></description></item>
///<item><description>Columns &lt;w:cols></description></item>
///<item><description>FormProtection &lt;w:formProt></description></item>
///<item><description>VerticalTextAlignmentOnPage &lt;w:vAlign></description></item>
///<item><description>NoEndnote &lt;w:noEndnote></description></item>
///<item><description>TitlePage &lt;w:titlePg></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>GutterOnRight &lt;w:rtlGutter></description></item>
///<item><description>DocGrid &lt;w:docGrid></description></item>
///<item><description>PrinterSettingsReference &lt;w:printerSettings></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns &lt;w15:footnoteColumns></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FootnoteProperties))]
    [ChildElementInfo(typeof(EndnoteProperties))]
    [ChildElementInfo(typeof(SectionType))]
    [ChildElementInfo(typeof(PageSize))]
    [ChildElementInfo(typeof(PageMargin))]
    [ChildElementInfo(typeof(PaperSource))]
    [ChildElementInfo(typeof(PageBorders))]
    [ChildElementInfo(typeof(LineNumberType))]
    [ChildElementInfo(typeof(PageNumberType))]
    [ChildElementInfo(typeof(Columns))]
    [ChildElementInfo(typeof(FormProtection))]
    [ChildElementInfo(typeof(VerticalTextAlignmentOnPage))]
    [ChildElementInfo(typeof(NoEndnote))]
    [ChildElementInfo(typeof(TitlePage))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(GutterOnRight))]
    [ChildElementInfo(typeof(DocGrid))]
    [ChildElementInfo(typeof(PrinterSettingsReference))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousSectionProperties : OpenXmlCompositeElement
{
    private const string tagName = "sectPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11771;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rsidRPr","rsidDel","rsidR","rsidSect" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Physical Section Mark Character Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRPr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRPr")]
    public HexBinaryValue RsidRPr
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Section Deletion Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidDel")]
    public HexBinaryValue RsidDel
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Section Addition Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidR </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidR")]
    public HexBinaryValue RsidR
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Section Properties Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidSect </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidSect")]
    public HexBinaryValue RsidSect
    {
        get { return (HexBinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PreviousSectionProperties class.
    /// </summary>
    public PreviousSectionProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousSectionProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousSectionProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousSectionProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousSectionProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousSectionProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousSectionProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "footnotePr" == name)
    return new FootnoteProperties();
    
if( 23 == namespaceId && "endnotePr" == name)
    return new EndnoteProperties();
    
if( 23 == namespaceId && "type" == name)
    return new SectionType();
    
if( 23 == namespaceId && "pgSz" == name)
    return new PageSize();
    
if( 23 == namespaceId && "pgMar" == name)
    return new PageMargin();
    
if( 23 == namespaceId && "paperSrc" == name)
    return new PaperSource();
    
if( 23 == namespaceId && "pgBorders" == name)
    return new PageBorders();
    
if( 23 == namespaceId && "lnNumType" == name)
    return new LineNumberType();
    
if( 23 == namespaceId && "pgNumType" == name)
    return new PageNumberType();
    
if( 23 == namespaceId && "cols" == name)
    return new Columns();
    
if( 23 == namespaceId && "formProt" == name)
    return new FormProtection();
    
if( 23 == namespaceId && "vAlign" == name)
    return new VerticalTextAlignmentOnPage();
    
if( 23 == namespaceId && "noEndnote" == name)
    return new NoEndnote();
    
if( 23 == namespaceId && "titlePg" == name)
    return new TitlePage();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "rtlGutter" == name)
    return new GutterOnRight();
    
if( 23 == namespaceId && "docGrid" == name)
    return new DocGrid();
    
if( 23 == namespaceId && "printerSettings" == name)
    return new PrinterSettingsReference();
    
if( 69 == namespaceId && "footnoteColumns" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns();
    

    return null;
}

        private static readonly string[] eleTagNames = { "footnotePr","endnotePr","type","pgSz","pgMar","paperSrc","pgBorders","lnNumType","pgNumType","cols","formProt","vAlign","noEndnote","titlePg","textDirection","bidi","rtlGutter","docGrid","printerSettings","footnoteColumns" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,69 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> FootnoteProperties.</para>
    /// <para> Represents the following element tag in the schema: w:footnotePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FootnoteProperties FootnoteProperties
    {
        get 
        {
            return GetElement<FootnoteProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> EndnoteProperties.</para>
    /// <para> Represents the following element tag in the schema: w:endnotePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndnoteProperties EndnoteProperties
    {
        get 
        {
            return GetElement<EndnoteProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> SectionType.</para>
    /// <para> Represents the following element tag in the schema: w:type </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SectionType SectionType
    {
        get 
        {
            return GetElement<SectionType>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> PageSize.</para>
    /// <para> Represents the following element tag in the schema: w:pgSz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageSize PageSize
    {
        get 
        {
            return GetElement<PageSize>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> PageMargin.</para>
    /// <para> Represents the following element tag in the schema: w:pgMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageMargin PageMargin
    {
        get 
        {
            return GetElement<PageMargin>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> PaperSource.</para>
    /// <para> Represents the following element tag in the schema: w:paperSrc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PaperSource PaperSource
    {
        get 
        {
            return GetElement<PaperSource>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> PageBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pgBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBorders PageBorders
    {
        get 
        {
            return GetElement<PageBorders>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> LineNumberType.</para>
    /// <para> Represents the following element tag in the schema: w:lnNumType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LineNumberType LineNumberType
    {
        get 
        {
            return GetElement<LineNumberType>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> PageNumberType.</para>
    /// <para> Represents the following element tag in the schema: w:pgNumType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageNumberType PageNumberType
    {
        get 
        {
            return GetElement<PageNumberType>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Columns.</para>
    /// <para> Represents the following element tag in the schema: w:cols </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Columns Columns
    {
        get 
        {
            return GetElement<Columns>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> FormProtection.</para>
    /// <para> Represents the following element tag in the schema: w:formProt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FormProtection FormProtection
    {
        get 
        {
            return GetElement<FormProtection>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> VerticalTextAlignmentOnPage.</para>
    /// <para> Represents the following element tag in the schema: w:vAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalTextAlignmentOnPage VerticalTextAlignmentOnPage
    {
        get 
        {
            return GetElement<VerticalTextAlignmentOnPage>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> NoEndnote.</para>
    /// <para> Represents the following element tag in the schema: w:noEndnote </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoEndnote NoEndnote
    {
        get 
        {
            return GetElement<NoEndnote>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> TitlePage.</para>
    /// <para> Represents the following element tag in the schema: w:titlePg </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TitlePage TitlePage
    {
        get 
        {
            return GetElement<TitlePage>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> GutterOnRight.</para>
    /// <para> Represents the following element tag in the schema: w:rtlGutter </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public GutterOnRight GutterOnRight
    {
        get 
        {
            return GetElement<GutterOnRight>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> DocGrid.</para>
    /// <para> Represents the following element tag in the schema: w:docGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocGrid DocGrid
    {
        get 
        {
            return GetElement<DocGrid>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> PrinterSettingsReference.</para>
    /// <para> Represents the following element tag in the schema: w:printerSettings </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrinterSettingsReference PrinterSettingsReference
    {
        get 
        {
            return GetElement<PrinterSettingsReference>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> FootnoteColumns.</para>
    /// <para> Represents the following element tag in the schema: w15:footnoteColumns </para>
    /// </summary>
    /// <remark>
    /// xmlns:w15 = http://schemas.microsoft.com/office/word/2012/wordml
    /// </remark>
    public DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns FootnoteColumns
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRPr" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidDel" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidR" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidSect" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousSectionProperties>(deep);
    }

   
}
/// <summary>
/// <para>Previous Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphStyleId &lt;w:pStyle></description></item>
///<item><description>KeepNext &lt;w:keepNext></description></item>
///<item><description>KeepLines &lt;w:keepLines></description></item>
///<item><description>PageBreakBefore &lt;w:pageBreakBefore></description></item>
///<item><description>FrameProperties &lt;w:framePr></description></item>
///<item><description>WidowControl &lt;w:widowControl></description></item>
///<item><description>NumberingProperties &lt;w:numPr></description></item>
///<item><description>SuppressLineNumbers &lt;w:suppressLineNumbers></description></item>
///<item><description>ParagraphBorders &lt;w:pBdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>Tabs &lt;w:tabs></description></item>
///<item><description>SuppressAutoHyphens &lt;w:suppressAutoHyphens></description></item>
///<item><description>Kinsoku &lt;w:kinsoku></description></item>
///<item><description>WordWrap &lt;w:wordWrap></description></item>
///<item><description>OverflowPunctuation &lt;w:overflowPunct></description></item>
///<item><description>TopLinePunctuation &lt;w:topLinePunct></description></item>
///<item><description>AutoSpaceDE &lt;w:autoSpaceDE></description></item>
///<item><description>AutoSpaceDN &lt;w:autoSpaceDN></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>AdjustRightIndent &lt;w:adjustRightInd></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>SpacingBetweenLines &lt;w:spacing></description></item>
///<item><description>Indentation &lt;w:ind></description></item>
///<item><description>ContextualSpacing &lt;w:contextualSpacing></description></item>
///<item><description>MirrorIndents &lt;w:mirrorIndents></description></item>
///<item><description>SuppressOverlap &lt;w:suppressOverlap></description></item>
///<item><description>Justification &lt;w:jc></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TextAlignment &lt;w:textAlignment></description></item>
///<item><description>TextBoxTightWrap &lt;w:textboxTightWrap></description></item>
///<item><description>OutlineLevel &lt;w:outlineLvl></description></item>
///<item><description>DivId &lt;w:divId></description></item>
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphStyleId))]
    [ChildElementInfo(typeof(KeepNext))]
    [ChildElementInfo(typeof(KeepLines))]
    [ChildElementInfo(typeof(PageBreakBefore))]
    [ChildElementInfo(typeof(FrameProperties))]
    [ChildElementInfo(typeof(WidowControl))]
    [ChildElementInfo(typeof(NumberingProperties))]
    [ChildElementInfo(typeof(SuppressLineNumbers))]
    [ChildElementInfo(typeof(ParagraphBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(Tabs))]
    [ChildElementInfo(typeof(SuppressAutoHyphens))]
    [ChildElementInfo(typeof(Kinsoku))]
    [ChildElementInfo(typeof(WordWrap))]
    [ChildElementInfo(typeof(OverflowPunctuation))]
    [ChildElementInfo(typeof(TopLinePunctuation))]
    [ChildElementInfo(typeof(AutoSpaceDE))]
    [ChildElementInfo(typeof(AutoSpaceDN))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(AdjustRightIndent))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(SpacingBetweenLines))]
    [ChildElementInfo(typeof(Indentation))]
    [ChildElementInfo(typeof(ContextualSpacing))]
    [ChildElementInfo(typeof(MirrorIndents))]
    [ChildElementInfo(typeof(SuppressOverlap))]
    [ChildElementInfo(typeof(Justification))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TextAlignment))]
    [ChildElementInfo(typeof(TextBoxTightWrap))]
    [ChildElementInfo(typeof(OutlineLevel))]
    [ChildElementInfo(typeof(DivId))]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphPropertiesExtended : OpenXmlCompositeElement
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11772;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesExtended class.
    /// </summary>
    public ParagraphPropertiesExtended():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphPropertiesExtended class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesExtended(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesExtended class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesExtended(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesExtended class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphPropertiesExtended(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pStyle" == name)
    return new ParagraphStyleId();
    
if( 23 == namespaceId && "keepNext" == name)
    return new KeepNext();
    
if( 23 == namespaceId && "keepLines" == name)
    return new KeepLines();
    
if( 23 == namespaceId && "pageBreakBefore" == name)
    return new PageBreakBefore();
    
if( 23 == namespaceId && "framePr" == name)
    return new FrameProperties();
    
if( 23 == namespaceId && "widowControl" == name)
    return new WidowControl();
    
if( 23 == namespaceId && "numPr" == name)
    return new NumberingProperties();
    
if( 23 == namespaceId && "suppressLineNumbers" == name)
    return new SuppressLineNumbers();
    
if( 23 == namespaceId && "pBdr" == name)
    return new ParagraphBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tabs" == name)
    return new Tabs();
    
if( 23 == namespaceId && "suppressAutoHyphens" == name)
    return new SuppressAutoHyphens();
    
if( 23 == namespaceId && "kinsoku" == name)
    return new Kinsoku();
    
if( 23 == namespaceId && "wordWrap" == name)
    return new WordWrap();
    
if( 23 == namespaceId && "overflowPunct" == name)
    return new OverflowPunctuation();
    
if( 23 == namespaceId && "topLinePunct" == name)
    return new TopLinePunctuation();
    
if( 23 == namespaceId && "autoSpaceDE" == name)
    return new AutoSpaceDE();
    
if( 23 == namespaceId && "autoSpaceDN" == name)
    return new AutoSpaceDN();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "adjustRightInd" == name)
    return new AdjustRightIndent();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "spacing" == name)
    return new SpacingBetweenLines();
    
if( 23 == namespaceId && "ind" == name)
    return new Indentation();
    
if( 23 == namespaceId && "contextualSpacing" == name)
    return new ContextualSpacing();
    
if( 23 == namespaceId && "mirrorIndents" == name)
    return new MirrorIndents();
    
if( 23 == namespaceId && "suppressOverlap" == name)
    return new SuppressOverlap();
    
if( 23 == namespaceId && "jc" == name)
    return new Justification();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "textAlignment" == name)
    return new TextAlignment();
    
if( 23 == namespaceId && "textboxTightWrap" == name)
    return new TextBoxTightWrap();
    
if( 23 == namespaceId && "outlineLvl" == name)
    return new OutlineLevel();
    
if( 23 == namespaceId && "divId" == name)
    return new DivId();
    
if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pStyle","keepNext","keepLines","pageBreakBefore","framePr","widowControl","numPr","suppressLineNumbers","pBdr","shd","tabs","suppressAutoHyphens","kinsoku","wordWrap","overflowPunct","topLinePunct","autoSpaceDE","autoSpaceDN","bidi","adjustRightInd","snapToGrid","spacing","ind","contextualSpacing","mirrorIndents","suppressOverlap","jc","textDirection","textAlignment","textboxTightWrap","outlineLvl","divId","cnfStyle" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ParagraphStyleId.</para>
    /// <para> Represents the following element tag in the schema: w:pStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphStyleId ParagraphStyleId
    {
        get 
        {
            return GetElement<ParagraphStyleId>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> KeepNext.</para>
    /// <para> Represents the following element tag in the schema: w:keepNext </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepNext KeepNext
    {
        get 
        {
            return GetElement<KeepNext>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> KeepLines.</para>
    /// <para> Represents the following element tag in the schema: w:keepLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepLines KeepLines
    {
        get 
        {
            return GetElement<KeepLines>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> PageBreakBefore.</para>
    /// <para> Represents the following element tag in the schema: w:pageBreakBefore </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBreakBefore PageBreakBefore
    {
        get 
        {
            return GetElement<PageBreakBefore>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> FrameProperties.</para>
    /// <para> Represents the following element tag in the schema: w:framePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameProperties FrameProperties
    {
        get 
        {
            return GetElement<FrameProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> WidowControl.</para>
    /// <para> Represents the following element tag in the schema: w:widowControl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WidowControl WidowControl
    {
        get 
        {
            return GetElement<WidowControl>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> NumberingProperties.</para>
    /// <para> Represents the following element tag in the schema: w:numPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingProperties NumberingProperties
    {
        get 
        {
            return GetElement<NumberingProperties>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> SuppressLineNumbers.</para>
    /// <para> Represents the following element tag in the schema: w:suppressLineNumbers </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressLineNumbers SuppressLineNumbers
    {
        get 
        {
            return GetElement<SuppressLineNumbers>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ParagraphBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphBorders ParagraphBorders
    {
        get 
        {
            return GetElement<ParagraphBorders>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Tabs.</para>
    /// <para> Represents the following element tag in the schema: w:tabs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Tabs Tabs
    {
        get 
        {
            return GetElement<Tabs>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> SuppressAutoHyphens.</para>
    /// <para> Represents the following element tag in the schema: w:suppressAutoHyphens </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressAutoHyphens SuppressAutoHyphens
    {
        get 
        {
            return GetElement<SuppressAutoHyphens>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Kinsoku.</para>
    /// <para> Represents the following element tag in the schema: w:kinsoku </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kinsoku Kinsoku
    {
        get 
        {
            return GetElement<Kinsoku>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> WordWrap.</para>
    /// <para> Represents the following element tag in the schema: w:wordWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordWrap WordWrap
    {
        get 
        {
            return GetElement<WordWrap>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> OverflowPunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:overflowPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OverflowPunctuation OverflowPunctuation
    {
        get 
        {
            return GetElement<OverflowPunctuation>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> TopLinePunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:topLinePunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLinePunctuation TopLinePunctuation
    {
        get 
        {
            return GetElement<TopLinePunctuation>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDE.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDE </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDE AutoSpaceDE
    {
        get 
        {
            return GetElement<AutoSpaceDE>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDN.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDN </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDN AutoSpaceDN
    {
        get 
        {
            return GetElement<AutoSpaceDN>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> AdjustRightIndent.</para>
    /// <para> Represents the following element tag in the schema: w:adjustRightInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustRightIndent AdjustRightIndent
    {
        get 
        {
            return GetElement<AdjustRightIndent>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> SpacingBetweenLines.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingBetweenLines SpacingBetweenLines
    {
        get 
        {
            return GetElement<SpacingBetweenLines>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:ind </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Indentation Indentation
    {
        get 
        {
            return GetElement<Indentation>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> ContextualSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:contextualSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ContextualSpacing ContextualSpacing
    {
        get 
        {
            return GetElement<ContextualSpacing>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> MirrorIndents.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorIndents </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorIndents MirrorIndents
    {
        get 
        {
            return GetElement<MirrorIndents>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> SuppressOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:suppressOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressOverlap SuppressOverlap
    {
        get 
        {
            return GetElement<SuppressOverlap>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Justification Justification
    {
        get 
        {
            return GetElement<Justification>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> TextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:textAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextAlignment TextAlignment
    {
        get 
        {
            return GetElement<TextAlignment>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> TextBoxTightWrap.</para>
    /// <para> Represents the following element tag in the schema: w:textboxTightWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxTightWrap TextBoxTightWrap
    {
        get 
        {
            return GetElement<TextBoxTightWrap>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> OutlineLevel.</para>
    /// <para> Represents the following element tag in the schema: w:outlineLvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OutlineLevel OutlineLevel
    {
        get 
        {
            return GetElement<OutlineLevel>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> DivId.</para>
    /// <para> Represents the following element tag in the schema: w:divId </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DivId DivId
    {
        get 
        {
            return GetElement<DivId>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> ConditionalFormatStyle.</para>
    /// <para> Represents the following element tag in the schema: w:cnfStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConditionalFormatStyle ConditionalFormatStyle
    {
        get 
        {
            return GetElement<ConditionalFormatStyle>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphPropertiesExtended>(deep);
    }

   
}
/// <summary>
/// <para>Previous Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunStyle &lt;w:rStyle></description></item>
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Highlight &lt;w:highlight></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>RightToLeftText &lt;w:rtl></description></item>
///<item><description>ComplexScript &lt;w:cs></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Glow &lt;w14:glow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Shadow &lt;w14:shadow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Reflection &lt;w14:reflection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect &lt;w14:textOutline></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.FillTextEffect &lt;w14:textFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Scene3D &lt;w14:scene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Properties3D &lt;w14:props3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Ligatures &lt;w14:ligatures></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberingFormat &lt;w14:numForm></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberSpacing &lt;w14:numSpacing></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.StylisticSets &lt;w14:stylisticSets></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives &lt;w14:cntxtAlts></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunStyle))]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Highlight))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(RightToLeftText))]
    [ChildElementInfo(typeof(ComplexScript))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Glow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Shadow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Reflection),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.FillTextEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Scene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Properties3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Ligatures),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberingFormat),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberSpacing),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.StylisticSets),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousRunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11773;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousRunProperties class.
    /// </summary>
    public PreviousRunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousRunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rStyle" == name)
    return new RunStyle();
    
if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "highlight" == name)
    return new Highlight();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "rtl" == name)
    return new RightToLeftText();
    
if( 23 == namespaceId && "cs" == name)
    return new ComplexScript();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    
if( 52 == namespaceId && "glow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Glow();
    
if( 52 == namespaceId && "shadow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Shadow();
    
if( 52 == namespaceId && "reflection" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Reflection();
    
if( 52 == namespaceId && "textOutline" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect();
    
if( 52 == namespaceId && "textFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.FillTextEffect();
    
if( 52 == namespaceId && "scene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Scene3D();
    
if( 52 == namespaceId && "props3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Properties3D();
    
if( 52 == namespaceId && "ligatures" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Ligatures();
    
if( 52 == namespaceId && "numForm" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberingFormat();
    
if( 52 == namespaceId && "numSpacing" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberSpacing();
    
if( 52 == namespaceId && "stylisticSets" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.StylisticSets();
    
if( 52 == namespaceId && "cntxtAlts" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousRunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Previous Run Properties for the Paragraph Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Inserted &lt;w:ins></description></item>
///<item><description>Deleted &lt;w:del></description></item>
///<item><description>MoveFrom &lt;w:moveFrom></description></item>
///<item><description>MoveTo &lt;w:moveTo></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>RunStyle &lt;w:rStyle></description></item>
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Highlight &lt;w:highlight></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>RightToLeftText &lt;w:rtl></description></item>
///<item><description>ComplexScript &lt;w:cs></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Glow &lt;w14:glow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Shadow &lt;w14:shadow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Reflection &lt;w14:reflection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect &lt;w14:textOutline></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.FillTextEffect &lt;w14:textFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Scene3D &lt;w14:scene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Properties3D &lt;w14:props3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Ligatures &lt;w14:ligatures></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberingFormat &lt;w14:numForm></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberSpacing &lt;w14:numSpacing></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.StylisticSets &lt;w14:stylisticSets></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives &lt;w14:cntxtAlts></description></item>
///<item><description>OfficeMath &lt;w:oMath></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Inserted))]
    [ChildElementInfo(typeof(Deleted))]
    [ChildElementInfo(typeof(MoveFrom))]
    [ChildElementInfo(typeof(MoveTo))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(RunStyle))]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Highlight))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(RightToLeftText))]
    [ChildElementInfo(typeof(ComplexScript))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Glow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Shadow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Reflection),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.FillTextEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Scene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Properties3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Ligatures),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberingFormat),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberSpacing),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.StylisticSets),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(OfficeMath))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousParagraphMarkRunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11774;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphMarkRunProperties class.
    /// </summary>
    public PreviousParagraphMarkRunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousParagraphMarkRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousParagraphMarkRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphMarkRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousParagraphMarkRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphMarkRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousParagraphMarkRunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "ins" == name)
    return new Inserted();
    
if( 23 == namespaceId && "del" == name)
    return new Deleted();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFrom();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveTo();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion();
    
if( 23 == namespaceId && "rStyle" == name)
    return new RunStyle();
    
if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "highlight" == name)
    return new Highlight();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "rtl" == name)
    return new RightToLeftText();
    
if( 23 == namespaceId && "cs" == name)
    return new ComplexScript();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    
if( 52 == namespaceId && "glow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Glow();
    
if( 52 == namespaceId && "shadow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Shadow();
    
if( 52 == namespaceId && "reflection" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Reflection();
    
if( 52 == namespaceId && "textOutline" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect();
    
if( 52 == namespaceId && "textFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.FillTextEffect();
    
if( 52 == namespaceId && "scene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Scene3D();
    
if( 52 == namespaceId && "props3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Properties3D();
    
if( 52 == namespaceId && "ligatures" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Ligatures();
    
if( 52 == namespaceId && "numForm" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberingFormat();
    
if( 52 == namespaceId && "numSpacing" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberSpacing();
    
if( 52 == namespaceId && "stylisticSets" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.StylisticSets();
    
if( 52 == namespaceId && "cntxtAlts" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives();
    
if( 23 == namespaceId && "oMath" == name)
    return new OfficeMath();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ins","del","moveFrom","moveTo","conflictIns","conflictDel","rStyle","rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","highlight","u","effect","bdr","shd","fitText","vertAlign","rtl","cs","em","lang","eastAsianLayout","specVanish","glow","shadow","reflection","textOutline","textFill","scene3d","props3d","ligatures","numForm","numSpacing","stylisticSets","cntxtAlts","oMath" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,52,52,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,52,52,52,52,52,52,52,52,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Inserted Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:ins </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Inserted Inserted
    {
        get 
        {
            return GetElement<Inserted>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Deleted Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:del </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Deleted Deleted
    {
        get 
        {
            return GetElement<Deleted>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Move Source Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:moveFrom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MoveFrom MoveFrom
    {
        get 
        {
            return GetElement<MoveFrom>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Move Destination Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:moveTo </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MoveTo MoveTo
    {
        get 
        {
            return GetElement<MoveTo>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousParagraphMarkRunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Level Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ilvl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingLevelReference : OpenXmlLeafElement
{
    private const string tagName = "ilvl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11775;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingLevelReference class.
    /// </summary>
    public NumberingLevelReference():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingLevelReference>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Definition Instance Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingId : NonNegativeDecimalNumberType
{
    private const string tagName = "numId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11776;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingId class.
    /// </summary>
    public NumberingId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingId>(deep);
    }

}
/// <summary>
/// <para>Starting Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:start.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StartNumberingValue : NonNegativeDecimalNumberType
{
    private const string tagName = "start";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11911;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartNumberingValue class.
    /// </summary>
    public StartNumberingValue():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartNumberingValue>(deep);
    }

}
/// <summary>
/// <para>Abstract Numbering Definition Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:abstractNumId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AbstractNumId : NonNegativeDecimalNumberType
{
    private const string tagName = "abstractNumId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11930;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the AbstractNumId class.
    /// </summary>
    public AbstractNumId():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AbstractNumId>(deep);
    }

}
/// <summary>
/// Defines the NonNegativeDecimalNumberType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class NonNegativeDecimalNumberType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the NonNegativeDecimalNumberType class.
    /// </summary>
    protected NonNegativeDecimalNumberType(){}
    
    
    
}
/// <summary>
/// <para>Previous Paragraph Numbering Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numberingChange.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingChange : OpenXmlLeafElement
{
    private const string tagName = "numberingChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11777;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "original","author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> original.</para>
    /// <para>Represents the following attribute in the schema: w:original </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "original")]
    public StringValue Original
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingChange class.
    /// </summary>
    public NumberingChange():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "original" == name)
    return new StringValue();
    
if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingChange>(deep);
    }

   
}
/// <summary>
/// <para>Custom Tab Stop.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tab.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TabStop : OpenXmlLeafElement
{
    private const string tagName = "tab";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11784;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","leader","pos" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Tab Stop Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Tab Leader Character.</para>
    /// <para>Represents the following attribute in the schema: w:leader </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "leader")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopLeaderCharValues> Leader
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopLeaderCharValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Tab Stop Position.</para>
    /// <para>Represents the following attribute in the schema: w:pos </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "pos")]
    public Int32Value Position
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TabStop class.
    /// </summary>
    public TabStop():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopValues>();
    
if( 23 == namespaceId && "leader" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TabStopLeaderCharValues>();
    
if( 23 == namespaceId && "pos" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TabStop>(deep);
    }

   
}
/// <summary>
/// <para>Run Properties for the Paragraph Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Inserted &lt;w:ins></description></item>
///<item><description>Deleted &lt;w:del></description></item>
///<item><description>MoveFrom &lt;w:moveFrom></description></item>
///<item><description>MoveTo &lt;w:moveTo></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>RunStyle &lt;w:rStyle></description></item>
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Highlight &lt;w:highlight></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>RightToLeftText &lt;w:rtl></description></item>
///<item><description>ComplexScript &lt;w:cs></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Glow &lt;w14:glow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Shadow &lt;w14:shadow></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Reflection &lt;w14:reflection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect &lt;w14:textOutline></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.FillTextEffect &lt;w14:textFill></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Scene3D &lt;w14:scene3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Properties3D &lt;w14:props3d></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.Ligatures &lt;w14:ligatures></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberingFormat &lt;w14:numForm></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.NumberSpacing &lt;w14:numSpacing></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.StylisticSets &lt;w14:stylisticSets></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives &lt;w14:cntxtAlts></description></item>
///<item><description>OfficeMath &lt;w:oMath></description></item>
///<item><description>ParagraphMarkRunPropertiesChange &lt;w:rPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Inserted))]
    [ChildElementInfo(typeof(Deleted))]
    [ChildElementInfo(typeof(MoveFrom))]
    [ChildElementInfo(typeof(MoveTo))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(RunStyle))]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Highlight))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(RightToLeftText))]
    [ChildElementInfo(typeof(ComplexScript))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Glow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Shadow),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Reflection),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.FillTextEffect),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Scene3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Properties3D),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.Ligatures),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberingFormat),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.NumberSpacing),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.StylisticSets),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(OfficeMath))]
    [ChildElementInfo(typeof(ParagraphMarkRunPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphMarkRunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11785;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunProperties class.
    /// </summary>
    public ParagraphMarkRunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphMarkRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphMarkRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphMarkRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphMarkRunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "ins" == name)
    return new Inserted();
    
if( 23 == namespaceId && "del" == name)
    return new Deleted();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFrom();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveTo();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion();
    
if( 23 == namespaceId && "rStyle" == name)
    return new RunStyle();
    
if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "highlight" == name)
    return new Highlight();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "rtl" == name)
    return new RightToLeftText();
    
if( 23 == namespaceId && "cs" == name)
    return new ComplexScript();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    
if( 52 == namespaceId && "glow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Glow();
    
if( 52 == namespaceId && "shadow" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Shadow();
    
if( 52 == namespaceId && "reflection" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Reflection();
    
if( 52 == namespaceId && "textOutline" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.TextOutlineEffect();
    
if( 52 == namespaceId && "textFill" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.FillTextEffect();
    
if( 52 == namespaceId && "scene3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Scene3D();
    
if( 52 == namespaceId && "props3d" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Properties3D();
    
if( 52 == namespaceId && "ligatures" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.Ligatures();
    
if( 52 == namespaceId && "numForm" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberingFormat();
    
if( 52 == namespaceId && "numSpacing" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.NumberSpacing();
    
if( 52 == namespaceId && "stylisticSets" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.StylisticSets();
    
if( 52 == namespaceId && "cntxtAlts" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ContextualAlternatives();
    
if( 23 == namespaceId && "oMath" == name)
    return new OfficeMath();
    
if( 23 == namespaceId && "rPrChange" == name)
    return new ParagraphMarkRunPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ins","del","moveFrom","moveTo","conflictIns","conflictDel","rStyle","rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","highlight","u","effect","bdr","shd","fitText","vertAlign","rtl","cs","em","lang","eastAsianLayout","specVanish","glow","shadow","reflection","textOutline","textFill","scene3d","props3d","ligatures","numForm","numSpacing","stylisticSets","cntxtAlts","oMath","rPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,52,52,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,52,52,52,52,52,52,52,52,52,52,52,52,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Inserted Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:ins </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Inserted Inserted
    {
        get 
        {
            return GetElement<Inserted>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Deleted Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:del </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Deleted Deleted
    {
        get 
        {
            return GetElement<Deleted>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Move Source Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:moveFrom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MoveFrom MoveFrom
    {
        get 
        {
            return GetElement<MoveFrom>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Move Destination Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:moveTo </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MoveTo MoveTo
    {
        get 
        {
            return GetElement<MoveTo>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphMarkRunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Section Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sectPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>HeaderReference &lt;w:headerReference></description></item>
///<item><description>FooterReference &lt;w:footerReference></description></item>
///<item><description>FootnoteProperties &lt;w:footnotePr></description></item>
///<item><description>EndnoteProperties &lt;w:endnotePr></description></item>
///<item><description>SectionType &lt;w:type></description></item>
///<item><description>PageSize &lt;w:pgSz></description></item>
///<item><description>PageMargin &lt;w:pgMar></description></item>
///<item><description>PaperSource &lt;w:paperSrc></description></item>
///<item><description>PageBorders &lt;w:pgBorders></description></item>
///<item><description>LineNumberType &lt;w:lnNumType></description></item>
///<item><description>PageNumberType &lt;w:pgNumType></description></item>
///<item><description>Columns &lt;w:cols></description></item>
///<item><description>FormProtection &lt;w:formProt></description></item>
///<item><description>VerticalTextAlignmentOnPage &lt;w:vAlign></description></item>
///<item><description>NoEndnote &lt;w:noEndnote></description></item>
///<item><description>TitlePage &lt;w:titlePg></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>GutterOnRight &lt;w:rtlGutter></description></item>
///<item><description>DocGrid &lt;w:docGrid></description></item>
///<item><description>PrinterSettingsReference &lt;w:printerSettings></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns &lt;w15:footnoteColumns></description></item>
///<item><description>SectionPropertiesChange &lt;w:sectPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(HeaderReference))]
    [ChildElementInfo(typeof(FooterReference))]
    [ChildElementInfo(typeof(FootnoteProperties))]
    [ChildElementInfo(typeof(EndnoteProperties))]
    [ChildElementInfo(typeof(SectionType))]
    [ChildElementInfo(typeof(PageSize))]
    [ChildElementInfo(typeof(PageMargin))]
    [ChildElementInfo(typeof(PaperSource))]
    [ChildElementInfo(typeof(PageBorders))]
    [ChildElementInfo(typeof(LineNumberType))]
    [ChildElementInfo(typeof(PageNumberType))]
    [ChildElementInfo(typeof(Columns))]
    [ChildElementInfo(typeof(FormProtection))]
    [ChildElementInfo(typeof(VerticalTextAlignmentOnPage))]
    [ChildElementInfo(typeof(NoEndnote))]
    [ChildElementInfo(typeof(TitlePage))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(GutterOnRight))]
    [ChildElementInfo(typeof(DocGrid))]
    [ChildElementInfo(typeof(PrinterSettingsReference))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(SectionPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SectionProperties : OpenXmlCompositeElement
{
    private const string tagName = "sectPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11786;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rsidRPr","rsidDel","rsidR","rsidSect" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Physical Section Mark Character Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidRPr </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidRPr")]
    public HexBinaryValue RsidRPr
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Section Deletion Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidDel")]
    public HexBinaryValue RsidDel
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Section Addition Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidR </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidR")]
    public HexBinaryValue RsidR
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Section Properties Revision ID.</para>
    /// <para>Represents the following attribute in the schema: w:rsidSect </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "rsidSect")]
    public HexBinaryValue RsidSect
    {
        get { return (HexBinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SectionProperties class.
    /// </summary>
    public SectionProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SectionProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SectionProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SectionProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SectionProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SectionProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SectionProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "headerReference" == name)
    return new HeaderReference();
    
if( 23 == namespaceId && "footerReference" == name)
    return new FooterReference();
    
if( 23 == namespaceId && "footnotePr" == name)
    return new FootnoteProperties();
    
if( 23 == namespaceId && "endnotePr" == name)
    return new EndnoteProperties();
    
if( 23 == namespaceId && "type" == name)
    return new SectionType();
    
if( 23 == namespaceId && "pgSz" == name)
    return new PageSize();
    
if( 23 == namespaceId && "pgMar" == name)
    return new PageMargin();
    
if( 23 == namespaceId && "paperSrc" == name)
    return new PaperSource();
    
if( 23 == namespaceId && "pgBorders" == name)
    return new PageBorders();
    
if( 23 == namespaceId && "lnNumType" == name)
    return new LineNumberType();
    
if( 23 == namespaceId && "pgNumType" == name)
    return new PageNumberType();
    
if( 23 == namespaceId && "cols" == name)
    return new Columns();
    
if( 23 == namespaceId && "formProt" == name)
    return new FormProtection();
    
if( 23 == namespaceId && "vAlign" == name)
    return new VerticalTextAlignmentOnPage();
    
if( 23 == namespaceId && "noEndnote" == name)
    return new NoEndnote();
    
if( 23 == namespaceId && "titlePg" == name)
    return new TitlePage();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "rtlGutter" == name)
    return new GutterOnRight();
    
if( 23 == namespaceId && "docGrid" == name)
    return new DocGrid();
    
if( 23 == namespaceId && "printerSettings" == name)
    return new PrinterSettingsReference();
    
if( 69 == namespaceId && "footnoteColumns" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.FootnoteColumns();
    
if( 23 == namespaceId && "sectPrChange" == name)
    return new SectionPropertiesChange();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRPr" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidDel" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidR" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "rsidSect" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SectionProperties>(deep);
    }

   
}
/// <summary>
/// <para>Custom Field Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fldData.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldData : OpenXmlLeafTextElement
{
    private const string tagName = "fldData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11787;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FieldData class.
    /// </summary>
    public FieldData():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the FieldData class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public FieldData(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new Base64BinaryValue(){ InnerText = text };
    }
    
 
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldData>(deep);
    }

   
}
/// <summary>
/// <para>Form Field Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ffData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FormFieldName &lt;w:name></description></item>
///<item><description>Enabled &lt;w:enabled></description></item>
///<item><description>CalculateOnExit &lt;w:calcOnExit></description></item>
///<item><description>EntryMacro &lt;w:entryMacro></description></item>
///<item><description>ExitMacro &lt;w:exitMacro></description></item>
///<item><description>HelpText &lt;w:helpText></description></item>
///<item><description>StatusText &lt;w:statusText></description></item>
///<item><description>CheckBox &lt;w:checkBox></description></item>
///<item><description>DropDownListFormField &lt;w:ddList></description></item>
///<item><description>TextInput &lt;w:textInput></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FormFieldName))]
    [ChildElementInfo(typeof(Enabled))]
    [ChildElementInfo(typeof(CalculateOnExit))]
    [ChildElementInfo(typeof(EntryMacro))]
    [ChildElementInfo(typeof(ExitMacro))]
    [ChildElementInfo(typeof(HelpText))]
    [ChildElementInfo(typeof(StatusText))]
    [ChildElementInfo(typeof(CheckBox))]
    [ChildElementInfo(typeof(DropDownListFormField))]
    [ChildElementInfo(typeof(TextInput))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormFieldData : OpenXmlCompositeElement
{
    private const string tagName = "ffData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11788;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FormFieldData class.
    /// </summary>
    public FormFieldData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FormFieldData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FormFieldData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FormFieldData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FormFieldData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FormFieldData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FormFieldData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new FormFieldName();
    
if( 23 == namespaceId && "enabled" == name)
    return new Enabled();
    
if( 23 == namespaceId && "calcOnExit" == name)
    return new CalculateOnExit();
    
if( 23 == namespaceId && "entryMacro" == name)
    return new EntryMacro();
    
if( 23 == namespaceId && "exitMacro" == name)
    return new ExitMacro();
    
if( 23 == namespaceId && "helpText" == name)
    return new HelpText();
    
if( 23 == namespaceId && "statusText" == name)
    return new StatusText();
    
if( 23 == namespaceId && "checkBox" == name)
    return new CheckBox();
    
if( 23 == namespaceId && "ddList" == name)
    return new DropDownListFormField();
    
if( 23 == namespaceId && "textInput" == name)
    return new TextInput();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormFieldData>(deep);
    }

   
}
/// <summary>
/// <para>Form Field Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FormFieldName : OpenXmlLeafElement
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11789;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Form Field Name Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FormFieldName class.
    /// </summary>
    public FormFieldName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FormFieldName>(deep);
    }

   
}
/// <summary>
/// <para>Script Function to Execute on Form Field Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:entryMacro.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EntryMacro : MacroNameType
{
    private const string tagName = "entryMacro";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11792;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EntryMacro class.
    /// </summary>
    public EntryMacro():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EntryMacro>(deep);
    }

}
/// <summary>
/// <para>Script Function to Execute on Form Field Exit.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:exitMacro.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExitMacro : MacroNameType
{
    private const string tagName = "exitMacro";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11793;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ExitMacro class.
    /// </summary>
    public ExitMacro():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExitMacro>(deep);
    }

}
/// <summary>
/// Defines the MacroNameType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MacroNameType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Name of Script Function.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MacroNameType class.
    /// </summary>
    protected MacroNameType(){}
    
    
    
}
/// <summary>
/// <para>Associated Help Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:helpText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HelpText : OpenXmlLeafElement
{
    private const string tagName = "helpText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11794;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","val" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Help Text Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Help Text Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HelpText class.
    /// </summary>
    public HelpText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues>();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HelpText>(deep);
    }

   
}
/// <summary>
/// <para>Associated Status Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:statusText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StatusText : OpenXmlLeafElement
{
    private const string tagName = "statusText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11795;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","val" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Status Text Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Status Text Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StatusText class.
    /// </summary>
    public StatusText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.InfoTextValues>();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StatusText>(deep);
    }

   
}
/// <summary>
/// <para>Checkbox Form Field Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:checkBox.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FormFieldSize &lt;w:size></description></item>
///<item><description>AutomaticallySizeFormField &lt;w:sizeAuto></description></item>
///<item><description>DefaultCheckBoxFormFieldState &lt;w:default></description></item>
///<item><description>Checked &lt;w:checked></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FormFieldSize))]
    [ChildElementInfo(typeof(AutomaticallySizeFormField))]
    [ChildElementInfo(typeof(DefaultCheckBoxFormFieldState))]
    [ChildElementInfo(typeof(Checked))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CheckBox : OpenXmlCompositeElement
{
    private const string tagName = "checkBox";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11796;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CheckBox class.
    /// </summary>
    public CheckBox():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CheckBox class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CheckBox(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CheckBox class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CheckBox(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CheckBox class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CheckBox(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "size" == name)
    return new FormFieldSize();
    
if( 23 == namespaceId && "sizeAuto" == name)
    return new AutomaticallySizeFormField();
    
if( 23 == namespaceId && "default" == name)
    return new DefaultCheckBoxFormFieldState();
    
if( 23 == namespaceId && "checked" == name)
    return new Checked();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CheckBox>(deep);
    }

   
}
/// <summary>
/// <para>Drop-Down List Form Field Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:ddList.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DropDownListSelection &lt;w:result></description></item>
///<item><description>DefaultDropDownListItemIndex &lt;w:default></description></item>
///<item><description>ListEntryFormField &lt;w:listEntry></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DropDownListSelection))]
    [ChildElementInfo(typeof(DefaultDropDownListItemIndex))]
    [ChildElementInfo(typeof(ListEntryFormField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DropDownListFormField : OpenXmlCompositeElement
{
    private const string tagName = "ddList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11797;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DropDownListFormField class.
    /// </summary>
    public DropDownListFormField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DropDownListFormField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DropDownListFormField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DropDownListFormField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DropDownListFormField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DropDownListFormField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DropDownListFormField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "result" == name)
    return new DropDownListSelection();
    
if( 23 == namespaceId && "default" == name)
    return new DefaultDropDownListItemIndex();
    
if( 23 == namespaceId && "listEntry" == name)
    return new ListEntryFormField();
    

    return null;
}

        private static readonly string[] eleTagNames = { "result","default","listEntry" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Drop-Down List Selection.</para>
    /// <para> Represents the following element tag in the schema: w:result </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DropDownListSelection DropDownListSelection
    {
        get 
        {
            return GetElement<DropDownListSelection>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Default Drop-Down List Item Index.</para>
    /// <para> Represents the following element tag in the schema: w:default </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DefaultDropDownListItemIndex DefaultDropDownListItemIndex
    {
        get 
        {
            return GetElement<DefaultDropDownListItemIndex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DropDownListFormField>(deep);
    }

   
}
/// <summary>
/// <para>Text Box Form Field Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:textInput.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TextBoxFormFieldType &lt;w:type></description></item>
///<item><description>DefaultTextBoxFormFieldString &lt;w:default></description></item>
///<item><description>MaxLength &lt;w:maxLength></description></item>
///<item><description>Format &lt;w:format></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TextBoxFormFieldType))]
    [ChildElementInfo(typeof(DefaultTextBoxFormFieldString))]
    [ChildElementInfo(typeof(MaxLength))]
    [ChildElementInfo(typeof(Format))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextInput : OpenXmlCompositeElement
{
    private const string tagName = "textInput";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11798;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TextInput class.
    /// </summary>
    public TextInput():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextInput class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextInput(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextInput class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextInput(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextInput class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextInput(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new TextBoxFormFieldType();
    
if( 23 == namespaceId && "default" == name)
    return new DefaultTextBoxFormFieldString();
    
if( 23 == namespaceId && "maxLength" == name)
    return new MaxLength();
    
if( 23 == namespaceId && "format" == name)
    return new Format();
    

    return null;
}

        private static readonly string[] eleTagNames = { "type","default","maxLength","format" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text Box Form Field Type.</para>
    /// <para> Represents the following element tag in the schema: w:type </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxFormFieldType TextBoxFormFieldType
    {
        get 
        {
            return GetElement<TextBoxFormFieldType>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Default Text Box Form Field String.</para>
    /// <para> Represents the following element tag in the schema: w:default </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DefaultTextBoxFormFieldString DefaultTextBoxFormFieldString
    {
        get 
        {
            return GetElement<DefaultTextBoxFormFieldString>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Text Box Form Field Maximum Length.</para>
    /// <para> Represents the following element tag in the schema: w:maxLength </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MaxLength MaxLength
    {
        get 
        {
            return GetElement<MaxLength>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Text Box Form Field Formatting.</para>
    /// <para> Represents the following element tag in the schema: w:format </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Format Format
    {
        get 
        {
            return GetElement<Format>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextInput>(deep);
    }

   
}
/// <summary>
/// <para>Default Drop-Down List Item Index.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:default.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultDropDownListItemIndex : OpenXmlLeafElement
{
    private const string tagName = "default";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11804;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultDropDownListItemIndex class.
    /// </summary>
    public DefaultDropDownListItemIndex():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultDropDownListItemIndex>(deep);
    }

   
}
/// <summary>
/// <para>Drop-Down List Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:listEntry.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ListEntryFormField : String255Type
{
    private const string tagName = "listEntry";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11805;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ListEntryFormField class.
    /// </summary>
    public ListEntryFormField():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ListEntryFormField>(deep);
    }

}
/// <summary>
/// <para>Default Text Box Form Field String.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:default.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultTextBoxFormFieldString : String255Type
{
    private const string tagName = "default";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11807;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultTextBoxFormFieldString class.
    /// </summary>
    public DefaultTextBoxFormFieldString():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultTextBoxFormFieldString>(deep);
    }

}
/// <summary>
/// <para>Frame Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FrameName : String255Type
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11897;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FrameName class.
    /// </summary>
    public FrameName():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FrameName>(deep);
    }

}
/// <summary>
/// Defines the String255Type class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class String255Type : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the String255Type class.
    /// </summary>
    protected String255Type(){}
    
    
    
}
/// <summary>
/// <para>Text Box Form Field Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:type.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextBoxFormFieldType : OpenXmlLeafElement
{
    private const string tagName = "type";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11806;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Text Box Form Field Type Values.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxFormFieldValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxFormFieldValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextBoxFormFieldType class.
    /// </summary>
    public TextBoxFormFieldType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TextBoxFormFieldValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextBoxFormFieldType>(deep);
    }

   
}
/// <summary>
/// <para>Text Box Form Field Maximum Length.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:maxLength.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MaxLength : OpenXmlLeafElement
{
    private const string tagName = "maxLength";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11808;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int16Value Val
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MaxLength class.
    /// </summary>
    public MaxLength():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MaxLength>(deep);
    }

   
}
/// <summary>
/// <para>Text Box Form Field Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:format.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Format : OpenXmlLeafElement
{
    private const string tagName = "format";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11809;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Format class.
    /// </summary>
    public Format():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Format>(deep);
    }

   
}
/// <summary>
/// <para>Single Column Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:col.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Column : OpenXmlLeafElement
{
    private const string tagName = "col";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11810;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w","space" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Column Width.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public StringValue Width
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Space Before Following Column.</para>
    /// <para>Represents the following attribute in the schema: w:space </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "space")]
    public StringValue Space
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Column class.
    /// </summary>
    public Column():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new StringValue();
    
if( 23 == namespaceId && "space" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Column>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Section Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sectPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousSectionProperties &lt;w:sectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousSectionProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SectionPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "sectPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11811;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SectionPropertiesChange class.
    /// </summary>
    public SectionPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SectionPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SectionPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SectionPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SectionPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SectionPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SectionPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sectPr" == name)
    return new PreviousSectionProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sectPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Section Properties.</para>
    /// <para> Represents the following element tag in the schema: w:sectPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousSectionProperties PreviousSectionProperties
    {
        get 
        {
            return GetElement<PreviousSectionProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SectionPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Run Properties on the Paragraph Mark.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousParagraphMarkRunProperties &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousParagraphMarkRunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphMarkRunPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "rPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11812;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunPropertiesChange class.
    /// </summary>
    public ParagraphMarkRunPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphMarkRunPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphMarkRunPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphMarkRunPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphMarkRunPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphMarkRunPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new PreviousParagraphMarkRunProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Run Properties for the Paragraph Mark.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousParagraphMarkRunProperties PreviousParagraphMarkRunProperties
    {
        get 
        {
            return GetElement<PreviousParagraphMarkRunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphMarkRunPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>External Content Import Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:altChunkPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MatchSource &lt;w:matchSrc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MatchSource))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AltChunkProperties : OpenXmlCompositeElement
{
    private const string tagName = "altChunkPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11813;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AltChunkProperties class.
    /// </summary>
    public AltChunkProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AltChunkProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AltChunkProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AltChunkProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AltChunkProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AltChunkProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AltChunkProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "matchSrc" == name)
    return new MatchSource();
    

    return null;
}

        private static readonly string[] eleTagNames = { "matchSrc" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Keep Source Formatting on Import.</para>
    /// <para> Represents the following element tag in the schema: w:matchSrc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MatchSource MatchSource
    {
        get 
        {
            return GetElement<MatchSource>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AltChunkProperties>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Guide Text Alignment.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rubyAlign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RubyAlign : OpenXmlLeafElement
{
    private const string tagName = "rubyAlign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11815;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Phonetic Guide Text Alignment Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.RubyAlignValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.RubyAlignValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RubyAlign class.
    /// </summary>
    public RubyAlign():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.RubyAlignValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RubyAlign>(deep);
    }

   
}
/// <summary>
/// <para>Distance Between Phonetic Guide Text and Phonetic Guide Base Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hpsRaise.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PhoneticGuideRaise : OpenXmlLeafElement
{
    private const string tagName = "hpsRaise";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11817;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int16Value Val
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PhoneticGuideRaise class.
    /// </summary>
    public PhoneticGuideRaise():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PhoneticGuideRaise>(deep);
    }

   
}
/// <summary>
/// <para>Language ID for Phonetic Guide.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LanguageId : OpenXmlLeafElement
{
    private const string tagName = "lid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11819;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Language Code.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LanguageId class.
    /// </summary>
    public LanguageId():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LanguageId>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Guide Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rubyPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RubyAlign &lt;w:rubyAlign></description></item>
///<item><description>PhoneticGuideTextFontSize &lt;w:hps></description></item>
///<item><description>PhoneticGuideRaise &lt;w:hpsRaise></description></item>
///<item><description>PhoneticGuideBaseTextSize &lt;w:hpsBaseText></description></item>
///<item><description>LanguageId &lt;w:lid></description></item>
///<item><description>Dirty &lt;w:dirty></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RubyAlign))]
    [ChildElementInfo(typeof(PhoneticGuideTextFontSize))]
    [ChildElementInfo(typeof(PhoneticGuideRaise))]
    [ChildElementInfo(typeof(PhoneticGuideBaseTextSize))]
    [ChildElementInfo(typeof(LanguageId))]
    [ChildElementInfo(typeof(Dirty))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RubyProperties : OpenXmlCompositeElement
{
    private const string tagName = "rubyPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11821;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RubyProperties class.
    /// </summary>
    public RubyProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RubyProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RubyProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rubyAlign" == name)
    return new RubyAlign();
    
if( 23 == namespaceId && "hps" == name)
    return new PhoneticGuideTextFontSize();
    
if( 23 == namespaceId && "hpsRaise" == name)
    return new PhoneticGuideRaise();
    
if( 23 == namespaceId && "hpsBaseText" == name)
    return new PhoneticGuideBaseTextSize();
    
if( 23 == namespaceId && "lid" == name)
    return new LanguageId();
    
if( 23 == namespaceId && "dirty" == name)
    return new Dirty();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rubyAlign","hps","hpsRaise","hpsBaseText","lid","dirty" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Phonetic Guide Text Alignment.</para>
    /// <para> Represents the following element tag in the schema: w:rubyAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RubyAlign RubyAlign
    {
        get 
        {
            return GetElement<RubyAlign>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Phonetic Guide Text Font Size.</para>
    /// <para> Represents the following element tag in the schema: w:hps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PhoneticGuideTextFontSize PhoneticGuideTextFontSize
    {
        get 
        {
            return GetElement<PhoneticGuideTextFontSize>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Distance Between Phonetic Guide Text and Phonetic Guide Base Text.</para>
    /// <para> Represents the following element tag in the schema: w:hpsRaise </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PhoneticGuideRaise PhoneticGuideRaise
    {
        get 
        {
            return GetElement<PhoneticGuideRaise>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Phonetic Guide Base Text Font Size.</para>
    /// <para> Represents the following element tag in the schema: w:hpsBaseText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PhoneticGuideBaseTextSize PhoneticGuideBaseTextSize
    {
        get 
        {
            return GetElement<PhoneticGuideBaseTextSize>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Language ID for Phonetic Guide.</para>
    /// <para> Represents the following element tag in the schema: w:lid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LanguageId LanguageId
    {
        get 
        {
            return GetElement<LanguageId>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Invalidated Field Cache.</para>
    /// <para> Represents the following element tag in the schema: w:dirty </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Dirty Dirty
    {
        get 
        {
            return GetElement<Dirty>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RubyProperties>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Guide Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RubyContent : RubyContentType
{
    private const string tagName = "rt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11822;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RubyContent class.
    /// </summary>
    public RubyContent():base(){}
            /// <summary>
    ///Initializes a new instance of the RubyContent class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyContent(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyContent class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyContent(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyContent class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RubyContent(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RubyContent>(deep);
    }

}
/// <summary>
/// <para>Phonetic Guide Base Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rubyBase.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RubyBase : RubyContentType
{
    private const string tagName = "rubyBase";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11823;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RubyBase class.
    /// </summary>
    public RubyBase():base(){}
            /// <summary>
    ///Initializes a new instance of the RubyBase class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyBase(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyBase class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RubyBase(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyBase class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RubyBase(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RubyBase>(deep);
    }

}
/// <summary>
/// Defines the RubyContentType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRuby))]
    [ChildElementInfo(typeof(SimpleFieldRuby))]
    [ChildElementInfo(typeof(HyperlinkRuby))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(SdtRunRuby))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RubyContentType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRuby();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleFieldRuby();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new HyperlinkRuby();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRunRuby();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the RubyContentType class.
    /// </summary>
    protected RubyContentType(){}
    
            /// <summary>
    ///Initializes a new instance of the RubyContentType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RubyContentType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyContentType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RubyContentType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RubyContentType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected RubyContentType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Custom XML Data Date Storage Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:storeMappedDataAs.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtDateMappingType : OpenXmlLeafElement
{
    private const string tagName = "storeMappedDataAs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11825;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Date Storage Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DateFormatValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DateFormatValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtDateMappingType class.
    /// </summary>
    public SdtDateMappingType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DateFormatValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtDateMappingType>(deep);
    }

   
}
/// <summary>
/// <para>Date Picker Calendar Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:calendar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Calendar : OpenXmlLeafElement
{
    private const string tagName = "calendar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11826;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Calendar Type Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CalendarValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CalendarValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Calendar class.
    /// </summary>
    public Calendar():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CalendarValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Calendar>(deep);
    }

   
}
/// <summary>
/// <para>Combo Box List Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:listItem.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ListItem : OpenXmlLeafElement
{
    private const string tagName = "listItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11827;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "displayText","value" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> List Entry Display Text.</para>
    /// <para>Represents the following attribute in the schema: w:displayText </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "displayText")]
    public StringValue DisplayText
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> List Entry Value.</para>
    /// <para>Represents the following attribute in the schema: w:value </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "value")]
    public StringValue Value
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ListItem class.
    /// </summary>
    public ListItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "displayText" == name)
    return new StringValue();
    
if( 23 == namespaceId && "value" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ListItem>(deep);
    }

   
}
/// <summary>
/// <para>Structured Document Tag Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
///<item><description>SdtAlias &lt;w:alias></description></item>
///<item><description>Lock &lt;w:lock></description></item>
///<item><description>SdtPlaceholder &lt;w:placeholder></description></item>
///<item><description>ShowingPlaceholder &lt;w:showingPlcHdr></description></item>
///<item><description>DataBinding &lt;w:dataBinding></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.DataBinding &lt;w15:dataBinding></description></item>
///<item><description>TemporarySdt &lt;w:temporary></description></item>
///<item><description>SdtId &lt;w:id></description></item>
///<item><description>Tag &lt;w:tag></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Color &lt;w15:color></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.Appearance &lt;w15:appearance></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked &lt;w15:webExtensionLinked></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated &lt;w15:webExtensionCreated></description></item>
///<item><description>SdtContentEquation &lt;w:equation></description></item>
///<item><description>SdtContentComboBox &lt;w:comboBox></description></item>
///<item><description>SdtContentDate &lt;w:date></description></item>
///<item><description>SdtContentDocPartObject &lt;w:docPartObj></description></item>
///<item><description>SdtContentDocPartList &lt;w:docPartList></description></item>
///<item><description>SdtContentDropDownList &lt;w:dropDownList></description></item>
///<item><description>SdtContentPicture &lt;w:picture></description></item>
///<item><description>SdtContentRichText &lt;w:richText></description></item>
///<item><description>SdtContentText &lt;w:text></description></item>
///<item><description>SdtContentCitation &lt;w:citation></description></item>
///<item><description>SdtContentGroup &lt;w:group></description></item>
///<item><description>SdtContentBibliography &lt;w:bibliography></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty &lt;w14:entityPicker></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox &lt;w14:checkbox></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection &lt;w15:repeatingSection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem &lt;w15:repeatingSectionItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(SdtAlias))]
    [ChildElementInfo(typeof(Lock))]
    [ChildElementInfo(typeof(SdtPlaceholder))]
    [ChildElementInfo(typeof(ShowingPlaceholder))]
    [ChildElementInfo(typeof(DataBinding))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.DataBinding),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(TemporarySdt))]
    [ChildElementInfo(typeof(SdtId))]
    [ChildElementInfo(typeof(Tag))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Color),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.Appearance),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(SdtContentEquation))]
    [ChildElementInfo(typeof(SdtContentComboBox))]
    [ChildElementInfo(typeof(SdtContentDate))]
    [ChildElementInfo(typeof(SdtContentDocPartObject))]
    [ChildElementInfo(typeof(SdtContentDocPartList))]
    [ChildElementInfo(typeof(SdtContentDropDownList))]
    [ChildElementInfo(typeof(SdtContentPicture))]
    [ChildElementInfo(typeof(SdtContentRichText))]
    [ChildElementInfo(typeof(SdtContentText))]
    [ChildElementInfo(typeof(SdtContentCitation))]
    [ChildElementInfo(typeof(SdtContentGroup))]
    [ChildElementInfo(typeof(SdtContentBibliography))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtProperties : OpenXmlCompositeElement
{
    private const string tagName = "sdtPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11832;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtProperties class.
    /// </summary>
    public SdtProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 23 == namespaceId && "alias" == name)
    return new SdtAlias();
    
if( 23 == namespaceId && "lock" == name)
    return new Lock();
    
if( 23 == namespaceId && "placeholder" == name)
    return new SdtPlaceholder();
    
if( 23 == namespaceId && "showingPlcHdr" == name)
    return new ShowingPlaceholder();
    
if( 23 == namespaceId && "dataBinding" == name)
    return new DataBinding();
    
if( 69 == namespaceId && "dataBinding" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.DataBinding();
    
if( 23 == namespaceId && "temporary" == name)
    return new TemporarySdt();
    
if( 23 == namespaceId && "id" == name)
    return new SdtId();
    
if( 23 == namespaceId && "tag" == name)
    return new Tag();
    
if( 69 == namespaceId && "color" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Color();
    
if( 69 == namespaceId && "appearance" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.Appearance();
    
if( 69 == namespaceId && "webExtensionLinked" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.WebExtensionLinked();
    
if( 69 == namespaceId && "webExtensionCreated" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.WebExtensionCreated();
    
if( 23 == namespaceId && "equation" == name)
    return new SdtContentEquation();
    
if( 23 == namespaceId && "comboBox" == name)
    return new SdtContentComboBox();
    
if( 23 == namespaceId && "date" == name)
    return new SdtContentDate();
    
if( 23 == namespaceId && "docPartObj" == name)
    return new SdtContentDocPartObject();
    
if( 23 == namespaceId && "docPartList" == name)
    return new SdtContentDocPartList();
    
if( 23 == namespaceId && "dropDownList" == name)
    return new SdtContentDropDownList();
    
if( 23 == namespaceId && "picture" == name)
    return new SdtContentPicture();
    
if( 23 == namespaceId && "richText" == name)
    return new SdtContentRichText();
    
if( 23 == namespaceId && "text" == name)
    return new SdtContentText();
    
if( 23 == namespaceId && "citation" == name)
    return new SdtContentCitation();
    
if( 23 == namespaceId && "group" == name)
    return new SdtContentGroup();
    
if( 23 == namespaceId && "bibliography" == name)
    return new SdtContentBibliography();
    
if( 52 == namespaceId && "entityPicker" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.EntityPickerEmpty();
    
if( 52 == namespaceId && "checkbox" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.SdtContentCheckBox();
    
if( 69 == namespaceId && "repeatingSection" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSection();
    
if( 69 == namespaceId && "repeatingSectionItem" == name)
    return new DocumentFormat.OpenXml.Office2013.Word.SdtRepeatedSectionItem();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtProperties>(deep);
    }

   
}
/// <summary>
/// <para>Structured Document Tag End Character Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtEndPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtEndCharProperties : OpenXmlCompositeElement
{
    private const string tagName = "sdtEndPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11833;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtEndCharProperties class.
    /// </summary>
    public SdtEndCharProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtEndCharProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtEndCharProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtEndCharProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtEndCharProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtEndCharProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtEndCharProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunProperties();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtEndCharProperties>(deep);
    }

   
}
/// <summary>
/// <para>Block-Level Structured Document Tag Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentBlock : OpenXmlCompositeElement
{
    private const string tagName = "sdtContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11834;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtContentBlock class.
    /// </summary>
    public SdtContentBlock():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentBlock(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentBlock(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentBlock class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentBlock(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentBlock>(deep);
    }

   
}
/// <summary>
/// <para>Inline-Level Structured Document Tag Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
///<item><description>CustomXmlRun &lt;w:customXml></description></item>
///<item><description>SimpleField &lt;w:fldSimple></description></item>
///<item><description>Hyperlink &lt;w:hyperlink></description></item>
///<item><description>SdtRun &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>BidirectionalOverride &lt;w:bdo></description></item>
///<item><description>BidirectionalEmbedding &lt;w:dir></description></item>
///<item><description>SubDocumentReference &lt;w:subDoc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
    [ChildElementInfo(typeof(CustomXmlRun))]
    [ChildElementInfo(typeof(SimpleField))]
    [ChildElementInfo(typeof(Hyperlink))]
    [ChildElementInfo(typeof(SdtRun))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(BidirectionalOverride),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(BidirectionalEmbedding),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SubDocumentReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentRun : OpenXmlCompositeElement
{
    private const string tagName = "sdtContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11835;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRun class.
    /// </summary>
    public SdtContentRun():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentRun(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRun();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleField();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRun();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "bdo" == name)
    return new BidirectionalOverride();
    
if( 23 == namespaceId && "dir" == name)
    return new BidirectionalEmbedding();
    
if( 23 == namespaceId && "subDoc" == name)
    return new SubDocumentReference();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentRun>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtContentRunRuby Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlRuby &lt;w:customXml></description></item>
///<item><description>SimpleFieldRuby &lt;w:fldSimple></description></item>
///<item><description>HyperlinkRuby &lt;w:hyperlink></description></item>
///<item><description>Run &lt;w:r></description></item>
///<item><description>SdtRunRuby &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Paragraph &lt;m:oMathPara></description></item>
///<item><description>DocumentFormat.OpenXml.Math.OfficeMath &lt;m:oMath></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Accent &lt;m:acc></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Bar &lt;m:bar></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Box &lt;m:box></description></item>
///<item><description>DocumentFormat.OpenXml.Math.BorderBox &lt;m:borderBox></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Delimiter &lt;m:d></description></item>
///<item><description>DocumentFormat.OpenXml.Math.EquationArray &lt;m:eqArr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Fraction &lt;m:f></description></item>
///<item><description>DocumentFormat.OpenXml.Math.MathFunction &lt;m:func></description></item>
///<item><description>DocumentFormat.OpenXml.Math.GroupChar &lt;m:groupChr></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitLower &lt;m:limLow></description></item>
///<item><description>DocumentFormat.OpenXml.Math.LimitUpper &lt;m:limUpp></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Matrix &lt;m:m></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Nary &lt;m:nary></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Phantom &lt;m:phant></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Radical &lt;m:rad></description></item>
///<item><description>DocumentFormat.OpenXml.Math.PreSubSuper &lt;m:sPre></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Subscript &lt;m:sSub></description></item>
///<item><description>DocumentFormat.OpenXml.Math.SubSuperscript &lt;m:sSubSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Superscript &lt;m:sSup></description></item>
///<item><description>DocumentFormat.OpenXml.Math.Run &lt;m:r></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlRuby))]
    [ChildElementInfo(typeof(SimpleFieldRuby))]
    [ChildElementInfo(typeof(HyperlinkRuby))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(SdtRunRuby))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Paragraph))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.OfficeMath))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Accent))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Bar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Box))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.BorderBox))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Delimiter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.EquationArray))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Fraction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.MathFunction))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.GroupChar))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitLower))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.LimitUpper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Matrix))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Nary))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Phantom))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Radical))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.PreSubSuper))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Subscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.SubSuperscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Superscript))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Math.Run))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentRunRuby : OpenXmlCompositeElement
{
    private const string tagName = "sdtContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11836;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRunRuby class.
    /// </summary>
    public SdtContentRunRuby():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentRunRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRunRuby(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRunRuby class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRunRuby(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRunRuby class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentRunRuby(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRuby();
    
if( 23 == namespaceId && "fldSimple" == name)
    return new SimpleFieldRuby();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new HyperlinkRuby();
    
if( 23 == namespaceId && "r" == name)
    return new Run();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRunRuby();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 21 == namespaceId && "oMathPara" == name)
    return new DocumentFormat.OpenXml.Math.Paragraph();
    
if( 21 == namespaceId && "oMath" == name)
    return new DocumentFormat.OpenXml.Math.OfficeMath();
    
if( 21 == namespaceId && "acc" == name)
    return new DocumentFormat.OpenXml.Math.Accent();
    
if( 21 == namespaceId && "bar" == name)
    return new DocumentFormat.OpenXml.Math.Bar();
    
if( 21 == namespaceId && "box" == name)
    return new DocumentFormat.OpenXml.Math.Box();
    
if( 21 == namespaceId && "borderBox" == name)
    return new DocumentFormat.OpenXml.Math.BorderBox();
    
if( 21 == namespaceId && "d" == name)
    return new DocumentFormat.OpenXml.Math.Delimiter();
    
if( 21 == namespaceId && "eqArr" == name)
    return new DocumentFormat.OpenXml.Math.EquationArray();
    
if( 21 == namespaceId && "f" == name)
    return new DocumentFormat.OpenXml.Math.Fraction();
    
if( 21 == namespaceId && "func" == name)
    return new DocumentFormat.OpenXml.Math.MathFunction();
    
if( 21 == namespaceId && "groupChr" == name)
    return new DocumentFormat.OpenXml.Math.GroupChar();
    
if( 21 == namespaceId && "limLow" == name)
    return new DocumentFormat.OpenXml.Math.LimitLower();
    
if( 21 == namespaceId && "limUpp" == name)
    return new DocumentFormat.OpenXml.Math.LimitUpper();
    
if( 21 == namespaceId && "m" == name)
    return new DocumentFormat.OpenXml.Math.Matrix();
    
if( 21 == namespaceId && "nary" == name)
    return new DocumentFormat.OpenXml.Math.Nary();
    
if( 21 == namespaceId && "phant" == name)
    return new DocumentFormat.OpenXml.Math.Phantom();
    
if( 21 == namespaceId && "rad" == name)
    return new DocumentFormat.OpenXml.Math.Radical();
    
if( 21 == namespaceId && "sPre" == name)
    return new DocumentFormat.OpenXml.Math.PreSubSuper();
    
if( 21 == namespaceId && "sSub" == name)
    return new DocumentFormat.OpenXml.Math.Subscript();
    
if( 21 == namespaceId && "sSubSup" == name)
    return new DocumentFormat.OpenXml.Math.SubSuperscript();
    
if( 21 == namespaceId && "sSup" == name)
    return new DocumentFormat.OpenXml.Math.Superscript();
    
if( 21 == namespaceId && "r" == name)
    return new DocumentFormat.OpenXml.Math.Run();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentRunRuby>(deep);
    }

   
}
/// <summary>
/// <para>Cell-Level Structured Document Tag Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCell &lt;w:tc></description></item>
///<item><description>CustomXmlCell &lt;w:customXml></description></item>
///<item><description>SdtCell &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCell))]
    [ChildElementInfo(typeof(CustomXmlCell))]
    [ChildElementInfo(typeof(SdtCell))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentCell : OpenXmlCompositeElement
{
    private const string tagName = "sdtContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11837;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtContentCell class.
    /// </summary>
    public SdtContentCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tc" == name)
    return new TableCell();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlCell();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtCell();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentCell>(deep);
    }

   
}
/// <summary>
/// <para>Row-Level Structured Document Tag Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sdtContent.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableRow &lt;w:tr></description></item>
///<item><description>CustomXmlRow &lt;w:customXml></description></item>
///<item><description>SdtRow &lt;w:sdt></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableRow))]
    [ChildElementInfo(typeof(CustomXmlRow))]
    [ChildElementInfo(typeof(SdtRow))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentRow : OpenXmlCompositeElement
{
    private const string tagName = "sdtContent";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11838;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRow class.
    /// </summary>
    public SdtContentRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tr" == name)
    return new TableRow();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlRow();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtRow();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentRow>(deep);
    }

   
}
/// <summary>
/// <para>Custom XML Element Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:customXmlPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomXmlPlaceholder &lt;w:placeholder></description></item>
///<item><description>CustomXmlAttribute &lt;w:attr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomXmlPlaceholder))]
    [ChildElementInfo(typeof(CustomXmlAttribute))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlProperties : OpenXmlCompositeElement
{
    private const string tagName = "customXmlPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11839;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlProperties class.
    /// </summary>
    public CustomXmlProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomXmlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomXmlProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomXmlProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomXmlProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "placeholder" == name)
    return new CustomXmlPlaceholder();
    
if( 23 == namespaceId && "attr" == name)
    return new CustomXmlAttribute();
    

    return null;
}

        private static readonly string[] eleTagNames = { "placeholder","attr" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Custom XML Element Placeholder Text.</para>
    /// <para> Represents the following element tag in the schema: w:placeholder </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CustomXmlPlaceholder CustomXmlPlaceholder
    {
        get 
        {
            return GetElement<CustomXmlPlaceholder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlProperties>(deep);
    }

   
}
/// <summary>
/// <para>Custom XML Attribute.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:attr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomXmlAttribute : OpenXmlLeafElement
{
    private const string tagName = "attr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11841;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri","name","val" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> uri.</para>
    /// <para>Represents the following attribute in the schema: w:uri </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomXmlAttribute class.
    /// </summary>
    public CustomXmlAttribute():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomXmlAttribute>(deep);
    }

   
}
/// <summary>
/// <para>Grid Column Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gridCol.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GridColumn : OpenXmlLeafElement
{
    private const string tagName = "gridCol";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11842;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "w" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Grid Column Width.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public StringValue Width
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GridColumn class.
    /// </summary>
    public GridColumn():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GridColumn>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Table Grid Column Definitions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblGridChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousTableGrid &lt;w:tblGrid></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousTableGrid))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableGridChange : OpenXmlCompositeElement
{
    private const string tagName = "tblGridChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11843;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableGridChange class.
    /// </summary>
    public TableGridChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableGridChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGridChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGridChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGridChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGridChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableGridChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblGrid" == name)
    return new PreviousTableGrid();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblGrid" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Table Grid.</para>
    /// <para> Represents the following element tag in the schema: w:tblGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousTableGrid PreviousTableGrid
    {
        get 
        {
            return GetElement<PreviousTableGrid>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableGridChange>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousTableCellProperties &lt;w:tcPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousTableCellProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "tcPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11844;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellPropertiesChange class.
    /// </summary>
    public TableCellPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tcPr" == name)
    return new PreviousTableCellProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tcPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Table Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousTableCellProperties PreviousTableCellProperties
    {
        get 
        {
            return GetElement<PreviousTableCellProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
///<item><description>TableCellWidth &lt;w:tcW></description></item>
///<item><description>GridSpan &lt;w:gridSpan></description></item>
///<item><description>HorizontalMerge &lt;w:hMerge></description></item>
///<item><description>VerticalMerge &lt;w:vMerge></description></item>
///<item><description>TableCellBorders &lt;w:tcBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>NoWrap &lt;w:noWrap></description></item>
///<item><description>TableCellMargin &lt;w:tcMar></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TableCellFitText &lt;w:tcFitText></description></item>
///<item><description>TableCellVerticalAlignment &lt;w:vAlign></description></item>
///<item><description>HideMark &lt;w:hideMark></description></item>
///<item><description>CellInsertion &lt;w:cellIns></description></item>
///<item><description>CellDeletion &lt;w:cellDel></description></item>
///<item><description>CellMerge &lt;w:cellMerge></description></item>
///<item><description>TableCellPropertiesChange &lt;w:tcPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
    [ChildElementInfo(typeof(TableCellWidth))]
    [ChildElementInfo(typeof(GridSpan))]
    [ChildElementInfo(typeof(HorizontalMerge))]
    [ChildElementInfo(typeof(VerticalMerge))]
    [ChildElementInfo(typeof(TableCellBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(NoWrap))]
    [ChildElementInfo(typeof(TableCellMargin))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TableCellFitText))]
    [ChildElementInfo(typeof(TableCellVerticalAlignment))]
    [ChildElementInfo(typeof(HideMark))]
    [ChildElementInfo(typeof(CellInsertion))]
    [ChildElementInfo(typeof(CellDeletion))]
    [ChildElementInfo(typeof(CellMerge))]
    [ChildElementInfo(typeof(TableCellPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "tcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11845;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableCellProperties class.
    /// </summary>
    public TableCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    
if( 23 == namespaceId && "tcW" == name)
    return new TableCellWidth();
    
if( 23 == namespaceId && "gridSpan" == name)
    return new GridSpan();
    
if( 23 == namespaceId && "hMerge" == name)
    return new HorizontalMerge();
    
if( 23 == namespaceId && "vMerge" == name)
    return new VerticalMerge();
    
if( 23 == namespaceId && "tcBorders" == name)
    return new TableCellBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "noWrap" == name)
    return new NoWrap();
    
if( 23 == namespaceId && "tcMar" == name)
    return new TableCellMargin();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "tcFitText" == name)
    return new TableCellFitText();
    
if( 23 == namespaceId && "vAlign" == name)
    return new TableCellVerticalAlignment();
    
if( 23 == namespaceId && "hideMark" == name)
    return new HideMark();
    
if( 23 == namespaceId && "cellIns" == name)
    return new CellInsertion();
    
if( 23 == namespaceId && "cellDel" == name)
    return new CellDeletion();
    
if( 23 == namespaceId && "cellMerge" == name)
    return new CellMerge();
    
if( 23 == namespaceId && "tcPrChange" == name)
    return new TableCellPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cnfStyle","tcW","gridSpan","hMerge","vMerge","tcBorders","shd","noWrap","tcMar","textDirection","tcFitText","vAlign","hideMark","cellIns","cellDel","cellMerge","tcPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ConditionalFormatStyle.</para>
    /// <para> Represents the following element tag in the schema: w:cnfStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConditionalFormatStyle ConditionalFormatStyle
    {
        get 
        {
            return GetElement<ConditionalFormatStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TableCellWidth.</para>
    /// <para> Represents the following element tag in the schema: w:tcW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellWidth TableCellWidth
    {
        get 
        {
            return GetElement<TableCellWidth>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> GridSpan.</para>
    /// <para> Represents the following element tag in the schema: w:gridSpan </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public GridSpan GridSpan
    {
        get 
        {
            return GetElement<GridSpan>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> HorizontalMerge.</para>
    /// <para> Represents the following element tag in the schema: w:hMerge </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HorizontalMerge HorizontalMerge
    {
        get 
        {
            return GetElement<HorizontalMerge>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> VerticalMerge.</para>
    /// <para> Represents the following element tag in the schema: w:vMerge </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalMerge VerticalMerge
    {
        get 
        {
            return GetElement<VerticalMerge>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableCellBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tcBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellBorders TableCellBorders
    {
        get 
        {
            return GetElement<TableCellBorders>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> NoWrap.</para>
    /// <para> Represents the following element tag in the schema: w:noWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoWrap NoWrap
    {
        get 
        {
            return GetElement<NoWrap>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> TableCellMargin.</para>
    /// <para> Represents the following element tag in the schema: w:tcMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMargin TableCellMargin
    {
        get 
        {
            return GetElement<TableCellMargin>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> TableCellFitText.</para>
    /// <para> Represents the following element tag in the schema: w:tcFitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellFitText TableCellFitText
    {
        get 
        {
            return GetElement<TableCellFitText>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> TableCellVerticalAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellVerticalAlignment TableCellVerticalAlignment
    {
        get 
        {
            return GetElement<TableCellVerticalAlignment>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> HideMark.</para>
    /// <para> Represents the following element tag in the schema: w:hideMark </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HideMark HideMark
    {
        get 
        {
            return GetElement<HideMark>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousTableProperties &lt;w:tblPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousTableProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TablePropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "tblPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11848;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TablePropertiesChange class.
    /// </summary>
    public TablePropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TablePropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TablePropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblPr" == name)
    return new PreviousTableProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Table Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tblPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousTableProperties PreviousTableProperties
    {
        get 
        {
            return GetElement<PreviousTableProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TablePropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Table-Level Property Exceptions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPrExChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousTablePropertyExceptions &lt;w:tblPrEx></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousTablePropertyExceptions))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TablePropertyExceptionsChange : OpenXmlCompositeElement
{
    private const string tagName = "tblPrExChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11849;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptionsChange class.
    /// </summary>
    public TablePropertyExceptionsChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TablePropertyExceptionsChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertyExceptionsChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptionsChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertyExceptionsChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptionsChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TablePropertyExceptionsChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblPrEx" == name)
    return new PreviousTablePropertyExceptions();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblPrEx" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Table-Level Property Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblPrEx </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousTablePropertyExceptions PreviousTablePropertyExceptions
    {
        get 
        {
            return GetElement<PreviousTablePropertyExceptions>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TablePropertyExceptionsChange>(deep);
    }

   
}
/// <summary>
/// <para>Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyle &lt;w:tblStyle></description></item>
///<item><description>TablePositionProperties &lt;w:tblpPr></description></item>
///<item><description>TableOverlap &lt;w:tblOverlap></description></item>
///<item><description>BiDiVisual &lt;w:bidiVisual></description></item>
///<item><description>TableWidth &lt;w:tblW></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableLayout &lt;w:tblLayout></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
///<item><description>TableLook &lt;w:tblLook></description></item>
///<item><description>TableCaption &lt;w:tblCaption></description></item>
///<item><description>TableDescription &lt;w:tblDescription></description></item>
///<item><description>TablePropertiesChange &lt;w:tblPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyle))]
    [ChildElementInfo(typeof(TablePositionProperties))]
    [ChildElementInfo(typeof(TableOverlap))]
    [ChildElementInfo(typeof(BiDiVisual))]
    [ChildElementInfo(typeof(TableWidth))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableLayout))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
    [ChildElementInfo(typeof(TableLook))]
    [ChildElementInfo(typeof(TableCaption),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(TableDescription),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(TablePropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11850;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableProperties class.
    /// </summary>
    public TableProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblStyle" == name)
    return new TableStyle();
    
if( 23 == namespaceId && "tblpPr" == name)
    return new TablePositionProperties();
    
if( 23 == namespaceId && "tblOverlap" == name)
    return new TableOverlap();
    
if( 23 == namespaceId && "bidiVisual" == name)
    return new BiDiVisual();
    
if( 23 == namespaceId && "tblW" == name)
    return new TableWidth();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblLayout" == name)
    return new TableLayout();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    
if( 23 == namespaceId && "tblLook" == name)
    return new TableLook();
    
if( 23 == namespaceId && "tblCaption" == name)
    return new TableCaption();
    
if( 23 == namespaceId && "tblDescription" == name)
    return new TableDescription();
    
if( 23 == namespaceId && "tblPrChange" == name)
    return new TablePropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblStyle","tblpPr","tblOverlap","bidiVisual","tblW","jc","tblCellSpacing","tblInd","tblBorders","shd","tblLayout","tblCellMar","tblLook","tblCaption","tblDescription","tblPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TableStyle.</para>
    /// <para> Represents the following element tag in the schema: w:tblStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyle TableStyle
    {
        get 
        {
            return GetElement<TableStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TablePositionProperties.</para>
    /// <para> Represents the following element tag in the schema: w:tblpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TablePositionProperties TablePositionProperties
    {
        get 
        {
            return GetElement<TablePositionProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> TableOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:tblOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableOverlap TableOverlap
    {
        get 
        {
            return GetElement<TableOverlap>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> BiDiVisual.</para>
    /// <para> Represents the following element tag in the schema: w:bidiVisual </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDiVisual BiDiVisual
    {
        get 
        {
            return GetElement<BiDiVisual>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> TableWidth.</para>
    /// <para> Represents the following element tag in the schema: w:tblW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableWidth TableWidth
    {
        get 
        {
            return GetElement<TableWidth>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableJustification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> TableCellSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> TableIndentation.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> TableBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> TableLayout.</para>
    /// <para> Represents the following element tag in the schema: w:tblLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLayout TableLayout
    {
        get 
        {
            return GetElement<TableLayout>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> TableCellMarginDefault.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> TableLook.</para>
    /// <para> Represents the following element tag in the schema: w:tblLook </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLook TableLook
    {
        get 
        {
            return GetElement<TableLook>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> TableCaption.</para>
    /// <para> Represents the following element tag in the schema: w:tblCaption </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCaption TableCaption
    {
        get 
        {
            return GetElement<TableCaption>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> TableDescription.</para>
    /// <para> Represents the following element tag in the schema: w:tblDescription </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableDescription TableDescription
    {
        get 
        {
            return GetElement<TableDescription>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Revision Information for Table Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tblPrChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TablePropertiesChange TablePropertiesChange
    {
        get 
        {
            return GetElement<TablePropertiesChange>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Grid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblGrid.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GridColumn &lt;w:gridCol></description></item>
///<item><description>TableGridChange &lt;w:tblGridChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GridColumn))]
    [ChildElementInfo(typeof(TableGridChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableGrid : OpenXmlCompositeElement
{
    private const string tagName = "tblGrid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11851;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class.
    /// </summary>
    public TableGrid():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGrid(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableGrid(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableGrid class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableGrid(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "gridCol" == name)
    return new GridColumn();
    
if( 23 == namespaceId && "tblGridChange" == name)
    return new TableGridChange();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableGrid>(deep);
    }

   
}
/// <summary>
/// <para>Footnote Placement.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pos.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnotePosition : OpenXmlLeafElement
{
    private const string tagName = "pos";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11852;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Footnote Position Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnotePositionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnotePositionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FootnotePosition class.
    /// </summary>
    public FootnotePosition():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnotePositionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnotePosition>(deep);
    }

   
}
/// <summary>
/// <para>Footnote Numbering Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numFmt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingFormat : OpenXmlLeafElement
{
    private const string tagName = "numFmt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11853;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","format" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Numbering Format Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> format.</para>
    /// <para>Represents the following attribute in the schema: w:format </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "format")]
    public StringValue Format
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingFormat class.
    /// </summary>
    public NumberingFormat():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>();
    
if( 23 == namespaceId && "format" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingFormat>(deep);
    }

   
}
/// <summary>
/// <para>Endnote Placement.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pos.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnotePosition : OpenXmlLeafElement
{
    private const string tagName = "pos";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11854;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Endnote Position Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.EndnotePositionValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.EndnotePositionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the EndnotePosition class.
    /// </summary>
    public EndnotePosition():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.EndnotePositionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnotePosition>(deep);
    }

   
}
/// <summary>
/// <para>Special Footnote List.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnote.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteSpecialReference : FootnoteEndnoteSeparatorReferenceType
{
    private const string tagName = "footnote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11855;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FootnoteSpecialReference class.
    /// </summary>
    public FootnoteSpecialReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteSpecialReference>(deep);
    }

}
/// <summary>
/// <para>Special Endnote List.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnote.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnoteSpecialReference : FootnoteEndnoteSeparatorReferenceType
{
    private const string tagName = "endnote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11856;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndnoteSpecialReference class.
    /// </summary>
    public EndnoteSpecialReference():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnoteSpecialReference>(deep);
    }

}
/// <summary>
/// Defines the FootnoteEndnoteSeparatorReferenceType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class FootnoteEndnoteSeparatorReferenceType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Footnote/Endnote ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public IntegerValue Id
    {
        get { return (IntegerValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new IntegerValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the FootnoteEndnoteSeparatorReferenceType class.
    /// </summary>
    protected FootnoteEndnoteSeparatorReferenceType(){}
    
    
    
}
/// <summary>
/// <para>Index of Column Containing Unique Values for Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:column.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnIndex : UnsignedDecimalNumberType
{
    private const string tagName = "column";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11858;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnIndex class.
    /// </summary>
    public ColumnIndex():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnIndex>(deep);
    }

}
/// <summary>
/// <para>Column Delimiter for Data Source.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:colDelim.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnDelimiter : UnsignedDecimalNumberType
{
    private const string tagName = "colDelim";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11868;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnDelimiter class.
    /// </summary>
    public ColumnDelimiter():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnDelimiter>(deep);
    }

}
/// <summary>
/// Defines the UnsignedDecimalNumberType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class UnsignedDecimalNumberType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the UnsignedDecimalNumberType class.
    /// </summary>
    protected UnsignedDecimalNumberType(){}
    
    
    
}
/// <summary>
/// <para>Unique Value for Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:uniqueTag.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UniqueTag : OpenXmlLeafElement
{
    private const string tagName = "uniqueTag";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11859;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Base64BinaryValue Val
    {
        get { return (Base64BinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the UniqueTag class.
    /// </summary>
    public UniqueTag():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Base64BinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UniqueTag>(deep);
    }

   
}
/// <summary>
/// <para>Data About Single Data Source Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:recipientData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Active &lt;w:active></description></item>
///<item><description>ColumnIndex &lt;w:column></description></item>
///<item><description>UniqueTag &lt;w:uniqueTag></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Active))]
    [ChildElementInfo(typeof(ColumnIndex))]
    [ChildElementInfo(typeof(UniqueTag))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RecipientData : OpenXmlCompositeElement
{
    private const string tagName = "recipientData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11860;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RecipientData class.
    /// </summary>
    public RecipientData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RecipientData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RecipientData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RecipientData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RecipientData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RecipientData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RecipientData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "active" == name)
    return new Active();
    
if( 23 == namespaceId && "column" == name)
    return new ColumnIndex();
    
if( 23 == namespaceId && "uniqueTag" == name)
    return new UniqueTag();
    

    return null;
}

        private static readonly string[] eleTagNames = { "active","column","uniqueTag" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Record Is Included in Mail Merge.</para>
    /// <para> Represents the following element tag in the schema: w:active </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Active Active
    {
        get 
        {
            return GetElement<Active>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Index of Column Containing Unique Values for Record.</para>
    /// <para> Represents the following element tag in the schema: w:column </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ColumnIndex ColumnIndex
    {
        get 
        {
            return GetElement<ColumnIndex>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Unique Value for Record.</para>
    /// <para> Represents the following element tag in the schema: w:uniqueTag </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UniqueTag UniqueTag
    {
        get 
        {
            return GetElement<UniqueTag>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RecipientData>(deep);
    }

   
}
/// <summary>
/// <para>Merge Field Mapping.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:type.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MailMergeFieldType : OpenXmlLeafElement
{
    private const string tagName = "type";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11861;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Merge Field Mapping Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeOdsoFieldValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeOdsoFieldValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MailMergeFieldType class.
    /// </summary>
    public MailMergeFieldType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeOdsoFieldValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MailMergeFieldType>(deep);
    }

   
}
/// <summary>
/// <para>ODSO Data Source Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:type.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MailMergeSource : OpenXmlLeafElement
{
    private const string tagName = "type";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11869;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Data Source Type Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeSourceValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeSourceValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MailMergeSource class.
    /// </summary>
    public MailMergeSource():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeSourceValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MailMergeSource>(deep);
    }

   
}
/// <summary>
/// <para>External Data Source to Merge Field Mapping.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:fieldMapData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MailMergeFieldType &lt;w:type></description></item>
///<item><description>Name &lt;w:name></description></item>
///<item><description>MappedName &lt;w:mappedName></description></item>
///<item><description>ColumnIndex &lt;w:column></description></item>
///<item><description>LanguageId &lt;w:lid></description></item>
///<item><description>DynamicAddress &lt;w:dynamicAddress></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MailMergeFieldType))]
    [ChildElementInfo(typeof(Name))]
    [ChildElementInfo(typeof(MappedName))]
    [ChildElementInfo(typeof(ColumnIndex))]
    [ChildElementInfo(typeof(LanguageId))]
    [ChildElementInfo(typeof(DynamicAddress))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldMapData : OpenXmlCompositeElement
{
    private const string tagName = "fieldMapData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11871;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FieldMapData class.
    /// </summary>
    public FieldMapData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FieldMapData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldMapData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldMapData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldMapData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldMapData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FieldMapData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new MailMergeFieldType();
    
if( 23 == namespaceId && "name" == name)
    return new Name();
    
if( 23 == namespaceId && "mappedName" == name)
    return new MappedName();
    
if( 23 == namespaceId && "column" == name)
    return new ColumnIndex();
    
if( 23 == namespaceId && "lid" == name)
    return new LanguageId();
    
if( 23 == namespaceId && "dynamicAddress" == name)
    return new DynamicAddress();
    

    return null;
}

        private static readonly string[] eleTagNames = { "type","name","mappedName","column","lid","dynamicAddress" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneAll;}
    }
    
        /// <summary>
    /// <para> Merge Field Mapping.</para>
    /// <para> Represents the following element tag in the schema: w:type </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MailMergeFieldType MailMergeFieldType
    {
        get 
        {
            return GetElement<MailMergeFieldType>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Data Source Name for Column.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Name Name
    {
        get 
        {
            return GetElement<Name>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Predefined Merge Field Name.</para>
    /// <para> Represents the following element tag in the schema: w:mappedName </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MappedName MappedName
    {
        get 
        {
            return GetElement<MappedName>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Index of Column Being Mapped.</para>
    /// <para> Represents the following element tag in the schema: w:column </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ColumnIndex ColumnIndex
    {
        get 
        {
            return GetElement<ColumnIndex>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Merge Field Name Language ID.</para>
    /// <para> Represents the following element tag in the schema: w:lid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LanguageId LanguageId
    {
        get 
        {
            return GetElement<LanguageId>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Use Country/Region-Based Address Field Ordering.</para>
    /// <para> Represents the following element tag in the schema: w:dynamicAddress </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DynamicAddress DynamicAddress
    {
        get 
        {
            return GetElement<DynamicAddress>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldMapData>(deep);
    }

   
}
/// <summary>
/// <para>Source Document Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mainDocumentType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MainDocumentType : OpenXmlLeafElement
{
    private const string tagName = "mainDocumentType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11873;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Mail Merge Source Document Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDocumentValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDocumentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MainDocumentType class.
    /// </summary>
    public MainDocumentType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDocumentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MainDocumentType>(deep);
    }

   
}
/// <summary>
/// <para>Data Source Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dataType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataType : OpenXmlLeafElement
{
    private const string tagName = "dataType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11875;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDataValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDataValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataType class.
    /// </summary>
    public DataType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDataValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataType>(deep);
    }

   
}
/// <summary>
/// <para>Merged Document Destination.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:destination.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Destination : OpenXmlLeafElement
{
    private const string tagName = "destination";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11881;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Mail Merge Merged Document Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDestinationValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDestinationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Destination class.
    /// </summary>
    public Destination():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MailMergeDestinationValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Destination>(deep);
    }

   
}
/// <summary>
/// <para>Office Data Source Object Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:odso.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>UdlConnectionString &lt;w:udl></description></item>
///<item><description>DataSourceTableName &lt;w:table></description></item>
///<item><description>SourceReference &lt;w:src></description></item>
///<item><description>ColumnDelimiter &lt;w:colDelim></description></item>
///<item><description>MailMergeSource &lt;w:type></description></item>
///<item><description>FirstRowHeader &lt;w:fHdr></description></item>
///<item><description>FieldMapData &lt;w:fieldMapData></description></item>
///<item><description>RecipientDataReference &lt;w:recipientData></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(UdlConnectionString))]
    [ChildElementInfo(typeof(DataSourceTableName))]
    [ChildElementInfo(typeof(SourceReference))]
    [ChildElementInfo(typeof(ColumnDelimiter))]
    [ChildElementInfo(typeof(MailMergeSource))]
    [ChildElementInfo(typeof(FirstRowHeader))]
    [ChildElementInfo(typeof(FieldMapData))]
    [ChildElementInfo(typeof(RecipientDataReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataSourceObject : OpenXmlCompositeElement
{
    private const string tagName = "odso";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11888;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DataSourceObject class.
    /// </summary>
    public DataSourceObject():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataSourceObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataSourceObject(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataSourceObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataSourceObject(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataSourceObject class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataSourceObject(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "udl" == name)
    return new UdlConnectionString();
    
if( 23 == namespaceId && "table" == name)
    return new DataSourceTableName();
    
if( 23 == namespaceId && "src" == name)
    return new SourceReference();
    
if( 23 == namespaceId && "colDelim" == name)
    return new ColumnDelimiter();
    
if( 23 == namespaceId && "type" == name)
    return new MailMergeSource();
    
if( 23 == namespaceId && "fHdr" == name)
    return new FirstRowHeader();
    
if( 23 == namespaceId && "fieldMapData" == name)
    return new FieldMapData();
    
if( 23 == namespaceId && "recipientData" == name)
    return new RecipientDataReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "udl","table","src","colDelim","type","fHdr","fieldMapData","recipientData" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> UDL Connection String.</para>
    /// <para> Represents the following element tag in the schema: w:udl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UdlConnectionString UdlConnectionString
    {
        get 
        {
            return GetElement<UdlConnectionString>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Data Source Table Name.</para>
    /// <para> Represents the following element tag in the schema: w:table </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DataSourceTableName DataSourceTableName
    {
        get 
        {
            return GetElement<DataSourceTableName>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ODSO Data Source File Path.</para>
    /// <para> Represents the following element tag in the schema: w:src </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SourceReference SourceReference
    {
        get 
        {
            return GetElement<SourceReference>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Column Delimiter for Data Source.</para>
    /// <para> Represents the following element tag in the schema: w:colDelim </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ColumnDelimiter ColumnDelimiter
    {
        get 
        {
            return GetElement<ColumnDelimiter>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ODSO Data Source Type.</para>
    /// <para> Represents the following element tag in the schema: w:type </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MailMergeSource MailMergeSource
    {
        get 
        {
            return GetElement<MailMergeSource>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> First Row of Data Source Contains Column Names.</para>
    /// <para> Represents the following element tag in the schema: w:fHdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FirstRowHeader FirstRowHeader
    {
        get 
        {
            return GetElement<FirstRowHeader>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataSourceObject>(deep);
    }

   
}
/// <summary>
/// <para>Single Document Variable.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docVar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocumentVariable : OpenXmlLeafElement
{
    private const string tagName = "docVar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11889;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","val" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Document Variable Name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Document Variable Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocumentVariable class.
    /// </summary>
    public DocumentVariable():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocumentVariable>(deep);
    }

   
}
/// <summary>
/// <para>Original Document Revision Save ID.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rsidRoot.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RsidRoot : LongHexNumberType
{
    private const string tagName = "rsidRoot";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11890;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RsidRoot class.
    /// </summary>
    public RsidRoot():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RsidRoot>(deep);
    }

}
/// <summary>
/// <para>Single Session Revision Save ID.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rsid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Rsid : LongHexNumberType
{
    private const string tagName = "rsid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11891;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Rsid class.
    /// </summary>
    public Rsid():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Rsid>(deep);
    }

}
/// <summary>
/// <para>Abstract Numbering Definition Identifier.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:nsid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Nsid : LongHexNumberType
{
    private const string tagName = "nsid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11922;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Nsid class.
    /// </summary>
    public Nsid():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Nsid>(deep);
    }

}
/// <summary>
/// <para>Numbering Template Code.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tmpl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TemplateCode : LongHexNumberType
{
    private const string tagName = "tmpl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11924;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TemplateCode class.
    /// </summary>
    public TemplateCode():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TemplateCode>(deep);
    }

}
/// <summary>
/// Defines the LongHexNumberType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class LongHexNumberType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Long Hexadecimal Number Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public HexBinaryValue Val
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the LongHexNumberType class.
    /// </summary>
    protected LongHexNumberType(){}
    
    
    
}
/// <summary>
/// <para>Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunPropertiesBaseStyle : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11892;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesBaseStyle class.
    /// </summary>
    public RunPropertiesBaseStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RunPropertiesBaseStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesBaseStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesBaseStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesBaseStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesBaseStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunPropertiesBaseStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","u","effect","bdr","shd","fitText","vertAlign","em","lang","eastAsianLayout","specVanish" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> RunFonts.</para>
    /// <para> Represents the following element tag in the schema: w:rFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunFonts RunFonts
    {
        get 
        {
            return GetElement<RunFonts>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Bold.</para>
    /// <para> Represents the following element tag in the schema: w:b </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Bold Bold
    {
        get 
        {
            return GetElement<Bold>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> BoldComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:bCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BoldComplexScript BoldComplexScript
    {
        get 
        {
            return GetElement<BoldComplexScript>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Italic.</para>
    /// <para> Represents the following element tag in the schema: w:i </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Italic Italic
    {
        get 
        {
            return GetElement<Italic>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ItalicComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:iCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ItalicComplexScript ItalicComplexScript
    {
        get 
        {
            return GetElement<ItalicComplexScript>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Caps.</para>
    /// <para> Represents the following element tag in the schema: w:caps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Caps Caps
    {
        get 
        {
            return GetElement<Caps>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> SmallCaps.</para>
    /// <para> Represents the following element tag in the schema: w:smallCaps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SmallCaps SmallCaps
    {
        get 
        {
            return GetElement<SmallCaps>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Strike.</para>
    /// <para> Represents the following element tag in the schema: w:strike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Strike Strike
    {
        get 
        {
            return GetElement<Strike>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> DoubleStrike.</para>
    /// <para> Represents the following element tag in the schema: w:dstrike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoubleStrike DoubleStrike
    {
        get 
        {
            return GetElement<DoubleStrike>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: w:outline </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Shadow.</para>
    /// <para> Represents the following element tag in the schema: w:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shadow Shadow
    {
        get 
        {
            return GetElement<Shadow>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Emboss.</para>
    /// <para> Represents the following element tag in the schema: w:emboss </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emboss Emboss
    {
        get 
        {
            return GetElement<Emboss>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Imprint.</para>
    /// <para> Represents the following element tag in the schema: w:imprint </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Imprint Imprint
    {
        get 
        {
            return GetElement<Imprint>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> NoProof.</para>
    /// <para> Represents the following element tag in the schema: w:noProof </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoProof NoProof
    {
        get 
        {
            return GetElement<NoProof>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Vanish.</para>
    /// <para> Represents the following element tag in the schema: w:vanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Vanish Vanish
    {
        get 
        {
            return GetElement<Vanish>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> WebHidden.</para>
    /// <para> Represents the following element tag in the schema: w:webHidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WebHidden WebHidden
    {
        get 
        {
            return GetElement<WebHidden>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: w:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Spacing Spacing
    {
        get 
        {
            return GetElement<Spacing>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> CharacterScale.</para>
    /// <para> Represents the following element tag in the schema: w:w </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CharacterScale CharacterScale
    {
        get 
        {
            return GetElement<CharacterScale>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Kern.</para>
    /// <para> Represents the following element tag in the schema: w:kern </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kern Kern
    {
        get 
        {
            return GetElement<Kern>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: w:position </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> FontSize.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSize FontSize
    {
        get 
        {
            return GetElement<FontSize>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> FontSizeComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:szCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSizeComplexScript FontSizeComplexScript
    {
        get 
        {
            return GetElement<FontSizeComplexScript>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> Underline.</para>
    /// <para> Represents the following element tag in the schema: w:u </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Underline Underline
    {
        get 
        {
            return GetElement<Underline>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> TextEffect.</para>
    /// <para> Represents the following element tag in the schema: w:effect </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextEffect TextEffect
    {
        get 
        {
            return GetElement<TextEffect>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Border.</para>
    /// <para> Represents the following element tag in the schema: w:bdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Border Border
    {
        get 
        {
            return GetElement<Border>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> FitText.</para>
    /// <para> Represents the following element tag in the schema: w:fitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FitText FitText
    {
        get 
        {
            return GetElement<FitText>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> VerticalTextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vertAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalTextAlignment VerticalTextAlignment
    {
        get 
        {
            return GetElement<VerticalTextAlignment>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> Emphasis.</para>
    /// <para> Represents the following element tag in the schema: w:em </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emphasis Emphasis
    {
        get 
        {
            return GetElement<Emphasis>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> Languages.</para>
    /// <para> Represents the following element tag in the schema: w:lang </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Languages Languages
    {
        get 
        {
            return GetElement<Languages>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> EastAsianLayout.</para>
    /// <para> Represents the following element tag in the schema: w:eastAsianLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EastAsianLayout EastAsianLayout
    {
        get 
        {
            return GetElement<EastAsianLayout>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> SpecVanish.</para>
    /// <para> Represents the following element tag in the schema: w:specVanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpecVanish SpecVanish
    {
        get 
        {
            return GetElement<SpecVanish>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunPropertiesBaseStyle>(deep);
    }

   
}
/// <summary>
/// <para>Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>KeepNext &lt;w:keepNext></description></item>
///<item><description>KeepLines &lt;w:keepLines></description></item>
///<item><description>PageBreakBefore &lt;w:pageBreakBefore></description></item>
///<item><description>FrameProperties &lt;w:framePr></description></item>
///<item><description>WidowControl &lt;w:widowControl></description></item>
///<item><description>NumberingProperties &lt;w:numPr></description></item>
///<item><description>SuppressLineNumbers &lt;w:suppressLineNumbers></description></item>
///<item><description>ParagraphBorders &lt;w:pBdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>Tabs &lt;w:tabs></description></item>
///<item><description>SuppressAutoHyphens &lt;w:suppressAutoHyphens></description></item>
///<item><description>Kinsoku &lt;w:kinsoku></description></item>
///<item><description>WordWrap &lt;w:wordWrap></description></item>
///<item><description>OverflowPunctuation &lt;w:overflowPunct></description></item>
///<item><description>TopLinePunctuation &lt;w:topLinePunct></description></item>
///<item><description>AutoSpaceDE &lt;w:autoSpaceDE></description></item>
///<item><description>AutoSpaceDN &lt;w:autoSpaceDN></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>AdjustRightIndent &lt;w:adjustRightInd></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>SpacingBetweenLines &lt;w:spacing></description></item>
///<item><description>Indentation &lt;w:ind></description></item>
///<item><description>ContextualSpacing &lt;w:contextualSpacing></description></item>
///<item><description>MirrorIndents &lt;w:mirrorIndents></description></item>
///<item><description>SuppressOverlap &lt;w:suppressOverlap></description></item>
///<item><description>Justification &lt;w:jc></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TextAlignment &lt;w:textAlignment></description></item>
///<item><description>TextBoxTightWrap &lt;w:textboxTightWrap></description></item>
///<item><description>OutlineLevel &lt;w:outlineLvl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(KeepNext))]
    [ChildElementInfo(typeof(KeepLines))]
    [ChildElementInfo(typeof(PageBreakBefore))]
    [ChildElementInfo(typeof(FrameProperties))]
    [ChildElementInfo(typeof(WidowControl))]
    [ChildElementInfo(typeof(NumberingProperties))]
    [ChildElementInfo(typeof(SuppressLineNumbers))]
    [ChildElementInfo(typeof(ParagraphBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(Tabs))]
    [ChildElementInfo(typeof(SuppressAutoHyphens))]
    [ChildElementInfo(typeof(Kinsoku))]
    [ChildElementInfo(typeof(WordWrap))]
    [ChildElementInfo(typeof(OverflowPunctuation))]
    [ChildElementInfo(typeof(TopLinePunctuation))]
    [ChildElementInfo(typeof(AutoSpaceDE))]
    [ChildElementInfo(typeof(AutoSpaceDN))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(AdjustRightIndent))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(SpacingBetweenLines))]
    [ChildElementInfo(typeof(Indentation))]
    [ChildElementInfo(typeof(ContextualSpacing))]
    [ChildElementInfo(typeof(MirrorIndents))]
    [ChildElementInfo(typeof(SuppressOverlap))]
    [ChildElementInfo(typeof(Justification))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TextAlignment))]
    [ChildElementInfo(typeof(TextBoxTightWrap))]
    [ChildElementInfo(typeof(OutlineLevel))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphPropertiesBaseStyle : OpenXmlCompositeElement
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11893;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesBaseStyle class.
    /// </summary>
    public ParagraphPropertiesBaseStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphPropertiesBaseStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesBaseStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesBaseStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesBaseStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesBaseStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphPropertiesBaseStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "keepNext" == name)
    return new KeepNext();
    
if( 23 == namespaceId && "keepLines" == name)
    return new KeepLines();
    
if( 23 == namespaceId && "pageBreakBefore" == name)
    return new PageBreakBefore();
    
if( 23 == namespaceId && "framePr" == name)
    return new FrameProperties();
    
if( 23 == namespaceId && "widowControl" == name)
    return new WidowControl();
    
if( 23 == namespaceId && "numPr" == name)
    return new NumberingProperties();
    
if( 23 == namespaceId && "suppressLineNumbers" == name)
    return new SuppressLineNumbers();
    
if( 23 == namespaceId && "pBdr" == name)
    return new ParagraphBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tabs" == name)
    return new Tabs();
    
if( 23 == namespaceId && "suppressAutoHyphens" == name)
    return new SuppressAutoHyphens();
    
if( 23 == namespaceId && "kinsoku" == name)
    return new Kinsoku();
    
if( 23 == namespaceId && "wordWrap" == name)
    return new WordWrap();
    
if( 23 == namespaceId && "overflowPunct" == name)
    return new OverflowPunctuation();
    
if( 23 == namespaceId && "topLinePunct" == name)
    return new TopLinePunctuation();
    
if( 23 == namespaceId && "autoSpaceDE" == name)
    return new AutoSpaceDE();
    
if( 23 == namespaceId && "autoSpaceDN" == name)
    return new AutoSpaceDN();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "adjustRightInd" == name)
    return new AdjustRightIndent();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "spacing" == name)
    return new SpacingBetweenLines();
    
if( 23 == namespaceId && "ind" == name)
    return new Indentation();
    
if( 23 == namespaceId && "contextualSpacing" == name)
    return new ContextualSpacing();
    
if( 23 == namespaceId && "mirrorIndents" == name)
    return new MirrorIndents();
    
if( 23 == namespaceId && "suppressOverlap" == name)
    return new SuppressOverlap();
    
if( 23 == namespaceId && "jc" == name)
    return new Justification();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "textAlignment" == name)
    return new TextAlignment();
    
if( 23 == namespaceId && "textboxTightWrap" == name)
    return new TextBoxTightWrap();
    
if( 23 == namespaceId && "outlineLvl" == name)
    return new OutlineLevel();
    

    return null;
}

        private static readonly string[] eleTagNames = { "keepNext","keepLines","pageBreakBefore","framePr","widowControl","numPr","suppressLineNumbers","pBdr","shd","tabs","suppressAutoHyphens","kinsoku","wordWrap","overflowPunct","topLinePunct","autoSpaceDE","autoSpaceDN","bidi","adjustRightInd","snapToGrid","spacing","ind","contextualSpacing","mirrorIndents","suppressOverlap","jc","textDirection","textAlignment","textboxTightWrap","outlineLvl" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> KeepNext.</para>
    /// <para> Represents the following element tag in the schema: w:keepNext </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepNext KeepNext
    {
        get 
        {
            return GetElement<KeepNext>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> KeepLines.</para>
    /// <para> Represents the following element tag in the schema: w:keepLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepLines KeepLines
    {
        get 
        {
            return GetElement<KeepLines>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> PageBreakBefore.</para>
    /// <para> Represents the following element tag in the schema: w:pageBreakBefore </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBreakBefore PageBreakBefore
    {
        get 
        {
            return GetElement<PageBreakBefore>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> FrameProperties.</para>
    /// <para> Represents the following element tag in the schema: w:framePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameProperties FrameProperties
    {
        get 
        {
            return GetElement<FrameProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> WidowControl.</para>
    /// <para> Represents the following element tag in the schema: w:widowControl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WidowControl WidowControl
    {
        get 
        {
            return GetElement<WidowControl>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> NumberingProperties.</para>
    /// <para> Represents the following element tag in the schema: w:numPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingProperties NumberingProperties
    {
        get 
        {
            return GetElement<NumberingProperties>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> SuppressLineNumbers.</para>
    /// <para> Represents the following element tag in the schema: w:suppressLineNumbers </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressLineNumbers SuppressLineNumbers
    {
        get 
        {
            return GetElement<SuppressLineNumbers>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> ParagraphBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphBorders ParagraphBorders
    {
        get 
        {
            return GetElement<ParagraphBorders>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Tabs.</para>
    /// <para> Represents the following element tag in the schema: w:tabs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Tabs Tabs
    {
        get 
        {
            return GetElement<Tabs>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> SuppressAutoHyphens.</para>
    /// <para> Represents the following element tag in the schema: w:suppressAutoHyphens </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressAutoHyphens SuppressAutoHyphens
    {
        get 
        {
            return GetElement<SuppressAutoHyphens>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Kinsoku.</para>
    /// <para> Represents the following element tag in the schema: w:kinsoku </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kinsoku Kinsoku
    {
        get 
        {
            return GetElement<Kinsoku>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> WordWrap.</para>
    /// <para> Represents the following element tag in the schema: w:wordWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordWrap WordWrap
    {
        get 
        {
            return GetElement<WordWrap>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> OverflowPunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:overflowPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OverflowPunctuation OverflowPunctuation
    {
        get 
        {
            return GetElement<OverflowPunctuation>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> TopLinePunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:topLinePunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLinePunctuation TopLinePunctuation
    {
        get 
        {
            return GetElement<TopLinePunctuation>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDE.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDE </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDE AutoSpaceDE
    {
        get 
        {
            return GetElement<AutoSpaceDE>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDN.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDN </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDN AutoSpaceDN
    {
        get 
        {
            return GetElement<AutoSpaceDN>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> AdjustRightIndent.</para>
    /// <para> Represents the following element tag in the schema: w:adjustRightInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustRightIndent AdjustRightIndent
    {
        get 
        {
            return GetElement<AdjustRightIndent>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> SpacingBetweenLines.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingBetweenLines SpacingBetweenLines
    {
        get 
        {
            return GetElement<SpacingBetweenLines>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:ind </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Indentation Indentation
    {
        get 
        {
            return GetElement<Indentation>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> ContextualSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:contextualSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ContextualSpacing ContextualSpacing
    {
        get 
        {
            return GetElement<ContextualSpacing>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> MirrorIndents.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorIndents </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorIndents MirrorIndents
    {
        get 
        {
            return GetElement<MirrorIndents>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> SuppressOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:suppressOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressOverlap SuppressOverlap
    {
        get 
        {
            return GetElement<SuppressOverlap>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Justification Justification
    {
        get 
        {
            return GetElement<Justification>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:textAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextAlignment TextAlignment
    {
        get 
        {
            return GetElement<TextAlignment>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> TextBoxTightWrap.</para>
    /// <para> Represents the following element tag in the schema: w:textboxTightWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxTightWrap TextBoxTightWrap
    {
        get 
        {
            return GetElement<TextBoxTightWrap>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> OutlineLevel.</para>
    /// <para> Represents the following element tag in the schema: w:outlineLvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OutlineLevel OutlineLevel
    {
        get 
        {
            return GetElement<OutlineLevel>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphPropertiesBaseStyle>(deep);
    }

   
}
/// <summary>
/// <para>Default Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPrDefault.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunPropertiesBaseStyle &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunPropertiesBaseStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunPropertiesDefault : OpenXmlCompositeElement
{
    private const string tagName = "rPrDefault";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11894;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesDefault class.
    /// </summary>
    public RunPropertiesDefault():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RunPropertiesDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunPropertiesDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunPropertiesDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunPropertiesDefault(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPr" == name)
    return new RunPropertiesBaseStyle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunPropertiesBaseStyle RunPropertiesBaseStyle
    {
        get 
        {
            return GetElement<RunPropertiesBaseStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunPropertiesDefault>(deep);
    }

   
}
/// <summary>
/// <para>Default Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPrDefault.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphPropertiesBaseStyle &lt;w:pPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphPropertiesBaseStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphPropertiesDefault : OpenXmlCompositeElement
{
    private const string tagName = "pPrDefault";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11895;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesDefault class.
    /// </summary>
    public ParagraphPropertiesDefault():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphPropertiesDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesDefault(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesDefault class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphPropertiesDefault(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphPropertiesDefault class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphPropertiesDefault(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pPr" == name)
    return new ParagraphPropertiesBaseStyle();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphPropertiesBaseStyle ParagraphPropertiesBaseStyle
    {
        get 
        {
            return GetElement<ParagraphPropertiesBaseStyle>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphPropertiesDefault>(deep);
    }

   
}
/// <summary>
/// <para>Left and Right Margin for Frame.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marW.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MarginWidth : PixelsMeasureType
{
    private const string tagName = "marW";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11899;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MarginWidth class.
    /// </summary>
    public MarginWidth():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MarginWidth>(deep);
    }

}
/// <summary>
/// <para>Top and Bottom Margin for Frame.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marH.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MarginHeight : PixelsMeasureType
{
    private const string tagName = "marH";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11900;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MarginHeight class.
    /// </summary>
    public MarginHeight():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MarginHeight>(deep);
    }

}
/// <summary>
/// Defines the PixelsMeasureType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PixelsMeasureType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Measurement in Pixels.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PixelsMeasureType class.
    /// </summary>
    protected PixelsMeasureType(){}
    
    
    
}
/// <summary>
/// <para>Scrollbar Display Option.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:scrollbar.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ScrollbarVisibility : OpenXmlLeafElement
{
    private const string tagName = "scrollbar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11901;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Scrollbar Display Option Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameScrollbarVisibilityValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameScrollbarVisibilityValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ScrollbarVisibility class.
    /// </summary>
    public ScrollbarVisibility():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameScrollbarVisibilityValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ScrollbarVisibility>(deep);
    }

   
}
/// <summary>
/// <para>Frameset Splitter Width.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:w.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Width : TwipsMeasureType
{
    private const string tagName = "w";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11904;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Width class.
    /// </summary>
    public Width():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Width>(deep);
    }

}
/// <summary>
/// <para>Hyphenation Zone.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hyphenationZone.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HyphenationZone : TwipsMeasureType
{
    private const string tagName = "hyphenationZone";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12144;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HyphenationZone class.
    /// </summary>
    public HyphenationZone():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HyphenationZone>(deep);
    }

}
/// <summary>
/// <para>Drawing Grid Horizontal Grid Unit Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:drawingGridHorizontalSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DrawingGridHorizontalSpacing : TwipsMeasureType
{
    private const string tagName = "drawingGridHorizontalSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12154;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DrawingGridHorizontalSpacing class.
    /// </summary>
    public DrawingGridHorizontalSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DrawingGridHorizontalSpacing>(deep);
    }

}
/// <summary>
/// <para>Drawing Grid Vertical Grid Unit Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:drawingGridVerticalSpacing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DrawingGridVerticalSpacing : TwipsMeasureType
{
    private const string tagName = "drawingGridVerticalSpacing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12155;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DrawingGridVerticalSpacing class.
    /// </summary>
    public DrawingGridVerticalSpacing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DrawingGridVerticalSpacing>(deep);
    }

}
/// <summary>
/// <para>Drawing Grid Horizontal Origin Point.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:drawingGridHorizontalOrigin.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DrawingGridHorizontalOrigin : TwipsMeasureType
{
    private const string tagName = "drawingGridHorizontalOrigin";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12159;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DrawingGridHorizontalOrigin class.
    /// </summary>
    public DrawingGridHorizontalOrigin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DrawingGridHorizontalOrigin>(deep);
    }

}
/// <summary>
/// <para>Drawing Grid Vertical Origin Point.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:drawingGridVerticalOrigin.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DrawingGridVerticalOrigin : TwipsMeasureType
{
    private const string tagName = "drawingGridVerticalOrigin";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12160;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DrawingGridVerticalOrigin class.
    /// </summary>
    public DrawingGridVerticalOrigin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DrawingGridVerticalOrigin>(deep);
    }

}
/// <summary>
/// Defines the TwipsMeasureType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TwipsMeasureType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Measurement in Twentieths of a Point.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TwipsMeasureType class.
    /// </summary>
    protected TwipsMeasureType(){}
    
    
    
}
/// <summary>
/// <para>Frameset Splitter Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:framesetSplitbar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Width &lt;w:w></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>NoBorder &lt;w:noBorder></description></item>
///<item><description>FlatBorders &lt;w:flatBorders></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Width))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(NoBorder))]
    [ChildElementInfo(typeof(FlatBorders))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FramesetSplitbar : OpenXmlCompositeElement
{
    private const string tagName = "framesetSplitbar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11907;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FramesetSplitbar class.
    /// </summary>
    public FramesetSplitbar():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FramesetSplitbar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FramesetSplitbar(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FramesetSplitbar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FramesetSplitbar(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FramesetSplitbar class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FramesetSplitbar(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new Width();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "noBorder" == name)
    return new NoBorder();
    
if( 23 == namespaceId && "flatBorders" == name)
    return new FlatBorders();
    

    return null;
}

        private static readonly string[] eleTagNames = { "w","color","noBorder","flatBorders" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Frameset Splitter Width.</para>
    /// <para> Represents the following element tag in the schema: w:w </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Width Width
    {
        get 
        {
            return GetElement<Width>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Frameset Splitter Color.</para>
    /// <para> Represents the following element tag in the schema: w:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Do Not Display Frameset Splitters.</para>
    /// <para> Represents the following element tag in the schema: w:noBorder </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoBorder NoBorder
    {
        get 
        {
            return GetElement<NoBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Frameset Splitter Border Style.</para>
    /// <para> Represents the following element tag in the schema: w:flatBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FlatBorders FlatBorders
    {
        get 
        {
            return GetElement<FlatBorders>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FramesetSplitbar>(deep);
    }

   
}
/// <summary>
/// <para>Frameset Layout.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:frameLayout.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FrameLayout : OpenXmlLeafElement
{
    private const string tagName = "frameLayout";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11908;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Frameset Layout Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameLayoutValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameLayoutValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FrameLayout class.
    /// </summary>
    public FrameLayout():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FrameLayoutValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FrameLayout>(deep);
    }

   
}
/// <summary>
/// <para>Nested Frameset Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:frameset.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FrameSize &lt;w:sz></description></item>
///<item><description>FramesetSplitbar &lt;w:framesetSplitbar></description></item>
///<item><description>FrameLayout &lt;w:frameLayout></description></item>
///<item><description>Frameset &lt;w:frameset></description></item>
///<item><description>Frame &lt;w:frame></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FrameSize))]
    [ChildElementInfo(typeof(FramesetSplitbar))]
    [ChildElementInfo(typeof(FrameLayout))]
    [ChildElementInfo(typeof(Frameset))]
    [ChildElementInfo(typeof(Frame))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Frameset : OpenXmlCompositeElement
{
    private const string tagName = "frameset";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11909;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Frameset class.
    /// </summary>
    public Frameset():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Frameset class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Frameset(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Frameset class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Frameset(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Frameset class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Frameset(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sz" == name)
    return new FrameSize();
    
if( 23 == namespaceId && "framesetSplitbar" == name)
    return new FramesetSplitbar();
    
if( 23 == namespaceId && "frameLayout" == name)
    return new FrameLayout();
    
if( 23 == namespaceId && "frameset" == name)
    return new Frameset();
    
if( 23 == namespaceId && "frame" == name)
    return new Frame();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sz","framesetSplitbar","frameLayout","frameset","frame" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Nested Frameset Size.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameSize FrameSize
    {
        get 
        {
            return GetElement<FrameSize>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Frameset Splitter Properties.</para>
    /// <para> Represents the following element tag in the schema: w:framesetSplitbar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FramesetSplitbar FramesetSplitbar
    {
        get 
        {
            return GetElement<FramesetSplitbar>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Frameset Layout.</para>
    /// <para> Represents the following element tag in the schema: w:frameLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameLayout FrameLayout
    {
        get 
        {
            return GetElement<FrameLayout>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Frameset>(deep);
    }

   
}
/// <summary>
/// <para>Single Frame Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:frame.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FrameSize &lt;w:sz></description></item>
///<item><description>FrameName &lt;w:name></description></item>
///<item><description>SourceFileReference &lt;w:sourceFileName></description></item>
///<item><description>MarginWidth &lt;w:marW></description></item>
///<item><description>MarginHeight &lt;w:marH></description></item>
///<item><description>ScrollbarVisibility &lt;w:scrollbar></description></item>
///<item><description>NoResizeAllowed &lt;w:noResizeAllowed></description></item>
///<item><description>LinkedToFile &lt;w:linkedToFile></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FrameSize))]
    [ChildElementInfo(typeof(FrameName))]
    [ChildElementInfo(typeof(SourceFileReference))]
    [ChildElementInfo(typeof(MarginWidth))]
    [ChildElementInfo(typeof(MarginHeight))]
    [ChildElementInfo(typeof(ScrollbarVisibility))]
    [ChildElementInfo(typeof(NoResizeAllowed))]
    [ChildElementInfo(typeof(LinkedToFile))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Frame : OpenXmlCompositeElement
{
    private const string tagName = "frame";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11910;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Frame class.
    /// </summary>
    public Frame():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Frame class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Frame(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Frame class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Frame(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Frame class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Frame(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "sz" == name)
    return new FrameSize();
    
if( 23 == namespaceId && "name" == name)
    return new FrameName();
    
if( 23 == namespaceId && "sourceFileName" == name)
    return new SourceFileReference();
    
if( 23 == namespaceId && "marW" == name)
    return new MarginWidth();
    
if( 23 == namespaceId && "marH" == name)
    return new MarginHeight();
    
if( 23 == namespaceId && "scrollbar" == name)
    return new ScrollbarVisibility();
    
if( 23 == namespaceId && "noResizeAllowed" == name)
    return new NoResizeAllowed();
    
if( 23 == namespaceId && "linkedToFile" == name)
    return new LinkedToFile();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sz","name","sourceFileName","marW","marH","scrollbar","noResizeAllowed","linkedToFile" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Frame Size.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameSize FrameSize
    {
        get 
        {
            return GetElement<FrameSize>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Frame Name.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameName FrameName
    {
        get 
        {
            return GetElement<FrameName>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Source File for Frame.</para>
    /// <para> Represents the following element tag in the schema: w:sourceFileName </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SourceFileReference SourceFileReference
    {
        get 
        {
            return GetElement<SourceFileReference>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Left and Right Margin for Frame.</para>
    /// <para> Represents the following element tag in the schema: w:marW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MarginWidth MarginWidth
    {
        get 
        {
            return GetElement<MarginWidth>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Top and Bottom Margin for Frame.</para>
    /// <para> Represents the following element tag in the schema: w:marH </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MarginHeight MarginHeight
    {
        get 
        {
            return GetElement<MarginHeight>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Scrollbar Display Option.</para>
    /// <para> Represents the following element tag in the schema: w:scrollbar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ScrollbarVisibility ScrollbarVisibility
    {
        get 
        {
            return GetElement<ScrollbarVisibility>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Frame Cannot Be Resized.</para>
    /// <para> Represents the following element tag in the schema: w:noResizeAllowed </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoResizeAllowed NoResizeAllowed
    {
        get 
        {
            return GetElement<NoResizeAllowed>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Maintain Link to Existing File.</para>
    /// <para> Represents the following element tag in the schema: w:linkedToFile </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LinkedToFile LinkedToFile
    {
        get 
        {
            return GetElement<LinkedToFile>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Frame>(deep);
    }

   
}
/// <summary>
/// <para>Content Between Numbering Symbol and Paragraph Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:suff.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelSuffix : OpenXmlLeafElement
{
    private const string tagName = "suff";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11915;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Character Type Between Numbering and Text.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelSuffixValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelSuffixValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelSuffix class.
    /// </summary>
    public LevelSuffix():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelSuffixValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelSuffix>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Level Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvlText.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelText : OpenXmlLeafElement
{
    private const string tagName = "lvlText";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11916;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","null" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Level Text.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Level Text Is Null Character.</para>
    /// <para>Represents the following attribute in the schema: w:null </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "null")]
    public OnOffValue Null
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelText class.
    /// </summary>
    public LevelText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "null" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelText>(deep);
    }

   
}
/// <summary>
/// <para>Legacy Numbering Level Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:legacy.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LegacyNumbering : OpenXmlLeafElement
{
    private const string tagName = "legacy";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11918;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "legacy","legacySpace","legacyIndent" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Use Legacy Numbering Properties.</para>
    /// <para>Represents the following attribute in the schema: w:legacy </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "legacy")]
    public OnOffValue Legacy
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Legacy Spacing.</para>
    /// <para>Represents the following attribute in the schema: w:legacySpace </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "legacySpace")]
    public StringValue LegacySpace
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Legacy Indent.</para>
    /// <para>Represents the following attribute in the schema: w:legacyIndent </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "legacyIndent")]
    public StringValue LegacyIndent
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LegacyNumbering class.
    /// </summary>
    public LegacyNumbering():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "legacy" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "legacySpace" == name)
    return new StringValue();
    
if( 23 == namespaceId && "legacyIndent" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LegacyNumbering>(deep);
    }

   
}
/// <summary>
/// <para>Justification.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvlJc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelJustification : OpenXmlLeafElement
{
    private const string tagName = "lvlJc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11919;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Alignment Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelJustificationValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelJustificationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelJustification class.
    /// </summary>
    public LevelJustification():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.LevelJustificationValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelJustification>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Level Associated Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphStyleId &lt;w:pStyle></description></item>
///<item><description>KeepNext &lt;w:keepNext></description></item>
///<item><description>KeepLines &lt;w:keepLines></description></item>
///<item><description>PageBreakBefore &lt;w:pageBreakBefore></description></item>
///<item><description>FrameProperties &lt;w:framePr></description></item>
///<item><description>WidowControl &lt;w:widowControl></description></item>
///<item><description>NumberingProperties &lt;w:numPr></description></item>
///<item><description>SuppressLineNumbers &lt;w:suppressLineNumbers></description></item>
///<item><description>ParagraphBorders &lt;w:pBdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>Tabs &lt;w:tabs></description></item>
///<item><description>SuppressAutoHyphens &lt;w:suppressAutoHyphens></description></item>
///<item><description>Kinsoku &lt;w:kinsoku></description></item>
///<item><description>WordWrap &lt;w:wordWrap></description></item>
///<item><description>OverflowPunctuation &lt;w:overflowPunct></description></item>
///<item><description>TopLinePunctuation &lt;w:topLinePunct></description></item>
///<item><description>AutoSpaceDE &lt;w:autoSpaceDE></description></item>
///<item><description>AutoSpaceDN &lt;w:autoSpaceDN></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>AdjustRightIndent &lt;w:adjustRightInd></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>SpacingBetweenLines &lt;w:spacing></description></item>
///<item><description>Indentation &lt;w:ind></description></item>
///<item><description>ContextualSpacing &lt;w:contextualSpacing></description></item>
///<item><description>MirrorIndents &lt;w:mirrorIndents></description></item>
///<item><description>SuppressOverlap &lt;w:suppressOverlap></description></item>
///<item><description>Justification &lt;w:jc></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TextAlignment &lt;w:textAlignment></description></item>
///<item><description>TextBoxTightWrap &lt;w:textboxTightWrap></description></item>
///<item><description>OutlineLevel &lt;w:outlineLvl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphStyleId))]
    [ChildElementInfo(typeof(KeepNext))]
    [ChildElementInfo(typeof(KeepLines))]
    [ChildElementInfo(typeof(PageBreakBefore))]
    [ChildElementInfo(typeof(FrameProperties))]
    [ChildElementInfo(typeof(WidowControl))]
    [ChildElementInfo(typeof(NumberingProperties))]
    [ChildElementInfo(typeof(SuppressLineNumbers))]
    [ChildElementInfo(typeof(ParagraphBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(Tabs))]
    [ChildElementInfo(typeof(SuppressAutoHyphens))]
    [ChildElementInfo(typeof(Kinsoku))]
    [ChildElementInfo(typeof(WordWrap))]
    [ChildElementInfo(typeof(OverflowPunctuation))]
    [ChildElementInfo(typeof(TopLinePunctuation))]
    [ChildElementInfo(typeof(AutoSpaceDE))]
    [ChildElementInfo(typeof(AutoSpaceDN))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(AdjustRightIndent))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(SpacingBetweenLines))]
    [ChildElementInfo(typeof(Indentation))]
    [ChildElementInfo(typeof(ContextualSpacing))]
    [ChildElementInfo(typeof(MirrorIndents))]
    [ChildElementInfo(typeof(SuppressOverlap))]
    [ChildElementInfo(typeof(Justification))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TextAlignment))]
    [ChildElementInfo(typeof(TextBoxTightWrap))]
    [ChildElementInfo(typeof(OutlineLevel))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousParagraphProperties : OpenXmlCompositeElement
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11920;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphProperties class.
    /// </summary>
    public PreviousParagraphProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pStyle" == name)
    return new ParagraphStyleId();
    
if( 23 == namespaceId && "keepNext" == name)
    return new KeepNext();
    
if( 23 == namespaceId && "keepLines" == name)
    return new KeepLines();
    
if( 23 == namespaceId && "pageBreakBefore" == name)
    return new PageBreakBefore();
    
if( 23 == namespaceId && "framePr" == name)
    return new FrameProperties();
    
if( 23 == namespaceId && "widowControl" == name)
    return new WidowControl();
    
if( 23 == namespaceId && "numPr" == name)
    return new NumberingProperties();
    
if( 23 == namespaceId && "suppressLineNumbers" == name)
    return new SuppressLineNumbers();
    
if( 23 == namespaceId && "pBdr" == name)
    return new ParagraphBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tabs" == name)
    return new Tabs();
    
if( 23 == namespaceId && "suppressAutoHyphens" == name)
    return new SuppressAutoHyphens();
    
if( 23 == namespaceId && "kinsoku" == name)
    return new Kinsoku();
    
if( 23 == namespaceId && "wordWrap" == name)
    return new WordWrap();
    
if( 23 == namespaceId && "overflowPunct" == name)
    return new OverflowPunctuation();
    
if( 23 == namespaceId && "topLinePunct" == name)
    return new TopLinePunctuation();
    
if( 23 == namespaceId && "autoSpaceDE" == name)
    return new AutoSpaceDE();
    
if( 23 == namespaceId && "autoSpaceDN" == name)
    return new AutoSpaceDN();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "adjustRightInd" == name)
    return new AdjustRightIndent();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "spacing" == name)
    return new SpacingBetweenLines();
    
if( 23 == namespaceId && "ind" == name)
    return new Indentation();
    
if( 23 == namespaceId && "contextualSpacing" == name)
    return new ContextualSpacing();
    
if( 23 == namespaceId && "mirrorIndents" == name)
    return new MirrorIndents();
    
if( 23 == namespaceId && "suppressOverlap" == name)
    return new SuppressOverlap();
    
if( 23 == namespaceId && "jc" == name)
    return new Justification();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "textAlignment" == name)
    return new TextAlignment();
    
if( 23 == namespaceId && "textboxTightWrap" == name)
    return new TextBoxTightWrap();
    
if( 23 == namespaceId && "outlineLvl" == name)
    return new OutlineLevel();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pStyle","keepNext","keepLines","pageBreakBefore","framePr","widowControl","numPr","suppressLineNumbers","pBdr","shd","tabs","suppressAutoHyphens","kinsoku","wordWrap","overflowPunct","topLinePunct","autoSpaceDE","autoSpaceDN","bidi","adjustRightInd","snapToGrid","spacing","ind","contextualSpacing","mirrorIndents","suppressOverlap","jc","textDirection","textAlignment","textboxTightWrap","outlineLvl" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ParagraphStyleId.</para>
    /// <para> Represents the following element tag in the schema: w:pStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphStyleId ParagraphStyleId
    {
        get 
        {
            return GetElement<ParagraphStyleId>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> KeepNext.</para>
    /// <para> Represents the following element tag in the schema: w:keepNext </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepNext KeepNext
    {
        get 
        {
            return GetElement<KeepNext>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> KeepLines.</para>
    /// <para> Represents the following element tag in the schema: w:keepLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepLines KeepLines
    {
        get 
        {
            return GetElement<KeepLines>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> PageBreakBefore.</para>
    /// <para> Represents the following element tag in the schema: w:pageBreakBefore </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBreakBefore PageBreakBefore
    {
        get 
        {
            return GetElement<PageBreakBefore>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> FrameProperties.</para>
    /// <para> Represents the following element tag in the schema: w:framePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameProperties FrameProperties
    {
        get 
        {
            return GetElement<FrameProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> WidowControl.</para>
    /// <para> Represents the following element tag in the schema: w:widowControl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WidowControl WidowControl
    {
        get 
        {
            return GetElement<WidowControl>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> NumberingProperties.</para>
    /// <para> Represents the following element tag in the schema: w:numPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingProperties NumberingProperties
    {
        get 
        {
            return GetElement<NumberingProperties>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> SuppressLineNumbers.</para>
    /// <para> Represents the following element tag in the schema: w:suppressLineNumbers </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressLineNumbers SuppressLineNumbers
    {
        get 
        {
            return GetElement<SuppressLineNumbers>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ParagraphBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphBorders ParagraphBorders
    {
        get 
        {
            return GetElement<ParagraphBorders>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Tabs.</para>
    /// <para> Represents the following element tag in the schema: w:tabs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Tabs Tabs
    {
        get 
        {
            return GetElement<Tabs>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> SuppressAutoHyphens.</para>
    /// <para> Represents the following element tag in the schema: w:suppressAutoHyphens </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressAutoHyphens SuppressAutoHyphens
    {
        get 
        {
            return GetElement<SuppressAutoHyphens>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Kinsoku.</para>
    /// <para> Represents the following element tag in the schema: w:kinsoku </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kinsoku Kinsoku
    {
        get 
        {
            return GetElement<Kinsoku>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> WordWrap.</para>
    /// <para> Represents the following element tag in the schema: w:wordWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordWrap WordWrap
    {
        get 
        {
            return GetElement<WordWrap>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> OverflowPunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:overflowPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OverflowPunctuation OverflowPunctuation
    {
        get 
        {
            return GetElement<OverflowPunctuation>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> TopLinePunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:topLinePunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLinePunctuation TopLinePunctuation
    {
        get 
        {
            return GetElement<TopLinePunctuation>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDE.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDE </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDE AutoSpaceDE
    {
        get 
        {
            return GetElement<AutoSpaceDE>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDN.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDN </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDN AutoSpaceDN
    {
        get 
        {
            return GetElement<AutoSpaceDN>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> AdjustRightIndent.</para>
    /// <para> Represents the following element tag in the schema: w:adjustRightInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustRightIndent AdjustRightIndent
    {
        get 
        {
            return GetElement<AdjustRightIndent>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> SpacingBetweenLines.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingBetweenLines SpacingBetweenLines
    {
        get 
        {
            return GetElement<SpacingBetweenLines>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:ind </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Indentation Indentation
    {
        get 
        {
            return GetElement<Indentation>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> ContextualSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:contextualSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ContextualSpacing ContextualSpacing
    {
        get 
        {
            return GetElement<ContextualSpacing>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> MirrorIndents.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorIndents </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorIndents MirrorIndents
    {
        get 
        {
            return GetElement<MirrorIndents>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> SuppressOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:suppressOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressOverlap SuppressOverlap
    {
        get 
        {
            return GetElement<SuppressOverlap>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Justification Justification
    {
        get 
        {
            return GetElement<Justification>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> TextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:textAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextAlignment TextAlignment
    {
        get 
        {
            return GetElement<TextAlignment>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> TextBoxTightWrap.</para>
    /// <para> Represents the following element tag in the schema: w:textboxTightWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxTightWrap TextBoxTightWrap
    {
        get 
        {
            return GetElement<TextBoxTightWrap>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> OutlineLevel.</para>
    /// <para> Represents the following element tag in the schema: w:outlineLvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OutlineLevel OutlineLevel
    {
        get 
        {
            return GetElement<OutlineLevel>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousParagraphProperties>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Symbol Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>RightToLeftText &lt;w:rtl></description></item>
///<item><description>ComplexScript &lt;w:cs></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(RightToLeftText))]
    [ChildElementInfo(typeof(ComplexScript))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingSymbolRunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11921;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the NumberingSymbolRunProperties class.
    /// </summary>
    public NumberingSymbolRunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberingSymbolRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingSymbolRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingSymbolRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingSymbolRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingSymbolRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberingSymbolRunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "rtl" == name)
    return new RightToLeftText();
    
if( 23 == namespaceId && "cs" == name)
    return new ComplexScript();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","u","effect","bdr","shd","fitText","vertAlign","rtl","cs","em","lang","eastAsianLayout","specVanish" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> RunFonts.</para>
    /// <para> Represents the following element tag in the schema: w:rFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunFonts RunFonts
    {
        get 
        {
            return GetElement<RunFonts>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Bold.</para>
    /// <para> Represents the following element tag in the schema: w:b </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Bold Bold
    {
        get 
        {
            return GetElement<Bold>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> BoldComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:bCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BoldComplexScript BoldComplexScript
    {
        get 
        {
            return GetElement<BoldComplexScript>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Italic.</para>
    /// <para> Represents the following element tag in the schema: w:i </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Italic Italic
    {
        get 
        {
            return GetElement<Italic>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ItalicComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:iCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ItalicComplexScript ItalicComplexScript
    {
        get 
        {
            return GetElement<ItalicComplexScript>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Caps.</para>
    /// <para> Represents the following element tag in the schema: w:caps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Caps Caps
    {
        get 
        {
            return GetElement<Caps>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> SmallCaps.</para>
    /// <para> Represents the following element tag in the schema: w:smallCaps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SmallCaps SmallCaps
    {
        get 
        {
            return GetElement<SmallCaps>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Strike.</para>
    /// <para> Represents the following element tag in the schema: w:strike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Strike Strike
    {
        get 
        {
            return GetElement<Strike>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> DoubleStrike.</para>
    /// <para> Represents the following element tag in the schema: w:dstrike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoubleStrike DoubleStrike
    {
        get 
        {
            return GetElement<DoubleStrike>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: w:outline </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Shadow.</para>
    /// <para> Represents the following element tag in the schema: w:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shadow Shadow
    {
        get 
        {
            return GetElement<Shadow>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Emboss.</para>
    /// <para> Represents the following element tag in the schema: w:emboss </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emboss Emboss
    {
        get 
        {
            return GetElement<Emboss>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Imprint.</para>
    /// <para> Represents the following element tag in the schema: w:imprint </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Imprint Imprint
    {
        get 
        {
            return GetElement<Imprint>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> NoProof.</para>
    /// <para> Represents the following element tag in the schema: w:noProof </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoProof NoProof
    {
        get 
        {
            return GetElement<NoProof>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Vanish.</para>
    /// <para> Represents the following element tag in the schema: w:vanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Vanish Vanish
    {
        get 
        {
            return GetElement<Vanish>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> WebHidden.</para>
    /// <para> Represents the following element tag in the schema: w:webHidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WebHidden WebHidden
    {
        get 
        {
            return GetElement<WebHidden>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: w:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Spacing Spacing
    {
        get 
        {
            return GetElement<Spacing>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> CharacterScale.</para>
    /// <para> Represents the following element tag in the schema: w:w </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CharacterScale CharacterScale
    {
        get 
        {
            return GetElement<CharacterScale>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Kern.</para>
    /// <para> Represents the following element tag in the schema: w:kern </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kern Kern
    {
        get 
        {
            return GetElement<Kern>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: w:position </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> FontSize.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSize FontSize
    {
        get 
        {
            return GetElement<FontSize>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> FontSizeComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:szCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSizeComplexScript FontSizeComplexScript
    {
        get 
        {
            return GetElement<FontSizeComplexScript>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> Underline.</para>
    /// <para> Represents the following element tag in the schema: w:u </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Underline Underline
    {
        get 
        {
            return GetElement<Underline>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> TextEffect.</para>
    /// <para> Represents the following element tag in the schema: w:effect </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextEffect TextEffect
    {
        get 
        {
            return GetElement<TextEffect>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Border.</para>
    /// <para> Represents the following element tag in the schema: w:bdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Border Border
    {
        get 
        {
            return GetElement<Border>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> FitText.</para>
    /// <para> Represents the following element tag in the schema: w:fitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FitText FitText
    {
        get 
        {
            return GetElement<FitText>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> VerticalTextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vertAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalTextAlignment VerticalTextAlignment
    {
        get 
        {
            return GetElement<VerticalTextAlignment>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> RightToLeftText.</para>
    /// <para> Represents the following element tag in the schema: w:rtl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightToLeftText RightToLeftText
    {
        get 
        {
            return GetElement<RightToLeftText>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> ComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:cs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ComplexScript ComplexScript
    {
        get 
        {
            return GetElement<ComplexScript>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> Emphasis.</para>
    /// <para> Represents the following element tag in the schema: w:em </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emphasis Emphasis
    {
        get 
        {
            return GetElement<Emphasis>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> Languages.</para>
    /// <para> Represents the following element tag in the schema: w:lang </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Languages Languages
    {
        get 
        {
            return GetElement<Languages>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }
    /// <summary>
    /// <para> EastAsianLayout.</para>
    /// <para> Represents the following element tag in the schema: w:eastAsianLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EastAsianLayout EastAsianLayout
    {
        get 
        {
            return GetElement<EastAsianLayout>(34);
        }
        set
        {
            SetElement(34, value);
        }
    }
    /// <summary>
    /// <para> SpecVanish.</para>
    /// <para> Represents the following element tag in the schema: w:specVanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpecVanish SpecVanish
    {
        get 
        {
            return GetElement<SpecVanish>(35);
        }
        set
        {
            SetElement(35, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingSymbolRunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Abstract Numbering Definition Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:multiLevelType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MultiLevelType : OpenXmlLeafElement
{
    private const string tagName = "multiLevelType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11923;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Abstract Numbering Definition Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.MultiLevelValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.MultiLevelValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MultiLevelType class.
    /// </summary>
    public MultiLevelType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.MultiLevelValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MultiLevelType>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Level Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvl.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StartNumberingValue &lt;w:start></description></item>
///<item><description>NumberingFormat &lt;w:numFmt></description></item>
///<item><description>LevelRestart &lt;w:lvlRestart></description></item>
///<item><description>ParagraphStyleIdInLevel &lt;w:pStyle></description></item>
///<item><description>IsLegalNumberingStyle &lt;w:isLgl></description></item>
///<item><description>LevelSuffix &lt;w:suff></description></item>
///<item><description>LevelText &lt;w:lvlText></description></item>
///<item><description>LevelPictureBulletId &lt;w:lvlPicBulletId></description></item>
///<item><description>LegacyNumbering &lt;w:legacy></description></item>
///<item><description>LevelJustification &lt;w:lvlJc></description></item>
///<item><description>PreviousParagraphProperties &lt;w:pPr></description></item>
///<item><description>NumberingSymbolRunProperties &lt;w:rPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StartNumberingValue))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(LevelRestart))]
    [ChildElementInfo(typeof(ParagraphStyleIdInLevel))]
    [ChildElementInfo(typeof(IsLegalNumberingStyle))]
    [ChildElementInfo(typeof(LevelSuffix))]
    [ChildElementInfo(typeof(LevelText))]
    [ChildElementInfo(typeof(LevelPictureBulletId))]
    [ChildElementInfo(typeof(LegacyNumbering))]
    [ChildElementInfo(typeof(LevelJustification))]
    [ChildElementInfo(typeof(PreviousParagraphProperties))]
    [ChildElementInfo(typeof(NumberingSymbolRunProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Level : OpenXmlCompositeElement
{
    private const string tagName = "lvl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11928;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ilvl","tplc","tentative" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Numbering Level.</para>
    /// <para>Represents the following attribute in the schema: w:ilvl </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "ilvl")]
    public Int32Value LevelIndex
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Template Code.</para>
    /// <para>Represents the following attribute in the schema: w:tplc </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tplc")]
    public HexBinaryValue TemplateCode
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Tentative Numbering.</para>
    /// <para>Represents the following attribute in the schema: w:tentative </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tentative")]
    public OnOffValue Tentative
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Level class.
    /// </summary>
    public Level():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Level class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Level class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Level(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Level class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Level(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "start" == name)
    return new StartNumberingValue();
    
if( 23 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 23 == namespaceId && "lvlRestart" == name)
    return new LevelRestart();
    
if( 23 == namespaceId && "pStyle" == name)
    return new ParagraphStyleIdInLevel();
    
if( 23 == namespaceId && "isLgl" == name)
    return new IsLegalNumberingStyle();
    
if( 23 == namespaceId && "suff" == name)
    return new LevelSuffix();
    
if( 23 == namespaceId && "lvlText" == name)
    return new LevelText();
    
if( 23 == namespaceId && "lvlPicBulletId" == name)
    return new LevelPictureBulletId();
    
if( 23 == namespaceId && "legacy" == name)
    return new LegacyNumbering();
    
if( 23 == namespaceId && "lvlJc" == name)
    return new LevelJustification();
    
if( 23 == namespaceId && "pPr" == name)
    return new PreviousParagraphProperties();
    
if( 23 == namespaceId && "rPr" == name)
    return new NumberingSymbolRunProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "start","numFmt","lvlRestart","pStyle","isLgl","suff","lvlText","lvlPicBulletId","legacy","lvlJc","pPr","rPr" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Starting Value.</para>
    /// <para> Represents the following element tag in the schema: w:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartNumberingValue StartNumberingValue
    {
        get 
        {
            return GetElement<StartNumberingValue>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Numbering Format.</para>
    /// <para> Represents the following element tag in the schema: w:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Restart Numbering Level Symbol.</para>
    /// <para> Represents the following element tag in the schema: w:lvlRestart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LevelRestart LevelRestart
    {
        get 
        {
            return GetElement<LevelRestart>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Paragraph Style's Associated Numbering Level.</para>
    /// <para> Represents the following element tag in the schema: w:pStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphStyleIdInLevel ParagraphStyleIdInLevel
    {
        get 
        {
            return GetElement<ParagraphStyleIdInLevel>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Display All Levels Using Arabic Numerals.</para>
    /// <para> Represents the following element tag in the schema: w:isLgl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public IsLegalNumberingStyle IsLegalNumberingStyle
    {
        get 
        {
            return GetElement<IsLegalNumberingStyle>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Content Between Numbering Symbol and Paragraph Text.</para>
    /// <para> Represents the following element tag in the schema: w:suff </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LevelSuffix LevelSuffix
    {
        get 
        {
            return GetElement<LevelSuffix>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Numbering Level Text.</para>
    /// <para> Represents the following element tag in the schema: w:lvlText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LevelText LevelText
    {
        get 
        {
            return GetElement<LevelText>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Picture Numbering Symbol Definition Reference.</para>
    /// <para> Represents the following element tag in the schema: w:lvlPicBulletId </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LevelPictureBulletId LevelPictureBulletId
    {
        get 
        {
            return GetElement<LevelPictureBulletId>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Legacy Numbering Level Properties.</para>
    /// <para> Represents the following element tag in the schema: w:legacy </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LegacyNumbering LegacyNumbering
    {
        get 
        {
            return GetElement<LegacyNumbering>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:lvlJc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LevelJustification LevelJustification
    {
        get 
        {
            return GetElement<LevelJustification>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Numbering Level Associated Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousParagraphProperties PreviousParagraphProperties
    {
        get 
        {
            return GetElement<PreviousParagraphProperties>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Numbering Symbol Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingSymbolRunProperties NumberingSymbolRunProperties
    {
        get 
        {
            return GetElement<NumberingSymbolRunProperties>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "ilvl" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "tplc" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "tentative" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Level>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Level Definition Override.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lvlOverride.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StartOverrideNumberingValue &lt;w:startOverride></description></item>
///<item><description>Level &lt;w:lvl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StartOverrideNumberingValue))]
    [ChildElementInfo(typeof(Level))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LevelOverride : OpenXmlCompositeElement
{
    private const string tagName = "lvlOverride";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11931;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ilvl" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Numbering Level ID.</para>
    /// <para>Represents the following attribute in the schema: w:ilvl </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "ilvl")]
    public Int32Value LevelIndex
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LevelOverride class.
    /// </summary>
    public LevelOverride():base(){}
    
            /// <summary>
    ///Initializes a new instance of the LevelOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LevelOverride(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LevelOverride class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LevelOverride(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LevelOverride class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LevelOverride(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "startOverride" == name)
    return new StartOverrideNumberingValue();
    
if( 23 == namespaceId && "lvl" == name)
    return new Level();
    

    return null;
}

        private static readonly string[] eleTagNames = { "startOverride","lvl" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Numbering Level Starting Value Override.</para>
    /// <para> Represents the following element tag in the schema: w:startOverride </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StartOverrideNumberingValue StartOverrideNumberingValue
    {
        get 
        {
            return GetElement<StartOverrideNumberingValue>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Numbering Level Override Definition.</para>
    /// <para> Represents the following element tag in the schema: w:lvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Level Level
    {
        get 
        {
            return GetElement<Level>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "ilvl" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LevelOverride>(deep);
    }

   
}
/// <summary>
/// <para>Picture Numbering Symbol Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:numPicBullet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PictureBulletBase &lt;w:pict></description></item>
///<item><description>Drawing &lt;w:drawing></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PictureBulletBase))]
    [ChildElementInfo(typeof(Drawing))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingPictureBullet : OpenXmlCompositeElement
{
    private const string tagName = "numPicBullet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11932;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "numPicBulletId" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> numPicBulletId.</para>
    /// <para>Represents the following attribute in the schema: w:numPicBulletId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "numPicBulletId")]
    public Int32Value NumberingPictureBulletId
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingPictureBullet class.
    /// </summary>
    public NumberingPictureBullet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberingPictureBullet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingPictureBullet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingPictureBullet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingPictureBullet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingPictureBullet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberingPictureBullet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pict" == name)
    return new PictureBulletBase();
    
if( 23 == namespaceId && "drawing" == name)
    return new Drawing();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pict","drawing" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> PictureBulletBase.</para>
    /// <para> Represents the following element tag in the schema: w:pict </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PictureBulletBase PictureBulletBase
    {
        get 
        {
            return GetElement<PictureBulletBase>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Drawing.</para>
    /// <para> Represents the following element tag in the schema: w:drawing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Drawing Drawing
    {
        get 
        {
            return GetElement<Drawing>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "numPicBulletId" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingPictureBullet>(deep);
    }

   
}
/// <summary>
/// <para>Abstract Numbering Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:abstractNum.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Nsid &lt;w:nsid></description></item>
///<item><description>MultiLevelType &lt;w:multiLevelType></description></item>
///<item><description>TemplateCode &lt;w:tmpl></description></item>
///<item><description>AbstractNumDefinitionName &lt;w:name></description></item>
///<item><description>StyleLink &lt;w:styleLink></description></item>
///<item><description>NumberingStyleLink &lt;w:numStyleLink></description></item>
///<item><description>Level &lt;w:lvl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Nsid))]
    [ChildElementInfo(typeof(MultiLevelType))]
    [ChildElementInfo(typeof(TemplateCode))]
    [ChildElementInfo(typeof(AbstractNumDefinitionName))]
    [ChildElementInfo(typeof(StyleLink))]
    [ChildElementInfo(typeof(NumberingStyleLink))]
    [ChildElementInfo(typeof(Level))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AbstractNum : OpenXmlCompositeElement
{
    private const string tagName = "abstractNum";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11933;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "abstractNumId" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Abstract Numbering Definition ID.</para>
    /// <para>Represents the following attribute in the schema: w:abstractNumId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "abstractNumId")]
    public Int32Value AbstractNumberId
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AbstractNum class.
    /// </summary>
    public AbstractNum():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AbstractNum class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AbstractNum(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AbstractNum class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AbstractNum(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AbstractNum class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AbstractNum(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "nsid" == name)
    return new Nsid();
    
if( 23 == namespaceId && "multiLevelType" == name)
    return new MultiLevelType();
    
if( 23 == namespaceId && "tmpl" == name)
    return new TemplateCode();
    
if( 23 == namespaceId && "name" == name)
    return new AbstractNumDefinitionName();
    
if( 23 == namespaceId && "styleLink" == name)
    return new StyleLink();
    
if( 23 == namespaceId && "numStyleLink" == name)
    return new NumberingStyleLink();
    
if( 23 == namespaceId && "lvl" == name)
    return new Level();
    

    return null;
}

        private static readonly string[] eleTagNames = { "nsid","multiLevelType","tmpl","name","styleLink","numStyleLink","lvl" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Abstract Numbering Definition Identifier.</para>
    /// <para> Represents the following element tag in the schema: w:nsid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Nsid Nsid
    {
        get 
        {
            return GetElement<Nsid>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Abstract Numbering Definition Type.</para>
    /// <para> Represents the following element tag in the schema: w:multiLevelType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MultiLevelType MultiLevelType
    {
        get 
        {
            return GetElement<MultiLevelType>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Numbering Template Code.</para>
    /// <para> Represents the following element tag in the schema: w:tmpl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TemplateCode TemplateCode
    {
        get 
        {
            return GetElement<TemplateCode>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Abstract Numbering Definition Name.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AbstractNumDefinitionName AbstractNumDefinitionName
    {
        get 
        {
            return GetElement<AbstractNumDefinitionName>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Numbering Style Definition.</para>
    /// <para> Represents the following element tag in the schema: w:styleLink </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleLink StyleLink
    {
        get 
        {
            return GetElement<StyleLink>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Numbering Style Reference.</para>
    /// <para> Represents the following element tag in the schema: w:numStyleLink </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingStyleLink NumberingStyleLink
    {
        get 
        {
            return GetElement<NumberingStyleLink>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "abstractNumId" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AbstractNum>(deep);
    }

   
}
/// <summary>
/// <para>Numbering Definition Instance.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:num.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AbstractNumId &lt;w:abstractNumId></description></item>
///<item><description>LevelOverride &lt;w:lvlOverride></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AbstractNumId))]
    [ChildElementInfo(typeof(LevelOverride))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingInstance : OpenXmlCompositeElement
{
    private const string tagName = "num";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11934;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "numId" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Numbering Definition Instance ID.</para>
    /// <para>Represents the following attribute in the schema: w:numId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "numId")]
    public Int32Value NumberID
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingInstance class.
    /// </summary>
    public NumberingInstance():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberingInstance class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingInstance(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingInstance class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingInstance(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingInstance class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberingInstance(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "abstractNumId" == name)
    return new AbstractNumId();
    
if( 23 == namespaceId && "lvlOverride" == name)
    return new LevelOverride();
    

    return null;
}

        private static readonly string[] eleTagNames = { "abstractNumId","lvlOverride" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Abstract Numbering Definition Reference.</para>
    /// <para> Represents the following element tag in the schema: w:abstractNumId </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AbstractNumId AbstractNumId
    {
        get 
        {
            return GetElement<AbstractNumId>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "numId" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingInstance>(deep);
    }

   
}
/// <summary>
/// <para>Table Style Conditional Formatting Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>KeepNext &lt;w:keepNext></description></item>
///<item><description>KeepLines &lt;w:keepLines></description></item>
///<item><description>PageBreakBefore &lt;w:pageBreakBefore></description></item>
///<item><description>FrameProperties &lt;w:framePr></description></item>
///<item><description>WidowControl &lt;w:widowControl></description></item>
///<item><description>NumberingProperties &lt;w:numPr></description></item>
///<item><description>SuppressLineNumbers &lt;w:suppressLineNumbers></description></item>
///<item><description>ParagraphBorders &lt;w:pBdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>Tabs &lt;w:tabs></description></item>
///<item><description>SuppressAutoHyphens &lt;w:suppressAutoHyphens></description></item>
///<item><description>Kinsoku &lt;w:kinsoku></description></item>
///<item><description>WordWrap &lt;w:wordWrap></description></item>
///<item><description>OverflowPunctuation &lt;w:overflowPunct></description></item>
///<item><description>TopLinePunctuation &lt;w:topLinePunct></description></item>
///<item><description>AutoSpaceDE &lt;w:autoSpaceDE></description></item>
///<item><description>AutoSpaceDN &lt;w:autoSpaceDN></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>AdjustRightIndent &lt;w:adjustRightInd></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>SpacingBetweenLines &lt;w:spacing></description></item>
///<item><description>Indentation &lt;w:ind></description></item>
///<item><description>ContextualSpacing &lt;w:contextualSpacing></description></item>
///<item><description>MirrorIndents &lt;w:mirrorIndents></description></item>
///<item><description>SuppressOverlap &lt;w:suppressOverlap></description></item>
///<item><description>Justification &lt;w:jc></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TextAlignment &lt;w:textAlignment></description></item>
///<item><description>TextBoxTightWrap &lt;w:textboxTightWrap></description></item>
///<item><description>OutlineLevel &lt;w:outlineLvl></description></item>
///<item><description>ParagraphPropertiesChange &lt;w:pPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(KeepNext))]
    [ChildElementInfo(typeof(KeepLines))]
    [ChildElementInfo(typeof(PageBreakBefore))]
    [ChildElementInfo(typeof(FrameProperties))]
    [ChildElementInfo(typeof(WidowControl))]
    [ChildElementInfo(typeof(NumberingProperties))]
    [ChildElementInfo(typeof(SuppressLineNumbers))]
    [ChildElementInfo(typeof(ParagraphBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(Tabs))]
    [ChildElementInfo(typeof(SuppressAutoHyphens))]
    [ChildElementInfo(typeof(Kinsoku))]
    [ChildElementInfo(typeof(WordWrap))]
    [ChildElementInfo(typeof(OverflowPunctuation))]
    [ChildElementInfo(typeof(TopLinePunctuation))]
    [ChildElementInfo(typeof(AutoSpaceDE))]
    [ChildElementInfo(typeof(AutoSpaceDN))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(AdjustRightIndent))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(SpacingBetweenLines))]
    [ChildElementInfo(typeof(Indentation))]
    [ChildElementInfo(typeof(ContextualSpacing))]
    [ChildElementInfo(typeof(MirrorIndents))]
    [ChildElementInfo(typeof(SuppressOverlap))]
    [ChildElementInfo(typeof(Justification))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TextAlignment))]
    [ChildElementInfo(typeof(TextBoxTightWrap))]
    [ChildElementInfo(typeof(OutlineLevel))]
    [ChildElementInfo(typeof(ParagraphPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleParagraphProperties : OpenXmlCompositeElement
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11936;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the StyleParagraphProperties class.
    /// </summary>
    public StyleParagraphProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StyleParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StyleParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "keepNext" == name)
    return new KeepNext();
    
if( 23 == namespaceId && "keepLines" == name)
    return new KeepLines();
    
if( 23 == namespaceId && "pageBreakBefore" == name)
    return new PageBreakBefore();
    
if( 23 == namespaceId && "framePr" == name)
    return new FrameProperties();
    
if( 23 == namespaceId && "widowControl" == name)
    return new WidowControl();
    
if( 23 == namespaceId && "numPr" == name)
    return new NumberingProperties();
    
if( 23 == namespaceId && "suppressLineNumbers" == name)
    return new SuppressLineNumbers();
    
if( 23 == namespaceId && "pBdr" == name)
    return new ParagraphBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tabs" == name)
    return new Tabs();
    
if( 23 == namespaceId && "suppressAutoHyphens" == name)
    return new SuppressAutoHyphens();
    
if( 23 == namespaceId && "kinsoku" == name)
    return new Kinsoku();
    
if( 23 == namespaceId && "wordWrap" == name)
    return new WordWrap();
    
if( 23 == namespaceId && "overflowPunct" == name)
    return new OverflowPunctuation();
    
if( 23 == namespaceId && "topLinePunct" == name)
    return new TopLinePunctuation();
    
if( 23 == namespaceId && "autoSpaceDE" == name)
    return new AutoSpaceDE();
    
if( 23 == namespaceId && "autoSpaceDN" == name)
    return new AutoSpaceDN();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "adjustRightInd" == name)
    return new AdjustRightIndent();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "spacing" == name)
    return new SpacingBetweenLines();
    
if( 23 == namespaceId && "ind" == name)
    return new Indentation();
    
if( 23 == namespaceId && "contextualSpacing" == name)
    return new ContextualSpacing();
    
if( 23 == namespaceId && "mirrorIndents" == name)
    return new MirrorIndents();
    
if( 23 == namespaceId && "suppressOverlap" == name)
    return new SuppressOverlap();
    
if( 23 == namespaceId && "jc" == name)
    return new Justification();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "textAlignment" == name)
    return new TextAlignment();
    
if( 23 == namespaceId && "textboxTightWrap" == name)
    return new TextBoxTightWrap();
    
if( 23 == namespaceId && "outlineLvl" == name)
    return new OutlineLevel();
    
if( 23 == namespaceId && "pPrChange" == name)
    return new ParagraphPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "keepNext","keepLines","pageBreakBefore","framePr","widowControl","numPr","suppressLineNumbers","pBdr","shd","tabs","suppressAutoHyphens","kinsoku","wordWrap","overflowPunct","topLinePunct","autoSpaceDE","autoSpaceDN","bidi","adjustRightInd","snapToGrid","spacing","ind","contextualSpacing","mirrorIndents","suppressOverlap","jc","textDirection","textAlignment","textboxTightWrap","outlineLvl","pPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> KeepNext.</para>
    /// <para> Represents the following element tag in the schema: w:keepNext </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepNext KeepNext
    {
        get 
        {
            return GetElement<KeepNext>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> KeepLines.</para>
    /// <para> Represents the following element tag in the schema: w:keepLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepLines KeepLines
    {
        get 
        {
            return GetElement<KeepLines>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> PageBreakBefore.</para>
    /// <para> Represents the following element tag in the schema: w:pageBreakBefore </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBreakBefore PageBreakBefore
    {
        get 
        {
            return GetElement<PageBreakBefore>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> FrameProperties.</para>
    /// <para> Represents the following element tag in the schema: w:framePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameProperties FrameProperties
    {
        get 
        {
            return GetElement<FrameProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> WidowControl.</para>
    /// <para> Represents the following element tag in the schema: w:widowControl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WidowControl WidowControl
    {
        get 
        {
            return GetElement<WidowControl>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> NumberingProperties.</para>
    /// <para> Represents the following element tag in the schema: w:numPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingProperties NumberingProperties
    {
        get 
        {
            return GetElement<NumberingProperties>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> SuppressLineNumbers.</para>
    /// <para> Represents the following element tag in the schema: w:suppressLineNumbers </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressLineNumbers SuppressLineNumbers
    {
        get 
        {
            return GetElement<SuppressLineNumbers>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> ParagraphBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphBorders ParagraphBorders
    {
        get 
        {
            return GetElement<ParagraphBorders>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Tabs.</para>
    /// <para> Represents the following element tag in the schema: w:tabs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Tabs Tabs
    {
        get 
        {
            return GetElement<Tabs>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> SuppressAutoHyphens.</para>
    /// <para> Represents the following element tag in the schema: w:suppressAutoHyphens </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressAutoHyphens SuppressAutoHyphens
    {
        get 
        {
            return GetElement<SuppressAutoHyphens>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Kinsoku.</para>
    /// <para> Represents the following element tag in the schema: w:kinsoku </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kinsoku Kinsoku
    {
        get 
        {
            return GetElement<Kinsoku>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> WordWrap.</para>
    /// <para> Represents the following element tag in the schema: w:wordWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordWrap WordWrap
    {
        get 
        {
            return GetElement<WordWrap>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> OverflowPunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:overflowPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OverflowPunctuation OverflowPunctuation
    {
        get 
        {
            return GetElement<OverflowPunctuation>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> TopLinePunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:topLinePunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLinePunctuation TopLinePunctuation
    {
        get 
        {
            return GetElement<TopLinePunctuation>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDE.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDE </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDE AutoSpaceDE
    {
        get 
        {
            return GetElement<AutoSpaceDE>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDN.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDN </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDN AutoSpaceDN
    {
        get 
        {
            return GetElement<AutoSpaceDN>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> AdjustRightIndent.</para>
    /// <para> Represents the following element tag in the schema: w:adjustRightInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustRightIndent AdjustRightIndent
    {
        get 
        {
            return GetElement<AdjustRightIndent>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> SpacingBetweenLines.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingBetweenLines SpacingBetweenLines
    {
        get 
        {
            return GetElement<SpacingBetweenLines>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:ind </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Indentation Indentation
    {
        get 
        {
            return GetElement<Indentation>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> ContextualSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:contextualSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ContextualSpacing ContextualSpacing
    {
        get 
        {
            return GetElement<ContextualSpacing>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> MirrorIndents.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorIndents </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorIndents MirrorIndents
    {
        get 
        {
            return GetElement<MirrorIndents>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> SuppressOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:suppressOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressOverlap SuppressOverlap
    {
        get 
        {
            return GetElement<SuppressOverlap>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Justification Justification
    {
        get 
        {
            return GetElement<Justification>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:textAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextAlignment TextAlignment
    {
        get 
        {
            return GetElement<TextAlignment>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> TextBoxTightWrap.</para>
    /// <para> Represents the following element tag in the schema: w:textboxTightWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxTightWrap TextBoxTightWrap
    {
        get 
        {
            return GetElement<TextBoxTightWrap>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> OutlineLevel.</para>
    /// <para> Represents the following element tag in the schema: w:outlineLvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OutlineLevel OutlineLevel
    {
        get 
        {
            return GetElement<OutlineLevel>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> ParagraphPropertiesChange.</para>
    /// <para> Represents the following element tag in the schema: w:pPrChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphPropertiesChange ParagraphPropertiesChange
    {
        get 
        {
            return GetElement<ParagraphPropertiesChange>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleParagraphProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Style Conditional Formatting Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleConditionalFormattingTableProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11937;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableProperties class.
    /// </summary>
    public TableStyleConditionalFormattingTableProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyleConditionalFormattingTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleConditionalFormattingTableProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    

    return null;
}

        private static readonly string[] eleTagNames = { "jc","tblCellSpacing","tblInd","tblBorders","shd","tblCellMar" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TableJustification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TableCellSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> TableIndentation.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> TableBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableCellMarginDefault.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleConditionalFormattingTableProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Style Conditional Formatting Table Row Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Hidden &lt;w:hidden></description></item>
///<item><description>CantSplit &lt;w:cantSplit></description></item>
///<item><description>TableHeader &lt;w:tblHeader></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Hidden))]
    [ChildElementInfo(typeof(CantSplit))]
    [ChildElementInfo(typeof(TableHeader))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableJustification))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleConditionalFormattingTableRowProperties : OpenXmlCompositeElement
{
    private const string tagName = "trPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11938;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableRowProperties class.
    /// </summary>
    public TableStyleConditionalFormattingTableRowProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyleConditionalFormattingTableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableRowProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableRowProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableRowProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleConditionalFormattingTableRowProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "hidden" == name)
    return new Hidden();
    
if( 23 == namespaceId && "cantSplit" == name)
    return new CantSplit();
    
if( 23 == namespaceId && "tblHeader" == name)
    return new TableHeader();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleConditionalFormattingTableRowProperties>(deep);
    }

   
}
/// <summary>
/// <para>Table Style Conditional Formatting Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableCellBorders &lt;w:tcBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>NoWrap &lt;w:noWrap></description></item>
///<item><description>TableCellMargin &lt;w:tcMar></description></item>
///<item><description>TableCellVerticalAlignment &lt;w:vAlign></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableCellBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(NoWrap))]
    [ChildElementInfo(typeof(TableCellMargin))]
    [ChildElementInfo(typeof(TableCellVerticalAlignment))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleConditionalFormattingTableCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "tcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11939;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableCellProperties class.
    /// </summary>
    public TableStyleConditionalFormattingTableCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyleConditionalFormattingTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleConditionalFormattingTableCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleConditionalFormattingTableCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleConditionalFormattingTableCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tcBorders" == name)
    return new TableCellBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "noWrap" == name)
    return new NoWrap();
    
if( 23 == namespaceId && "tcMar" == name)
    return new TableCellMargin();
    
if( 23 == namespaceId && "vAlign" == name)
    return new TableCellVerticalAlignment();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tcBorders","shd","noWrap","tcMar","vAlign" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TableCellBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tcBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellBorders TableCellBorders
    {
        get 
        {
            return GetElement<TableCellBorders>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> NoWrap.</para>
    /// <para> Represents the following element tag in the schema: w:noWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoWrap NoWrap
    {
        get 
        {
            return GetElement<NoWrap>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> TableCellMargin.</para>
    /// <para> Represents the following element tag in the schema: w:tcMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMargin TableCellMargin
    {
        get 
        {
            return GetElement<TableCellMargin>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> TableCellVerticalAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellVerticalAlignment TableCellVerticalAlignment
    {
        get 
        {
            return GetElement<TableCellVerticalAlignment>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleConditionalFormattingTableCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Primary Style Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleName : OpenXmlLeafElement
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11940;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StyleName class.
    /// </summary>
    public StyleName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleName>(deep);
    }

   
}
/// <summary>
/// <para>Optional User Interface Sorting Order.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:uiPriority.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UIPriority : OpenXmlLeafElement
{
    private const string tagName = "uiPriority";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11947;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the UIPriority class.
    /// </summary>
    public UIPriority():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UIPriority>(deep);
    }

   
}
/// <summary>
/// <para>Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunFonts &lt;w:rFonts></description></item>
///<item><description>Bold &lt;w:b></description></item>
///<item><description>BoldComplexScript &lt;w:bCs></description></item>
///<item><description>Italic &lt;w:i></description></item>
///<item><description>ItalicComplexScript &lt;w:iCs></description></item>
///<item><description>Caps &lt;w:caps></description></item>
///<item><description>SmallCaps &lt;w:smallCaps></description></item>
///<item><description>Strike &lt;w:strike></description></item>
///<item><description>DoubleStrike &lt;w:dstrike></description></item>
///<item><description>Outline &lt;w:outline></description></item>
///<item><description>Shadow &lt;w:shadow></description></item>
///<item><description>Emboss &lt;w:emboss></description></item>
///<item><description>Imprint &lt;w:imprint></description></item>
///<item><description>NoProof &lt;w:noProof></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>Vanish &lt;w:vanish></description></item>
///<item><description>WebHidden &lt;w:webHidden></description></item>
///<item><description>Color &lt;w:color></description></item>
///<item><description>Spacing &lt;w:spacing></description></item>
///<item><description>CharacterScale &lt;w:w></description></item>
///<item><description>Kern &lt;w:kern></description></item>
///<item><description>Position &lt;w:position></description></item>
///<item><description>FontSize &lt;w:sz></description></item>
///<item><description>FontSizeComplexScript &lt;w:szCs></description></item>
///<item><description>Underline &lt;w:u></description></item>
///<item><description>TextEffect &lt;w:effect></description></item>
///<item><description>Border &lt;w:bdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>FitText &lt;w:fitText></description></item>
///<item><description>VerticalTextAlignment &lt;w:vertAlign></description></item>
///<item><description>Emphasis &lt;w:em></description></item>
///<item><description>Languages &lt;w:lang></description></item>
///<item><description>EastAsianLayout &lt;w:eastAsianLayout></description></item>
///<item><description>SpecVanish &lt;w:specVanish></description></item>
///<item><description>RunPropertiesChange &lt;w:rPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunFonts))]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(BoldComplexScript))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(ItalicComplexScript))]
    [ChildElementInfo(typeof(Caps))]
    [ChildElementInfo(typeof(SmallCaps))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(DoubleStrike))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Emboss))]
    [ChildElementInfo(typeof(Imprint))]
    [ChildElementInfo(typeof(NoProof))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(Vanish))]
    [ChildElementInfo(typeof(WebHidden))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(Spacing))]
    [ChildElementInfo(typeof(CharacterScale))]
    [ChildElementInfo(typeof(Kern))]
    [ChildElementInfo(typeof(Position))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(FontSizeComplexScript))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(TextEffect))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(FitText))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(Emphasis))]
    [ChildElementInfo(typeof(Languages))]
    [ChildElementInfo(typeof(EastAsianLayout))]
    [ChildElementInfo(typeof(SpecVanish))]
    [ChildElementInfo(typeof(RunPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleRunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11955;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the StyleRunProperties class.
    /// </summary>
    public StyleRunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StyleRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleRunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleRunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleRunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleRunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StyleRunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rFonts" == name)
    return new RunFonts();
    
if( 23 == namespaceId && "b" == name)
    return new Bold();
    
if( 23 == namespaceId && "bCs" == name)
    return new BoldComplexScript();
    
if( 23 == namespaceId && "i" == name)
    return new Italic();
    
if( 23 == namespaceId && "iCs" == name)
    return new ItalicComplexScript();
    
if( 23 == namespaceId && "caps" == name)
    return new Caps();
    
if( 23 == namespaceId && "smallCaps" == name)
    return new SmallCaps();
    
if( 23 == namespaceId && "strike" == name)
    return new Strike();
    
if( 23 == namespaceId && "dstrike" == name)
    return new DoubleStrike();
    
if( 23 == namespaceId && "outline" == name)
    return new Outline();
    
if( 23 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 23 == namespaceId && "emboss" == name)
    return new Emboss();
    
if( 23 == namespaceId && "imprint" == name)
    return new Imprint();
    
if( 23 == namespaceId && "noProof" == name)
    return new NoProof();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "vanish" == name)
    return new Vanish();
    
if( 23 == namespaceId && "webHidden" == name)
    return new WebHidden();
    
if( 23 == namespaceId && "color" == name)
    return new Color();
    
if( 23 == namespaceId && "spacing" == name)
    return new Spacing();
    
if( 23 == namespaceId && "w" == name)
    return new CharacterScale();
    
if( 23 == namespaceId && "kern" == name)
    return new Kern();
    
if( 23 == namespaceId && "position" == name)
    return new Position();
    
if( 23 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 23 == namespaceId && "szCs" == name)
    return new FontSizeComplexScript();
    
if( 23 == namespaceId && "u" == name)
    return new Underline();
    
if( 23 == namespaceId && "effect" == name)
    return new TextEffect();
    
if( 23 == namespaceId && "bdr" == name)
    return new Border();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "fitText" == name)
    return new FitText();
    
if( 23 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 23 == namespaceId && "em" == name)
    return new Emphasis();
    
if( 23 == namespaceId && "lang" == name)
    return new Languages();
    
if( 23 == namespaceId && "eastAsianLayout" == name)
    return new EastAsianLayout();
    
if( 23 == namespaceId && "specVanish" == name)
    return new SpecVanish();
    
if( 23 == namespaceId && "rPrChange" == name)
    return new RunPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rFonts","b","bCs","i","iCs","caps","smallCaps","strike","dstrike","outline","shadow","emboss","imprint","noProof","snapToGrid","vanish","webHidden","color","spacing","w","kern","position","sz","szCs","u","effect","bdr","shd","fitText","vertAlign","em","lang","eastAsianLayout","specVanish","rPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> RunFonts.</para>
    /// <para> Represents the following element tag in the schema: w:rFonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunFonts RunFonts
    {
        get 
        {
            return GetElement<RunFonts>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Bold.</para>
    /// <para> Represents the following element tag in the schema: w:b </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Bold Bold
    {
        get 
        {
            return GetElement<Bold>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> BoldComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:bCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BoldComplexScript BoldComplexScript
    {
        get 
        {
            return GetElement<BoldComplexScript>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Italic.</para>
    /// <para> Represents the following element tag in the schema: w:i </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Italic Italic
    {
        get 
        {
            return GetElement<Italic>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ItalicComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:iCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ItalicComplexScript ItalicComplexScript
    {
        get 
        {
            return GetElement<ItalicComplexScript>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Caps.</para>
    /// <para> Represents the following element tag in the schema: w:caps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Caps Caps
    {
        get 
        {
            return GetElement<Caps>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> SmallCaps.</para>
    /// <para> Represents the following element tag in the schema: w:smallCaps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SmallCaps SmallCaps
    {
        get 
        {
            return GetElement<SmallCaps>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Strike.</para>
    /// <para> Represents the following element tag in the schema: w:strike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Strike Strike
    {
        get 
        {
            return GetElement<Strike>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> DoubleStrike.</para>
    /// <para> Represents the following element tag in the schema: w:dstrike </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoubleStrike DoubleStrike
    {
        get 
        {
            return GetElement<DoubleStrike>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: w:outline </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Shadow.</para>
    /// <para> Represents the following element tag in the schema: w:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shadow Shadow
    {
        get 
        {
            return GetElement<Shadow>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Emboss.</para>
    /// <para> Represents the following element tag in the schema: w:emboss </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emboss Emboss
    {
        get 
        {
            return GetElement<Emboss>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Imprint.</para>
    /// <para> Represents the following element tag in the schema: w:imprint </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Imprint Imprint
    {
        get 
        {
            return GetElement<Imprint>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> NoProof.</para>
    /// <para> Represents the following element tag in the schema: w:noProof </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoProof NoProof
    {
        get 
        {
            return GetElement<NoProof>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Vanish.</para>
    /// <para> Represents the following element tag in the schema: w:vanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Vanish Vanish
    {
        get 
        {
            return GetElement<Vanish>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> WebHidden.</para>
    /// <para> Represents the following element tag in the schema: w:webHidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WebHidden WebHidden
    {
        get 
        {
            return GetElement<WebHidden>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: w:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Spacing Spacing
    {
        get 
        {
            return GetElement<Spacing>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> CharacterScale.</para>
    /// <para> Represents the following element tag in the schema: w:w </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CharacterScale CharacterScale
    {
        get 
        {
            return GetElement<CharacterScale>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Kern.</para>
    /// <para> Represents the following element tag in the schema: w:kern </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kern Kern
    {
        get 
        {
            return GetElement<Kern>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Position.</para>
    /// <para> Represents the following element tag in the schema: w:position </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Position Position
    {
        get 
        {
            return GetElement<Position>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> FontSize.</para>
    /// <para> Represents the following element tag in the schema: w:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSize FontSize
    {
        get 
        {
            return GetElement<FontSize>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> FontSizeComplexScript.</para>
    /// <para> Represents the following element tag in the schema: w:szCs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSizeComplexScript FontSizeComplexScript
    {
        get 
        {
            return GetElement<FontSizeComplexScript>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> Underline.</para>
    /// <para> Represents the following element tag in the schema: w:u </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Underline Underline
    {
        get 
        {
            return GetElement<Underline>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> TextEffect.</para>
    /// <para> Represents the following element tag in the schema: w:effect </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextEffect TextEffect
    {
        get 
        {
            return GetElement<TextEffect>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Border.</para>
    /// <para> Represents the following element tag in the schema: w:bdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Border Border
    {
        get 
        {
            return GetElement<Border>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> FitText.</para>
    /// <para> Represents the following element tag in the schema: w:fitText </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FitText FitText
    {
        get 
        {
            return GetElement<FitText>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> VerticalTextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vertAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public VerticalTextAlignment VerticalTextAlignment
    {
        get 
        {
            return GetElement<VerticalTextAlignment>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> Emphasis.</para>
    /// <para> Represents the following element tag in the schema: w:em </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Emphasis Emphasis
    {
        get 
        {
            return GetElement<Emphasis>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> Languages.</para>
    /// <para> Represents the following element tag in the schema: w:lang </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Languages Languages
    {
        get 
        {
            return GetElement<Languages>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> EastAsianLayout.</para>
    /// <para> Represents the following element tag in the schema: w:eastAsianLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EastAsianLayout EastAsianLayout
    {
        get 
        {
            return GetElement<EastAsianLayout>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> SpecVanish.</para>
    /// <para> Represents the following element tag in the schema: w:specVanish </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpecVanish SpecVanish
    {
        get 
        {
            return GetElement<SpecVanish>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }
    /// <summary>
    /// <para> RunPropertiesChange.</para>
    /// <para> Represents the following element tag in the schema: w:rPrChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunPropertiesChange RunPropertiesChange
    {
        get 
        {
            return GetElement<RunPropertiesChange>(34);
        }
        set
        {
            SetElement(34, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleRunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Style Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyleRowBandSize &lt;w:tblStyleRowBandSize></description></item>
///<item><description>TableStyleColumnBandSize &lt;w:tblStyleColBandSize></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyleRowBandSize))]
    [ChildElementInfo(typeof(TableStyleColumnBandSize))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleTableProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11956;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the StyleTableProperties class.
    /// </summary>
    public StyleTableProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StyleTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleTableProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleTableProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleTableProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleTableProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StyleTableProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblStyleRowBandSize" == name)
    return new TableStyleRowBandSize();
    
if( 23 == namespaceId && "tblStyleColBandSize" == name)
    return new TableStyleColumnBandSize();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblStyleRowBandSize","tblStyleColBandSize","jc","tblCellSpacing","tblInd","tblBorders","shd","tblCellMar" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TableStyleRowBandSize.</para>
    /// <para> Represents the following element tag in the schema: w:tblStyleRowBandSize </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleRowBandSize TableStyleRowBandSize
    {
        get 
        {
            return GetElement<TableStyleRowBandSize>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> TableStyleColumnBandSize.</para>
    /// <para> Represents the following element tag in the schema: w:tblStyleColBandSize </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleColumnBandSize TableStyleColumnBandSize
    {
        get 
        {
            return GetElement<TableStyleColumnBandSize>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> TableJustification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> TableCellSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> TableIndentation.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> TableBorders.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> TableCellMarginDefault.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleTableProperties>(deep);
    }

   
}
/// <summary>
/// <para>Style Table Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tcPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>NoWrap &lt;w:noWrap></description></item>
///<item><description>TableCellMargin &lt;w:tcMar></description></item>
///<item><description>TableCellVerticalAlignment &lt;w:vAlign></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(NoWrap))]
    [ChildElementInfo(typeof(TableCellMargin))]
    [ChildElementInfo(typeof(TableCellVerticalAlignment))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StyleTableCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "tcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11957;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the StyleTableCellProperties class.
    /// </summary>
    public StyleTableCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StyleTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleTableCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleTableCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StyleTableCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StyleTableCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StyleTableCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "noWrap" == name)
    return new NoWrap();
    
if( 23 == namespaceId && "tcMar" == name)
    return new TableCellMargin();
    
if( 23 == namespaceId && "vAlign" == name)
    return new TableCellVerticalAlignment();
    

    return null;
}

        private static readonly string[] eleTagNames = { "shd","noWrap","tcMar","vAlign" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> NoWrap.</para>
    /// <para> Represents the following element tag in the schema: w:noWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoWrap NoWrap
    {
        get 
        {
            return GetElement<NoWrap>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> TableCellMargin.</para>
    /// <para> Represents the following element tag in the schema: w:tcMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMargin TableCellMargin
    {
        get 
        {
            return GetElement<TableCellMargin>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> TableCellVerticalAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:vAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellVerticalAlignment TableCellVerticalAlignment
    {
        get 
        {
            return GetElement<TableCellVerticalAlignment>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StyleTableCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Style Conditional Table Formatting Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblStylePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StyleParagraphProperties &lt;w:pPr></description></item>
///<item><description>RunPropertiesBaseStyle &lt;w:rPr></description></item>
///<item><description>TableStyleConditionalFormattingTableProperties &lt;w:tblPr></description></item>
///<item><description>TableStyleConditionalFormattingTableRowProperties &lt;w:trPr></description></item>
///<item><description>TableStyleConditionalFormattingTableCellProperties &lt;w:tcPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StyleParagraphProperties))]
    [ChildElementInfo(typeof(RunPropertiesBaseStyle))]
    [ChildElementInfo(typeof(TableStyleConditionalFormattingTableProperties))]
    [ChildElementInfo(typeof(TableStyleConditionalFormattingTableRowProperties))]
    [ChildElementInfo(typeof(TableStyleConditionalFormattingTableCellProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleProperties : OpenXmlCompositeElement
{
    private const string tagName = "tblStylePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11958;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Style Conditional Formatting Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableStyleOverrideValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableStyleOverrideValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleProperties class.
    /// </summary>
    public TableStyleProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyleProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyleProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyleProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyleProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pPr" == name)
    return new StyleParagraphProperties();
    
if( 23 == namespaceId && "rPr" == name)
    return new RunPropertiesBaseStyle();
    
if( 23 == namespaceId && "tblPr" == name)
    return new TableStyleConditionalFormattingTableProperties();
    
if( 23 == namespaceId && "trPr" == name)
    return new TableStyleConditionalFormattingTableRowProperties();
    
if( 23 == namespaceId && "tcPr" == name)
    return new TableStyleConditionalFormattingTableCellProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pPr","rPr","tblPr","trPr","tcPr" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table Style Conditional Formatting Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleParagraphProperties StyleParagraphProperties
    {
        get 
        {
            return GetElement<StyleParagraphProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunPropertiesBaseStyle RunPropertiesBaseStyle
    {
        get 
        {
            return GetElement<RunPropertiesBaseStyle>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Table Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tblPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleConditionalFormattingTableProperties TableStyleConditionalFormattingTableProperties
    {
        get 
        {
            return GetElement<TableStyleConditionalFormattingTableProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Table Row Properties.</para>
    /// <para> Represents the following element tag in the schema: w:trPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleConditionalFormattingTableRowProperties TableStyleConditionalFormattingTableRowProperties
    {
        get 
        {
            return GetElement<TableStyleConditionalFormattingTableRowProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Table Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleConditionalFormattingTableCellProperties TableStyleConditionalFormattingTableCellProperties
    {
        get 
        {
            return GetElement<TableStyleConditionalFormattingTableCellProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableStyleOverrideValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleProperties>(deep);
    }

   
}
/// <summary>
/// <para>Latent Style Exception.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lsdException.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LatentStyleExceptionInfo : OpenXmlLeafElement
{
    private const string tagName = "lsdException";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11959;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","locked","uiPriority","semiHidden","unhideWhenUsed","qFormat" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Primary Style Name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Latent Style Locking Setting.</para>
    /// <para>Represents the following attribute in the schema: w:locked </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "locked")]
    public OnOffValue Locked
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Override default sorting order.</para>
    /// <para>Represents the following attribute in the schema: w:uiPriority </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "uiPriority")]
    public Int32Value UiPriority
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Semi hidden text override.</para>
    /// <para>Represents the following attribute in the schema: w:semiHidden </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "semiHidden")]
    public OnOffValue SemiHidden
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Unhide when used.</para>
    /// <para>Represents the following attribute in the schema: w:unhideWhenUsed </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "unhideWhenUsed")]
    public OnOffValue UnhideWhenUsed
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Latent Style Primary Style Setting.</para>
    /// <para>Represents the following attribute in the schema: w:qFormat </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "qFormat")]
    public OnOffValue PrimaryStyle
    {
        get { return (OnOffValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LatentStyleExceptionInfo class.
    /// </summary>
    public LatentStyleExceptionInfo():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "locked" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "uiPriority" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "semiHidden" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "unhideWhenUsed" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "qFormat" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LatentStyleExceptionInfo>(deep);
    }

   
}
/// <summary>
/// <para>Document Default Paragraph and Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docDefaults.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunPropertiesDefault &lt;w:rPrDefault></description></item>
///<item><description>ParagraphPropertiesDefault &lt;w:pPrDefault></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunPropertiesDefault))]
    [ChildElementInfo(typeof(ParagraphPropertiesDefault))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocDefaults : OpenXmlCompositeElement
{
    private const string tagName = "docDefaults";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11960;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DocDefaults class.
    /// </summary>
    public DocDefaults():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocDefaults(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocDefaults(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocDefaults class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocDefaults(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rPrDefault" == name)
    return new RunPropertiesDefault();
    
if( 23 == namespaceId && "pPrDefault" == name)
    return new ParagraphPropertiesDefault();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPrDefault","pPrDefault" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Default Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPrDefault </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RunPropertiesDefault RunPropertiesDefault
    {
        get 
        {
            return GetElement<RunPropertiesDefault>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Default Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPrDefault </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphPropertiesDefault ParagraphPropertiesDefault
    {
        get 
        {
            return GetElement<ParagraphPropertiesDefault>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocDefaults>(deep);
    }

   
}
/// <summary>
/// <para>Latent Style Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:latentStyles.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>LatentStyleExceptionInfo &lt;w:lsdException></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(LatentStyleExceptionInfo))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LatentStyles : OpenXmlCompositeElement
{
    private const string tagName = "latentStyles";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11961;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "defLockedState","defUIPriority","defSemiHidden","defUnhideWhenUsed","defQFormat","count" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Default Style Locking Setting.</para>
    /// <para>Represents the following attribute in the schema: w:defLockedState </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "defLockedState")]
    public OnOffValue DefaultLockedState
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Default User Interface Priority Setting.</para>
    /// <para>Represents the following attribute in the schema: w:defUIPriority </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "defUIPriority")]
    public Int32Value DefaultUiPriority
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Default Semi-Hidden Setting.</para>
    /// <para>Represents the following attribute in the schema: w:defSemiHidden </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "defSemiHidden")]
    public OnOffValue DefaultSemiHidden
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Default Hidden Until Used Setting.</para>
    /// <para>Represents the following attribute in the schema: w:defUnhideWhenUsed </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "defUnhideWhenUsed")]
    public OnOffValue DefaultUnhideWhenUsed
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Default Primary Style Setting.</para>
    /// <para>Represents the following attribute in the schema: w:defQFormat </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "defQFormat")]
    public OnOffValue DefaultPrimaryStyle
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Latent Style Count.</para>
    /// <para>Represents the following attribute in the schema: w:count </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "count")]
    public Int32Value Count
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the LatentStyles class.
    /// </summary>
    public LatentStyles():base(){}
    
            /// <summary>
    ///Initializes a new instance of the LatentStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LatentStyles(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LatentStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LatentStyles(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LatentStyles class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LatentStyles(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lsdException" == name)
    return new LatentStyleExceptionInfo();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "defLockedState" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "defUIPriority" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "defSemiHidden" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "defUnhideWhenUsed" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "defQFormat" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "count" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LatentStyles>(deep);
    }

   
}
/// <summary>
/// <para>Style Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:style.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StyleName &lt;w:name></description></item>
///<item><description>Aliases &lt;w:aliases></description></item>
///<item><description>BasedOn &lt;w:basedOn></description></item>
///<item><description>NextParagraphStyle &lt;w:next></description></item>
///<item><description>LinkedStyle &lt;w:link></description></item>
///<item><description>AutoRedefine &lt;w:autoRedefine></description></item>
///<item><description>StyleHidden &lt;w:hidden></description></item>
///<item><description>UIPriority &lt;w:uiPriority></description></item>
///<item><description>SemiHidden &lt;w:semiHidden></description></item>
///<item><description>UnhideWhenUsed &lt;w:unhideWhenUsed></description></item>
///<item><description>PrimaryStyle &lt;w:qFormat></description></item>
///<item><description>Locked &lt;w:locked></description></item>
///<item><description>Personal &lt;w:personal></description></item>
///<item><description>PersonalCompose &lt;w:personalCompose></description></item>
///<item><description>PersonalReply &lt;w:personalReply></description></item>
///<item><description>Rsid &lt;w:rsid></description></item>
///<item><description>StyleParagraphProperties &lt;w:pPr></description></item>
///<item><description>StyleRunProperties &lt;w:rPr></description></item>
///<item><description>StyleTableProperties &lt;w:tblPr></description></item>
///<item><description>TableStyleConditionalFormattingTableRowProperties &lt;w:trPr></description></item>
///<item><description>StyleTableCellProperties &lt;w:tcPr></description></item>
///<item><description>TableStyleProperties &lt;w:tblStylePr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StyleName))]
    [ChildElementInfo(typeof(Aliases))]
    [ChildElementInfo(typeof(BasedOn))]
    [ChildElementInfo(typeof(NextParagraphStyle))]
    [ChildElementInfo(typeof(LinkedStyle))]
    [ChildElementInfo(typeof(AutoRedefine))]
    [ChildElementInfo(typeof(StyleHidden))]
    [ChildElementInfo(typeof(UIPriority))]
    [ChildElementInfo(typeof(SemiHidden))]
    [ChildElementInfo(typeof(UnhideWhenUsed))]
    [ChildElementInfo(typeof(PrimaryStyle))]
    [ChildElementInfo(typeof(Locked))]
    [ChildElementInfo(typeof(Personal))]
    [ChildElementInfo(typeof(PersonalCompose))]
    [ChildElementInfo(typeof(PersonalReply))]
    [ChildElementInfo(typeof(Rsid))]
    [ChildElementInfo(typeof(StyleParagraphProperties))]
    [ChildElementInfo(typeof(StyleRunProperties))]
    [ChildElementInfo(typeof(StyleTableProperties))]
    [ChildElementInfo(typeof(TableStyleConditionalFormattingTableRowProperties))]
    [ChildElementInfo(typeof(StyleTableCellProperties))]
    [ChildElementInfo(typeof(TableStyleProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Style : OpenXmlCompositeElement
{
    private const string tagName = "style";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11962;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","styleId","default","customStyle" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Style Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.StyleValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.StyleValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Style ID.</para>
    /// <para>Represents the following attribute in the schema: w:styleId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "styleId")]
    public StringValue StyleId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Default Style.</para>
    /// <para>Represents the following attribute in the schema: w:default </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "default")]
    public OnOffValue Default
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> User-Defined Style.</para>
    /// <para>Represents the following attribute in the schema: w:customStyle </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "customStyle")]
    public OnOffValue CustomStyle
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Style class.
    /// </summary>
    public Style():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Style class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Style(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Style class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Style(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Style class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Style(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StyleName();
    
if( 23 == namespaceId && "aliases" == name)
    return new Aliases();
    
if( 23 == namespaceId && "basedOn" == name)
    return new BasedOn();
    
if( 23 == namespaceId && "next" == name)
    return new NextParagraphStyle();
    
if( 23 == namespaceId && "link" == name)
    return new LinkedStyle();
    
if( 23 == namespaceId && "autoRedefine" == name)
    return new AutoRedefine();
    
if( 23 == namespaceId && "hidden" == name)
    return new StyleHidden();
    
if( 23 == namespaceId && "uiPriority" == name)
    return new UIPriority();
    
if( 23 == namespaceId && "semiHidden" == name)
    return new SemiHidden();
    
if( 23 == namespaceId && "unhideWhenUsed" == name)
    return new UnhideWhenUsed();
    
if( 23 == namespaceId && "qFormat" == name)
    return new PrimaryStyle();
    
if( 23 == namespaceId && "locked" == name)
    return new Locked();
    
if( 23 == namespaceId && "personal" == name)
    return new Personal();
    
if( 23 == namespaceId && "personalCompose" == name)
    return new PersonalCompose();
    
if( 23 == namespaceId && "personalReply" == name)
    return new PersonalReply();
    
if( 23 == namespaceId && "rsid" == name)
    return new Rsid();
    
if( 23 == namespaceId && "pPr" == name)
    return new StyleParagraphProperties();
    
if( 23 == namespaceId && "rPr" == name)
    return new StyleRunProperties();
    
if( 23 == namespaceId && "tblPr" == name)
    return new StyleTableProperties();
    
if( 23 == namespaceId && "trPr" == name)
    return new TableStyleConditionalFormattingTableRowProperties();
    
if( 23 == namespaceId && "tcPr" == name)
    return new StyleTableCellProperties();
    
if( 23 == namespaceId && "tblStylePr" == name)
    return new TableStyleProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "name","aliases","basedOn","next","link","autoRedefine","hidden","uiPriority","semiHidden","unhideWhenUsed","qFormat","locked","personal","personalCompose","personalReply","rsid","pPr","rPr","tblPr","trPr","tcPr","tblStylePr" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Primary Style Name.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleName StyleName
    {
        get 
        {
            return GetElement<StyleName>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Alternate Style Names.</para>
    /// <para> Represents the following element tag in the schema: w:aliases </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Aliases Aliases
    {
        get 
        {
            return GetElement<Aliases>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Parent Style ID.</para>
    /// <para> Represents the following element tag in the schema: w:basedOn </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BasedOn BasedOn
    {
        get 
        {
            return GetElement<BasedOn>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Style For Next Paragraph.</para>
    /// <para> Represents the following element tag in the schema: w:next </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NextParagraphStyle NextParagraphStyle
    {
        get 
        {
            return GetElement<NextParagraphStyle>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Linked Style Reference.</para>
    /// <para> Represents the following element tag in the schema: w:link </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LinkedStyle LinkedStyle
    {
        get 
        {
            return GetElement<LinkedStyle>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Automatically Merge User Formatting Into Style Definition.</para>
    /// <para> Represents the following element tag in the schema: w:autoRedefine </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoRedefine AutoRedefine
    {
        get 
        {
            return GetElement<AutoRedefine>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Hide Style From User Interface.</para>
    /// <para> Represents the following element tag in the schema: w:hidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleHidden StyleHidden
    {
        get 
        {
            return GetElement<StyleHidden>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Optional User Interface Sorting Order.</para>
    /// <para> Represents the following element tag in the schema: w:uiPriority </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UIPriority UIPriority
    {
        get 
        {
            return GetElement<UIPriority>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Hide Style From Main User Interface.</para>
    /// <para> Represents the following element tag in the schema: w:semiHidden </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SemiHidden SemiHidden
    {
        get 
        {
            return GetElement<SemiHidden>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Remove Semi-Hidden Property When Style Is Used.</para>
    /// <para> Represents the following element tag in the schema: w:unhideWhenUsed </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UnhideWhenUsed UnhideWhenUsed
    {
        get 
        {
            return GetElement<UnhideWhenUsed>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Primary Style.</para>
    /// <para> Represents the following element tag in the schema: w:qFormat </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrimaryStyle PrimaryStyle
    {
        get 
        {
            return GetElement<PrimaryStyle>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Style Cannot Be Applied.</para>
    /// <para> Represents the following element tag in the schema: w:locked </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Locked Locked
    {
        get 
        {
            return GetElement<Locked>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> E-Mail Message Text Style.</para>
    /// <para> Represents the following element tag in the schema: w:personal </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Personal Personal
    {
        get 
        {
            return GetElement<Personal>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> E-Mail Message Composition Style.</para>
    /// <para> Represents the following element tag in the schema: w:personalCompose </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PersonalCompose PersonalCompose
    {
        get 
        {
            return GetElement<PersonalCompose>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> E-Mail Message Reply Style.</para>
    /// <para> Represents the following element tag in the schema: w:personalReply </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PersonalReply PersonalReply
    {
        get 
        {
            return GetElement<PersonalReply>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Revision Identifier for Style Definition.</para>
    /// <para> Represents the following element tag in the schema: w:rsid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Rsid Rsid
    {
        get 
        {
            return GetElement<Rsid>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> Style Paragraph Properties.</para>
    /// <para> Represents the following element tag in the schema: w:pPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleParagraphProperties StyleParagraphProperties
    {
        get 
        {
            return GetElement<StyleParagraphProperties>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Run Properties.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleRunProperties StyleRunProperties
    {
        get 
        {
            return GetElement<StyleRunProperties>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Style Table Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tblPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleTableProperties StyleTableProperties
    {
        get 
        {
            return GetElement<StyleTableProperties>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> Style Table Row Properties.</para>
    /// <para> Represents the following element tag in the schema: w:trPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableStyleConditionalFormattingTableRowProperties TableStyleConditionalFormattingTableRowProperties
    {
        get 
        {
            return GetElement<TableStyleConditionalFormattingTableRowProperties>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Style Table Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: w:tcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleTableCellProperties StyleTableCellProperties
    {
        get 
        {
            return GetElement<StyleTableCellProperties>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.StyleValues>();
    
if( 23 == namespaceId && "styleId" == name)
    return new StringValue();
    
if( 23 == namespaceId && "default" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "customStyle" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Style>(deep);
    }

   
}
/// <summary>
/// <para>Properties for a Single Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:font.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltName &lt;w:altName></description></item>
///<item><description>Panose1Number &lt;w:panose1></description></item>
///<item><description>FontCharSet &lt;w:charset></description></item>
///<item><description>FontFamily &lt;w:family></description></item>
///<item><description>NotTrueType &lt;w:notTrueType></description></item>
///<item><description>Pitch &lt;w:pitch></description></item>
///<item><description>FontSignature &lt;w:sig></description></item>
///<item><description>EmbedRegularFont &lt;w:embedRegular></description></item>
///<item><description>EmbedBoldFont &lt;w:embedBold></description></item>
///<item><description>EmbedItalicFont &lt;w:embedItalic></description></item>
///<item><description>EmbedBoldItalicFont &lt;w:embedBoldItalic></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltName))]
    [ChildElementInfo(typeof(Panose1Number))]
    [ChildElementInfo(typeof(FontCharSet))]
    [ChildElementInfo(typeof(FontFamily))]
    [ChildElementInfo(typeof(NotTrueType))]
    [ChildElementInfo(typeof(Pitch))]
    [ChildElementInfo(typeof(FontSignature))]
    [ChildElementInfo(typeof(EmbedRegularFont))]
    [ChildElementInfo(typeof(EmbedBoldFont))]
    [ChildElementInfo(typeof(EmbedItalicFont))]
    [ChildElementInfo(typeof(EmbedBoldItalicFont))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Font : OpenXmlCompositeElement
{
    private const string tagName = "font";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11963;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Font class.
    /// </summary>
    public Font():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Font class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Font(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Font class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Font(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Font class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Font(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altName" == name)
    return new AltName();
    
if( 23 == namespaceId && "panose1" == name)
    return new Panose1Number();
    
if( 23 == namespaceId && "charset" == name)
    return new FontCharSet();
    
if( 23 == namespaceId && "family" == name)
    return new FontFamily();
    
if( 23 == namespaceId && "notTrueType" == name)
    return new NotTrueType();
    
if( 23 == namespaceId && "pitch" == name)
    return new Pitch();
    
if( 23 == namespaceId && "sig" == name)
    return new FontSignature();
    
if( 23 == namespaceId && "embedRegular" == name)
    return new EmbedRegularFont();
    
if( 23 == namespaceId && "embedBold" == name)
    return new EmbedBoldFont();
    
if( 23 == namespaceId && "embedItalic" == name)
    return new EmbedItalicFont();
    
if( 23 == namespaceId && "embedBoldItalic" == name)
    return new EmbedBoldItalicFont();
    

    return null;
}

        private static readonly string[] eleTagNames = { "altName","panose1","charset","family","notTrueType","pitch","sig","embedRegular","embedBold","embedItalic","embedBoldItalic" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> AltName.</para>
    /// <para> Represents the following element tag in the schema: w:altName </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AltName AltName
    {
        get 
        {
            return GetElement<AltName>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Panose1Number.</para>
    /// <para> Represents the following element tag in the schema: w:panose1 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Panose1Number Panose1Number
    {
        get 
        {
            return GetElement<Panose1Number>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> FontCharSet.</para>
    /// <para> Represents the following element tag in the schema: w:charset </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontCharSet FontCharSet
    {
        get 
        {
            return GetElement<FontCharSet>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> FontFamily.</para>
    /// <para> Represents the following element tag in the schema: w:family </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontFamily FontFamily
    {
        get 
        {
            return GetElement<FontFamily>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> NotTrueType.</para>
    /// <para> Represents the following element tag in the schema: w:notTrueType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NotTrueType NotTrueType
    {
        get 
        {
            return GetElement<NotTrueType>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Pitch.</para>
    /// <para> Represents the following element tag in the schema: w:pitch </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Pitch Pitch
    {
        get 
        {
            return GetElement<Pitch>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> FontSignature.</para>
    /// <para> Represents the following element tag in the schema: w:sig </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FontSignature FontSignature
    {
        get 
        {
            return GetElement<FontSignature>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> EmbedRegularFont.</para>
    /// <para> Represents the following element tag in the schema: w:embedRegular </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedRegularFont EmbedRegularFont
    {
        get 
        {
            return GetElement<EmbedRegularFont>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> EmbedBoldFont.</para>
    /// <para> Represents the following element tag in the schema: w:embedBold </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedBoldFont EmbedBoldFont
    {
        get 
        {
            return GetElement<EmbedBoldFont>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> EmbedItalicFont.</para>
    /// <para> Represents the following element tag in the schema: w:embedItalic </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedItalicFont EmbedItalicFont
    {
        get 
        {
            return GetElement<EmbedItalicFont>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> EmbedBoldItalicFont.</para>
    /// <para> Represents the following element tag in the schema: w:embedBoldItalic </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EmbedBoldItalicFont EmbedBoldItalicFont
    {
        get 
        {
            return GetElement<EmbedBoldItalicFont>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Font>(deep);
    }

   
}
/// <summary>
/// <para>Left Margin for HTML div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marLeft.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftMarginDiv : SignedTwipsMeasureType
{
    private const string tagName = "marLeft";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11966;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftMarginDiv class.
    /// </summary>
    public LeftMarginDiv():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftMarginDiv>(deep);
    }

}
/// <summary>
/// <para>Right Margin for HTML div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marRight.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightMarginDiv : SignedTwipsMeasureType
{
    private const string tagName = "marRight";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11967;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightMarginDiv class.
    /// </summary>
    public RightMarginDiv():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightMarginDiv>(deep);
    }

}
/// <summary>
/// <para>Top Margin for HTML div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marTop.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopMarginDiv : SignedTwipsMeasureType
{
    private const string tagName = "marTop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11968;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopMarginDiv class.
    /// </summary>
    public TopMarginDiv():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopMarginDiv>(deep);
    }

}
/// <summary>
/// <para>Bottom Margin for HTML div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:marBottom.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomMarginDiv : SignedTwipsMeasureType
{
    private const string tagName = "marBottom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11969;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomMarginDiv class.
    /// </summary>
    public BottomMarginDiv():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomMarginDiv>(deep);
    }

}
/// <summary>
/// Defines the SignedTwipsMeasureType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class SignedTwipsMeasureType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Positive or Negative Value in Twentieths of a Point.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the SignedTwipsMeasureType class.
    /// </summary>
    protected SignedTwipsMeasureType(){}
    
    
    
}
/// <summary>
/// <para>Set of Borders for HTML div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:divBdr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TopBorder &lt;w:top></description></item>
///<item><description>LeftBorder &lt;w:left></description></item>
///<item><description>BottomBorder &lt;w:bottom></description></item>
///<item><description>RightBorder &lt;w:right></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(RightBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DivBorder : OpenXmlCompositeElement
{
    private const string tagName = "divBdr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11970;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DivBorder class.
    /// </summary>
    public DivBorder():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DivBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DivBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DivBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DivBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DivBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DivBorder(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 23 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 23 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 23 == namespaceId && "right" == name)
    return new RightBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "top","left","bottom","right" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Top Border for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Left Border for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Bottom Border for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Right Border for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DivBorder>(deep);
    }

   
}
/// <summary>
/// <para>Child div Elements Contained within Current div.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:divsChild.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Div &lt;w:div></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DivsChild : DivsType
{
    private const string tagName = "divsChild";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11971;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DivsChild class.
    /// </summary>
    public DivsChild():base(){}
            /// <summary>
    ///Initializes a new instance of the DivsChild class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DivsChild(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DivsChild class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DivsChild(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DivsChild class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DivsChild(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DivsChild>(deep);
    }

}
/// <summary>
/// <para>Defines the Divs Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:divs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Div &lt;w:div></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Divs : DivsType
{
    private const string tagName = "divs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12198;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Divs class.
    /// </summary>
    public Divs():base(){}
            /// <summary>
    ///Initializes a new instance of the Divs class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Divs(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Divs class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Divs(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Divs class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Divs(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Divs>(deep);
    }

}
/// <summary>
/// Defines the DivsType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Div &lt;w:div></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Div))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class DivsType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "div" == name)
    return new Div();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the DivsType class.
    /// </summary>
    protected DivsType(){}
    
            /// <summary>
    ///Initializes a new instance of the DivsType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DivsType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DivsType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DivsType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DivsType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected DivsType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Information About Single HTML div Element.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:div.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>BlockQuote &lt;w:blockQuote></description></item>
///<item><description>BodyDiv &lt;w:bodyDiv></description></item>
///<item><description>LeftMarginDiv &lt;w:marLeft></description></item>
///<item><description>RightMarginDiv &lt;w:marRight></description></item>
///<item><description>TopMarginDiv &lt;w:marTop></description></item>
///<item><description>BottomMarginDiv &lt;w:marBottom></description></item>
///<item><description>DivBorder &lt;w:divBdr></description></item>
///<item><description>DivsChild &lt;w:divsChild></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(BlockQuote))]
    [ChildElementInfo(typeof(BodyDiv))]
    [ChildElementInfo(typeof(LeftMarginDiv))]
    [ChildElementInfo(typeof(RightMarginDiv))]
    [ChildElementInfo(typeof(TopMarginDiv))]
    [ChildElementInfo(typeof(BottomMarginDiv))]
    [ChildElementInfo(typeof(DivBorder))]
    [ChildElementInfo(typeof(DivsChild))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Div : OpenXmlCompositeElement
{
    private const string tagName = "div";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11972;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> div Data ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Div class.
    /// </summary>
    public Div():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Div class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Div(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Div class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Div(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Div class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Div(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "blockQuote" == name)
    return new BlockQuote();
    
if( 23 == namespaceId && "bodyDiv" == name)
    return new BodyDiv();
    
if( 23 == namespaceId && "marLeft" == name)
    return new LeftMarginDiv();
    
if( 23 == namespaceId && "marRight" == name)
    return new RightMarginDiv();
    
if( 23 == namespaceId && "marTop" == name)
    return new TopMarginDiv();
    
if( 23 == namespaceId && "marBottom" == name)
    return new BottomMarginDiv();
    
if( 23 == namespaceId && "divBdr" == name)
    return new DivBorder();
    
if( 23 == namespaceId && "divsChild" == name)
    return new DivsChild();
    

    return null;
}

        private static readonly string[] eleTagNames = { "blockQuote","bodyDiv","marLeft","marRight","marTop","marBottom","divBdr","divsChild" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Data for HTML blockquote Element.</para>
    /// <para> Represents the following element tag in the schema: w:blockQuote </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BlockQuote BlockQuote
    {
        get 
        {
            return GetElement<BlockQuote>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Data for HTML body Element.</para>
    /// <para> Represents the following element tag in the schema: w:bodyDiv </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BodyDiv BodyDiv
    {
        get 
        {
            return GetElement<BodyDiv>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Left Margin for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:marLeft </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LeftMarginDiv LeftMarginDiv
    {
        get 
        {
            return GetElement<LeftMarginDiv>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Right Margin for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:marRight </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RightMarginDiv RightMarginDiv
    {
        get 
        {
            return GetElement<RightMarginDiv>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Top Margin for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:marTop </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopMarginDiv TopMarginDiv
    {
        get 
        {
            return GetElement<TopMarginDiv>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Bottom Margin for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:marBottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BottomMarginDiv BottomMarginDiv
    {
        get 
        {
            return GetElement<BottomMarginDiv>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Set of Borders for HTML div.</para>
    /// <para> Represents the following element tag in the schema: w:divBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DivBorder DivBorder
    {
        get 
        {
            return GetElement<DivBorder>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Div>(deep);
    }

   
}
/// <summary>
/// <para>Comment Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:comment.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Comment : OpenXmlCompositeElement
{
    private const string tagName = "comment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11973;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "initials","author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> initials.</para>
    /// <para>Represents the following attribute in the schema: w:initials </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "initials")]
    public StringValue Initials
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Comment class.
    /// </summary>
    public Comment():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Comment class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comment(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Comment class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comment(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Comment class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Comment(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "initials" == name)
    return new StringValue();
    
if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Comment>(deep);
    }

   
}
/// <summary>
/// <para>Footnote Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnote.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Footnote : FootnoteEndnoteType
{
    private const string tagName = "footnote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11974;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Footnote class.
    /// </summary>
    public Footnote():base(){}
            /// <summary>
    ///Initializes a new instance of the Footnote class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footnote(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Footnote class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Footnote(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Footnote class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Footnote(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Footnote>(deep);
    }

}
/// <summary>
/// <para>Endnote Content.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnote.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Endnote : FootnoteEndnoteType
{
    private const string tagName = "endnote";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11975;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Endnote class.
    /// </summary>
    public Endnote():base(){}
            /// <summary>
    ///Initializes a new instance of the Endnote class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Endnote(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Endnote class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Endnote(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Endnote class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Endnote(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Endnote>(deep);
    }

}
/// <summary>
/// Defines the FootnoteEndnoteType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class FootnoteEndnoteType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "type","id" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Footnote/Endnote Type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnoteEndnoteValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnoteEndnoteValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Footnote/Endnote ID.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public IntegerValue Id
    {
        get { return (IntegerValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FootnoteEndnoteValues>();
    
if( 23 == namespaceId && "id" == name)
    return new IntegerValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the FootnoteEndnoteType class.
    /// </summary>
    protected FootnoteEndnoteType(){}
    
            /// <summary>
    ///Initializes a new instance of the FootnoteEndnoteType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected FootnoteEndnoteType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteEndnoteType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected FootnoteEndnoteType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteEndnoteType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected FootnoteEndnoteType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Entry Insertion Behavior.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:behavior.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Behavior : OpenXmlLeafElement
{
    private const string tagName = "behavior";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11976;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Insertion Behavior Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartBehaviorValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartBehaviorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Behavior class.
    /// </summary>
    public Behavior():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartBehaviorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Behavior>(deep);
    }

   
}
/// <summary>
/// <para>Entry Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:type.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartType : OpenXmlLeafElement
{
    private const string tagName = "type";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11977;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Type Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartType class.
    /// </summary>
    public DocPartType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartType>(deep);
    }

   
}
/// <summary>
/// <para>Gallery Associated With Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:gallery.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Gallery : OpenXmlLeafElement
{
    private const string tagName = "gallery";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11978;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Gallery Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartGalleryValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartGalleryValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Gallery class.
    /// </summary>
    public Gallery():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocPartGalleryValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Gallery>(deep);
    }

   
}
/// <summary>
/// <para>Single Automatic Captioning Setting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoCaption.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoCaption : OpenXmlLeafElement
{
    private const string tagName = "autoCaption";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11979;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","caption" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Identifier of Object to be Automatically Captioned.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Caption Used for Automatic Captioning.</para>
    /// <para>Represents the following attribute in the schema: w:caption </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoCaption class.
    /// </summary>
    public AutoCaption():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "caption" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoCaption>(deep);
    }

   
}
/// <summary>
/// <para>Single Caption Type Definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:caption.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Caption : OpenXmlLeafElement
{
    private const string tagName = "caption";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11980;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","pos","chapNum","heading","noLabel","numFmt","sep" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Caption Type Name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Automatic Caption Placement.</para>
    /// <para>Represents the following attribute in the schema: w:pos </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "pos")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CaptionPositionValues> Position
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CaptionPositionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Include Chapter Number in Field for Caption.</para>
    /// <para>Represents the following attribute in the schema: w:chapNum </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "chapNum")]
    public OnOffValue ChapterNumber
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Style for Chapter Headings.</para>
    /// <para>Represents the following attribute in the schema: w:heading </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "heading")]
    public Int32Value Heading
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Do Not Include Name In Caption.</para>
    /// <para>Represents the following attribute in the schema: w:noLabel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "noLabel")]
    public OnOffValue NoLabel
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Caption Numbering Format.</para>
    /// <para>Represents the following attribute in the schema: w:numFmt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "numFmt")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues> NumberFormat
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Chapter Number/Item Index Separator.</para>
    /// <para>Represents the following attribute in the schema: w:sep </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "sep")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues> Separator
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Caption class.
    /// </summary>
    public Caption():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "pos" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CaptionPositionValues>();
    
if( 23 == namespaceId && "chapNum" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "heading" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "noLabel" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "numFmt" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.NumberFormatValues>();
    
if( 23 == namespaceId && "sep" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ChapterSeparatorValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Caption>(deep);
    }

   
}
/// <summary>
/// <para>Automatic Captioning Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:autoCaptions.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AutoCaption &lt;w:autoCaption></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AutoCaption))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoCaptions : OpenXmlCompositeElement
{
    private const string tagName = "autoCaptions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11981;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AutoCaptions class.
    /// </summary>
    public AutoCaptions():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AutoCaptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoCaptions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoCaptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoCaptions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoCaptions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AutoCaptions(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "autoCaption" == name)
    return new AutoCaption();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoCaptions>(deep);
    }

   
}
/// <summary>
/// <para>Document Background.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:background.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Background &lt;v:background></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Background))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocumentBackground : OpenXmlCompositeElement
{
    private const string tagName = "background";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11982;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "color","themeColor","themeTint","themeShade" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> color.</para>
    /// <para>Represents the following attribute in the schema: w:color </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "color")]
    public StringValue Color
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> themeColor.</para>
    /// <para>Represents the following attribute in the schema: w:themeColor </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeColor")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues> ThemeColor
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> themeTint.</para>
    /// <para>Represents the following attribute in the schema: w:themeTint </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeTint")]
    public StringValue ThemeTint
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> themeShade.</para>
    /// <para>Represents the following attribute in the schema: w:themeShade </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "themeShade")]
    public StringValue ThemeShade
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocumentBackground class.
    /// </summary>
    public DocumentBackground():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocumentBackground class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocumentBackground(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocumentBackground class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocumentBackground(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocumentBackground class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocumentBackground(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 26 == namespaceId && "background" == name)
    return new DocumentFormat.OpenXml.Vml.Background();
    

    return null;
}

        private static readonly string[] eleTagNames = { "background" };
    private static readonly byte[] eleNamespaceIds = { 26 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Background.</para>
    /// <para> Represents the following element tag in the schema: v:background </para>
    /// </summary>
    /// <remark>
    /// xmlns:v = urn:schemas-microsoft-com:vml
    /// </remark>
    public DocumentFormat.OpenXml.Vml.Background Background
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Vml.Background>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "color" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeColor" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ThemeColorValues>();
    
if( 23 == namespaceId && "themeTint" == name)
    return new StringValue();
    
if( 23 == namespaceId && "themeShade" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocumentBackground>(deep);
    }

   
}
/// <summary>
/// <para>List of Glossary Document Entries.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docParts.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPart &lt;w:docPart></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPart))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocParts : OpenXmlCompositeElement
{
    private const string tagName = "docParts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11983;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DocParts class.
    /// </summary>
    public DocParts():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocParts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocParts(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocParts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocParts(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocParts class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocParts(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docPart" == name)
    return new DocPart();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocParts>(deep);
    }

   
}
/// <summary>
/// <para>Entry Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartName : OpenXmlLeafElement
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11984;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","decorated" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Built-In Entry.</para>
    /// <para>Represents the following attribute in the schema: w:decorated </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "decorated")]
    public OnOffValue Decorated
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartName class.
    /// </summary>
    public DocPartName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "decorated" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartName>(deep);
    }

   
}
/// <summary>
/// <para>Entry Categorization.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:category.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Name &lt;w:name></description></item>
///<item><description>Gallery &lt;w:gallery></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Name))]
    [ChildElementInfo(typeof(Gallery))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Category : OpenXmlCompositeElement
{
    private const string tagName = "category";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11986;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Category class.
    /// </summary>
    public Category():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Category class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Category(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Category class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Category(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Category class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Category(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new Name();
    
if( 23 == namespaceId && "gallery" == name)
    return new Gallery();
    

    return null;
}

        private static readonly string[] eleTagNames = { "name","gallery" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Category Associated With Entry.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Name Name
    {
        get 
        {
            return GetElement<Name>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Gallery Associated With Entry.</para>
    /// <para> Represents the following element tag in the schema: w:gallery </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Gallery Gallery
    {
        get 
        {
            return GetElement<Gallery>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Category>(deep);
    }

   
}
/// <summary>
/// <para>Entry Types.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:types.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartType &lt;w:type></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPartType))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartTypes : OpenXmlCompositeElement
{
    private const string tagName = "types";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11987;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "all" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Entry Is Of All Types.</para>
    /// <para>Represents the following attribute in the schema: w:all </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "all")]
    public OnOffValue All
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartTypes class.
    /// </summary>
    public DocPartTypes():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocPartTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartTypes(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartTypes(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartTypes class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocPartTypes(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "type" == name)
    return new DocPartType();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "all" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartTypes>(deep);
    }

   
}
/// <summary>
/// <para>Entry Insertion Behaviors.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:behaviors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Behavior &lt;w:behavior></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Behavior))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Behaviors : OpenXmlCompositeElement
{
    private const string tagName = "behaviors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11988;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Behaviors class.
    /// </summary>
    public Behaviors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Behaviors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Behaviors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Behaviors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Behaviors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Behaviors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Behaviors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "behavior" == name)
    return new Behavior();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Behaviors>(deep);
    }

   
}
/// <summary>
/// <para>Entry ID.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:guid.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartId : OpenXmlLeafElement
{
    private const string tagName = "guid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11990;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> GUID Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartId class.
    /// </summary>
    public DocPartId():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartId>(deep);
    }

   
}
/// <summary>
/// <para>Glossary Document Entry Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartName &lt;w:name></description></item>
///<item><description>StyleId &lt;w:style></description></item>
///<item><description>Category &lt;w:category></description></item>
///<item><description>DocPartTypes &lt;w:types></description></item>
///<item><description>Behaviors &lt;w:behaviors></description></item>
///<item><description>Description &lt;w:description></description></item>
///<item><description>DocPartId &lt;w:guid></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPartName))]
    [ChildElementInfo(typeof(StyleId))]
    [ChildElementInfo(typeof(Category))]
    [ChildElementInfo(typeof(DocPartTypes))]
    [ChildElementInfo(typeof(Behaviors))]
    [ChildElementInfo(typeof(Description))]
    [ChildElementInfo(typeof(DocPartId))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartProperties : OpenXmlCompositeElement
{
    private const string tagName = "docPartPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11991;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DocPartProperties class.
    /// </summary>
    public DocPartProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocPartProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocPartProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new DocPartName();
    
if( 23 == namespaceId && "style" == name)
    return new StyleId();
    
if( 23 == namespaceId && "category" == name)
    return new Category();
    
if( 23 == namespaceId && "types" == name)
    return new DocPartTypes();
    
if( 23 == namespaceId && "behaviors" == name)
    return new Behaviors();
    
if( 23 == namespaceId && "description" == name)
    return new Description();
    
if( 23 == namespaceId && "guid" == name)
    return new DocPartId();
    

    return null;
}

        private static readonly string[] eleTagNames = { "name","style","category","types","behaviors","description","guid" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Entry Name.</para>
    /// <para> Represents the following element tag in the schema: w:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartName DocPartName
    {
        get 
        {
            return GetElement<DocPartName>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Associated Paragraph Style Name.</para>
    /// <para> Represents the following element tag in the schema: w:style </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public StyleId StyleId
    {
        get 
        {
            return GetElement<StyleId>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Entry Categorization.</para>
    /// <para> Represents the following element tag in the schema: w:category </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Category Category
    {
        get 
        {
            return GetElement<Category>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Entry Types.</para>
    /// <para> Represents the following element tag in the schema: w:types </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartTypes DocPartTypes
    {
        get 
        {
            return GetElement<DocPartTypes>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Entry Insertion Behaviors.</para>
    /// <para> Represents the following element tag in the schema: w:behaviors </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Behaviors Behaviors
    {
        get 
        {
            return GetElement<Behaviors>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Description for Entry.</para>
    /// <para> Represents the following element tag in the schema: w:description </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Description Description
    {
        get 
        {
            return GetElement<Description>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Entry ID.</para>
    /// <para> Represents the following element tag in the schema: w:guid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartId DocPartId
    {
        get 
        {
            return GetElement<DocPartId>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartProperties>(deep);
    }

   
}
/// <summary>
/// <para>Contents of Glossary Document Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartBody.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>SectionProperties &lt;w:sectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPartBody : BodyType
{
    private const string tagName = "docPartBody";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11992;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DocPartBody class.
    /// </summary>
    public DocPartBody():base(){}
            /// <summary>
    ///Initializes a new instance of the DocPartBody class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartBody(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartBody class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPartBody(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPartBody class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocPartBody(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPartBody>(deep);
    }

}
/// <summary>
/// <para>Defines the Body Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:body.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>SectionProperties &lt;w:sectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Body : BodyType
{
    private const string tagName = "body";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12221;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Body class.
    /// </summary>
    public Body():base(){}
            /// <summary>
    ///Initializes a new instance of the Body class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Body(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Body class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Body(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Body class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Body(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Body>(deep);
    }

}
/// <summary>
/// Defines the BodyType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AltChunk &lt;w:altChunk></description></item>
///<item><description>CustomXmlBlock &lt;w:customXml></description></item>
///<item><description>SdtBlock &lt;w:sdt></description></item>
///<item><description>Paragraph &lt;w:p></description></item>
///<item><description>Table &lt;w:tbl></description></item>
///<item><description>ProofError &lt;w:proofErr></description></item>
///<item><description>PermStart &lt;w:permStart></description></item>
///<item><description>PermEnd &lt;w:permEnd></description></item>
///<item><description>BookmarkStart &lt;w:bookmarkStart></description></item>
///<item><description>BookmarkEnd &lt;w:bookmarkEnd></description></item>
///<item><description>CommentRangeStart &lt;w:commentRangeStart></description></item>
///<item><description>CommentRangeEnd &lt;w:commentRangeEnd></description></item>
///<item><description>MoveFromRangeStart &lt;w:moveFromRangeStart></description></item>
///<item><description>MoveFromRangeEnd &lt;w:moveFromRangeEnd></description></item>
///<item><description>MoveToRangeStart &lt;w:moveToRangeStart></description></item>
///<item><description>MoveToRangeEnd &lt;w:moveToRangeEnd></description></item>
///<item><description>CustomXmlInsRangeStart &lt;w:customXmlInsRangeStart></description></item>
///<item><description>CustomXmlInsRangeEnd &lt;w:customXmlInsRangeEnd></description></item>
///<item><description>CustomXmlDelRangeStart &lt;w:customXmlDelRangeStart></description></item>
///<item><description>CustomXmlDelRangeEnd &lt;w:customXmlDelRangeEnd></description></item>
///<item><description>CustomXmlMoveFromRangeStart &lt;w:customXmlMoveFromRangeStart></description></item>
///<item><description>CustomXmlMoveFromRangeEnd &lt;w:customXmlMoveFromRangeEnd></description></item>
///<item><description>CustomXmlMoveToRangeStart &lt;w:customXmlMoveToRangeStart></description></item>
///<item><description>CustomXmlMoveToRangeEnd &lt;w:customXmlMoveToRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart &lt;w14:customXmlConflictInsRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd &lt;w14:customXmlConflictInsRangeEnd></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart &lt;w14:customXmlConflictDelRangeStart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd &lt;w14:customXmlConflictDelRangeEnd></description></item>
///<item><description>InsertedRun &lt;w:ins></description></item>
///<item><description>DeletedRun &lt;w:del></description></item>
///<item><description>MoveFromRun &lt;w:moveFrom></description></item>
///<item><description>MoveToRun &lt;w:moveTo></description></item>
///<item><description>ContentPart &lt;w:contentPart></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion &lt;w14:conflictDel></description></item>
///<item><description>SectionProperties &lt;w:sectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AltChunk))]
    [ChildElementInfo(typeof(CustomXmlBlock))]
    [ChildElementInfo(typeof(SdtBlock))]
    [ChildElementInfo(typeof(Paragraph))]
    [ChildElementInfo(typeof(Table))]
    [ChildElementInfo(typeof(ProofError))]
    [ChildElementInfo(typeof(PermStart))]
    [ChildElementInfo(typeof(PermEnd))]
    [ChildElementInfo(typeof(BookmarkStart))]
    [ChildElementInfo(typeof(BookmarkEnd))]
    [ChildElementInfo(typeof(CommentRangeStart))]
    [ChildElementInfo(typeof(CommentRangeEnd))]
    [ChildElementInfo(typeof(MoveFromRangeStart))]
    [ChildElementInfo(typeof(MoveFromRangeEnd))]
    [ChildElementInfo(typeof(MoveToRangeStart))]
    [ChildElementInfo(typeof(MoveToRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlInsRangeStart))]
    [ChildElementInfo(typeof(CustomXmlInsRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlDelRangeStart))]
    [ChildElementInfo(typeof(CustomXmlDelRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveFromRangeEnd))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeStart))]
    [ChildElementInfo(typeof(CustomXmlMoveToRangeEnd))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(InsertedRun))]
    [ChildElementInfo(typeof(DeletedRun))]
    [ChildElementInfo(typeof(MoveFromRun))]
    [ChildElementInfo(typeof(MoveToRun))]
    [ChildElementInfo(typeof(ContentPart),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SectionProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class BodyType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "altChunk" == name)
    return new AltChunk();
    
if( 23 == namespaceId && "customXml" == name)
    return new CustomXmlBlock();
    
if( 23 == namespaceId && "sdt" == name)
    return new SdtBlock();
    
if( 23 == namespaceId && "p" == name)
    return new Paragraph();
    
if( 23 == namespaceId && "tbl" == name)
    return new Table();
    
if( 23 == namespaceId && "proofErr" == name)
    return new ProofError();
    
if( 23 == namespaceId && "permStart" == name)
    return new PermStart();
    
if( 23 == namespaceId && "permEnd" == name)
    return new PermEnd();
    
if( 23 == namespaceId && "bookmarkStart" == name)
    return new BookmarkStart();
    
if( 23 == namespaceId && "bookmarkEnd" == name)
    return new BookmarkEnd();
    
if( 23 == namespaceId && "commentRangeStart" == name)
    return new CommentRangeStart();
    
if( 23 == namespaceId && "commentRangeEnd" == name)
    return new CommentRangeEnd();
    
if( 23 == namespaceId && "moveFromRangeStart" == name)
    return new MoveFromRangeStart();
    
if( 23 == namespaceId && "moveFromRangeEnd" == name)
    return new MoveFromRangeEnd();
    
if( 23 == namespaceId && "moveToRangeStart" == name)
    return new MoveToRangeStart();
    
if( 23 == namespaceId && "moveToRangeEnd" == name)
    return new MoveToRangeEnd();
    
if( 23 == namespaceId && "customXmlInsRangeStart" == name)
    return new CustomXmlInsRangeStart();
    
if( 23 == namespaceId && "customXmlInsRangeEnd" == name)
    return new CustomXmlInsRangeEnd();
    
if( 23 == namespaceId && "customXmlDelRangeStart" == name)
    return new CustomXmlDelRangeStart();
    
if( 23 == namespaceId && "customXmlDelRangeEnd" == name)
    return new CustomXmlDelRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveFromRangeStart" == name)
    return new CustomXmlMoveFromRangeStart();
    
if( 23 == namespaceId && "customXmlMoveFromRangeEnd" == name)
    return new CustomXmlMoveFromRangeEnd();
    
if( 23 == namespaceId && "customXmlMoveToRangeStart" == name)
    return new CustomXmlMoveToRangeStart();
    
if( 23 == namespaceId && "customXmlMoveToRangeEnd" == name)
    return new CustomXmlMoveToRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictInsRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictInsRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictInsertionRangeEnd();
    
if( 52 == namespaceId && "customXmlConflictDelRangeStart" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeStart();
    
if( 52 == namespaceId && "customXmlConflictDelRangeEnd" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.CustomXmlConflictDeletionRangeEnd();
    
if( 23 == namespaceId && "ins" == name)
    return new InsertedRun();
    
if( 23 == namespaceId && "del" == name)
    return new DeletedRun();
    
if( 23 == namespaceId && "moveFrom" == name)
    return new MoveFromRun();
    
if( 23 == namespaceId && "moveTo" == name)
    return new MoveToRun();
    
if( 23 == namespaceId && "contentPart" == name)
    return new ContentPart();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.RunConflictDeletion();
    
if( 23 == namespaceId && "sectPr" == name)
    return new SectionProperties();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the BodyType class.
    /// </summary>
    protected BodyType(){}
    
            /// <summary>
    ///Initializes a new instance of the BodyType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected BodyType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BodyType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected BodyType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BodyType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected BodyType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Glossary Document Entry.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPart.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartProperties &lt;w:docPartPr></description></item>
///<item><description>DocPartBody &lt;w:docPartBody></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPartProperties))]
    [ChildElementInfo(typeof(DocPartBody))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocPart : OpenXmlCompositeElement
{
    private const string tagName = "docPart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11993;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DocPart class.
    /// </summary>
    public DocPart():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocPart class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPart(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPart class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocPart(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocPart class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocPart(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docPartPr" == name)
    return new DocPartProperties();
    
if( 23 == namespaceId && "docPartBody" == name)
    return new DocPartBody();
    

    return null;
}

        private static readonly string[] eleTagNames = { "docPartPr","docPartBody" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Glossary Document Entry Properties.</para>
    /// <para> Represents the following element tag in the schema: w:docPartPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartProperties DocPartProperties
    {
        get 
        {
            return GetElement<DocPartProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Contents of Glossary Document Entry.</para>
    /// <para> Represents the following element tag in the schema: w:docPartBody </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartBody DocPartBody
    {
        get 
        {
            return GetElement<DocPartBody>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocPart>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CompatibilitySetting Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:compatSetting.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CompatibilitySetting : OpenXmlLeafElement
{
    private const string tagName = "compatSetting";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12059;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","uri","val" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CompatSettingNameValues> Name
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CompatSettingNameValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> uri.</para>
    /// <para>Represents the following attribute in the schema: w:uri </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CompatibilitySetting class.
    /// </summary>
    public CompatibilitySetting():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CompatSettingNameValues>();
    
if( 23 == namespaceId && "uri" == name)
    return new StringValue();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CompatibilitySetting>(deep);
    }

   
}
/// <summary>
/// <para>Table Cell Left Margin Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:left.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellLeftMargin : TableWidthDxaNilType
{
    private const string tagName = "left";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12065;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellLeftMargin class.
    /// </summary>
    public TableCellLeftMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellLeftMargin>(deep);
    }

}
/// <summary>
/// <para>Table Cell Right Margin Default.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:right.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableCellRightMargin : TableWidthDxaNilType
{
    private const string tagName = "right";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12068;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TableCellRightMargin class.
    /// </summary>
    public TableCellRightMargin():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableCellRightMargin>(deep);
    }

}
/// <summary>
/// Defines the TableWidthDxaNilType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TableWidthDxaNilType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "w","type" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> w.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public Int16Value Width
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: w:type </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "type")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "w" == name)
    return new Int16Value();
    
if( 23 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TableWidthValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TableWidthDxaNilType class.
    /// </summary>
    protected TableWidthDxaNilType(){}
    
    
    
}
/// <summary>
/// <para>Table-Level Property Exceptions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblPrEx.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableWidth &lt;w:tblW></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableIndentation &lt;w:tblInd></description></item>
///<item><description>TableBorders &lt;w:tblBorders></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>TableLayout &lt;w:tblLayout></description></item>
///<item><description>TableCellMarginDefault &lt;w:tblCellMar></description></item>
///<item><description>TableLook &lt;w:tblLook></description></item>
///<item><description>TablePropertyExceptionsChange &lt;w:tblPrExChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableWidth))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableIndentation))]
    [ChildElementInfo(typeof(TableBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(TableLayout))]
    [ChildElementInfo(typeof(TableCellMarginDefault))]
    [ChildElementInfo(typeof(TableLook))]
    [ChildElementInfo(typeof(TablePropertyExceptionsChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TablePropertyExceptions : OpenXmlCompositeElement
{
    private const string tagName = "tblPrEx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12070;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptions class.
    /// </summary>
    public TablePropertyExceptions():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TablePropertyExceptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertyExceptions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TablePropertyExceptions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TablePropertyExceptions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TablePropertyExceptions(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "tblW" == name)
    return new TableWidth();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "tblInd" == name)
    return new TableIndentation();
    
if( 23 == namespaceId && "tblBorders" == name)
    return new TableBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tblLayout" == name)
    return new TableLayout();
    
if( 23 == namespaceId && "tblCellMar" == name)
    return new TableCellMarginDefault();
    
if( 23 == namespaceId && "tblLook" == name)
    return new TableLook();
    
if( 23 == namespaceId && "tblPrExChange" == name)
    return new TablePropertyExceptionsChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tblW","jc","tblCellSpacing","tblInd","tblBorders","shd","tblLayout","tblCellMar","tblLook","tblPrExChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Preferred Table Width Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblW </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableWidth TableWidth
    {
        get 
        {
            return GetElement<TableWidth>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Table Alignment Exception.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableJustification TableJustification
    {
        get 
        {
            return GetElement<TableJustification>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Spacing Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellSpacing TableCellSpacing
    {
        get 
        {
            return GetElement<TableCellSpacing>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Indent from Leading Margin Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableIndentation TableIndentation
    {
        get 
        {
            return GetElement<TableIndentation>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Table Borders Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableBorders TableBorders
    {
        get 
        {
            return GetElement<TableBorders>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Table Shading Exception.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Table Layout Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblLayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLayout TableLayout
    {
        get 
        {
            return GetElement<TableLayout>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Table Cell Margin Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblCellMar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableCellMarginDefault TableCellMarginDefault
    {
        get 
        {
            return GetElement<TableCellMarginDefault>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Table Style Conditional Formatting Settings Exception.</para>
    /// <para> Represents the following element tag in the schema: w:tblLook </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TableLook TableLook
    {
        get 
        {
            return GetElement<TableLook>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Revision Information for Table-Level Property Exceptions.</para>
    /// <para> Represents the following element tag in the schema: w:tblPrExChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TablePropertyExceptionsChange TablePropertyExceptionsChange
    {
        get 
        {
            return GetElement<TablePropertyExceptionsChange>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TablePropertyExceptions>(deep);
    }

   
}
/// <summary>
/// <para>Table Row Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
///<item><description>DivId &lt;w:divId></description></item>
///<item><description>GridBefore &lt;w:gridBefore></description></item>
///<item><description>GridAfter &lt;w:gridAfter></description></item>
///<item><description>WidthBeforeTableRow &lt;w:wBefore></description></item>
///<item><description>WidthAfterTableRow &lt;w:wAfter></description></item>
///<item><description>TableRowHeight &lt;w:trHeight></description></item>
///<item><description>Hidden &lt;w:hidden></description></item>
///<item><description>CantSplit &lt;w:cantSplit></description></item>
///<item><description>TableHeader &lt;w:tblHeader></description></item>
///<item><description>TableCellSpacing &lt;w:tblCellSpacing></description></item>
///<item><description>TableJustification &lt;w:jc></description></item>
///<item><description>Inserted &lt;w:ins></description></item>
///<item><description>Deleted &lt;w:del></description></item>
///<item><description>TableRowPropertiesChange &lt;w:trPrChange></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion &lt;w14:conflictIns></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion &lt;w14:conflictDel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
    [ChildElementInfo(typeof(DivId))]
    [ChildElementInfo(typeof(GridBefore))]
    [ChildElementInfo(typeof(GridAfter))]
    [ChildElementInfo(typeof(WidthBeforeTableRow))]
    [ChildElementInfo(typeof(WidthAfterTableRow))]
    [ChildElementInfo(typeof(TableRowHeight))]
    [ChildElementInfo(typeof(Hidden))]
    [ChildElementInfo(typeof(CantSplit))]
    [ChildElementInfo(typeof(TableHeader))]
    [ChildElementInfo(typeof(TableCellSpacing))]
    [ChildElementInfo(typeof(TableJustification))]
    [ChildElementInfo(typeof(Inserted))]
    [ChildElementInfo(typeof(Deleted))]
    [ChildElementInfo(typeof(TableRowPropertiesChange))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableRowProperties : OpenXmlCompositeElement
{
    private const string tagName = "trPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12071;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableRowProperties class.
    /// </summary>
    public TableRowProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRowProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRowProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRowProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRowProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableRowProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    
if( 23 == namespaceId && "divId" == name)
    return new DivId();
    
if( 23 == namespaceId && "gridBefore" == name)
    return new GridBefore();
    
if( 23 == namespaceId && "gridAfter" == name)
    return new GridAfter();
    
if( 23 == namespaceId && "wBefore" == name)
    return new WidthBeforeTableRow();
    
if( 23 == namespaceId && "wAfter" == name)
    return new WidthAfterTableRow();
    
if( 23 == namespaceId && "trHeight" == name)
    return new TableRowHeight();
    
if( 23 == namespaceId && "hidden" == name)
    return new Hidden();
    
if( 23 == namespaceId && "cantSplit" == name)
    return new CantSplit();
    
if( 23 == namespaceId && "tblHeader" == name)
    return new TableHeader();
    
if( 23 == namespaceId && "tblCellSpacing" == name)
    return new TableCellSpacing();
    
if( 23 == namespaceId && "jc" == name)
    return new TableJustification();
    
if( 23 == namespaceId && "ins" == name)
    return new Inserted();
    
if( 23 == namespaceId && "del" == name)
    return new Deleted();
    
if( 23 == namespaceId && "trPrChange" == name)
    return new TableRowPropertiesChange();
    
if( 52 == namespaceId && "conflictIns" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictInsertion();
    
if( 52 == namespaceId && "conflictDel" == name)
    return new DocumentFormat.OpenXml.Office2010.Word.ConflictDeletion();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableRowProperties>(deep);
    }

   
}
/// <summary>
/// <para>Revision Information for Table Row Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:trPrChange.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PreviousTableRowProperties &lt;w:trPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PreviousTableRowProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableRowPropertiesChange : OpenXmlCompositeElement
{
    private const string tagName = "trPrChange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12072;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "author","date","id" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> author.</para>
    /// <para>Represents the following attribute in the schema: w:author </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> date.</para>
    /// <para>Represents the following attribute in the schema: w:date </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "date")]
    public DateTimeValue Date
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Annotation Identifier.</para>
    /// <para>Represents the following attribute in the schema: w:id </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableRowPropertiesChange class.
    /// </summary>
    public TableRowPropertiesChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableRowPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRowPropertiesChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRowPropertiesChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableRowPropertiesChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableRowPropertiesChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableRowPropertiesChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "trPr" == name)
    return new PreviousTableRowProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "trPr" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Previous Table Row Properties.</para>
    /// <para> Represents the following element tag in the schema: w:trPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PreviousTableRowProperties PreviousTableRowProperties
    {
        get 
        {
            return GetElement<PreviousTableRowProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "author" == name)
    return new StringValue();
    
if( 23 == namespaceId && "date" == name)
    return new DateTimeValue();
    
if( 23 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableRowPropertiesChange>(deep);
    }

   
}
/// <summary>
/// <para>Paragraph Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ParagraphStyleId &lt;w:pStyle></description></item>
///<item><description>KeepNext &lt;w:keepNext></description></item>
///<item><description>KeepLines &lt;w:keepLines></description></item>
///<item><description>PageBreakBefore &lt;w:pageBreakBefore></description></item>
///<item><description>FrameProperties &lt;w:framePr></description></item>
///<item><description>WidowControl &lt;w:widowControl></description></item>
///<item><description>NumberingProperties &lt;w:numPr></description></item>
///<item><description>SuppressLineNumbers &lt;w:suppressLineNumbers></description></item>
///<item><description>ParagraphBorders &lt;w:pBdr></description></item>
///<item><description>Shading &lt;w:shd></description></item>
///<item><description>Tabs &lt;w:tabs></description></item>
///<item><description>SuppressAutoHyphens &lt;w:suppressAutoHyphens></description></item>
///<item><description>Kinsoku &lt;w:kinsoku></description></item>
///<item><description>WordWrap &lt;w:wordWrap></description></item>
///<item><description>OverflowPunctuation &lt;w:overflowPunct></description></item>
///<item><description>TopLinePunctuation &lt;w:topLinePunct></description></item>
///<item><description>AutoSpaceDE &lt;w:autoSpaceDE></description></item>
///<item><description>AutoSpaceDN &lt;w:autoSpaceDN></description></item>
///<item><description>BiDi &lt;w:bidi></description></item>
///<item><description>AdjustRightIndent &lt;w:adjustRightInd></description></item>
///<item><description>SnapToGrid &lt;w:snapToGrid></description></item>
///<item><description>SpacingBetweenLines &lt;w:spacing></description></item>
///<item><description>Indentation &lt;w:ind></description></item>
///<item><description>ContextualSpacing &lt;w:contextualSpacing></description></item>
///<item><description>MirrorIndents &lt;w:mirrorIndents></description></item>
///<item><description>SuppressOverlap &lt;w:suppressOverlap></description></item>
///<item><description>Justification &lt;w:jc></description></item>
///<item><description>TextDirection &lt;w:textDirection></description></item>
///<item><description>TextAlignment &lt;w:textAlignment></description></item>
///<item><description>TextBoxTightWrap &lt;w:textboxTightWrap></description></item>
///<item><description>OutlineLevel &lt;w:outlineLvl></description></item>
///<item><description>DivId &lt;w:divId></description></item>
///<item><description>ConditionalFormatStyle &lt;w:cnfStyle></description></item>
///<item><description>ParagraphMarkRunProperties &lt;w:rPr></description></item>
///<item><description>SectionProperties &lt;w:sectPr></description></item>
///<item><description>ParagraphPropertiesChange &lt;w:pPrChange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ParagraphStyleId))]
    [ChildElementInfo(typeof(KeepNext))]
    [ChildElementInfo(typeof(KeepLines))]
    [ChildElementInfo(typeof(PageBreakBefore))]
    [ChildElementInfo(typeof(FrameProperties))]
    [ChildElementInfo(typeof(WidowControl))]
    [ChildElementInfo(typeof(NumberingProperties))]
    [ChildElementInfo(typeof(SuppressLineNumbers))]
    [ChildElementInfo(typeof(ParagraphBorders))]
    [ChildElementInfo(typeof(Shading))]
    [ChildElementInfo(typeof(Tabs))]
    [ChildElementInfo(typeof(SuppressAutoHyphens))]
    [ChildElementInfo(typeof(Kinsoku))]
    [ChildElementInfo(typeof(WordWrap))]
    [ChildElementInfo(typeof(OverflowPunctuation))]
    [ChildElementInfo(typeof(TopLinePunctuation))]
    [ChildElementInfo(typeof(AutoSpaceDE))]
    [ChildElementInfo(typeof(AutoSpaceDN))]
    [ChildElementInfo(typeof(BiDi))]
    [ChildElementInfo(typeof(AdjustRightIndent))]
    [ChildElementInfo(typeof(SnapToGrid))]
    [ChildElementInfo(typeof(SpacingBetweenLines))]
    [ChildElementInfo(typeof(Indentation))]
    [ChildElementInfo(typeof(ContextualSpacing))]
    [ChildElementInfo(typeof(MirrorIndents))]
    [ChildElementInfo(typeof(SuppressOverlap))]
    [ChildElementInfo(typeof(Justification))]
    [ChildElementInfo(typeof(TextDirection))]
    [ChildElementInfo(typeof(TextAlignment))]
    [ChildElementInfo(typeof(TextBoxTightWrap))]
    [ChildElementInfo(typeof(OutlineLevel))]
    [ChildElementInfo(typeof(DivId))]
    [ChildElementInfo(typeof(ConditionalFormatStyle))]
    [ChildElementInfo(typeof(ParagraphMarkRunProperties))]
    [ChildElementInfo(typeof(SectionProperties))]
    [ChildElementInfo(typeof(ParagraphPropertiesChange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ParagraphProperties : OpenXmlCompositeElement
{
    private const string tagName = "pPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12077;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class.
    /// </summary>
    public ParagraphProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ParagraphProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ParagraphProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ParagraphProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pStyle" == name)
    return new ParagraphStyleId();
    
if( 23 == namespaceId && "keepNext" == name)
    return new KeepNext();
    
if( 23 == namespaceId && "keepLines" == name)
    return new KeepLines();
    
if( 23 == namespaceId && "pageBreakBefore" == name)
    return new PageBreakBefore();
    
if( 23 == namespaceId && "framePr" == name)
    return new FrameProperties();
    
if( 23 == namespaceId && "widowControl" == name)
    return new WidowControl();
    
if( 23 == namespaceId && "numPr" == name)
    return new NumberingProperties();
    
if( 23 == namespaceId && "suppressLineNumbers" == name)
    return new SuppressLineNumbers();
    
if( 23 == namespaceId && "pBdr" == name)
    return new ParagraphBorders();
    
if( 23 == namespaceId && "shd" == name)
    return new Shading();
    
if( 23 == namespaceId && "tabs" == name)
    return new Tabs();
    
if( 23 == namespaceId && "suppressAutoHyphens" == name)
    return new SuppressAutoHyphens();
    
if( 23 == namespaceId && "kinsoku" == name)
    return new Kinsoku();
    
if( 23 == namespaceId && "wordWrap" == name)
    return new WordWrap();
    
if( 23 == namespaceId && "overflowPunct" == name)
    return new OverflowPunctuation();
    
if( 23 == namespaceId && "topLinePunct" == name)
    return new TopLinePunctuation();
    
if( 23 == namespaceId && "autoSpaceDE" == name)
    return new AutoSpaceDE();
    
if( 23 == namespaceId && "autoSpaceDN" == name)
    return new AutoSpaceDN();
    
if( 23 == namespaceId && "bidi" == name)
    return new BiDi();
    
if( 23 == namespaceId && "adjustRightInd" == name)
    return new AdjustRightIndent();
    
if( 23 == namespaceId && "snapToGrid" == name)
    return new SnapToGrid();
    
if( 23 == namespaceId && "spacing" == name)
    return new SpacingBetweenLines();
    
if( 23 == namespaceId && "ind" == name)
    return new Indentation();
    
if( 23 == namespaceId && "contextualSpacing" == name)
    return new ContextualSpacing();
    
if( 23 == namespaceId && "mirrorIndents" == name)
    return new MirrorIndents();
    
if( 23 == namespaceId && "suppressOverlap" == name)
    return new SuppressOverlap();
    
if( 23 == namespaceId && "jc" == name)
    return new Justification();
    
if( 23 == namespaceId && "textDirection" == name)
    return new TextDirection();
    
if( 23 == namespaceId && "textAlignment" == name)
    return new TextAlignment();
    
if( 23 == namespaceId && "textboxTightWrap" == name)
    return new TextBoxTightWrap();
    
if( 23 == namespaceId && "outlineLvl" == name)
    return new OutlineLevel();
    
if( 23 == namespaceId && "divId" == name)
    return new DivId();
    
if( 23 == namespaceId && "cnfStyle" == name)
    return new ConditionalFormatStyle();
    
if( 23 == namespaceId && "rPr" == name)
    return new ParagraphMarkRunProperties();
    
if( 23 == namespaceId && "sectPr" == name)
    return new SectionProperties();
    
if( 23 == namespaceId && "pPrChange" == name)
    return new ParagraphPropertiesChange();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pStyle","keepNext","keepLines","pageBreakBefore","framePr","widowControl","numPr","suppressLineNumbers","pBdr","shd","tabs","suppressAutoHyphens","kinsoku","wordWrap","overflowPunct","topLinePunct","autoSpaceDE","autoSpaceDN","bidi","adjustRightInd","snapToGrid","spacing","ind","contextualSpacing","mirrorIndents","suppressOverlap","jc","textDirection","textAlignment","textboxTightWrap","outlineLvl","divId","cnfStyle","rPr","sectPr","pPrChange" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ParagraphStyleId.</para>
    /// <para> Represents the following element tag in the schema: w:pStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphStyleId ParagraphStyleId
    {
        get 
        {
            return GetElement<ParagraphStyleId>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> KeepNext.</para>
    /// <para> Represents the following element tag in the schema: w:keepNext </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepNext KeepNext
    {
        get 
        {
            return GetElement<KeepNext>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> KeepLines.</para>
    /// <para> Represents the following element tag in the schema: w:keepLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public KeepLines KeepLines
    {
        get 
        {
            return GetElement<KeepLines>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> PageBreakBefore.</para>
    /// <para> Represents the following element tag in the schema: w:pageBreakBefore </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PageBreakBefore PageBreakBefore
    {
        get 
        {
            return GetElement<PageBreakBefore>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> FrameProperties.</para>
    /// <para> Represents the following element tag in the schema: w:framePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FrameProperties FrameProperties
    {
        get 
        {
            return GetElement<FrameProperties>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> WidowControl.</para>
    /// <para> Represents the following element tag in the schema: w:widowControl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WidowControl WidowControl
    {
        get 
        {
            return GetElement<WidowControl>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> NumberingProperties.</para>
    /// <para> Represents the following element tag in the schema: w:numPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingProperties NumberingProperties
    {
        get 
        {
            return GetElement<NumberingProperties>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> SuppressLineNumbers.</para>
    /// <para> Represents the following element tag in the schema: w:suppressLineNumbers </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressLineNumbers SuppressLineNumbers
    {
        get 
        {
            return GetElement<SuppressLineNumbers>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ParagraphBorders.</para>
    /// <para> Represents the following element tag in the schema: w:pBdr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphBorders ParagraphBorders
    {
        get 
        {
            return GetElement<ParagraphBorders>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Shading.</para>
    /// <para> Represents the following element tag in the schema: w:shd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Shading Shading
    {
        get 
        {
            return GetElement<Shading>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Tabs.</para>
    /// <para> Represents the following element tag in the schema: w:tabs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Tabs Tabs
    {
        get 
        {
            return GetElement<Tabs>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> SuppressAutoHyphens.</para>
    /// <para> Represents the following element tag in the schema: w:suppressAutoHyphens </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressAutoHyphens SuppressAutoHyphens
    {
        get 
        {
            return GetElement<SuppressAutoHyphens>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Kinsoku.</para>
    /// <para> Represents the following element tag in the schema: w:kinsoku </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Kinsoku Kinsoku
    {
        get 
        {
            return GetElement<Kinsoku>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> WordWrap.</para>
    /// <para> Represents the following element tag in the schema: w:wordWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordWrap WordWrap
    {
        get 
        {
            return GetElement<WordWrap>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> OverflowPunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:overflowPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OverflowPunctuation OverflowPunctuation
    {
        get 
        {
            return GetElement<OverflowPunctuation>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> TopLinePunctuation.</para>
    /// <para> Represents the following element tag in the schema: w:topLinePunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TopLinePunctuation TopLinePunctuation
    {
        get 
        {
            return GetElement<TopLinePunctuation>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDE.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDE </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDE AutoSpaceDE
    {
        get 
        {
            return GetElement<AutoSpaceDE>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> AutoSpaceDN.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceDN </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceDN AutoSpaceDN
    {
        get 
        {
            return GetElement<AutoSpaceDN>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> BiDi.</para>
    /// <para> Represents the following element tag in the schema: w:bidi </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BiDi BiDi
    {
        get 
        {
            return GetElement<BiDi>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> AdjustRightIndent.</para>
    /// <para> Represents the following element tag in the schema: w:adjustRightInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustRightIndent AdjustRightIndent
    {
        get 
        {
            return GetElement<AdjustRightIndent>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> SnapToGrid.</para>
    /// <para> Represents the following element tag in the schema: w:snapToGrid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SnapToGrid SnapToGrid
    {
        get 
        {
            return GetElement<SnapToGrid>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> SpacingBetweenLines.</para>
    /// <para> Represents the following element tag in the schema: w:spacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingBetweenLines SpacingBetweenLines
    {
        get 
        {
            return GetElement<SpacingBetweenLines>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:ind </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Indentation Indentation
    {
        get 
        {
            return GetElement<Indentation>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> ContextualSpacing.</para>
    /// <para> Represents the following element tag in the schema: w:contextualSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ContextualSpacing ContextualSpacing
    {
        get 
        {
            return GetElement<ContextualSpacing>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> MirrorIndents.</para>
    /// <para> Represents the following element tag in the schema: w:mirrorIndents </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MirrorIndents MirrorIndents
    {
        get 
        {
            return GetElement<MirrorIndents>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> SuppressOverlap.</para>
    /// <para> Represents the following element tag in the schema: w:suppressOverlap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressOverlap SuppressOverlap
    {
        get 
        {
            return GetElement<SuppressOverlap>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Justification.</para>
    /// <para> Represents the following element tag in the schema: w:jc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Justification Justification
    {
        get 
        {
            return GetElement<Justification>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> TextDirection.</para>
    /// <para> Represents the following element tag in the schema: w:textDirection </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextDirection TextDirection
    {
        get 
        {
            return GetElement<TextDirection>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> TextAlignment.</para>
    /// <para> Represents the following element tag in the schema: w:textAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextAlignment TextAlignment
    {
        get 
        {
            return GetElement<TextAlignment>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> TextBoxTightWrap.</para>
    /// <para> Represents the following element tag in the schema: w:textboxTightWrap </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TextBoxTightWrap TextBoxTightWrap
    {
        get 
        {
            return GetElement<TextBoxTightWrap>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> OutlineLevel.</para>
    /// <para> Represents the following element tag in the schema: w:outlineLvl </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public OutlineLevel OutlineLevel
    {
        get 
        {
            return GetElement<OutlineLevel>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> DivId.</para>
    /// <para> Represents the following element tag in the schema: w:divId </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DivId DivId
    {
        get 
        {
            return GetElement<DivId>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> ConditionalFormatStyle.</para>
    /// <para> Represents the following element tag in the schema: w:cnfStyle </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConditionalFormatStyle ConditionalFormatStyle
    {
        get 
        {
            return GetElement<ConditionalFormatStyle>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> Run Properties for the Paragraph Mark.</para>
    /// <para> Represents the following element tag in the schema: w:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphMarkRunProperties ParagraphMarkRunProperties
    {
        get 
        {
            return GetElement<ParagraphMarkRunProperties>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }
    /// <summary>
    /// <para> Section Properties.</para>
    /// <para> Represents the following element tag in the schema: w:sectPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SectionProperties SectionProperties
    {
        get 
        {
            return GetElement<SectionProperties>(34);
        }
        set
        {
            SetElement(34, value);
        }
    }
    /// <summary>
    /// <para> ParagraphPropertiesChange.</para>
    /// <para> Represents the following element tag in the schema: w:pPrChange </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ParagraphPropertiesChange ParagraphPropertiesChange
    {
        get 
        {
            return GetElement<ParagraphPropertiesChange>(35);
        }
        set
        {
            SetElement(35, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ParagraphProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Control Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:control.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Control : OpenXmlLeafElement
{
    private const string tagName = "control";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12079;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","shapeid","id" };
    private static byte[] attributeNamespaceIds = { 23,23,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Unique Name for Embedded Control.</para>
    /// <para>Represents the following attribute in the schema: w:name </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Associated VML Data Reference.</para>
    /// <para>Represents the following attribute in the schema: w:shapeid </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "shapeid")]
    public StringValue ShapeId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Embedded Control Properties Relationship Reference.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Control class.
    /// </summary>
    public Control():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "name" == name)
    return new StringValue();
    
if( 23 == namespaceId && "shapeid" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Control>(deep);
    }

   
}
/// <summary>
/// <para>Previous Table Grid.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:tblGrid.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GridColumn &lt;w:gridCol></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GridColumn))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PreviousTableGrid : OpenXmlCompositeElement
{
    private const string tagName = "tblGrid";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12080;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableGrid class.
    /// </summary>
    public PreviousTableGrid():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PreviousTableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableGrid(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableGrid class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PreviousTableGrid(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PreviousTableGrid class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PreviousTableGrid(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "gridCol" == name)
    return new GridColumn();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PreviousTableGrid>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ObjectEmbed Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:objectEmbed.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ObjectEmbed : OpenXmlLeafElement
{
    private const string tagName = "objectEmbed";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12081;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "drawAspect","id","progId","shapeId","fieldCodes" };
    private static byte[] attributeNamespaceIds = { 23,19,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> drawAspect.</para>
    /// <para>Represents the following attribute in the schema: w:drawAspect </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "drawAspect")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect> drawAspect
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> progId.</para>
    /// <para>Represents the following attribute in the schema: w:progId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "progId")]
    public StringValue ProgId
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> shapeId.</para>
    /// <para>Represents the following attribute in the schema: w:shapeId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "shapeId")]
    public StringValue ShapeId
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> fieldCodes.</para>
    /// <para>Represents the following attribute in the schema: w:fieldCodes </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fieldCodes")]
    public StringValue FieldCodes
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ObjectEmbed class.
    /// </summary>
    public ObjectEmbed():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "drawAspect" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect>();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 23 == namespaceId && "progId" == name)
    return new StringValue();
    
if( 23 == namespaceId && "shapeId" == name)
    return new StringValue();
    
if( 23 == namespaceId && "fieldCodes" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ObjectEmbed>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ObjectLink Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:objectLink.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ObjectLink : OpenXmlLeafElement
{
    private const string tagName = "objectLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12082;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "updateMode","lockedField","drawAspect","id","progId","shapeId","fieldCodes" };
    private static byte[] attributeNamespaceIds = { 23,23,23,19,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> updateMode.</para>
    /// <para>Represents the following attribute in the schema: w:updateMode </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "updateMode")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectUpdateMode> UpdateMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectUpdateMode>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> lockedField.</para>
    /// <para>Represents the following attribute in the schema: w:lockedField </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lockedField")]
    public OnOffValue LockedField
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> drawAspect.</para>
    /// <para>Represents the following attribute in the schema: w:drawAspect </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "drawAspect")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect> drawAspect
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> progId.</para>
    /// <para>Represents the following attribute in the schema: w:progId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "progId")]
    public StringValue ProgId
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> shapeId.</para>
    /// <para>Represents the following attribute in the schema: w:shapeId </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "shapeId")]
    public StringValue ShapeId
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> fieldCodes.</para>
    /// <para>Represents the following attribute in the schema: w:fieldCodes </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fieldCodes")]
    public StringValue FieldCodes
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ObjectLink class.
    /// </summary>
    public ObjectLink():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "updateMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectUpdateMode>();
    
if( 23 == namespaceId && "lockedField" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "drawAspect" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ObjectDrawAspect>();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 23 == namespaceId && "progId" == name)
    return new StringValue();
    
if( 23 == namespaceId && "shapeId" == name)
    return new StringValue();
    
if( 23 == namespaceId && "fieldCodes" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ObjectLink>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Lock Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:lock.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Lock : OpenXmlLeafElement
{
    private const string tagName = "lock";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12084;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Locking Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.LockingValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.LockingValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Lock class.
    /// </summary>
    public Lock():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.LockingValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Lock>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtPlaceholder Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:placeholder.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartReference &lt;w:docPart></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPartReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtPlaceholder : OpenXmlCompositeElement
{
    private const string tagName = "placeholder";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12085;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SdtPlaceholder class.
    /// </summary>
    public SdtPlaceholder():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtPlaceholder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtPlaceholder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtPlaceholder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtPlaceholder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtPlaceholder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtPlaceholder(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docPart" == name)
    return new DocPartReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "docPart" };
    private static readonly byte[] eleNamespaceIds = { 23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Document Part Reference.</para>
    /// <para> Represents the following element tag in the schema: w:docPart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartReference DocPartReference
    {
        get 
        {
            return GetElement<DocPartReference>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtPlaceholder>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataBinding Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dataBinding.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataBinding : OpenXmlLeafElement
{
    private const string tagName = "dataBinding";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12087;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prefixMappings","xpath","storeItemID" };
    private static byte[] attributeNamespaceIds = { 23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XML Namespace Prefix Mappings.</para>
    /// <para>Represents the following attribute in the schema: w:prefixMappings </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "prefixMappings")]
    public StringValue PrefixMappings
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> XPath.</para>
    /// <para>Represents the following attribute in the schema: w:xpath </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "xpath")]
    public StringValue XPath
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Custom XML Data Storage ID.</para>
    /// <para>Represents the following attribute in the schema: w:storeItemID </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "storeItemID")]
    public StringValue StoreItemId
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataBinding class.
    /// </summary>
    public DataBinding():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "prefixMappings" == name)
    return new StringValue();
    
if( 23 == namespaceId && "xpath" == name)
    return new StringValue();
    
if( 23 == namespaceId && "storeItemID" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataBinding>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtContentComboBox Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:comboBox.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ListItem &lt;w:listItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ListItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentComboBox : OpenXmlCompositeElement
{
    private const string tagName = "comboBox";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12092;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lastValue" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Combo Box Last Saved Value.</para>
    /// <para>Represents the following attribute in the schema: w:lastValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastValue")]
    public StringValue LastValue
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentComboBox class.
    /// </summary>
    public SdtContentComboBox():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentComboBox class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentComboBox(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentComboBox class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentComboBox(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentComboBox class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentComboBox(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "listItem" == name)
    return new ListItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lastValue" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentComboBox>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtContentDate Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:date.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DateFormat &lt;w:dateFormat></description></item>
///<item><description>LanguageId &lt;w:lid></description></item>
///<item><description>SdtDateMappingType &lt;w:storeMappedDataAs></description></item>
///<item><description>Calendar &lt;w:calendar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DateFormat))]
    [ChildElementInfo(typeof(LanguageId))]
    [ChildElementInfo(typeof(SdtDateMappingType))]
    [ChildElementInfo(typeof(Calendar))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentDate : OpenXmlCompositeElement
{
    private const string tagName = "date";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12093;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fullDate" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Last Known Date in XML Schema DateTime Format.</para>
    /// <para>Represents the following attribute in the schema: w:fullDate </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fullDate")]
    public DateTimeValue FullDate
    {
        get { return (DateTimeValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentDate class.
    /// </summary>
    public SdtContentDate():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentDate class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDate(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDate class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDate(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDate class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentDate(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "dateFormat" == name)
    return new DateFormat();
    
if( 23 == namespaceId && "lid" == name)
    return new LanguageId();
    
if( 23 == namespaceId && "storeMappedDataAs" == name)
    return new SdtDateMappingType();
    
if( 23 == namespaceId && "calendar" == name)
    return new Calendar();
    

    return null;
}

        private static readonly string[] eleTagNames = { "dateFormat","lid","storeMappedDataAs","calendar" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Date Display Mask.</para>
    /// <para> Represents the following element tag in the schema: w:dateFormat </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DateFormat DateFormat
    {
        get 
        {
            return GetElement<DateFormat>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Date Picker Language ID.</para>
    /// <para> Represents the following element tag in the schema: w:lid </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LanguageId LanguageId
    {
        get 
        {
            return GetElement<LanguageId>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Custom XML Data Date Storage Format.</para>
    /// <para> Represents the following element tag in the schema: w:storeMappedDataAs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SdtDateMappingType SdtDateMappingType
    {
        get 
        {
            return GetElement<SdtDateMappingType>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Date Picker Calendar Type.</para>
    /// <para> Represents the following element tag in the schema: w:calendar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Calendar Calendar
    {
        get 
        {
            return GetElement<Calendar>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fullDate" == name)
    return new DateTimeValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentDate>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtContentDocPartObject Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartObj.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartGallery &lt;w:docPartGallery></description></item>
///<item><description>DocPartCategory &lt;w:docPartCategory></description></item>
///<item><description>DocPartUnique &lt;w:docPartUnique></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentDocPartObject : SdtDocPartType
{
    private const string tagName = "docPartObj";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12094;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartObject class.
    /// </summary>
    public SdtContentDocPartObject():base(){}
            /// <summary>
    ///Initializes a new instance of the SdtContentDocPartObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDocPartObject(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDocPartObject(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartObject class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentDocPartObject(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentDocPartObject>(deep);
    }

}
/// <summary>
/// <para>Defines the SdtContentDocPartList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docPartList.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartGallery &lt;w:docPartGallery></description></item>
///<item><description>DocPartCategory &lt;w:docPartCategory></description></item>
///<item><description>DocPartUnique &lt;w:docPartUnique></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentDocPartList : SdtDocPartType
{
    private const string tagName = "docPartList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12095;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartList class.
    /// </summary>
    public SdtContentDocPartList():base(){}
            /// <summary>
    ///Initializes a new instance of the SdtContentDocPartList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDocPartList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDocPartList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDocPartList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentDocPartList(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentDocPartList>(deep);
    }

}
/// <summary>
/// Defines the SdtDocPartType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocPartGallery &lt;w:docPartGallery></description></item>
///<item><description>DocPartCategory &lt;w:docPartCategory></description></item>
///<item><description>DocPartUnique &lt;w:docPartUnique></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocPartGallery))]
    [ChildElementInfo(typeof(DocPartCategory))]
    [ChildElementInfo(typeof(DocPartUnique))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class SdtDocPartType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docPartGallery" == name)
    return new DocPartGallery();
    
if( 23 == namespaceId && "docPartCategory" == name)
    return new DocPartCategory();
    
if( 23 == namespaceId && "docPartUnique" == name)
    return new DocPartUnique();
    

    return null;
}

        private static readonly string[] eleTagNames = { "docPartGallery","docPartCategory","docPartUnique" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Document Part Gallery Filter.</para>
    /// <para> Represents the following element tag in the schema: w:docPartGallery </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartGallery DocPartGallery
    {
        get 
        {
            return GetElement<DocPartGallery>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Document Part Category Filter.</para>
    /// <para> Represents the following element tag in the schema: w:docPartCategory </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartCategory DocPartCategory
    {
        get 
        {
            return GetElement<DocPartCategory>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Built-In Document Part.</para>
    /// <para> Represents the following element tag in the schema: w:docPartUnique </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DocPartUnique DocPartUnique
    {
        get 
        {
            return GetElement<DocPartUnique>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the SdtDocPartType class.
    /// </summary>
    protected SdtDocPartType(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtDocPartType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected SdtDocPartType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtDocPartType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected SdtDocPartType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtDocPartType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected SdtDocPartType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the SdtContentDropDownList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:dropDownList.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ListItem &lt;w:listItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ListItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentDropDownList : OpenXmlCompositeElement
{
    private const string tagName = "dropDownList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12096;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lastValue" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Drop-down List Last Saved Value.</para>
    /// <para>Represents the following attribute in the schema: w:lastValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lastValue")]
    public StringValue LastValue
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentDropDownList class.
    /// </summary>
    public SdtContentDropDownList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SdtContentDropDownList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDropDownList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDropDownList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SdtContentDropDownList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SdtContentDropDownList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SdtContentDropDownList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "listItem" == name)
    return new ListItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lastValue" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentDropDownList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SdtContentText Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:text.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SdtContentText : OpenXmlLeafElement
{
    private const string tagName = "text";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12099;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "multiLine" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Allow Soft Line Breaks.</para>
    /// <para>Represents the following attribute in the schema: w:multiLine </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "multiLine")]
    public OnOffValue MultiLine
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SdtContentText class.
    /// </summary>
    public SdtContentText():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "multiLine" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SdtContentText>(deep);
    }

   
}
/// <summary>
/// <para>Write Protection.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:writeProtection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WriteProtection : OpenXmlLeafElement
{
    private const string tagName = "writeProtection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12103;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "recommended","cryptProviderType","cryptAlgorithmClass","cryptAlgorithmType","cryptAlgorithmSid","cryptSpinCount","cryptProvider","algIdExt","algIdExtSource","cryptProviderTypeExt","cryptProviderTypeExtSource","hash","salt","algorithmName","hashValue","saltValue","spinCount" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Recommend Write Protection in User Interface.</para>
    /// <para>Represents the following attribute in the schema: w:recommended </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "recommended")]
    public OnOffValue Recommended
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider Type.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderType </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderType")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues> CryptographicProviderType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Class.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmClass </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmClass")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues> CryptographicAlgorithmClass
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Type.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmType </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmType")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues> CryptographicAlgorithmType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmSid </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmSid")]
    public Int32Value CryptographicAlgorithmSid
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: w:cryptSpinCount </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptSpinCount")]
    public UInt32Value CryptographicSpinCount
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProvider </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProvider")]
    public StringValue CryptographicProvider
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Extensibility.</para>
    /// <para>Represents the following attribute in the schema: w:algIdExt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algIdExt")]
    public HexBinaryValue AlgorithmIdExtensibility
    {
        get { return (HexBinaryValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Algorithm Extensibility Source.</para>
    /// <para>Represents the following attribute in the schema: w:algIdExtSource </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algIdExtSource")]
    public StringValue AlgorithmIdExtensibilitySource
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider Type Extensibility.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderTypeExt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderTypeExt")]
    public HexBinaryValue CryptographicProviderTypeExtensibility
    {
        get { return (HexBinaryValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Provider Type Extensibility Source.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderTypeExtSource </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderTypeExtSource")]
    public StringValue CryptographicProviderTypeExtSource
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash.</para>
    /// <para>Represents the following attribute in the schema: w:hash </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hash")]
    public Base64BinaryValue Hash
    {
        get { return (Base64BinaryValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Salt for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: w:salt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "salt")]
    public Base64BinaryValue Salt
    {
        get { return (Base64BinaryValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> algorithmName.</para>
    /// <para>Represents the following attribute in the schema: w:algorithmName </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> hashValue.</para>
    /// <para>Represents the following attribute in the schema: w:hashValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> saltValue.</para>
    /// <para>Represents the following attribute in the schema: w:saltValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> spinCount.</para>
    /// <para>Represents the following attribute in the schema: w:spinCount </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "spinCount")]
    public Int32Value SpinCount
    {
        get { return (Int32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WriteProtection class.
    /// </summary>
    public WriteProtection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "recommended" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "cryptProviderType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues>();
    
if( 23 == namespaceId && "cryptAlgorithmClass" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues>();
    
if( 23 == namespaceId && "cryptAlgorithmType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues>();
    
if( 23 == namespaceId && "cryptAlgorithmSid" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "cryptSpinCount" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "cryptProvider" == name)
    return new StringValue();
    
if( 23 == namespaceId && "algIdExt" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "algIdExtSource" == name)
    return new StringValue();
    
if( 23 == namespaceId && "cryptProviderTypeExt" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "cryptProviderTypeExtSource" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hash" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "salt" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "spinCount" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WriteProtection>(deep);
    }

   
}
/// <summary>
/// <para>Document View Setting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:view.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class View : OpenXmlLeafElement
{
    private const string tagName = "view";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12104;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Document View Setting  Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ViewValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ViewValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the View class.
    /// </summary>
    public View():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ViewValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<View>(deep);
    }

   
}
/// <summary>
/// <para>Magnification Setting.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:zoom.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Zoom : OpenXmlLeafElement
{
    private const string tagName = "zoom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12105;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","percent" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Zoom Type.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.PresetZoomValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.PresetZoomValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Zoom Percentage.</para>
    /// <para>Represents the following attribute in the schema: w:percent </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "percent")]
    public StringValue Percent
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Zoom class.
    /// </summary>
    public Zoom():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.PresetZoomValues>();
    
if( 23 == namespaceId && "percent" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Zoom>(deep);
    }

   
}
/// <summary>
/// <para>Grammar Checking Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:activeWritingStyle.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ActiveWritingStyle : OpenXmlLeafElement
{
    private const string tagName = "activeWritingStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12124;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lang","vendorID","dllVersion","nlCheck","checkStyle","appName" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Writing Style Language.</para>
    /// <para>Represents the following attribute in the schema: w:lang </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lang")]
    public StringValue Language
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Grammatical Engine ID.</para>
    /// <para>Represents the following attribute in the schema: w:vendorID </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "vendorID")]
    public UInt16Value VendorID
    {
        get { return (UInt16Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Grammatical Check Engine Version.</para>
    /// <para>Represents the following attribute in the schema: w:dllVersion </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "dllVersion")]
    public Int32Value DllVersion
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Natural Language Grammar Check.</para>
    /// <para>Represents the following attribute in the schema: w:nlCheck </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "nlCheck")]
    public OnOffValue NaturalLanguageGrammarCheck
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Check Stylistic Rules With Grammar.</para>
    /// <para>Represents the following attribute in the schema: w:checkStyle </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "checkStyle")]
    public OnOffValue CheckStyle
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Application Name.</para>
    /// <para>Represents the following attribute in the schema: w:appName </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "appName")]
    public StringValue ApplicationName
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ActiveWritingStyle class.
    /// </summary>
    public ActiveWritingStyle():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lang" == name)
    return new StringValue();
    
if( 23 == namespaceId && "vendorID" == name)
    return new UInt16Value();
    
if( 23 == namespaceId && "dllVersion" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "nlCheck" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "checkStyle" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "appName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ActiveWritingStyle>(deep);
    }

   
}
/// <summary>
/// <para>Spelling and Grammatical Checking State.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:proofState.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ProofState : OpenXmlLeafElement
{
    private const string tagName = "proofState";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12125;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "spelling","grammar" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Spell Checking State.</para>
    /// <para>Represents the following attribute in the schema: w:spelling </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "spelling")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues> Spelling
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Grammatical Checking State.</para>
    /// <para>Represents the following attribute in the schema: w:grammar </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "grammar")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues> Grammar
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ProofState class.
    /// </summary>
    public ProofState():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "spelling" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues>();
    
if( 23 == namespaceId && "grammar" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ProofingStateValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ProofState>(deep);
    }

   
}
/// <summary>
/// <para>Suggested Filtering for List of Document Styles.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:stylePaneFormatFilter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StylePaneFormatFilter : OpenXmlLeafElement
{
    private const string tagName = "stylePaneFormatFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12129;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","allStyles","customStyles","latentStyles","stylesInUse","headingStyles","numberingStyles","tableStyles","directFormattingOnRuns","directFormattingOnParagraphs","directFormattingOnNumbering","directFormattingOnTables","clearFormatting","top3HeadingStyles","visibleStyles","alternateStyleNames" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public HexBinaryValue Val
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> allStyles.</para>
    /// <para>Represents the following attribute in the schema: w:allStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "allStyles")]
    public OnOffValue AllStyles
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> customStyles.</para>
    /// <para>Represents the following attribute in the schema: w:customStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "customStyles")]
    public OnOffValue CustomStyles
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> latentStyles.</para>
    /// <para>Represents the following attribute in the schema: w:latentStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "latentStyles")]
    public OnOffValue LatentStyles
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> stylesInUse.</para>
    /// <para>Represents the following attribute in the schema: w:stylesInUse </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "stylesInUse")]
    public OnOffValue StylesInUse
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> headingStyles.</para>
    /// <para>Represents the following attribute in the schema: w:headingStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "headingStyles")]
    public OnOffValue HeadingStyles
    {
        get { return (OnOffValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> numberingStyles.</para>
    /// <para>Represents the following attribute in the schema: w:numberingStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "numberingStyles")]
    public OnOffValue NumberingStyles
    {
        get { return (OnOffValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> tableStyles.</para>
    /// <para>Represents the following attribute in the schema: w:tableStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "tableStyles")]
    public OnOffValue TableStyles
    {
        get { return (OnOffValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> directFormattingOnRuns.</para>
    /// <para>Represents the following attribute in the schema: w:directFormattingOnRuns </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "directFormattingOnRuns")]
    public OnOffValue DirectFormattingOnRuns
    {
        get { return (OnOffValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> directFormattingOnParagraphs.</para>
    /// <para>Represents the following attribute in the schema: w:directFormattingOnParagraphs </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "directFormattingOnParagraphs")]
    public OnOffValue DirectFormattingOnParagraphs
    {
        get { return (OnOffValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> directFormattingOnNumbering.</para>
    /// <para>Represents the following attribute in the schema: w:directFormattingOnNumbering </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "directFormattingOnNumbering")]
    public OnOffValue DirectFormattingOnNumbering
    {
        get { return (OnOffValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> directFormattingOnTables.</para>
    /// <para>Represents the following attribute in the schema: w:directFormattingOnTables </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "directFormattingOnTables")]
    public OnOffValue DirectFormattingOnTables
    {
        get { return (OnOffValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> clearFormatting.</para>
    /// <para>Represents the following attribute in the schema: w:clearFormatting </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "clearFormatting")]
    public OnOffValue ClearFormatting
    {
        get { return (OnOffValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> top3HeadingStyles.</para>
    /// <para>Represents the following attribute in the schema: w:top3HeadingStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "top3HeadingStyles")]
    public OnOffValue Top3HeadingStyles
    {
        get { return (OnOffValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> visibleStyles.</para>
    /// <para>Represents the following attribute in the schema: w:visibleStyles </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "visibleStyles")]
    public OnOffValue VisibleStyles
    {
        get { return (OnOffValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> alternateStyleNames.</para>
    /// <para>Represents the following attribute in the schema: w:alternateStyleNames </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "alternateStyleNames")]
    public OnOffValue AlternateStyleNames
    {
        get { return (OnOffValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StylePaneFormatFilter class.
    /// </summary>
    public StylePaneFormatFilter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "allStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "customStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "latentStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "stylesInUse" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "headingStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "numberingStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "tableStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "directFormattingOnRuns" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "directFormattingOnParagraphs" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "directFormattingOnNumbering" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "directFormattingOnTables" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "clearFormatting" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "top3HeadingStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "visibleStyles" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "alternateStyleNames" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StylePaneFormatFilter>(deep);
    }

   
}
/// <summary>
/// <para>Suggested Sorting for List of Document Styles.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:stylePaneSortMethod.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StylePaneSortMethods : OpenXmlLeafElement
{
    private const string tagName = "stylePaneSortMethod";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12130;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StylePaneSortMethods class.
    /// </summary>
    public StylePaneSortMethods():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StylePaneSortMethods>(deep);
    }

   
}
/// <summary>
/// <para>Document Classification.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:documentType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocumentType : OpenXmlLeafElement
{
    private const string tagName = "documentType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12131;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Document Classification Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentTypeValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentTypeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocumentType class.
    /// </summary>
    public DocumentType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentTypeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocumentType>(deep);
    }

   
}
/// <summary>
/// <para>Mail Merge Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:mailMerge.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MainDocumentType &lt;w:mainDocumentType></description></item>
///<item><description>LinkToQuery &lt;w:linkToQuery></description></item>
///<item><description>DataType &lt;w:dataType></description></item>
///<item><description>ConnectString &lt;w:connectString></description></item>
///<item><description>Query &lt;w:query></description></item>
///<item><description>DataSourceReference &lt;w:dataSource></description></item>
///<item><description>HeaderSource &lt;w:headerSource></description></item>
///<item><description>DoNotSuppressBlankLines &lt;w:doNotSuppressBlankLines></description></item>
///<item><description>Destination &lt;w:destination></description></item>
///<item><description>AddressFieldName &lt;w:addressFieldName></description></item>
///<item><description>MailSubject &lt;w:mailSubject></description></item>
///<item><description>MailAsAttachment &lt;w:mailAsAttachment></description></item>
///<item><description>ViewMergedData &lt;w:viewMergedData></description></item>
///<item><description>ActiveRecord &lt;w:activeRecord></description></item>
///<item><description>CheckErrors &lt;w:checkErrors></description></item>
///<item><description>DataSourceObject &lt;w:odso></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MainDocumentType))]
    [ChildElementInfo(typeof(LinkToQuery))]
    [ChildElementInfo(typeof(DataType))]
    [ChildElementInfo(typeof(ConnectString))]
    [ChildElementInfo(typeof(Query))]
    [ChildElementInfo(typeof(DataSourceReference))]
    [ChildElementInfo(typeof(HeaderSource))]
    [ChildElementInfo(typeof(DoNotSuppressBlankLines))]
    [ChildElementInfo(typeof(Destination))]
    [ChildElementInfo(typeof(AddressFieldName))]
    [ChildElementInfo(typeof(MailSubject))]
    [ChildElementInfo(typeof(MailAsAttachment))]
    [ChildElementInfo(typeof(ViewMergedData))]
    [ChildElementInfo(typeof(ActiveRecord))]
    [ChildElementInfo(typeof(CheckErrors))]
    [ChildElementInfo(typeof(DataSourceObject))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MailMerge : OpenXmlCompositeElement
{
    private const string tagName = "mailMerge";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12132;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the MailMerge class.
    /// </summary>
    public MailMerge():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MailMerge class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MailMerge(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MailMerge class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MailMerge(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MailMerge class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MailMerge(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "mainDocumentType" == name)
    return new MainDocumentType();
    
if( 23 == namespaceId && "linkToQuery" == name)
    return new LinkToQuery();
    
if( 23 == namespaceId && "dataType" == name)
    return new DataType();
    
if( 23 == namespaceId && "connectString" == name)
    return new ConnectString();
    
if( 23 == namespaceId && "query" == name)
    return new Query();
    
if( 23 == namespaceId && "dataSource" == name)
    return new DataSourceReference();
    
if( 23 == namespaceId && "headerSource" == name)
    return new HeaderSource();
    
if( 23 == namespaceId && "doNotSuppressBlankLines" == name)
    return new DoNotSuppressBlankLines();
    
if( 23 == namespaceId && "destination" == name)
    return new Destination();
    
if( 23 == namespaceId && "addressFieldName" == name)
    return new AddressFieldName();
    
if( 23 == namespaceId && "mailSubject" == name)
    return new MailSubject();
    
if( 23 == namespaceId && "mailAsAttachment" == name)
    return new MailAsAttachment();
    
if( 23 == namespaceId && "viewMergedData" == name)
    return new ViewMergedData();
    
if( 23 == namespaceId && "activeRecord" == name)
    return new ActiveRecord();
    
if( 23 == namespaceId && "checkErrors" == name)
    return new CheckErrors();
    
if( 23 == namespaceId && "odso" == name)
    return new DataSourceObject();
    

    return null;
}

        private static readonly string[] eleTagNames = { "mainDocumentType","linkToQuery","dataType","connectString","query","dataSource","headerSource","doNotSuppressBlankLines","destination","addressFieldName","mailSubject","mailAsAttachment","viewMergedData","activeRecord","checkErrors","odso" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Source Document Type.</para>
    /// <para> Represents the following element tag in the schema: w:mainDocumentType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MainDocumentType MainDocumentType
    {
        get 
        {
            return GetElement<MainDocumentType>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Query Contains Link to External Query File.</para>
    /// <para> Represents the following element tag in the schema: w:linkToQuery </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LinkToQuery LinkToQuery
    {
        get 
        {
            return GetElement<LinkToQuery>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Data Source Type.</para>
    /// <para> Represents the following element tag in the schema: w:dataType </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DataType DataType
    {
        get 
        {
            return GetElement<DataType>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Data Source Connection String.</para>
    /// <para> Represents the following element tag in the schema: w:connectString </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConnectString ConnectString
    {
        get 
        {
            return GetElement<ConnectString>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Query For Data Source Records To Merge.</para>
    /// <para> Represents the following element tag in the schema: w:query </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Query Query
    {
        get 
        {
            return GetElement<Query>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Data Source File Path.</para>
    /// <para> Represents the following element tag in the schema: w:dataSource </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DataSourceReference DataSourceReference
    {
        get 
        {
            return GetElement<DataSourceReference>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Header Definition File Path.</para>
    /// <para> Represents the following element tag in the schema: w:headerSource </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public HeaderSource HeaderSource
    {
        get 
        {
            return GetElement<HeaderSource>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Remove Blank Lines from Merged Documents.</para>
    /// <para> Represents the following element tag in the schema: w:doNotSuppressBlankLines </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotSuppressBlankLines DoNotSuppressBlankLines
    {
        get 
        {
            return GetElement<DoNotSuppressBlankLines>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Merged Document Destination.</para>
    /// <para> Represents the following element tag in the schema: w:destination </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public Destination Destination
    {
        get 
        {
            return GetElement<Destination>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Column Containing E-mail Address.</para>
    /// <para> Represents the following element tag in the schema: w:addressFieldName </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AddressFieldName AddressFieldName
    {
        get 
        {
            return GetElement<AddressFieldName>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Merged E-mail or Fax Subject Line.</para>
    /// <para> Represents the following element tag in the schema: w:mailSubject </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MailSubject MailSubject
    {
        get 
        {
            return GetElement<MailSubject>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Merged Document To E-Mail Attachment.</para>
    /// <para> Represents the following element tag in the schema: w:mailAsAttachment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MailAsAttachment MailAsAttachment
    {
        get 
        {
            return GetElement<MailAsAttachment>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> View Merged Data Within Document.</para>
    /// <para> Represents the following element tag in the schema: w:viewMergedData </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ViewMergedData ViewMergedData
    {
        get 
        {
            return GetElement<ViewMergedData>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Record Currently Displayed In Merged Document.</para>
    /// <para> Represents the following element tag in the schema: w:activeRecord </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ActiveRecord ActiveRecord
    {
        get 
        {
            return GetElement<ActiveRecord>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> Mail Merge Error Reporting Setting.</para>
    /// <para> Represents the following element tag in the schema: w:checkErrors </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CheckErrors CheckErrors
    {
        get 
        {
            return GetElement<CheckErrors>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Office Data Source Object Settings.</para>
    /// <para> Represents the following element tag in the schema: w:odso </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DataSourceObject DataSourceObject
    {
        get 
        {
            return GetElement<DataSourceObject>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MailMerge>(deep);
    }

   
}
/// <summary>
/// <para>Visibility of Annotation Types.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:revisionView.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionView : OpenXmlLeafElement
{
    private const string tagName = "revisionView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12133;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "markup","comments","insDel","formatting","inkAnnotations" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Display Visual Indicator Of Markup Area.</para>
    /// <para>Represents the following attribute in the schema: w:markup </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "markup")]
    public OnOffValue Markup
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Display Comments.</para>
    /// <para>Represents the following attribute in the schema: w:comments </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "comments")]
    public OnOffValue Comments
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Display Content Revisions.</para>
    /// <para>Represents the following attribute in the schema: w:insDel </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "insDel")]
    public OnOffValue DisplayRevision
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Display Formatting Revisions.</para>
    /// <para>Represents the following attribute in the schema: w:formatting </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "formatting")]
    public OnOffValue Formatting
    {
        get { return (OnOffValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Display Ink Annotations.</para>
    /// <para>Represents the following attribute in the schema: w:inkAnnotations </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "inkAnnotations")]
    public OnOffValue InkAnnotations
    {
        get { return (OnOffValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionView class.
    /// </summary>
    public RevisionView():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "markup" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "comments" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "insDel" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "formatting" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "inkAnnotations" == name)
    return new OnOffValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionView>(deep);
    }

   
}
/// <summary>
/// <para>Document Editing Restrictions.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:documentProtection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocumentProtection : OpenXmlLeafElement
{
    private const string tagName = "documentProtection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12137;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "edit","formatting","enforcement","cryptProviderType","cryptAlgorithmClass","cryptAlgorithmType","cryptAlgorithmSid","cryptSpinCount","cryptProvider","algIdExt","algIdExtSource","cryptProviderTypeExt","cryptProviderTypeExtSource","hash","salt","algorithmName","hashValue","saltValue","spinCount" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Document Editing Restrictions.</para>
    /// <para>Represents the following attribute in the schema: w:edit </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "edit")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentProtectionValues> Edit
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentProtectionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Only Allow Formatting With Unlocked Styles.</para>
    /// <para>Represents the following attribute in the schema: w:formatting </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "formatting")]
    public OnOffValue Formatting
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Enforce Document Protection Settings.</para>
    /// <para>Represents the following attribute in the schema: w:enforcement </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "enforcement")]
    public OnOffValue Enforcement
    {
        get { return (OnOffValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider Type.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderType </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderType")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues> CryptographicProviderType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Class.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmClass </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmClass")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues> CryptographicAlgorithmClass
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Type.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmType </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmType")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues> CryptographicAlgorithmType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: w:cryptAlgorithmSid </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptAlgorithmSid")]
    public Int32Value CryptographicAlgorithmSid
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: w:cryptSpinCount </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptSpinCount")]
    public UInt32Value CryptographicSpinCount
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProvider </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProvider")]
    public StringValue CryptographicProvider
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Extensibility.</para>
    /// <para>Represents the following attribute in the schema: w:algIdExt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algIdExt")]
    public HexBinaryValue AlgorithmIdExtensibility
    {
        get { return (HexBinaryValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Algorithm Extensibility Source.</para>
    /// <para>Represents the following attribute in the schema: w:algIdExtSource </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algIdExtSource")]
    public StringValue AlgorithmIdExtensibilitySource
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Provider Type Extensibility.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderTypeExt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderTypeExt")]
    public HexBinaryValue CryptographicProviderTypeExtensibility
    {
        get { return (HexBinaryValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Provider Type Extensibility Source.</para>
    /// <para>Represents the following attribute in the schema: w:cryptProviderTypeExtSource </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "cryptProviderTypeExtSource")]
    public StringValue CryptographicProviderTypeExtSource
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash.</para>
    /// <para>Represents the following attribute in the schema: w:hash </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hash")]
    public Base64BinaryValue Hash
    {
        get { return (Base64BinaryValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Salt for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: w:salt </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "salt")]
    public Base64BinaryValue Salt
    {
        get { return (Base64BinaryValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> algorithmName.</para>
    /// <para>Represents the following attribute in the schema: w:algorithmName </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> hashValue.</para>
    /// <para>Represents the following attribute in the schema: w:hashValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> saltValue.</para>
    /// <para>Represents the following attribute in the schema: w:saltValue </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> spinCount.</para>
    /// <para>Represents the following attribute in the schema: w:spinCount </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "spinCount")]
    public Int32Value SpinCount
    {
        get { return (Int32Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DocumentProtection class.
    /// </summary>
    public DocumentProtection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "edit" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.DocumentProtectionValues>();
    
if( 23 == namespaceId && "formatting" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "enforcement" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "cryptProviderType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptProviderValues>();
    
if( 23 == namespaceId && "cryptAlgorithmClass" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmClassValues>();
    
if( 23 == namespaceId && "cryptAlgorithmType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CryptAlgorithmValues>();
    
if( 23 == namespaceId && "cryptAlgorithmSid" == name)
    return new Int32Value();
    
if( 23 == namespaceId && "cryptSpinCount" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "cryptProvider" == name)
    return new StringValue();
    
if( 23 == namespaceId && "algIdExt" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "algIdExtSource" == name)
    return new StringValue();
    
if( 23 == namespaceId && "cryptProviderTypeExt" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "cryptProviderTypeExtSource" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hash" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "salt" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 23 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 23 == namespaceId && "spinCount" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocumentProtection>(deep);
    }

   
}
/// <summary>
/// <para>Distance Between Automatic Tab Stops.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:defaultTabStop.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefaultTabStop : NonNegativeShortType
{
    private const string tagName = "defaultTabStop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12141;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DefaultTabStop class.
    /// </summary>
    public DefaultTabStop():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefaultTabStop>(deep);
    }

}
/// <summary>
/// <para>Number of Pages Per Booklet.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:bookFoldPrintingSheets.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookFoldPrintingSheets : NonNegativeShortType
{
    private const string tagName = "bookFoldPrintingSheets";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12153;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BookFoldPrintingSheets class.
    /// </summary>
    public BookFoldPrintingSheets():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookFoldPrintingSheets>(deep);
    }

}
/// <summary>
/// Defines the NonNegativeShortType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class NonNegativeShortType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int16Value Val
    {
        get { return (Int16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the NonNegativeShortType class.
    /// </summary>
    protected NonNegativeShortType(){}
    
    
    
}
/// <summary>
/// <para>Maximum Number of Consecutively Hyphenated Lines.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:consecutiveHyphenLimit.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConsecutiveHyphenLimit : OpenXmlLeafElement
{
    private const string tagName = "consecutiveHyphenLimit";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12143;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public UInt16Value Val
    {
        get { return (UInt16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConsecutiveHyphenLimit class.
    /// </summary>
    public ConsecutiveHyphenLimit():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new UInt16Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConsecutiveHyphenLimit>(deep);
    }

   
}
/// <summary>
/// <para>Percentage of Document to Use When Generating Summary.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:summaryLength.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SummaryLength : OpenXmlLeafElement
{
    private const string tagName = "summaryLength";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12147;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SummaryLength class.
    /// </summary>
    public SummaryLength():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SummaryLength>(deep);
    }

   
}
/// <summary>
/// <para>Distance between Horizontal Gridlines.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:displayHorizontalDrawingGridEvery.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DisplayHorizontalDrawingGrid : UnsignedInt7Type
{
    private const string tagName = "displayHorizontalDrawingGridEvery";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12156;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DisplayHorizontalDrawingGrid class.
    /// </summary>
    public DisplayHorizontalDrawingGrid():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DisplayHorizontalDrawingGrid>(deep);
    }

}
/// <summary>
/// <para>Distance between Vertical Gridlines.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:displayVerticalDrawingGridEvery.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DisplayVerticalDrawingGrid : UnsignedInt7Type
{
    private const string tagName = "displayVerticalDrawingGridEvery";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12157;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DisplayVerticalDrawingGrid class.
    /// </summary>
    public DisplayVerticalDrawingGrid():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DisplayVerticalDrawingGrid>(deep);
    }

}
/// <summary>
/// Defines the UnsignedInt7Type class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class UnsignedInt7Type : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the UnsignedInt7Type class.
    /// </summary>
    protected UnsignedInt7Type(){}
    
    
    
}
/// <summary>
/// <para>Character-Level Whitespace Compression.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:characterSpacingControl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CharacterSpacingControl : OpenXmlLeafElement
{
    private const string tagName = "characterSpacingControl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12163;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.CharacterSpacingValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.CharacterSpacingValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CharacterSpacingControl class.
    /// </summary>
    public CharacterSpacingControl():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.CharacterSpacingValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CharacterSpacingControl>(deep);
    }

   
}
/// <summary>
/// <para>Custom Set of Characters Which Cannot End a Line.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noLineBreaksAfter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoLineBreaksAfterKinsoku : OpenXmlLeafElement
{
    private const string tagName = "noLineBreaksAfter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12166;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lang","val" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> lang.</para>
    /// <para>Represents the following attribute in the schema: w:lang </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lang")]
    public StringValue Language
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NoLineBreaksAfterKinsoku class.
    /// </summary>
    public NoLineBreaksAfterKinsoku():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lang" == name)
    return new StringValue();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoLineBreaksAfterKinsoku>(deep);
    }

   
}
/// <summary>
/// <para>Custom Set Of Characters Which Cannot Begin A Line.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:noLineBreaksBefore.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NoLineBreaksBeforeKinsoku : OpenXmlLeafElement
{
    private const string tagName = "noLineBreaksBefore";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12167;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "lang","val" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> lang.</para>
    /// <para>Represents the following attribute in the schema: w:lang </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "lang")]
    public StringValue Language
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NoLineBreaksBeforeKinsoku class.
    /// </summary>
    public NoLineBreaksBeforeKinsoku():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "lang" == name)
    return new StringValue();
    
if( 23 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NoLineBreaksBeforeKinsoku>(deep);
    }

   
}
/// <summary>
/// <para>Custom XSL Transform To Use When Saving As XML File.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:saveThroughXslt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SaveThroughXslt : OpenXmlLeafElement
{
    private const string tagName = "saveThroughXslt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12176;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","solutionID" };
    private static byte[] attributeNamespaceIds = { 19,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XSL Transformation Location.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Local Identifier for XSL Transform.</para>
    /// <para>Represents the following attribute in the schema: w:solutionID </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "solutionID")]
    public StringValue SolutionId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SaveThroughXslt class.
    /// </summary>
    public SaveThroughXslt():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 23 == namespaceId && "solutionID" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SaveThroughXslt>(deep);
    }

   
}
/// <summary>
/// <para>Default Properties for VML Objects in Header and Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:hdrShapeDefaults.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeDefaults &lt;o:shapedefaults></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeLayout &lt;o:shapelayout></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HeaderShapeDefaults : ShapeDefaultsType
{
    private const string tagName = "hdrShapeDefaults";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12180;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HeaderShapeDefaults class.
    /// </summary>
    public HeaderShapeDefaults():base(){}
            /// <summary>
    ///Initializes a new instance of the HeaderShapeDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HeaderShapeDefaults(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderShapeDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HeaderShapeDefaults(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderShapeDefaults class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HeaderShapeDefaults(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HeaderShapeDefaults>(deep);
    }

}
/// <summary>
/// <para>Default Properties for VML Objects in Main Document.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:shapeDefaults.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeDefaults &lt;o:shapedefaults></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeLayout &lt;o:shapelayout></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ShapeDefaults : ShapeDefaultsType
{
    private const string tagName = "shapeDefaults";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12195;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ShapeDefaults class.
    /// </summary>
    public ShapeDefaults():base(){}
            /// <summary>
    ///Initializes a new instance of the ShapeDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeDefaults(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefaults class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ShapeDefaults(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefaults class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ShapeDefaults(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ShapeDefaults>(deep);
    }

}
/// <summary>
/// Defines the ShapeDefaultsType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeDefaults &lt;o:shapedefaults></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Office.ShapeLayout &lt;o:shapelayout></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ShapeDefaults))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Office.ShapeLayout))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ShapeDefaultsType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 27 == namespaceId && "shapedefaults" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ShapeDefaults();
    
if( 27 == namespaceId && "shapelayout" == name)
    return new DocumentFormat.OpenXml.Vml.Office.ShapeLayout();
    

    return null;
}

    
    
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefaultsType class.
    /// </summary>
    protected ShapeDefaultsType(){}
    
            /// <summary>
    ///Initializes a new instance of the ShapeDefaultsType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ShapeDefaultsType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefaultsType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected ShapeDefaultsType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ShapeDefaultsType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected ShapeDefaultsType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Document-Wide Footnote Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:footnotePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FootnotePosition &lt;w:pos></description></item>
///<item><description>NumberingFormat &lt;w:numFmt></description></item>
///<item><description>NumberingStart &lt;w:numStart></description></item>
///<item><description>NumberingRestart &lt;w:numRestart></description></item>
///<item><description>FootnoteSpecialReference &lt;w:footnote></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FootnotePosition))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(NumberingStart))]
    [ChildElementInfo(typeof(NumberingRestart))]
    [ChildElementInfo(typeof(FootnoteSpecialReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FootnoteDocumentWideProperties : OpenXmlCompositeElement
{
    private const string tagName = "footnotePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12181;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FootnoteDocumentWideProperties class.
    /// </summary>
    public FootnoteDocumentWideProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FootnoteDocumentWideProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FootnoteDocumentWideProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteDocumentWideProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FootnoteDocumentWideProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FootnoteDocumentWideProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FootnoteDocumentWideProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pos" == name)
    return new FootnotePosition();
    
if( 23 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 23 == namespaceId && "numStart" == name)
    return new NumberingStart();
    
if( 23 == namespaceId && "numRestart" == name)
    return new NumberingRestart();
    
if( 23 == namespaceId && "footnote" == name)
    return new FootnoteSpecialReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos","numFmt","numStart","numRestart","footnote" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Footnote Placement.</para>
    /// <para> Represents the following element tag in the schema: w:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FootnotePosition FootnotePosition
    {
        get 
        {
            return GetElement<FootnotePosition>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Footnote Numbering Format.</para>
    /// <para> Represents the following element tag in the schema: w:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Starting Value.</para>
    /// <para> Represents the following element tag in the schema: w:numStart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingStart NumberingStart
    {
        get 
        {
            return GetElement<NumberingStart>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Restart Location.</para>
    /// <para> Represents the following element tag in the schema: w:numRestart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingRestart NumberingRestart
    {
        get 
        {
            return GetElement<NumberingRestart>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FootnoteDocumentWideProperties>(deep);
    }

   
}
/// <summary>
/// <para>Document-Wide Endnote Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:endnotePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EndnotePosition &lt;w:pos></description></item>
///<item><description>NumberingFormat &lt;w:numFmt></description></item>
///<item><description>NumberingStart &lt;w:numStart></description></item>
///<item><description>NumberingRestart &lt;w:numRestart></description></item>
///<item><description>EndnoteSpecialReference &lt;w:endnote></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EndnotePosition))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(NumberingStart))]
    [ChildElementInfo(typeof(NumberingRestart))]
    [ChildElementInfo(typeof(EndnoteSpecialReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EndnoteDocumentWideProperties : OpenXmlCompositeElement
{
    private const string tagName = "endnotePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12182;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the EndnoteDocumentWideProperties class.
    /// </summary>
    public EndnoteDocumentWideProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EndnoteDocumentWideProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndnoteDocumentWideProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EndnoteDocumentWideProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndnoteDocumentWideProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EndnoteDocumentWideProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EndnoteDocumentWideProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "pos" == name)
    return new EndnotePosition();
    
if( 23 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 23 == namespaceId && "numStart" == name)
    return new NumberingStart();
    
if( 23 == namespaceId && "numRestart" == name)
    return new NumberingRestart();
    
if( 23 == namespaceId && "endnote" == name)
    return new EndnoteSpecialReference();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pos","numFmt","numStart","numRestart","endnote" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Endnote Placement.</para>
    /// <para> Represents the following element tag in the schema: w:pos </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public EndnotePosition EndnotePosition
    {
        get 
        {
            return GetElement<EndnotePosition>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Endnote Numbering Format.</para>
    /// <para> Represents the following element tag in the schema: w:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Starting Value.</para>
    /// <para> Represents the following element tag in the schema: w:numStart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingStart NumberingStart
    {
        get 
        {
            return GetElement<NumberingStart>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Footnote and Endnote Numbering Restart Location.</para>
    /// <para> Represents the following element tag in the schema: w:numRestart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NumberingRestart NumberingRestart
    {
        get 
        {
            return GetElement<NumberingRestart>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndnoteDocumentWideProperties>(deep);
    }

   
}
/// <summary>
/// <para>Compatibility Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:compat.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>UseSingleBorderForContiguousCells &lt;w:useSingleBorderforContiguousCells></description></item>
///<item><description>WordPerfectJustification &lt;w:wpJustification></description></item>
///<item><description>NoTabHangIndent &lt;w:noTabHangInd></description></item>
///<item><description>NoLeading &lt;w:noLeading></description></item>
///<item><description>SpaceForUnderline &lt;w:spaceForUL></description></item>
///<item><description>NoColumnBalance &lt;w:noColumnBalance></description></item>
///<item><description>BalanceSingleByteDoubleByteWidth &lt;w:balanceSingleByteDoubleByteWidth></description></item>
///<item><description>NoExtraLineSpacing &lt;w:noExtraLineSpacing></description></item>
///<item><description>DoNotLeaveBackslashAlone &lt;w:doNotLeaveBackslashAlone></description></item>
///<item><description>UnderlineTrailingSpaces &lt;w:ulTrailSpace></description></item>
///<item><description>DoNotExpandShiftReturn &lt;w:doNotExpandShiftReturn></description></item>
///<item><description>SpacingInWholePoints &lt;w:spacingInWholePoints></description></item>
///<item><description>LineWrapLikeWord6 &lt;w:lineWrapLikeWord6></description></item>
///<item><description>PrintBodyTextBeforeHeader &lt;w:printBodyTextBeforeHeader></description></item>
///<item><description>PrintColorBlackWhite &lt;w:printColBlack></description></item>
///<item><description>WordPerfectSpaceWidth &lt;w:wpSpaceWidth></description></item>
///<item><description>ShowBreaksInFrames &lt;w:showBreaksInFrames></description></item>
///<item><description>SubFontBySize &lt;w:subFontBySize></description></item>
///<item><description>SuppressBottomSpacing &lt;w:suppressBottomSpacing></description></item>
///<item><description>SuppressTopSpacing &lt;w:suppressTopSpacing></description></item>
///<item><description>SuppressSpacingAtTopOfPage &lt;w:suppressSpacingAtTopOfPage></description></item>
///<item><description>SuppressTopSpacingWordPerfect &lt;w:suppressTopSpacingWP></description></item>
///<item><description>SuppressSpacingBeforeAfterPageBreak &lt;w:suppressSpBfAfterPgBrk></description></item>
///<item><description>SwapBordersFacingPages &lt;w:swapBordersFacingPages></description></item>
///<item><description>ConvertMailMergeEscape &lt;w:convMailMergeEsc></description></item>
///<item><description>TruncateFontHeightsLikeWordPerfect &lt;w:truncateFontHeightsLikeWP6></description></item>
///<item><description>MacWordSmallCaps &lt;w:mwSmallCaps></description></item>
///<item><description>UsePrinterMetrics &lt;w:usePrinterMetrics></description></item>
///<item><description>DoNotSuppressParagraphBorders &lt;w:doNotSuppressParagraphBorders></description></item>
///<item><description>WrapTrailSpaces &lt;w:wrapTrailSpaces></description></item>
///<item><description>FootnoteLayoutLikeWord8 &lt;w:footnoteLayoutLikeWW8></description></item>
///<item><description>ShapeLayoutLikeWord8 &lt;w:shapeLayoutLikeWW8></description></item>
///<item><description>AlignTablesRowByRow &lt;w:alignTablesRowByRow></description></item>
///<item><description>ForgetLastTabAlignment &lt;w:forgetLastTabAlignment></description></item>
///<item><description>AdjustLineHeightInTable &lt;w:adjustLineHeightInTable></description></item>
///<item><description>AutoSpaceLikeWord95 &lt;w:autoSpaceLikeWord95></description></item>
///<item><description>NoSpaceRaiseLower &lt;w:noSpaceRaiseLower></description></item>
///<item><description>DoNotUseHTMLParagraphAutoSpacing &lt;w:doNotUseHTMLParagraphAutoSpacing></description></item>
///<item><description>LayoutRawTableWidth &lt;w:layoutRawTableWidth></description></item>
///<item><description>LayoutTableRowsApart &lt;w:layoutTableRowsApart></description></item>
///<item><description>UseWord97LineBreakRules &lt;w:useWord97LineBreakRules></description></item>
///<item><description>DoNotBreakWrappedTables &lt;w:doNotBreakWrappedTables></description></item>
///<item><description>DoNotSnapToGridInCell &lt;w:doNotSnapToGridInCell></description></item>
///<item><description>SelectFieldWithFirstOrLastChar &lt;w:selectFldWithFirstOrLastChar></description></item>
///<item><description>ApplyBreakingRules &lt;w:applyBreakingRules></description></item>
///<item><description>DoNotWrapTextWithPunctuation &lt;w:doNotWrapTextWithPunct></description></item>
///<item><description>DoNotUseEastAsianBreakRules &lt;w:doNotUseEastAsianBreakRules></description></item>
///<item><description>UseWord2002TableStyleRules &lt;w:useWord2002TableStyleRules></description></item>
///<item><description>GrowAutofit &lt;w:growAutofit></description></item>
///<item><description>UseFarEastLayout &lt;w:useFELayout></description></item>
///<item><description>UseNormalStyleForList &lt;w:useNormalStyleForList></description></item>
///<item><description>DoNotUseIndentAsNumberingTabStop &lt;w:doNotUseIndentAsNumberingTabStop></description></item>
///<item><description>UseAltKinsokuLineBreakRules &lt;w:useAltKinsokuLineBreakRules></description></item>
///<item><description>AllowSpaceOfSameStyleInTable &lt;w:allowSpaceOfSameStyleInTable></description></item>
///<item><description>DoNotSuppressIndentation &lt;w:doNotSuppressIndentation></description></item>
///<item><description>DoNotAutofitConstrainedTables &lt;w:doNotAutofitConstrainedTables></description></item>
///<item><description>AutofitToFirstFixedWidthCell &lt;w:autofitToFirstFixedWidthCell></description></item>
///<item><description>UnderlineTabInNumberingList &lt;w:underlineTabInNumList></description></item>
///<item><description>DisplayHangulFixedWidth &lt;w:displayHangulFixedWidth></description></item>
///<item><description>SplitPageBreakAndParagraphMark &lt;w:splitPgBreakAndParaMark></description></item>
///<item><description>DoNotVerticallyAlignCellWithShape &lt;w:doNotVertAlignCellWithSp></description></item>
///<item><description>DoNotBreakConstrainedForcedTable &lt;w:doNotBreakConstrainedForcedTable></description></item>
///<item><description>DoNotVerticallyAlignInTextBox &lt;w:doNotVertAlignInTxbx></description></item>
///<item><description>UseAnsiKerningPairs &lt;w:useAnsiKerningPairs></description></item>
///<item><description>CachedColumnBalance &lt;w:cachedColBalance></description></item>
///<item><description>CompatibilitySetting &lt;w:compatSetting></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(UseSingleBorderForContiguousCells))]
    [ChildElementInfo(typeof(WordPerfectJustification))]
    [ChildElementInfo(typeof(NoTabHangIndent))]
    [ChildElementInfo(typeof(NoLeading))]
    [ChildElementInfo(typeof(SpaceForUnderline))]
    [ChildElementInfo(typeof(NoColumnBalance))]
    [ChildElementInfo(typeof(BalanceSingleByteDoubleByteWidth))]
    [ChildElementInfo(typeof(NoExtraLineSpacing))]
    [ChildElementInfo(typeof(DoNotLeaveBackslashAlone))]
    [ChildElementInfo(typeof(UnderlineTrailingSpaces))]
    [ChildElementInfo(typeof(DoNotExpandShiftReturn))]
    [ChildElementInfo(typeof(SpacingInWholePoints))]
    [ChildElementInfo(typeof(LineWrapLikeWord6))]
    [ChildElementInfo(typeof(PrintBodyTextBeforeHeader))]
    [ChildElementInfo(typeof(PrintColorBlackWhite))]
    [ChildElementInfo(typeof(WordPerfectSpaceWidth))]
    [ChildElementInfo(typeof(ShowBreaksInFrames))]
    [ChildElementInfo(typeof(SubFontBySize))]
    [ChildElementInfo(typeof(SuppressBottomSpacing))]
    [ChildElementInfo(typeof(SuppressTopSpacing))]
    [ChildElementInfo(typeof(SuppressSpacingAtTopOfPage))]
    [ChildElementInfo(typeof(SuppressTopSpacingWordPerfect))]
    [ChildElementInfo(typeof(SuppressSpacingBeforeAfterPageBreak))]
    [ChildElementInfo(typeof(SwapBordersFacingPages))]
    [ChildElementInfo(typeof(ConvertMailMergeEscape))]
    [ChildElementInfo(typeof(TruncateFontHeightsLikeWordPerfect))]
    [ChildElementInfo(typeof(MacWordSmallCaps))]
    [ChildElementInfo(typeof(UsePrinterMetrics))]
    [ChildElementInfo(typeof(DoNotSuppressParagraphBorders))]
    [ChildElementInfo(typeof(WrapTrailSpaces))]
    [ChildElementInfo(typeof(FootnoteLayoutLikeWord8))]
    [ChildElementInfo(typeof(ShapeLayoutLikeWord8))]
    [ChildElementInfo(typeof(AlignTablesRowByRow))]
    [ChildElementInfo(typeof(ForgetLastTabAlignment))]
    [ChildElementInfo(typeof(AdjustLineHeightInTable))]
    [ChildElementInfo(typeof(AutoSpaceLikeWord95))]
    [ChildElementInfo(typeof(NoSpaceRaiseLower))]
    [ChildElementInfo(typeof(DoNotUseHTMLParagraphAutoSpacing))]
    [ChildElementInfo(typeof(LayoutRawTableWidth))]
    [ChildElementInfo(typeof(LayoutTableRowsApart))]
    [ChildElementInfo(typeof(UseWord97LineBreakRules))]
    [ChildElementInfo(typeof(DoNotBreakWrappedTables))]
    [ChildElementInfo(typeof(DoNotSnapToGridInCell))]
    [ChildElementInfo(typeof(SelectFieldWithFirstOrLastChar))]
    [ChildElementInfo(typeof(ApplyBreakingRules))]
    [ChildElementInfo(typeof(DoNotWrapTextWithPunctuation))]
    [ChildElementInfo(typeof(DoNotUseEastAsianBreakRules))]
    [ChildElementInfo(typeof(UseWord2002TableStyleRules))]
    [ChildElementInfo(typeof(GrowAutofit))]
    [ChildElementInfo(typeof(UseFarEastLayout))]
    [ChildElementInfo(typeof(UseNormalStyleForList))]
    [ChildElementInfo(typeof(DoNotUseIndentAsNumberingTabStop))]
    [ChildElementInfo(typeof(UseAltKinsokuLineBreakRules))]
    [ChildElementInfo(typeof(AllowSpaceOfSameStyleInTable))]
    [ChildElementInfo(typeof(DoNotSuppressIndentation))]
    [ChildElementInfo(typeof(DoNotAutofitConstrainedTables))]
    [ChildElementInfo(typeof(AutofitToFirstFixedWidthCell))]
    [ChildElementInfo(typeof(UnderlineTabInNumberingList))]
    [ChildElementInfo(typeof(DisplayHangulFixedWidth))]
    [ChildElementInfo(typeof(SplitPageBreakAndParagraphMark))]
    [ChildElementInfo(typeof(DoNotVerticallyAlignCellWithShape))]
    [ChildElementInfo(typeof(DoNotBreakConstrainedForcedTable))]
    [ChildElementInfo(typeof(DoNotVerticallyAlignInTextBox))]
    [ChildElementInfo(typeof(UseAnsiKerningPairs))]
    [ChildElementInfo(typeof(CachedColumnBalance))]
    [ChildElementInfo(typeof(CompatibilitySetting))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Compatibility : OpenXmlCompositeElement
{
    private const string tagName = "compat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12183;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Compatibility class.
    /// </summary>
    public Compatibility():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Compatibility class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Compatibility(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Compatibility class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Compatibility(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Compatibility class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Compatibility(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "useSingleBorderforContiguousCells" == name)
    return new UseSingleBorderForContiguousCells();
    
if( 23 == namespaceId && "wpJustification" == name)
    return new WordPerfectJustification();
    
if( 23 == namespaceId && "noTabHangInd" == name)
    return new NoTabHangIndent();
    
if( 23 == namespaceId && "noLeading" == name)
    return new NoLeading();
    
if( 23 == namespaceId && "spaceForUL" == name)
    return new SpaceForUnderline();
    
if( 23 == namespaceId && "noColumnBalance" == name)
    return new NoColumnBalance();
    
if( 23 == namespaceId && "balanceSingleByteDoubleByteWidth" == name)
    return new BalanceSingleByteDoubleByteWidth();
    
if( 23 == namespaceId && "noExtraLineSpacing" == name)
    return new NoExtraLineSpacing();
    
if( 23 == namespaceId && "doNotLeaveBackslashAlone" == name)
    return new DoNotLeaveBackslashAlone();
    
if( 23 == namespaceId && "ulTrailSpace" == name)
    return new UnderlineTrailingSpaces();
    
if( 23 == namespaceId && "doNotExpandShiftReturn" == name)
    return new DoNotExpandShiftReturn();
    
if( 23 == namespaceId && "spacingInWholePoints" == name)
    return new SpacingInWholePoints();
    
if( 23 == namespaceId && "lineWrapLikeWord6" == name)
    return new LineWrapLikeWord6();
    
if( 23 == namespaceId && "printBodyTextBeforeHeader" == name)
    return new PrintBodyTextBeforeHeader();
    
if( 23 == namespaceId && "printColBlack" == name)
    return new PrintColorBlackWhite();
    
if( 23 == namespaceId && "wpSpaceWidth" == name)
    return new WordPerfectSpaceWidth();
    
if( 23 == namespaceId && "showBreaksInFrames" == name)
    return new ShowBreaksInFrames();
    
if( 23 == namespaceId && "subFontBySize" == name)
    return new SubFontBySize();
    
if( 23 == namespaceId && "suppressBottomSpacing" == name)
    return new SuppressBottomSpacing();
    
if( 23 == namespaceId && "suppressTopSpacing" == name)
    return new SuppressTopSpacing();
    
if( 23 == namespaceId && "suppressSpacingAtTopOfPage" == name)
    return new SuppressSpacingAtTopOfPage();
    
if( 23 == namespaceId && "suppressTopSpacingWP" == name)
    return new SuppressTopSpacingWordPerfect();
    
if( 23 == namespaceId && "suppressSpBfAfterPgBrk" == name)
    return new SuppressSpacingBeforeAfterPageBreak();
    
if( 23 == namespaceId && "swapBordersFacingPages" == name)
    return new SwapBordersFacingPages();
    
if( 23 == namespaceId && "convMailMergeEsc" == name)
    return new ConvertMailMergeEscape();
    
if( 23 == namespaceId && "truncateFontHeightsLikeWP6" == name)
    return new TruncateFontHeightsLikeWordPerfect();
    
if( 23 == namespaceId && "mwSmallCaps" == name)
    return new MacWordSmallCaps();
    
if( 23 == namespaceId && "usePrinterMetrics" == name)
    return new UsePrinterMetrics();
    
if( 23 == namespaceId && "doNotSuppressParagraphBorders" == name)
    return new DoNotSuppressParagraphBorders();
    
if( 23 == namespaceId && "wrapTrailSpaces" == name)
    return new WrapTrailSpaces();
    
if( 23 == namespaceId && "footnoteLayoutLikeWW8" == name)
    return new FootnoteLayoutLikeWord8();
    
if( 23 == namespaceId && "shapeLayoutLikeWW8" == name)
    return new ShapeLayoutLikeWord8();
    
if( 23 == namespaceId && "alignTablesRowByRow" == name)
    return new AlignTablesRowByRow();
    
if( 23 == namespaceId && "forgetLastTabAlignment" == name)
    return new ForgetLastTabAlignment();
    
if( 23 == namespaceId && "adjustLineHeightInTable" == name)
    return new AdjustLineHeightInTable();
    
if( 23 == namespaceId && "autoSpaceLikeWord95" == name)
    return new AutoSpaceLikeWord95();
    
if( 23 == namespaceId && "noSpaceRaiseLower" == name)
    return new NoSpaceRaiseLower();
    
if( 23 == namespaceId && "doNotUseHTMLParagraphAutoSpacing" == name)
    return new DoNotUseHTMLParagraphAutoSpacing();
    
if( 23 == namespaceId && "layoutRawTableWidth" == name)
    return new LayoutRawTableWidth();
    
if( 23 == namespaceId && "layoutTableRowsApart" == name)
    return new LayoutTableRowsApart();
    
if( 23 == namespaceId && "useWord97LineBreakRules" == name)
    return new UseWord97LineBreakRules();
    
if( 23 == namespaceId && "doNotBreakWrappedTables" == name)
    return new DoNotBreakWrappedTables();
    
if( 23 == namespaceId && "doNotSnapToGridInCell" == name)
    return new DoNotSnapToGridInCell();
    
if( 23 == namespaceId && "selectFldWithFirstOrLastChar" == name)
    return new SelectFieldWithFirstOrLastChar();
    
if( 23 == namespaceId && "applyBreakingRules" == name)
    return new ApplyBreakingRules();
    
if( 23 == namespaceId && "doNotWrapTextWithPunct" == name)
    return new DoNotWrapTextWithPunctuation();
    
if( 23 == namespaceId && "doNotUseEastAsianBreakRules" == name)
    return new DoNotUseEastAsianBreakRules();
    
if( 23 == namespaceId && "useWord2002TableStyleRules" == name)
    return new UseWord2002TableStyleRules();
    
if( 23 == namespaceId && "growAutofit" == name)
    return new GrowAutofit();
    
if( 23 == namespaceId && "useFELayout" == name)
    return new UseFarEastLayout();
    
if( 23 == namespaceId && "useNormalStyleForList" == name)
    return new UseNormalStyleForList();
    
if( 23 == namespaceId && "doNotUseIndentAsNumberingTabStop" == name)
    return new DoNotUseIndentAsNumberingTabStop();
    
if( 23 == namespaceId && "useAltKinsokuLineBreakRules" == name)
    return new UseAltKinsokuLineBreakRules();
    
if( 23 == namespaceId && "allowSpaceOfSameStyleInTable" == name)
    return new AllowSpaceOfSameStyleInTable();
    
if( 23 == namespaceId && "doNotSuppressIndentation" == name)
    return new DoNotSuppressIndentation();
    
if( 23 == namespaceId && "doNotAutofitConstrainedTables" == name)
    return new DoNotAutofitConstrainedTables();
    
if( 23 == namespaceId && "autofitToFirstFixedWidthCell" == name)
    return new AutofitToFirstFixedWidthCell();
    
if( 23 == namespaceId && "underlineTabInNumList" == name)
    return new UnderlineTabInNumberingList();
    
if( 23 == namespaceId && "displayHangulFixedWidth" == name)
    return new DisplayHangulFixedWidth();
    
if( 23 == namespaceId && "splitPgBreakAndParaMark" == name)
    return new SplitPageBreakAndParagraphMark();
    
if( 23 == namespaceId && "doNotVertAlignCellWithSp" == name)
    return new DoNotVerticallyAlignCellWithShape();
    
if( 23 == namespaceId && "doNotBreakConstrainedForcedTable" == name)
    return new DoNotBreakConstrainedForcedTable();
    
if( 23 == namespaceId && "doNotVertAlignInTxbx" == name)
    return new DoNotVerticallyAlignInTextBox();
    
if( 23 == namespaceId && "useAnsiKerningPairs" == name)
    return new UseAnsiKerningPairs();
    
if( 23 == namespaceId && "cachedColBalance" == name)
    return new CachedColumnBalance();
    
if( 23 == namespaceId && "compatSetting" == name)
    return new CompatibilitySetting();
    

    return null;
}

        private static readonly string[] eleTagNames = { "useSingleBorderforContiguousCells","wpJustification","noTabHangInd","noLeading","spaceForUL","noColumnBalance","balanceSingleByteDoubleByteWidth","noExtraLineSpacing","doNotLeaveBackslashAlone","ulTrailSpace","doNotExpandShiftReturn","spacingInWholePoints","lineWrapLikeWord6","printBodyTextBeforeHeader","printColBlack","wpSpaceWidth","showBreaksInFrames","subFontBySize","suppressBottomSpacing","suppressTopSpacing","suppressSpacingAtTopOfPage","suppressTopSpacingWP","suppressSpBfAfterPgBrk","swapBordersFacingPages","convMailMergeEsc","truncateFontHeightsLikeWP6","mwSmallCaps","usePrinterMetrics","doNotSuppressParagraphBorders","wrapTrailSpaces","footnoteLayoutLikeWW8","shapeLayoutLikeWW8","alignTablesRowByRow","forgetLastTabAlignment","adjustLineHeightInTable","autoSpaceLikeWord95","noSpaceRaiseLower","doNotUseHTMLParagraphAutoSpacing","layoutRawTableWidth","layoutTableRowsApart","useWord97LineBreakRules","doNotBreakWrappedTables","doNotSnapToGridInCell","selectFldWithFirstOrLastChar","applyBreakingRules","doNotWrapTextWithPunct","doNotUseEastAsianBreakRules","useWord2002TableStyleRules","growAutofit","useFELayout","useNormalStyleForList","doNotUseIndentAsNumberingTabStop","useAltKinsokuLineBreakRules","allowSpaceOfSameStyleInTable","doNotSuppressIndentation","doNotAutofitConstrainedTables","autofitToFirstFixedWidthCell","underlineTabInNumList","displayHangulFixedWidth","splitPgBreakAndParaMark","doNotVertAlignCellWithSp","doNotBreakConstrainedForcedTable","doNotVertAlignInTxbx","useAnsiKerningPairs","cachedColBalance","compatSetting" };
    private static readonly byte[] eleNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Use Simplified Rules For Table Border Conflicts.</para>
    /// <para> Represents the following element tag in the schema: w:useSingleBorderforContiguousCells </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseSingleBorderForContiguousCells UseSingleBorderForContiguousCells
    {
        get 
        {
            return GetElement<UseSingleBorderForContiguousCells>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Emulate WordPerfect 6.x Paragraph Justification.</para>
    /// <para> Represents the following element tag in the schema: w:wpJustification </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordPerfectJustification WordPerfectJustification
    {
        get 
        {
            return GetElement<WordPerfectJustification>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Do Not Create Custom Tab Stop for Hanging Indent.</para>
    /// <para> Represents the following element tag in the schema: w:noTabHangInd </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoTabHangIndent NoTabHangIndent
    {
        get 
        {
            return GetElement<NoTabHangIndent>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Do Not Add Leading Between Lines of Text.</para>
    /// <para> Represents the following element tag in the schema: w:noLeading </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoLeading NoLeading
    {
        get 
        {
            return GetElement<NoLeading>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Add Additional Space Below Baseline For Underlined East Asian Text.</para>
    /// <para> Represents the following element tag in the schema: w:spaceForUL </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpaceForUnderline SpaceForUnderline
    {
        get 
        {
            return GetElement<SpaceForUnderline>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Do Not Balance Text Columns within a Section.</para>
    /// <para> Represents the following element tag in the schema: w:noColumnBalance </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoColumnBalance NoColumnBalance
    {
        get 
        {
            return GetElement<NoColumnBalance>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Balance Single Byte and Double Byte Characters.</para>
    /// <para> Represents the following element tag in the schema: w:balanceSingleByteDoubleByteWidth </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public BalanceSingleByteDoubleByteWidth BalanceSingleByteDoubleByteWidth
    {
        get 
        {
            return GetElement<BalanceSingleByteDoubleByteWidth>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Do Not Center Content on Lines With Exact Line Height.</para>
    /// <para> Represents the following element tag in the schema: w:noExtraLineSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoExtraLineSpacing NoExtraLineSpacing
    {
        get 
        {
            return GetElement<NoExtraLineSpacing>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Convert Backslash To Yen Sign When Entered.</para>
    /// <para> Represents the following element tag in the schema: w:doNotLeaveBackslashAlone </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotLeaveBackslashAlone DoNotLeaveBackslashAlone
    {
        get 
        {
            return GetElement<DoNotLeaveBackslashAlone>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Underline All Trailing Spaces.</para>
    /// <para> Represents the following element tag in the schema: w:ulTrailSpace </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UnderlineTrailingSpaces UnderlineTrailingSpaces
    {
        get 
        {
            return GetElement<UnderlineTrailingSpaces>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Don't Justify Lines Ending in Soft Line Break.</para>
    /// <para> Represents the following element tag in the schema: w:doNotExpandShiftReturn </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotExpandShiftReturn DoNotExpandShiftReturn
    {
        get 
        {
            return GetElement<DoNotExpandShiftReturn>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Only Expand/Condense Text By Whole Points.</para>
    /// <para> Represents the following element tag in the schema: w:spacingInWholePoints </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SpacingInWholePoints SpacingInWholePoints
    {
        get 
        {
            return GetElement<SpacingInWholePoints>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 6.0 Line Wrapping for East Asian Text.</para>
    /// <para> Represents the following element tag in the schema: w:lineWrapLikeWord6 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LineWrapLikeWord6 LineWrapLikeWord6
    {
        get 
        {
            return GetElement<LineWrapLikeWord6>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Print Body Text before Header/Footer Contents.</para>
    /// <para> Represents the following element tag in the schema: w:printBodyTextBeforeHeader </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrintBodyTextBeforeHeader PrintBodyTextBeforeHeader
    {
        get 
        {
            return GetElement<PrintBodyTextBeforeHeader>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> Print Colors as Black And White without Dithering.</para>
    /// <para> Represents the following element tag in the schema: w:printColBlack </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public PrintColorBlackWhite PrintColorBlackWhite
    {
        get 
        {
            return GetElement<PrintColorBlackWhite>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Space width.</para>
    /// <para> Represents the following element tag in the schema: w:wpSpaceWidth </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WordPerfectSpaceWidth WordPerfectSpaceWidth
    {
        get 
        {
            return GetElement<WordPerfectSpaceWidth>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> Display Page/Column Breaks Present in Frames.</para>
    /// <para> Represents the following element tag in the schema: w:showBreaksInFrames </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ShowBreaksInFrames ShowBreaksInFrames
    {
        get 
        {
            return GetElement<ShowBreaksInFrames>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }
    /// <summary>
    /// <para> Increase Priority Of Font Size During Font Substitution.</para>
    /// <para> Represents the following element tag in the schema: w:subFontBySize </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SubFontBySize SubFontBySize
    {
        get 
        {
            return GetElement<SubFontBySize>(17);
        }
        set
        {
            SetElement(17, value);
        }
    }
    /// <summary>
    /// <para> Ignore Exact Line Height for Last Line on Page.</para>
    /// <para> Represents the following element tag in the schema: w:suppressBottomSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressBottomSpacing SuppressBottomSpacing
    {
        get 
        {
            return GetElement<SuppressBottomSpacing>(18);
        }
        set
        {
            SetElement(18, value);
        }
    }
    /// <summary>
    /// <para> Ignore Minimum and Exact Line Height for First Line on Page.</para>
    /// <para> Represents the following element tag in the schema: w:suppressTopSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressTopSpacing SuppressTopSpacing
    {
        get 
        {
            return GetElement<SuppressTopSpacing>(19);
        }
        set
        {
            SetElement(19, value);
        }
    }
    /// <summary>
    /// <para> Ignore Minimum Line Height for First Line on Page.</para>
    /// <para> Represents the following element tag in the schema: w:suppressSpacingAtTopOfPage </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressSpacingAtTopOfPage SuppressSpacingAtTopOfPage
    {
        get 
        {
            return GetElement<SuppressSpacingAtTopOfPage>(20);
        }
        set
        {
            SetElement(20, value);
        }
    }
    /// <summary>
    /// <para> Emulate WordPerfect 5.x Line Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:suppressTopSpacingWP </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressTopSpacingWordPerfect SuppressTopSpacingWordPerfect
    {
        get 
        {
            return GetElement<SuppressTopSpacingWordPerfect>(21);
        }
        set
        {
            SetElement(21, value);
        }
    }
    /// <summary>
    /// <para> Do Not Use Space Before On First Line After a Page Break.</para>
    /// <para> Represents the following element tag in the schema: w:suppressSpBfAfterPgBrk </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SuppressSpacingBeforeAfterPageBreak SuppressSpacingBeforeAfterPageBreak
    {
        get 
        {
            return GetElement<SuppressSpacingBeforeAfterPageBreak>(22);
        }
        set
        {
            SetElement(22, value);
        }
    }
    /// <summary>
    /// <para> Swap Paragraph Borders on Odd Numbered Pages.</para>
    /// <para> Represents the following element tag in the schema: w:swapBordersFacingPages </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SwapBordersFacingPages SwapBordersFacingPages
    {
        get 
        {
            return GetElement<SwapBordersFacingPages>(23);
        }
        set
        {
            SetElement(23, value);
        }
    }
    /// <summary>
    /// <para> Treat Backslash Quotation Delimiter as Two Quotation Marks.</para>
    /// <para> Represents the following element tag in the schema: w:convMailMergeEsc </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ConvertMailMergeEscape ConvertMailMergeEscape
    {
        get 
        {
            return GetElement<ConvertMailMergeEscape>(24);
        }
        set
        {
            SetElement(24, value);
        }
    }
    /// <summary>
    /// <para> Emulate WordPerfect 6.x Font Height Calculation.</para>
    /// <para> Represents the following element tag in the schema: w:truncateFontHeightsLikeWP6 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public TruncateFontHeightsLikeWordPerfect TruncateFontHeightsLikeWordPerfect
    {
        get 
        {
            return GetElement<TruncateFontHeightsLikeWordPerfect>(25);
        }
        set
        {
            SetElement(25, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 5.x for the Macintosh Small Caps Formatting.</para>
    /// <para> Represents the following element tag in the schema: w:mwSmallCaps </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public MacWordSmallCaps MacWordSmallCaps
    {
        get 
        {
            return GetElement<MacWordSmallCaps>(26);
        }
        set
        {
            SetElement(26, value);
        }
    }
    /// <summary>
    /// <para> Use Printer Metrics To Display Documents.</para>
    /// <para> Represents the following element tag in the schema: w:usePrinterMetrics </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UsePrinterMetrics UsePrinterMetrics
    {
        get 
        {
            return GetElement<UsePrinterMetrics>(27);
        }
        set
        {
            SetElement(27, value);
        }
    }
    /// <summary>
    /// <para> Do Not Suppress Paragraph Borders Next To Frames.</para>
    /// <para> Represents the following element tag in the schema: w:doNotSuppressParagraphBorders </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotSuppressParagraphBorders DoNotSuppressParagraphBorders
    {
        get 
        {
            return GetElement<DoNotSuppressParagraphBorders>(28);
        }
        set
        {
            SetElement(28, value);
        }
    }
    /// <summary>
    /// <para> Line Wrap Trailing Spaces.</para>
    /// <para> Represents the following element tag in the schema: w:wrapTrailSpaces </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public WrapTrailSpaces WrapTrailSpaces
    {
        get 
        {
            return GetElement<WrapTrailSpaces>(29);
        }
        set
        {
            SetElement(29, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 6.x/95/97 Footnote Placement.</para>
    /// <para> Represents the following element tag in the schema: w:footnoteLayoutLikeWW8 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public FootnoteLayoutLikeWord8 FootnoteLayoutLikeWord8
    {
        get 
        {
            return GetElement<FootnoteLayoutLikeWord8>(30);
        }
        set
        {
            SetElement(30, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 97 Text Wrapping Around Floating Objects.</para>
    /// <para> Represents the following element tag in the schema: w:shapeLayoutLikeWW8 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ShapeLayoutLikeWord8 ShapeLayoutLikeWord8
    {
        get 
        {
            return GetElement<ShapeLayoutLikeWord8>(31);
        }
        set
        {
            SetElement(31, value);
        }
    }
    /// <summary>
    /// <para> Align Table Rows Independently.</para>
    /// <para> Represents the following element tag in the schema: w:alignTablesRowByRow </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AlignTablesRowByRow AlignTablesRowByRow
    {
        get 
        {
            return GetElement<AlignTablesRowByRow>(32);
        }
        set
        {
            SetElement(32, value);
        }
    }
    /// <summary>
    /// <para> Ignore Width of Last Tab Stop When Aligning Paragraph If It Is Not Left Aligned.</para>
    /// <para> Represents the following element tag in the schema: w:forgetLastTabAlignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ForgetLastTabAlignment ForgetLastTabAlignment
    {
        get 
        {
            return GetElement<ForgetLastTabAlignment>(33);
        }
        set
        {
            SetElement(33, value);
        }
    }
    /// <summary>
    /// <para> Add Document Grid Line Pitch To Lines in Table Cells.</para>
    /// <para> Represents the following element tag in the schema: w:adjustLineHeightInTable </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AdjustLineHeightInTable AdjustLineHeightInTable
    {
        get 
        {
            return GetElement<AdjustLineHeightInTable>(34);
        }
        set
        {
            SetElement(34, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 95 Full-Width Character Spacing.</para>
    /// <para> Represents the following element tag in the schema: w:autoSpaceLikeWord95 </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutoSpaceLikeWord95 AutoSpaceLikeWord95
    {
        get 
        {
            return GetElement<AutoSpaceLikeWord95>(35);
        }
        set
        {
            SetElement(35, value);
        }
    }
    /// <summary>
    /// <para> Do Not Increase Line Height for Raised/Lowered Text.</para>
    /// <para> Represents the following element tag in the schema: w:noSpaceRaiseLower </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public NoSpaceRaiseLower NoSpaceRaiseLower
    {
        get 
        {
            return GetElement<NoSpaceRaiseLower>(36);
        }
        set
        {
            SetElement(36, value);
        }
    }
    /// <summary>
    /// <para> Use Fixed Paragraph Spacing for HTML Auto Setting.</para>
    /// <para> Represents the following element tag in the schema: w:doNotUseHTMLParagraphAutoSpacing </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotUseHTMLParagraphAutoSpacing DoNotUseHTMLParagraphAutoSpacing
    {
        get 
        {
            return GetElement<DoNotUseHTMLParagraphAutoSpacing>(37);
        }
        set
        {
            SetElement(37, value);
        }
    }
    /// <summary>
    /// <para> Ignore Space Before Table When Deciding If Table Should Wrap Floating Object.</para>
    /// <para> Represents the following element tag in the schema: w:layoutRawTableWidth </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LayoutRawTableWidth LayoutRawTableWidth
    {
        get 
        {
            return GetElement<LayoutRawTableWidth>(38);
        }
        set
        {
            SetElement(38, value);
        }
    }
    /// <summary>
    /// <para> Allow Table Rows to Wrap Inline Objects Independently.</para>
    /// <para> Represents the following element tag in the schema: w:layoutTableRowsApart </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public LayoutTableRowsApart LayoutTableRowsApart
    {
        get 
        {
            return GetElement<LayoutTableRowsApart>(39);
        }
        set
        {
            SetElement(39, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 97 East Asian Line Breaking.</para>
    /// <para> Represents the following element tag in the schema: w:useWord97LineBreakRules </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseWord97LineBreakRules UseWord97LineBreakRules
    {
        get 
        {
            return GetElement<UseWord97LineBreakRules>(40);
        }
        set
        {
            SetElement(40, value);
        }
    }
    /// <summary>
    /// <para> Do Not Allow Floating Tables To Break Across Pages.</para>
    /// <para> Represents the following element tag in the schema: w:doNotBreakWrappedTables </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotBreakWrappedTables DoNotBreakWrappedTables
    {
        get 
        {
            return GetElement<DoNotBreakWrappedTables>(41);
        }
        set
        {
            SetElement(41, value);
        }
    }
    /// <summary>
    /// <para> Do Not Snap to Document Grid in Table Cells with Objects.</para>
    /// <para> Represents the following element tag in the schema: w:doNotSnapToGridInCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotSnapToGridInCell DoNotSnapToGridInCell
    {
        get 
        {
            return GetElement<DoNotSnapToGridInCell>(42);
        }
        set
        {
            SetElement(42, value);
        }
    }
    /// <summary>
    /// <para> Select Field When First or Last Character Is Selected.</para>
    /// <para> Represents the following element tag in the schema: w:selectFldWithFirstOrLastChar </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SelectFieldWithFirstOrLastChar SelectFieldWithFirstOrLastChar
    {
        get 
        {
            return GetElement<SelectFieldWithFirstOrLastChar>(43);
        }
        set
        {
            SetElement(43, value);
        }
    }
    /// <summary>
    /// <para> Use Legacy Ethiopic and Amharic Line Breaking Rules.</para>
    /// <para> Represents the following element tag in the schema: w:applyBreakingRules </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public ApplyBreakingRules ApplyBreakingRules
    {
        get 
        {
            return GetElement<ApplyBreakingRules>(44);
        }
        set
        {
            SetElement(44, value);
        }
    }
    /// <summary>
    /// <para> Do Not Allow Hanging Punctuation With Character Grid.</para>
    /// <para> Represents the following element tag in the schema: w:doNotWrapTextWithPunct </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotWrapTextWithPunctuation DoNotWrapTextWithPunctuation
    {
        get 
        {
            return GetElement<DoNotWrapTextWithPunctuation>(45);
        }
        set
        {
            SetElement(45, value);
        }
    }
    /// <summary>
    /// <para> Do Not Compress Compressible Characters When Using Document Grid.</para>
    /// <para> Represents the following element tag in the schema: w:doNotUseEastAsianBreakRules </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotUseEastAsianBreakRules DoNotUseEastAsianBreakRules
    {
        get 
        {
            return GetElement<DoNotUseEastAsianBreakRules>(46);
        }
        set
        {
            SetElement(46, value);
        }
    }
    /// <summary>
    /// <para> Emulate Word 2002 Table Style Rules.</para>
    /// <para> Represents the following element tag in the schema: w:useWord2002TableStyleRules </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseWord2002TableStyleRules UseWord2002TableStyleRules
    {
        get 
        {
            return GetElement<UseWord2002TableStyleRules>(47);
        }
        set
        {
            SetElement(47, value);
        }
    }
    /// <summary>
    /// <para> Allow Tables to AutoFit Into Page Margins.</para>
    /// <para> Represents the following element tag in the schema: w:growAutofit </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public GrowAutofit GrowAutofit
    {
        get 
        {
            return GetElement<GrowAutofit>(48);
        }
        set
        {
            SetElement(48, value);
        }
    }
    /// <summary>
    /// <para> Do Not Bypass East Asian/Complex Script Layout Code.</para>
    /// <para> Represents the following element tag in the schema: w:useFELayout </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseFarEastLayout UseFarEastLayout
    {
        get 
        {
            return GetElement<UseFarEastLayout>(49);
        }
        set
        {
            SetElement(49, value);
        }
    }
    /// <summary>
    /// <para> Do Not Automatically Apply List Paragraph Style To Bulleted/Numbered Text.</para>
    /// <para> Represents the following element tag in the schema: w:useNormalStyleForList </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseNormalStyleForList UseNormalStyleForList
    {
        get 
        {
            return GetElement<UseNormalStyleForList>(50);
        }
        set
        {
            SetElement(50, value);
        }
    }
    /// <summary>
    /// <para> Ignore Hanging Indent When Creating Tab Stop After Numbering.</para>
    /// <para> Represents the following element tag in the schema: w:doNotUseIndentAsNumberingTabStop </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotUseIndentAsNumberingTabStop DoNotUseIndentAsNumberingTabStop
    {
        get 
        {
            return GetElement<DoNotUseIndentAsNumberingTabStop>(51);
        }
        set
        {
            SetElement(51, value);
        }
    }
    /// <summary>
    /// <para> Use Alternate Set of East Asian Line Breaking Rules.</para>
    /// <para> Represents the following element tag in the schema: w:useAltKinsokuLineBreakRules </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseAltKinsokuLineBreakRules UseAltKinsokuLineBreakRules
    {
        get 
        {
            return GetElement<UseAltKinsokuLineBreakRules>(52);
        }
        set
        {
            SetElement(52, value);
        }
    }
    /// <summary>
    /// <para> Allow Contextual Spacing of Paragraphs in Tables.</para>
    /// <para> Represents the following element tag in the schema: w:allowSpaceOfSameStyleInTable </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AllowSpaceOfSameStyleInTable AllowSpaceOfSameStyleInTable
    {
        get 
        {
            return GetElement<AllowSpaceOfSameStyleInTable>(53);
        }
        set
        {
            SetElement(53, value);
        }
    }
    /// <summary>
    /// <para> Do Not Ignore Floating Objects When Calculating Paragraph Indentation.</para>
    /// <para> Represents the following element tag in the schema: w:doNotSuppressIndentation </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotSuppressIndentation DoNotSuppressIndentation
    {
        get 
        {
            return GetElement<DoNotSuppressIndentation>(54);
        }
        set
        {
            SetElement(54, value);
        }
    }
    /// <summary>
    /// <para> Do Not AutoFit Tables To Fit Next To Wrapped Objects.</para>
    /// <para> Represents the following element tag in the schema: w:doNotAutofitConstrainedTables </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotAutofitConstrainedTables DoNotAutofitConstrainedTables
    {
        get 
        {
            return GetElement<DoNotAutofitConstrainedTables>(55);
        }
        set
        {
            SetElement(55, value);
        }
    }
    /// <summary>
    /// <para> Allow Table Columns To Exceed Preferred Widths of Constituent Cells.</para>
    /// <para> Represents the following element tag in the schema: w:autofitToFirstFixedWidthCell </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public AutofitToFirstFixedWidthCell AutofitToFirstFixedWidthCell
    {
        get 
        {
            return GetElement<AutofitToFirstFixedWidthCell>(56);
        }
        set
        {
            SetElement(56, value);
        }
    }
    /// <summary>
    /// <para> Underline Following Character Following Numbering.</para>
    /// <para> Represents the following element tag in the schema: w:underlineTabInNumList </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UnderlineTabInNumberingList UnderlineTabInNumberingList
    {
        get 
        {
            return GetElement<UnderlineTabInNumberingList>(57);
        }
        set
        {
            SetElement(57, value);
        }
    }
    /// <summary>
    /// <para> Always Use Fixed Width for Hangul Characters.</para>
    /// <para> Represents the following element tag in the schema: w:displayHangulFixedWidth </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DisplayHangulFixedWidth DisplayHangulFixedWidth
    {
        get 
        {
            return GetElement<DisplayHangulFixedWidth>(58);
        }
        set
        {
            SetElement(58, value);
        }
    }
    /// <summary>
    /// <para> Always Move Paragraph Mark to Page after a Page Break.</para>
    /// <para> Represents the following element tag in the schema: w:splitPgBreakAndParaMark </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public SplitPageBreakAndParagraphMark SplitPageBreakAndParagraphMark
    {
        get 
        {
            return GetElement<SplitPageBreakAndParagraphMark>(59);
        }
        set
        {
            SetElement(59, value);
        }
    }
    /// <summary>
    /// <para> Don't Vertically Align Cells Containing Floating Objects.</para>
    /// <para> Represents the following element tag in the schema: w:doNotVertAlignCellWithSp </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotVerticallyAlignCellWithShape DoNotVerticallyAlignCellWithShape
    {
        get 
        {
            return GetElement<DoNotVerticallyAlignCellWithShape>(60);
        }
        set
        {
            SetElement(60, value);
        }
    }
    /// <summary>
    /// <para> Don't Break Table Rows Around Floating Tables.</para>
    /// <para> Represents the following element tag in the schema: w:doNotBreakConstrainedForcedTable </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotBreakConstrainedForcedTable DoNotBreakConstrainedForcedTable
    {
        get 
        {
            return GetElement<DoNotBreakConstrainedForcedTable>(61);
        }
        set
        {
            SetElement(61, value);
        }
    }
    /// <summary>
    /// <para> Ignore Vertical Alignment in Textboxes.</para>
    /// <para> Represents the following element tag in the schema: w:doNotVertAlignInTxbx </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public DoNotVerticallyAlignInTextBox DoNotVerticallyAlignInTextBox
    {
        get 
        {
            return GetElement<DoNotVerticallyAlignInTextBox>(62);
        }
        set
        {
            SetElement(62, value);
        }
    }
    /// <summary>
    /// <para> Use ANSI Kerning Pairs from Fonts.</para>
    /// <para> Represents the following element tag in the schema: w:useAnsiKerningPairs </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public UseAnsiKerningPairs UseAnsiKerningPairs
    {
        get 
        {
            return GetElement<UseAnsiKerningPairs>(63);
        }
        set
        {
            SetElement(63, value);
        }
    }
    /// <summary>
    /// <para> Use Cached Paragraph Information for Column Balancing.</para>
    /// <para> Represents the following element tag in the schema: w:cachedColBalance </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public CachedColumnBalance CachedColumnBalance
    {
        get 
        {
            return GetElement<CachedColumnBalance>(64);
        }
        set
        {
            SetElement(64, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Compatibility>(deep);
    }

   
}
/// <summary>
/// <para>Document Variables.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:docVars.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentVariable &lt;w:docVar></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentVariable))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DocumentVariables : OpenXmlCompositeElement
{
    private const string tagName = "docVars";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12184;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DocumentVariables class.
    /// </summary>
    public DocumentVariables():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DocumentVariables class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocumentVariables(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DocumentVariables class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DocumentVariables(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DocumentVariables class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DocumentVariables(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "docVar" == name)
    return new DocumentVariable();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DocumentVariables>(deep);
    }

   
}
/// <summary>
/// <para>Listing of All Revision Save ID Values.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:rsids.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RsidRoot &lt;w:rsidRoot></description></item>
///<item><description>Rsid &lt;w:rsid></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RsidRoot))]
    [ChildElementInfo(typeof(Rsid))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Rsids : OpenXmlCompositeElement
{
    private const string tagName = "rsids";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12185;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Rsids class.
    /// </summary>
    public Rsids():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Rsids class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Rsids(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Rsids class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Rsids(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Rsids class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Rsids(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "rsidRoot" == name)
    return new RsidRoot();
    
if( 23 == namespaceId && "rsid" == name)
    return new Rsid();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rsidRoot","rsid" };
    private static readonly byte[] eleNamespaceIds = { 23,23 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Original Document Revision Save ID.</para>
    /// <para> Represents the following element tag in the schema: w:rsidRoot </para>
    /// </summary>
    /// <remark>
    /// xmlns:w = http://schemas.openxmlformats.org/wordprocessingml/2006/main
    /// </remark>
    public RsidRoot RsidRoot
    {
        get 
        {
            return GetElement<RsidRoot>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Rsids>(deep);
    }

   
}
/// <summary>
/// <para>Theme Color Mappings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:clrSchemeMapping.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorSchemeMapping : OpenXmlLeafElement
{
    private const string tagName = "clrSchemeMapping";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12189;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "bg1","t1","bg2","t2","accent1","accent2","accent3","accent4","accent5","accent6","hyperlink","followedHyperlink" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23,23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Background 1 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:bg1 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "bg1")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Background1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Text 1 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:t1 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "t1")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Text1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Background 2 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:bg2 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "bg2")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Background2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Text 2 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:t2 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "t2")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Text2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Accent 1 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent1 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent1")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent1
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Accent 2 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent2 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent2")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent2
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Accent3 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent3 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent3")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent3
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Accent4 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent4 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent4")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent4
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Accent5 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent5 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent5")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent5
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Accent6 Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:accent6 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "accent6")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Accent6
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Hyperlink Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:hyperlink </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "hyperlink")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> Hyperlink
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Followed Hyperlink Theme Color Mapping.</para>
    /// <para>Represents the following attribute in the schema: w:followedHyperlink </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "followedHyperlink")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues> FollowedHyperlink
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorSchemeMapping class.
    /// </summary>
    public ColorSchemeMapping():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "bg1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "t1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "bg2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "t2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent1" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent2" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent3" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent4" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent5" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "accent6" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "hyperlink" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    
if( 23 == namespaceId && "followedHyperlink" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.ColorSchemeIndexValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorSchemeMapping>(deep);
    }

   
}
/// <summary>
/// <para>Caption Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:captions.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Caption &lt;w:caption></description></item>
///<item><description>AutoCaptions &lt;w:autoCaptions></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Caption))]
    [ChildElementInfo(typeof(AutoCaptions))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Captions : OpenXmlCompositeElement
{
    private const string tagName = "captions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12193;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Captions class.
    /// </summary>
    public Captions():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Captions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Captions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Captions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Captions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Captions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Captions(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "caption" == name)
    return new Caption();
    
if( 23 == namespaceId && "autoCaptions" == name)
    return new AutoCaptions();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Captions>(deep);
    }

   
}
/// <summary>
/// <para>Freeze Document Layout.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:readModeInkLockDown.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ReadModeInkLockDown : OpenXmlLeafElement
{
    private const string tagName = "readModeInkLockDown";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12194;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "actualPg","w","h","fontSz" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Use Actual Pages, Not Virtual Pages.</para>
    /// <para>Represents the following attribute in the schema: w:actualPg </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "actualPg")]
    public OnOffValue UseActualPages
    {
        get { return (OnOffValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Virtual Page Width.</para>
    /// <para>Represents the following attribute in the schema: w:w </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "w")]
    public UInt32Value Width
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Virtual Page Height.</para>
    /// <para>Represents the following attribute in the schema: w:h </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "h")]
    public UInt32Value Height
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Font Size Scaling.</para>
    /// <para>Represents the following attribute in the schema: w:fontSz </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fontSz")]
    public StringValue FontSize
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ReadModeInkLockDown class.
    /// </summary>
    public ReadModeInkLockDown():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "actualPg" == name)
    return new OnOffValue();
    
if( 23 == namespaceId && "w" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "h" == name)
    return new UInt32Value();
    
if( 23 == namespaceId && "fontSz" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ReadModeInkLockDown>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TargetScreenSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:targetScreenSz.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TargetScreenSize : OpenXmlLeafElement
{
    private const string tagName = "targetScreenSz";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12208;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Target Screen Size Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.TargetScreenSizeValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.TargetScreenSizeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TargetScreenSize class.
    /// </summary>
    public TargetScreenSize():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.TargetScreenSizeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TargetScreenSize>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PictureBulletBase Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pict.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Vml.Group &lt;v:group></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.ImageFile &lt;v:image></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Line &lt;v:line></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Oval &lt;v:oval></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.PolyLine &lt;v:polyline></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Rectangle &lt;v:rect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.RoundRectangle &lt;v:roundrect></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shape &lt;v:shape></description></item>
///<item><description>DocumentFormat.OpenXml.Vml.Shapetype &lt;v:shapetype></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Group))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.ImageFile))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Line))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Oval))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.PolyLine))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Rectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.RoundRectangle))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shape))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Vml.Shapetype))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PictureBulletBase : OpenXmlCompositeElement
{
    private const string tagName = "pict";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12209;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PictureBulletBase class.
    /// </summary>
    public PictureBulletBase():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PictureBulletBase class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureBulletBase(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureBulletBase class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PictureBulletBase(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PictureBulletBase class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PictureBulletBase(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 26 == namespaceId && "group" == name)
    return new DocumentFormat.OpenXml.Vml.Group();
    
if( 26 == namespaceId && "image" == name)
    return new DocumentFormat.OpenXml.Vml.ImageFile();
    
if( 26 == namespaceId && "line" == name)
    return new DocumentFormat.OpenXml.Vml.Line();
    
if( 26 == namespaceId && "oval" == name)
    return new DocumentFormat.OpenXml.Vml.Oval();
    
if( 26 == namespaceId && "polyline" == name)
    return new DocumentFormat.OpenXml.Vml.PolyLine();
    
if( 26 == namespaceId && "rect" == name)
    return new DocumentFormat.OpenXml.Vml.Rectangle();
    
if( 26 == namespaceId && "roundrect" == name)
    return new DocumentFormat.OpenXml.Vml.RoundRectangle();
    
if( 26 == namespaceId && "shape" == name)
    return new DocumentFormat.OpenXml.Vml.Shape();
    
if( 26 == namespaceId && "shapetype" == name)
    return new DocumentFormat.OpenXml.Vml.Shapetype();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PictureBulletBase>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Panose1Number Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:panose1.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Panose1Number : OpenXmlLeafElement
{
    private const string tagName = "panose1";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12211;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public HexBinaryValue Val
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Panose1Number class.
    /// </summary>
    public Panose1Number():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Panose1Number>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FontCharSet Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:charset.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontCharSet : OpenXmlLeafElement
{
    private const string tagName = "charset";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12212;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val","characterSet" };
    private static byte[] attributeNamespaceIds = { 23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> val.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> characterSet.</para>
    /// <para>Represents the following attribute in the schema: w:characterSet </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "characterSet")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.StrictCharacterSet> StrictCharacterSet
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.StrictCharacterSet>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontCharSet class.
    /// </summary>
    public FontCharSet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new StringValue();
    
if( 23 == namespaceId && "characterSet" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.StrictCharacterSet>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontCharSet>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FontFamily Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:family.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontFamily : OpenXmlLeafElement
{
    private const string tagName = "family";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12213;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Family Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontFamilyValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontFamilyValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontFamily class.
    /// </summary>
    public FontFamily():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontFamilyValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontFamily>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Pitch Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:pitch.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Pitch : OpenXmlLeafElement
{
    private const string tagName = "pitch";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12215;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: w:val </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "val")]
    public EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontPitchValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontPitchValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Pitch class.
    /// </summary>
    public Pitch():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Wordprocessing.FontPitchValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Pitch>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FontSignature Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:sig.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontSignature : OpenXmlLeafElement
{
    private const string tagName = "sig";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12216;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "usb0","usb1","usb2","usb3","csb0","csb1" };
    private static byte[] attributeNamespaceIds = { 23,23,23,23,23,23 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> First 32 Bits of Unicode Subset Bitfield.</para>
    /// <para>Represents the following attribute in the schema: w:usb0 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "usb0")]
    public HexBinaryValue UnicodeSignature0
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Second 32 Bits of Unicode Subset Bitfield.</para>
    /// <para>Represents the following attribute in the schema: w:usb1 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "usb1")]
    public HexBinaryValue UnicodeSignature1
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Third 32 Bits of Unicode Subset Bitfield.</para>
    /// <para>Represents the following attribute in the schema: w:usb2 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "usb2")]
    public HexBinaryValue UnicodeSignature2
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Fourth 32 Bits of Unicode Subset Bitfield.</para>
    /// <para>Represents the following attribute in the schema: w:usb3 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "usb3")]
    public HexBinaryValue UnicodeSignature3
    {
        get { return (HexBinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Lower 32 Bits of Code Page Bit Field.</para>
    /// <para>Represents the following attribute in the schema: w:csb0 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "csb0")]
    public HexBinaryValue CodePageSignature0
    {
        get { return (HexBinaryValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Upper 32 Bits of Code Page Bit Field.</para>
    /// <para>Represents the following attribute in the schema: w:csb1 </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "csb1")]
    public HexBinaryValue CodePageSignature1
    {
        get { return (HexBinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontSignature class.
    /// </summary>
    public FontSignature():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "usb0" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "usb1" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "usb2" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "usb3" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "csb0" == name)
    return new HexBinaryValue();
    
if( 23 == namespaceId && "csb1" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontSignature>(deep);
    }

   
}
/// <summary>
/// <para>Defines the EmbedRegularFont Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedRegular.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedRegularFont : FontRelationshipType
{
    private const string tagName = "embedRegular";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12217;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedRegularFont class.
    /// </summary>
    public EmbedRegularFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedRegularFont>(deep);
    }

}
/// <summary>
/// <para>Defines the EmbedBoldFont Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedBold.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedBoldFont : FontRelationshipType
{
    private const string tagName = "embedBold";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12218;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedBoldFont class.
    /// </summary>
    public EmbedBoldFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedBoldFont>(deep);
    }

}
/// <summary>
/// <para>Defines the EmbedItalicFont Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedItalic.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedItalicFont : FontRelationshipType
{
    private const string tagName = "embedItalic";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12219;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedItalicFont class.
    /// </summary>
    public EmbedItalicFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedItalicFont>(deep);
    }

}
/// <summary>
/// <para>Defines the EmbedBoldItalicFont Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is w:embedBoldItalic.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EmbedBoldItalicFont : FontRelationshipType
{
    private const string tagName = "embedBoldItalic";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 23;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 12220;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbedBoldItalicFont class.
    /// </summary>
    public EmbedBoldItalicFont():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbedBoldItalicFont>(deep);
    }

}
/// <summary>
/// Defines the FontRelationshipType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class FontRelationshipType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "fontKey","subsetted","id" };
    private static byte[] attributeNamespaceIds = { 23,23,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> fontKey.</para>
    /// <para>Represents the following attribute in the schema: w:fontKey </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "fontKey")]
    public StringValue FontKey
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> subsetted.</para>
    /// <para>Represents the following attribute in the schema: w:subsetted </para>
    /// </summary>
///<remark> xmlns:w=http://schemas.openxmlformats.org/wordprocessingml/2006/main
///</remark>
    [SchemaAttr(23, "subsetted")]
    public OnOffValue Subsetted
    {
        get { return (OnOffValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Relationship to Part.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 23 == namespaceId && "fontKey" == name)
    return new StringValue();
    
if( 23 == namespaceId && "subsetted" == name)
    return new OnOffValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the FontRelationshipType class.
    /// </summary>
    protected FontRelationshipType(){}
    
    
    
}
/// <summary>
/// Defines the OnOffOnlyValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum OnOffOnlyValues
{  
	///<summary>
///on.
///<para>When the item is serialized out as xml, its value is "on".</para>
///</summary>
[EnumString("on")]
On,
///<summary>
///off.
///<para>When the item is serialized out as xml, its value is "off".</para>
///</summary>
[EnumString("off")]
Off,
 
}
/// <summary>
/// Defines the HighlightColorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HighlightColorValues
{  
	///<summary>
///Black Highlighting Color.
///<para>When the item is serialized out as xml, its value is "black".</para>
///</summary>
[EnumString("black")]
Black,
///<summary>
///Blue Highlighting Color.
///<para>When the item is serialized out as xml, its value is "blue".</para>
///</summary>
[EnumString("blue")]
Blue,
///<summary>
///Cyan Highlighting Color.
///<para>When the item is serialized out as xml, its value is "cyan".</para>
///</summary>
[EnumString("cyan")]
Cyan,
///<summary>
///Green Highlighting Color.
///<para>When the item is serialized out as xml, its value is "green".</para>
///</summary>
[EnumString("green")]
Green,
///<summary>
///Magenta Highlighting Color.
///<para>When the item is serialized out as xml, its value is "magenta".</para>
///</summary>
[EnumString("magenta")]
Magenta,
///<summary>
///Red Highlighting Color.
///<para>When the item is serialized out as xml, its value is "red".</para>
///</summary>
[EnumString("red")]
Red,
///<summary>
///Yellow Highlighting Color.
///<para>When the item is serialized out as xml, its value is "yellow".</para>
///</summary>
[EnumString("yellow")]
Yellow,
///<summary>
///White Highlighting Color.
///<para>When the item is serialized out as xml, its value is "white".</para>
///</summary>
[EnumString("white")]
White,
///<summary>
///Dark Blue Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkBlue".</para>
///</summary>
[EnumString("darkBlue")]
DarkBlue,
///<summary>
///Dark Cyan Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkCyan".</para>
///</summary>
[EnumString("darkCyan")]
DarkCyan,
///<summary>
///Dark Green Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkGreen".</para>
///</summary>
[EnumString("darkGreen")]
DarkGreen,
///<summary>
///Dark Magenta Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkMagenta".</para>
///</summary>
[EnumString("darkMagenta")]
DarkMagenta,
///<summary>
///Dark Red Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkRed".</para>
///</summary>
[EnumString("darkRed")]
DarkRed,
///<summary>
///Dark Yellow Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkYellow".</para>
///</summary>
[EnumString("darkYellow")]
DarkYellow,
///<summary>
///Dark Gray Highlighting Color.
///<para>When the item is serialized out as xml, its value is "darkGray".</para>
///</summary>
[EnumString("darkGray")]
DarkGray,
///<summary>
///Light Gray Highlighting Color.
///<para>When the item is serialized out as xml, its value is "lightGray".</para>
///</summary>
[EnumString("lightGray")]
LightGray,
///<summary>
///No Text Highlighting.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the AutomaticColorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AutomaticColorValues
{  
	///<summary>
///Automatically Determined Color.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
 
}
/// <summary>
/// Defines the UnderlineValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum UnderlineValues
{  
	///<summary>
///Single Underline.
///<para>When the item is serialized out as xml, its value is "single".</para>
///</summary>
[EnumString("single")]
Single,
///<summary>
///Underline Non-Space Characters Only.
///<para>When the item is serialized out as xml, its value is "words".</para>
///</summary>
[EnumString("words")]
Words,
///<summary>
///Double Underline.
///<para>When the item is serialized out as xml, its value is "double".</para>
///</summary>
[EnumString("double")]
Double,
///<summary>
///Thick Underline.
///<para>When the item is serialized out as xml, its value is "thick".</para>
///</summary>
[EnumString("thick")]
Thick,
///<summary>
///Dotted Underline.
///<para>When the item is serialized out as xml, its value is "dotted".</para>
///</summary>
[EnumString("dotted")]
Dotted,
///<summary>
///Thick Dotted Underline.
///<para>When the item is serialized out as xml, its value is "dottedHeavy".</para>
///</summary>
[EnumString("dottedHeavy")]
DottedHeavy,
///<summary>
///Dashed Underline.
///<para>When the item is serialized out as xml, its value is "dash".</para>
///</summary>
[EnumString("dash")]
Dash,
///<summary>
///Thick Dashed Underline.
///<para>When the item is serialized out as xml, its value is "dashedHeavy".</para>
///</summary>
[EnumString("dashedHeavy")]
DashedHeavy,
///<summary>
///Long Dashed Underline.
///<para>When the item is serialized out as xml, its value is "dashLong".</para>
///</summary>
[EnumString("dashLong")]
DashLong,
///<summary>
///Thick Long Dashed Underline.
///<para>When the item is serialized out as xml, its value is "dashLongHeavy".</para>
///</summary>
[EnumString("dashLongHeavy")]
DashLongHeavy,
///<summary>
///Dash-Dot Underline.
///<para>When the item is serialized out as xml, its value is "dotDash".</para>
///</summary>
[EnumString("dotDash")]
DotDash,
///<summary>
///Thick Dash-Dot Underline.
///<para>When the item is serialized out as xml, its value is "dashDotHeavy".</para>
///</summary>
[EnumString("dashDotHeavy")]
DashDotHeavy,
///<summary>
///Dash-Dot-Dot Underline.
///<para>When the item is serialized out as xml, its value is "dotDotDash".</para>
///</summary>
[EnumString("dotDotDash")]
DotDotDash,
///<summary>
///Thick Dash-Dot-Dot Underline.
///<para>When the item is serialized out as xml, its value is "dashDotDotHeavy".</para>
///</summary>
[EnumString("dashDotDotHeavy")]
DashDotDotHeavy,
///<summary>
///Wave Underline.
///<para>When the item is serialized out as xml, its value is "wave".</para>
///</summary>
[EnumString("wave")]
Wave,
///<summary>
///Heavy Wave Underline.
///<para>When the item is serialized out as xml, its value is "wavyHeavy".</para>
///</summary>
[EnumString("wavyHeavy")]
WavyHeavy,
///<summary>
///Double Wave Underline.
///<para>When the item is serialized out as xml, its value is "wavyDouble".</para>
///</summary>
[EnumString("wavyDouble")]
WavyDouble,
///<summary>
///No Underline.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the TextEffectValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextEffectValues
{  
	///<summary>
///Blinking Background Animation.
///<para>When the item is serialized out as xml, its value is "blinkBackground".</para>
///</summary>
[EnumString("blinkBackground")]
BlinkBackground,
///<summary>
///Colored Lights Animation.
///<para>When the item is serialized out as xml, its value is "lights".</para>
///</summary>
[EnumString("lights")]
Lights,
///<summary>
///Black Dashed Line Animation.
///<para>When the item is serialized out as xml, its value is "antsBlack".</para>
///</summary>
[EnumString("antsBlack")]
AntsBlack,
///<summary>
///Marching Red Ants.
///<para>When the item is serialized out as xml, its value is "antsRed".</para>
///</summary>
[EnumString("antsRed")]
AntsRed,
///<summary>
///Shimmer Animation.
///<para>When the item is serialized out as xml, its value is "shimmer".</para>
///</summary>
[EnumString("shimmer")]
Shimmer,
///<summary>
///Sparkling Lights Animation.
///<para>When the item is serialized out as xml, its value is "sparkle".</para>
///</summary>
[EnumString("sparkle")]
Sparkle,
///<summary>
///No Animation.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the VerticalPositionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalPositionValues
{  
	///<summary>
///Regular Vertical Positioning.
///<para>When the item is serialized out as xml, its value is "baseline".</para>
///</summary>
[EnumString("baseline")]
Baseline,
///<summary>
///Superscript.
///<para>When the item is serialized out as xml, its value is "superscript".</para>
///</summary>
[EnumString("superscript")]
Superscript,
///<summary>
///Subscript.
///<para>When the item is serialized out as xml, its value is "subscript".</para>
///</summary>
[EnumString("subscript")]
Subscript,
 
}
/// <summary>
/// Defines the EmphasisMarkValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum EmphasisMarkValues
{  
	///<summary>
///No Emphasis Mark.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Dot Emphasis Mark Above Characters.
///<para>When the item is serialized out as xml, its value is "dot".</para>
///</summary>
[EnumString("dot")]
Dot,
///<summary>
///Comma Emphasis Mark Above Characters.
///<para>When the item is serialized out as xml, its value is "comma".</para>
///</summary>
[EnumString("comma")]
Comma,
///<summary>
///Circle Emphasis Mark Above Characters.
///<para>When the item is serialized out as xml, its value is "circle".</para>
///</summary>
[EnumString("circle")]
Circle,
///<summary>
///Dot Emphasis Mark Below Characters.
///<para>When the item is serialized out as xml, its value is "underDot".</para>
///</summary>
[EnumString("underDot")]
UnderDot,
 
}
/// <summary>
/// Defines the CombineBracketValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CombineBracketValues
{  
	///<summary>
///No Enclosing Brackets.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Round Brackets.
///<para>When the item is serialized out as xml, its value is "round".</para>
///</summary>
[EnumString("round")]
Round,
///<summary>
///Square Brackets.
///<para>When the item is serialized out as xml, its value is "square".</para>
///</summary>
[EnumString("square")]
Square,
///<summary>
///Angle Brackets.
///<para>When the item is serialized out as xml, its value is "angle".</para>
///</summary>
[EnumString("angle")]
Angle,
///<summary>
///Curly Brackets.
///<para>When the item is serialized out as xml, its value is "curly".</para>
///</summary>
[EnumString("curly")]
Curly,
 
}
/// <summary>
/// Defines the HorizontalAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HorizontalAlignmentValues
{  
	///<summary>
///Left Aligned Horizontally.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Centered Horizontally.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Right Aligned Horizontally.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///Inside.
///<para>When the item is serialized out as xml, its value is "inside".</para>
///</summary>
[EnumString("inside")]
Inside,
///<summary>
///Outside.
///<para>When the item is serialized out as xml, its value is "outside".</para>
///</summary>
[EnumString("outside")]
Outside,
 
}
/// <summary>
/// Defines the VerticalAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalAlignmentValues
{  
	///<summary>
///In line With Text.
///<para>When the item is serialized out as xml, its value is "inline".</para>
///</summary>
[EnumString("inline")]
Inline,
///<summary>
///Top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///Centered Vertically.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
///<summary>
///Inside Anchor Extents.
///<para>When the item is serialized out as xml, its value is "inside".</para>
///</summary>
[EnumString("inside")]
Inside,
///<summary>
///Outside Anchor Extents.
///<para>When the item is serialized out as xml, its value is "outside".</para>
///</summary>
[EnumString("outside")]
Outside,
 
}
/// <summary>
/// Defines the HeightRuleValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HeightRuleValues
{  
	///<summary>
///Determine Height Based On Contents.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
///<summary>
///Exact Height.
///<para>When the item is serialized out as xml, its value is "exact".</para>
///</summary>
[EnumString("exact")]
Exact,
///<summary>
///Minimum Height.
///<para>When the item is serialized out as xml, its value is "atLeast".</para>
///</summary>
[EnumString("atLeast")]
AtLeast,
 
}
/// <summary>
/// Defines the TextWrappingValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextWrappingValues
{  
	///<summary>
///Default Text Wrapping Around Frame.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
///<summary>
///No Text Wrapping Beside Frame.
///<para>When the item is serialized out as xml, its value is "notBeside".</para>
///</summary>
[EnumString("notBeside")]
NotBeside,
///<summary>
///Allow Text Wrapping Around Frame.
///<para>When the item is serialized out as xml, its value is "around".</para>
///</summary>
[EnumString("around")]
Around,
///<summary>
///Tight Text Wrapping Around Frame.
///<para>When the item is serialized out as xml, its value is "tight".</para>
///</summary>
[EnumString("tight")]
Tight,
///<summary>
///Through Text Wrapping Around Frame.
///<para>When the item is serialized out as xml, its value is "through".</para>
///</summary>
[EnumString("through")]
Through,
///<summary>
///No Text Wrapping Around Frame.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the VerticalAnchorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalAnchorValues
{  
	///<summary>
///Relative To Vertical Text Extents.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///Relative To Margin.
///<para>When the item is serialized out as xml, its value is "margin".</para>
///</summary>
[EnumString("margin")]
Margin,
///<summary>
///Relative To Page.
///<para>When the item is serialized out as xml, its value is "page".</para>
///</summary>
[EnumString("page")]
Page,
 
}
/// <summary>
/// Defines the HorizontalAnchorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HorizontalAnchorValues
{  
	///<summary>
///Relative to Text Extents.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///Relative To Margin.
///<para>When the item is serialized out as xml, its value is "margin".</para>
///</summary>
[EnumString("margin")]
Margin,
///<summary>
///Relative to Page.
///<para>When the item is serialized out as xml, its value is "page".</para>
///</summary>
[EnumString("page")]
Page,
 
}
/// <summary>
/// Defines the DropCapLocationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DropCapLocationValues
{  
	///<summary>
///Not Drop Cap.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Drop Cap Inside Margin.
///<para>When the item is serialized out as xml, its value is "drop".</para>
///</summary>
[EnumString("drop")]
Drop,
///<summary>
///Drop Cap Outside Margin.
///<para>When the item is serialized out as xml, its value is "margin".</para>
///</summary>
[EnumString("margin")]
Margin,
 
}
/// <summary>
/// Defines the TabStopLeaderCharValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TabStopLeaderCharValues
{  
	///<summary>
///No tab stop leader.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Dotted leader line.
///<para>When the item is serialized out as xml, its value is "dot".</para>
///</summary>
[EnumString("dot")]
Dot,
///<summary>
///Dashed tab stop leader line.
///<para>When the item is serialized out as xml, its value is "hyphen".</para>
///</summary>
[EnumString("hyphen")]
Hyphen,
///<summary>
///Solid leader line.
///<para>When the item is serialized out as xml, its value is "underscore".</para>
///</summary>
[EnumString("underscore")]
Underscore,
///<summary>
///Heavy solid leader line.
///<para>When the item is serialized out as xml, its value is "heavy".</para>
///</summary>
[EnumString("heavy")]
Heavy,
///<summary>
///Middle dot leader line.
///<para>When the item is serialized out as xml, its value is "middleDot".</para>
///</summary>
[EnumString("middleDot")]
MiddleDot,
 
}
/// <summary>
/// Defines the LineSpacingRuleValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineSpacingRuleValues
{  
	///<summary>
///Automatically Determined Line Height.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
///<summary>
///Exact Line Height.
///<para>When the item is serialized out as xml, its value is "exact".</para>
///</summary>
[EnumString("exact")]
Exact,
///<summary>
///Minimum Line Height.
///<para>When the item is serialized out as xml, its value is "atLeast".</para>
///</summary>
[EnumString("atLeast")]
AtLeast,
 
}
/// <summary>
/// Defines the TableRowAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableRowAlignmentValues
{  
	///<summary>
///left.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///right.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
 
}
/// <summary>
/// Defines the ViewValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ViewValues
{  
	///<summary>
///Default View.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Print Layout View.
///<para>When the item is serialized out as xml, its value is "print".</para>
///</summary>
[EnumString("print")]
Print,
///<summary>
///Outline View.
///<para>When the item is serialized out as xml, its value is "outline".</para>
///</summary>
[EnumString("outline")]
Outline,
///<summary>
///Master Document View.
///<para>When the item is serialized out as xml, its value is "masterPages".</para>
///</summary>
[EnumString("masterPages")]
MasterPages,
///<summary>
///Draft View.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Web Page View.
///<para>When the item is serialized out as xml, its value is "web".</para>
///</summary>
[EnumString("web")]
Web,
 
}
/// <summary>
/// Defines the PresetZoomValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PresetZoomValues
{  
	///<summary>
///No Preset Magnification.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Display One Full Page.
///<para>When the item is serialized out as xml, its value is "fullPage".</para>
///</summary>
[EnumString("fullPage")]
FullPage,
///<summary>
///Display Page Width.
///<para>When the item is serialized out as xml, its value is "bestFit".</para>
///</summary>
[EnumString("bestFit")]
BestFit,
///<summary>
///Display Text Width.
///<para>When the item is serialized out as xml, its value is "textFit".</para>
///</summary>
[EnumString("textFit")]
TextFit,
 
}
/// <summary>
/// Defines the ProofingStateValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ProofingStateValues
{  
	///<summary>
///Check Completed.
///<para>When the item is serialized out as xml, its value is "clean".</para>
///</summary>
[EnumString("clean")]
Clean,
///<summary>
///Check Not Completed.
///<para>When the item is serialized out as xml, its value is "dirty".</para>
///</summary>
[EnumString("dirty")]
Dirty,
 
}
/// <summary>
/// Defines the DocumentTypeValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocumentTypeValues
{  
	///<summary>
///Default Document.
///<para>When the item is serialized out as xml, its value is "notSpecified".</para>
///</summary>
[EnumString("notSpecified")]
NotSpecified,
///<summary>
///Letter.
///<para>When the item is serialized out as xml, its value is "letter".</para>
///</summary>
[EnumString("letter")]
Letter,
///<summary>
///E-Mail Message.
///<para>When the item is serialized out as xml, its value is "eMail".</para>
///</summary>
[EnumString("eMail")]
Email,
 
}
/// <summary>
/// Defines the DocumentProtectionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocumentProtectionValues
{  
	///<summary>
///No Editing Restrictions.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Allow No Editing.
///<para>When the item is serialized out as xml, its value is "readOnly".</para>
///</summary>
[EnumString("readOnly")]
ReadOnly,
///<summary>
///Allow Editing of Comments.
///<para>When the item is serialized out as xml, its value is "comments".</para>
///</summary>
[EnumString("comments")]
Comments,
///<summary>
///Allow Editing With Revision Tracking.
///<para>When the item is serialized out as xml, its value is "trackedChanges".</para>
///</summary>
[EnumString("trackedChanges")]
TrackedChanges,
///<summary>
///Allow Editing of Form Fields.
///<para>When the item is serialized out as xml, its value is "forms".</para>
///</summary>
[EnumString("forms")]
Forms,
 
}
/// <summary>
/// Defines the MailMergeDocumentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MailMergeDocumentValues
{  
	///<summary>
///Catalog Source Document.
///<para>When the item is serialized out as xml, its value is "catalog".</para>
///</summary>
[EnumString("catalog")]
Catalog,
///<summary>
///Envelope Source Document.
///<para>When the item is serialized out as xml, its value is "envelopes".</para>
///</summary>
[EnumString("envelopes")]
Envelope,
///<summary>
///Mailing Label Source Document.
///<para>When the item is serialized out as xml, its value is "mailingLabels".</para>
///</summary>
[EnumString("mailingLabels")]
MailingLabel,
///<summary>
///Form Letter Source Document.
///<para>When the item is serialized out as xml, its value is "formLetters".</para>
///</summary>
[EnumString("formLetters")]
FormLetter,
///<summary>
///E-Mail Source Document.
///<para>When the item is serialized out as xml, its value is "email".</para>
///</summary>
[EnumString("email")]
Email,
///<summary>
///Fax Source Document.
///<para>When the item is serialized out as xml, its value is "fax".</para>
///</summary>
[EnumString("fax")]
Fax,
 
}
/// <summary>
/// Defines the MailMergeDataValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MailMergeDataValues
{  
	///<summary>
///Text File Data Source.
///<para>When the item is serialized out as xml, its value is "textFile".</para>
///</summary>
[EnumString("textFile")]
TextFile,
///<summary>
///Database Data Source.
///<para>When the item is serialized out as xml, its value is "database".</para>
///</summary>
[EnumString("database")]
Database,
///<summary>
///Spreadsheet Data Source.
///<para>When the item is serialized out as xml, its value is "spreadsheet".</para>
///</summary>
[EnumString("spreadsheet")]
Spreadsheet,
///<summary>
///Query Data Source.
///<para>When the item is serialized out as xml, its value is "query".</para>
///</summary>
[EnumString("query")]
Query,
///<summary>
///Open Database Connectivity Data Source.
///<para>When the item is serialized out as xml, its value is "odbc".</para>
///</summary>
[EnumString("odbc")]
Odbc,
///<summary>
///Office Data Source Object Data Source.
///<para>When the item is serialized out as xml, its value is "native".</para>
///</summary>
[EnumString("native")]
Native,
 
}
/// <summary>
/// Defines the MailMergeDestinationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MailMergeDestinationValues
{  
	///<summary>
///Send Merged Documents to New Documents.
///<para>When the item is serialized out as xml, its value is "newDocument".</para>
///</summary>
[EnumString("newDocument")]
NewDocument,
///<summary>
///Send Merged Documents to Printer.
///<para>When the item is serialized out as xml, its value is "printer".</para>
///</summary>
[EnumString("printer")]
Printer,
///<summary>
///Send Merged Documents as E-mail Messages.
///<para>When the item is serialized out as xml, its value is "email".</para>
///</summary>
[EnumString("email")]
Email,
///<summary>
///Send Merged Documents as Faxes.
///<para>When the item is serialized out as xml, its value is "fax".</para>
///</summary>
[EnumString("fax")]
Fax,
 
}
/// <summary>
/// Defines the MailMergeOdsoFieldValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MailMergeOdsoFieldValues
{  
	///<summary>
///Field Not Mapped.
///<para>When the item is serialized out as xml, its value is "null".</para>
///</summary>
[EnumString("null")]
Null,
///<summary>
///Field Mapping to Data Source Column.
///<para>When the item is serialized out as xml, its value is "dbColumn".</para>
///</summary>
[EnumString("dbColumn")]
DbColumn,
 
}
/// <summary>
/// Defines the VerticalTextAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalTextAlignmentValues
{  
	///<summary>
///Align Text at Top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///Align Text at Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Align Text at Baseline.
///<para>When the item is serialized out as xml, its value is "baseline".</para>
///</summary>
[EnumString("baseline")]
Baseline,
///<summary>
///Align Text at Bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
///<summary>
///Automatically Determine Alignment.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
 
}
/// <summary>
/// Defines the DisplacedByCustomXmlValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DisplacedByCustomXmlValues
{  
	///<summary>
///Displaced by Next Custom XML Markup Tag.
///<para>When the item is serialized out as xml, its value is "next".</para>
///</summary>
[EnumString("next")]
Next,
///<summary>
///Displaced by Previous Custom XML Markup Tag.
///<para>When the item is serialized out as xml, its value is "prev".</para>
///</summary>
[EnumString("prev")]
Previous,
 
}
/// <summary>
/// Defines the VerticalMergeRevisionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalMergeRevisionValues
{  
	///<summary>
///Vertically Merged Cell.
///<para>When the item is serialized out as xml, its value is "cont".</para>
///</summary>
[EnumString("cont")]
Continue,
///<summary>
///Vertically Split Cell.
///<para>When the item is serialized out as xml, its value is "rest".</para>
///</summary>
[EnumString("rest")]
Restart,
 
}
/// <summary>
/// Defines the TextBoxTightWrapValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextBoxTightWrapValues
{  
	///<summary>
///Do Not Tight Wrap.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Tight Wrap All Lines.
///<para>When the item is serialized out as xml, its value is "allLines".</para>
///</summary>
[EnumString("allLines")]
AllLines,
///<summary>
///Tight Wrap First and Last Lines.
///<para>When the item is serialized out as xml, its value is "firstAndLastLine".</para>
///</summary>
[EnumString("firstAndLastLine")]
FirstAndLastLine,
///<summary>
///Tight Wrap First Line.
///<para>When the item is serialized out as xml, its value is "firstLineOnly".</para>
///</summary>
[EnumString("firstLineOnly")]
FirstLineOnly,
///<summary>
///Tight Wrap Last Line.
///<para>When the item is serialized out as xml, its value is "lastLineOnly".</para>
///</summary>
[EnumString("lastLineOnly")]
LastLineOnly,
 
}
/// <summary>
/// Defines the FieldCharValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FieldCharValues
{  
	///<summary>
///Start Character.
///<para>When the item is serialized out as xml, its value is "begin".</para>
///</summary>
[EnumString("begin")]
Begin,
///<summary>
///Separator Character.
///<para>When the item is serialized out as xml, its value is "separate".</para>
///</summary>
[EnumString("separate")]
Separate,
///<summary>
///End Character.
///<para>When the item is serialized out as xml, its value is "end".</para>
///</summary>
[EnumString("end")]
End,
 
}
/// <summary>
/// Defines the InfoTextValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum InfoTextValues
{  
	///<summary>
///Literal Text.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///Glossary Document Entry.
///<para>When the item is serialized out as xml, its value is "autoText".</para>
///</summary>
[EnumString("autoText")]
AutoText,
 
}
/// <summary>
/// Defines the TextBoxFormFieldValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextBoxFormFieldValues
{  
	///<summary>
///Text Box.
///<para>When the item is serialized out as xml, its value is "regular".</para>
///</summary>
[EnumString("regular")]
Regular,
///<summary>
///Number.
///<para>When the item is serialized out as xml, its value is "number".</para>
///</summary>
[EnumString("number")]
Number,
///<summary>
///Date.
///<para>When the item is serialized out as xml, its value is "date".</para>
///</summary>
[EnumString("date")]
Date,
///<summary>
///Current Time Display.
///<para>When the item is serialized out as xml, its value is "currentTime".</para>
///</summary>
[EnumString("currentTime")]
CurrentTime,
///<summary>
///Current Date Display.
///<para>When the item is serialized out as xml, its value is "currentDate".</para>
///</summary>
[EnumString("currentDate")]
CurrentDate,
///<summary>
///Field Calculation.
///<para>When the item is serialized out as xml, its value is "calculated".</para>
///</summary>
[EnumString("calculated")]
Calculated,
 
}
/// <summary>
/// Defines the SectionMarkValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SectionMarkValues
{  
	///<summary>
///Next Page Section Break.
///<para>When the item is serialized out as xml, its value is "nextPage".</para>
///</summary>
[EnumString("nextPage")]
NextPage,
///<summary>
///Column Section Break.
///<para>When the item is serialized out as xml, its value is "nextColumn".</para>
///</summary>
[EnumString("nextColumn")]
NextColumn,
///<summary>
///Continuous Section Break.
///<para>When the item is serialized out as xml, its value is "continuous".</para>
///</summary>
[EnumString("continuous")]
Continuous,
///<summary>
///Even Page Section Break.
///<para>When the item is serialized out as xml, its value is "evenPage".</para>
///</summary>
[EnumString("evenPage")]
EvenPage,
///<summary>
///Odd Page Section Break.
///<para>When the item is serialized out as xml, its value is "oddPage".</para>
///</summary>
[EnumString("oddPage")]
OddPage,
 
}
/// <summary>
/// Defines the PageOrientationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PageOrientationValues
{  
	///<summary>
///Portrait Mode.
///<para>When the item is serialized out as xml, its value is "portrait".</para>
///</summary>
[EnumString("portrait")]
Portrait,
///<summary>
///Landscape Mode.
///<para>When the item is serialized out as xml, its value is "landscape".</para>
///</summary>
[EnumString("landscape")]
Landscape,
 
}
/// <summary>
/// Defines the PageBorderZOrderValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PageBorderZOrderValues
{  
	///<summary>
///Page Border Ahead of Text.
///<para>When the item is serialized out as xml, its value is "front".</para>
///</summary>
[EnumString("front")]
Front,
///<summary>
///Page Border Behind Text.
///<para>When the item is serialized out as xml, its value is "back".</para>
///</summary>
[EnumString("back")]
Back,
 
}
/// <summary>
/// Defines the PageBorderDisplayValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PageBorderDisplayValues
{  
	///<summary>
///Display Page Border on All Pages.
///<para>When the item is serialized out as xml, its value is "allPages".</para>
///</summary>
[EnumString("allPages")]
AllPages,
///<summary>
///Display Page Border on First Page.
///<para>When the item is serialized out as xml, its value is "firstPage".</para>
///</summary>
[EnumString("firstPage")]
FirstPage,
///<summary>
///Display Page Border on All Pages Except First.
///<para>When the item is serialized out as xml, its value is "notFirstPage".</para>
///</summary>
[EnumString("notFirstPage")]
NotFirstPage,
 
}
/// <summary>
/// Defines the PageBorderOffsetValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PageBorderOffsetValues
{  
	///<summary>
///Page Border Is Positioned Relative to Page Edges.
///<para>When the item is serialized out as xml, its value is "page".</para>
///</summary>
[EnumString("page")]
Page,
///<summary>
///Page Border Is Positioned Relative to Text Extents.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
 
}
/// <summary>
/// Defines the ChapterSeparatorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ChapterSeparatorValues
{  
	///<summary>
///Hyphen Chapter Separator.
///<para>When the item is serialized out as xml, its value is "hyphen".</para>
///</summary>
[EnumString("hyphen")]
Hyphen,
///<summary>
///Period Chapter Separator.
///<para>When the item is serialized out as xml, its value is "period".</para>
///</summary>
[EnumString("period")]
Period,
///<summary>
///Colon Chapter Separator.
///<para>When the item is serialized out as xml, its value is "colon".</para>
///</summary>
[EnumString("colon")]
Colon,
///<summary>
///Em Dash Chapter Separator.
///<para>When the item is serialized out as xml, its value is "emDash".</para>
///</summary>
[EnumString("emDash")]
EmDash,
///<summary>
///En Dash Chapter Separator.
///<para>When the item is serialized out as xml, its value is "enDash".</para>
///</summary>
[EnumString("enDash")]
EnDash,
 
}
/// <summary>
/// Defines the LineNumberRestartValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LineNumberRestartValues
{  
	///<summary>
///Restart Line Numbering on Each Page.
///<para>When the item is serialized out as xml, its value is "newPage".</para>
///</summary>
[EnumString("newPage")]
NewPage,
///<summary>
///Restart Line Numbering for Each Section.
///<para>When the item is serialized out as xml, its value is "newSection".</para>
///</summary>
[EnumString("newSection")]
NewSection,
///<summary>
///Continue Line Numbering From Previous Section.
///<para>When the item is serialized out as xml, its value is "continuous".</para>
///</summary>
[EnumString("continuous")]
Continuous,
 
}
/// <summary>
/// Defines the VerticalJustificationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalJustificationValues
{  
	///<summary>
///Align Top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///Align Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Vertical Justification.
///<para>When the item is serialized out as xml, its value is "both".</para>
///</summary>
[EnumString("both")]
Both,
///<summary>
///Align Bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
 
}
/// <summary>
/// Defines the TableVerticalAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableVerticalAlignmentValues
{  
	///<summary>
///top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
 
}
/// <summary>
/// Defines the DocGridValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocGridValues
{  
	///<summary>
///No Document Grid.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///Line Grid Only.
///<para>When the item is serialized out as xml, its value is "lines".</para>
///</summary>
[EnumString("lines")]
Lines,
///<summary>
///Line and Character Grid.
///<para>When the item is serialized out as xml, its value is "linesAndChars".</para>
///</summary>
[EnumString("linesAndChars")]
LinesAndChars,
///<summary>
///Character Grid Only.
///<para>When the item is serialized out as xml, its value is "snapToChars".</para>
///</summary>
[EnumString("snapToChars")]
SnapToChars,
 
}
/// <summary>
/// Defines the HeaderFooterValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HeaderFooterValues
{  
	///<summary>
///Even Numbered Pages Only.
///<para>When the item is serialized out as xml, its value is "even".</para>
///</summary>
[EnumString("even")]
Even,
///<summary>
///Default Header or Footer.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///First Page Only.
///<para>When the item is serialized out as xml, its value is "first".</para>
///</summary>
[EnumString("first")]
First,
 
}
/// <summary>
/// Defines the FootnoteEndnoteValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FootnoteEndnoteValues
{  
	///<summary>
///Normal Footnote/Endnote.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Separator.
///<para>When the item is serialized out as xml, its value is "separator".</para>
///</summary>
[EnumString("separator")]
Separator,
///<summary>
///Continuation Separator.
///<para>When the item is serialized out as xml, its value is "continuationSeparator".</para>
///</summary>
[EnumString("continuationSeparator")]
ContinuationSeparator,
///<summary>
///Continuation Notice Separator.
///<para>When the item is serialized out as xml, its value is "continuationNotice".</para>
///</summary>
[EnumString("continuationNotice")]
ContinuationNotice,
 
}
/// <summary>
/// Defines the BreakValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BreakValues
{  
	///<summary>
///Page Break.
///<para>When the item is serialized out as xml, its value is "page".</para>
///</summary>
[EnumString("page")]
Page,
///<summary>
///Column Break.
///<para>When the item is serialized out as xml, its value is "column".</para>
///</summary>
[EnumString("column")]
Column,
///<summary>
///Line Break.
///<para>When the item is serialized out as xml, its value is "textWrapping".</para>
///</summary>
[EnumString("textWrapping")]
TextWrapping,
 
}
/// <summary>
/// Defines the BreakTextRestartLocationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BreakTextRestartLocationValues
{  
	///<summary>
///Restart On Next Line.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Restart In Next Text Region When In Leftmost Position.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Restart In Next Text Region When In Rightmost Position.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///Restart On Next Full Line.
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
 
}
/// <summary>
/// Defines the AbsolutePositionTabAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AbsolutePositionTabAlignmentValues
{  
	///<summary>
///Left.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Right.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
 
}
/// <summary>
/// Defines the AbsolutePositionTabPositioningBaseValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AbsolutePositionTabPositioningBaseValues
{  
	///<summary>
///Relative To Text Margins.
///<para>When the item is serialized out as xml, its value is "margin".</para>
///</summary>
[EnumString("margin")]
Margin,
///<summary>
///Relative To Indents.
///<para>When the item is serialized out as xml, its value is "indent".</para>
///</summary>
[EnumString("indent")]
Indent,
 
}
/// <summary>
/// Defines the AbsolutePositionTabLeaderCharValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum AbsolutePositionTabLeaderCharValues
{  
	///<summary>
///No Leader Character.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Dot Leader Character.
///<para>When the item is serialized out as xml, its value is "dot".</para>
///</summary>
[EnumString("dot")]
Dot,
///<summary>
///Hyphen Leader Character.
///<para>When the item is serialized out as xml, its value is "hyphen".</para>
///</summary>
[EnumString("hyphen")]
Hyphen,
///<summary>
///Underscore Leader Character.
///<para>When the item is serialized out as xml, its value is "underscore".</para>
///</summary>
[EnumString("underscore")]
Underscore,
///<summary>
///Centered Dot Leader Character.
///<para>When the item is serialized out as xml, its value is "middleDot".</para>
///</summary>
[EnumString("middleDot")]
MiddleDot,
 
}
/// <summary>
/// Defines the ProofingErrorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ProofingErrorValues
{  
	///<summary>
///Start of Region Marked as Spelling Error.
///<para>When the item is serialized out as xml, its value is "spellStart".</para>
///</summary>
[EnumString("spellStart")]
SpellStart,
///<summary>
///End of Region Marked as Spelling Error.
///<para>When the item is serialized out as xml, its value is "spellEnd".</para>
///</summary>
[EnumString("spellEnd")]
SpellEnd,
///<summary>
///Start of Region Marked as Grammatical Error.
///<para>When the item is serialized out as xml, its value is "gramStart".</para>
///</summary>
[EnumString("gramStart")]
GrammarStart,
///<summary>
///End of Region Marked as Grammatical Error.
///<para>When the item is serialized out as xml, its value is "gramEnd".</para>
///</summary>
[EnumString("gramEnd")]
GrammarEnd,
 
}
/// <summary>
/// Defines the RangePermissionEditingGroupValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RangePermissionEditingGroupValues
{  
	///<summary>
///No Users Have Editing Permissions.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///All Users Have Editing Permissions.
///<para>When the item is serialized out as xml, its value is "everyone".</para>
///</summary>
[EnumString("everyone")]
Everyone,
///<summary>
///Administrator Group.
///<para>When the item is serialized out as xml, its value is "administrators".</para>
///</summary>
[EnumString("administrators")]
Administrators,
///<summary>
///Contributors Group.
///<para>When the item is serialized out as xml, its value is "contributors".</para>
///</summary>
[EnumString("contributors")]
Contributors,
///<summary>
///Editors Group.
///<para>When the item is serialized out as xml, its value is "editors".</para>
///</summary>
[EnumString("editors")]
Editors,
///<summary>
///Owners Group.
///<para>When the item is serialized out as xml, its value is "owners".</para>
///</summary>
[EnumString("owners")]
Owners,
///<summary>
///Current Group.
///<para>When the item is serialized out as xml, its value is "current".</para>
///</summary>
[EnumString("current")]
Current,
 
}
/// <summary>
/// Defines the FontTypeHintValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FontTypeHintValues
{  
	///<summary>
///High ANSI Font.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///East Asian Font.
///<para>When the item is serialized out as xml, its value is "eastAsia".</para>
///</summary>
[EnumString("eastAsia")]
EastAsia,
///<summary>
///Complex Script Font.
///<para>When the item is serialized out as xml, its value is "cs".</para>
///</summary>
[EnumString("cs")]
ComplexScript,
 
}
/// <summary>
/// Defines the ThemeFontValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ThemeFontValues
{  
	///<summary>
///Major East Asian Theme Font.
///<para>When the item is serialized out as xml, its value is "majorEastAsia".</para>
///</summary>
[EnumString("majorEastAsia")]
MajorEastAsia,
///<summary>
///Major Complex Script Theme Font.
///<para>When the item is serialized out as xml, its value is "majorBidi".</para>
///</summary>
[EnumString("majorBidi")]
MajorBidi,
///<summary>
///Major ASCII Theme Font.
///<para>When the item is serialized out as xml, its value is "majorAscii".</para>
///</summary>
[EnumString("majorAscii")]
MajorAscii,
///<summary>
///Major High ANSI Theme Font.
///<para>When the item is serialized out as xml, its value is "majorHAnsi".</para>
///</summary>
[EnumString("majorHAnsi")]
MajorHighAnsi,
///<summary>
///Minor East Asian Theme Font.
///<para>When the item is serialized out as xml, its value is "minorEastAsia".</para>
///</summary>
[EnumString("minorEastAsia")]
MinorEastAsia,
///<summary>
///Minor Complex Script Theme Font.
///<para>When the item is serialized out as xml, its value is "minorBidi".</para>
///</summary>
[EnumString("minorBidi")]
MinorBidi,
///<summary>
///Minor ASCII Theme Font.
///<para>When the item is serialized out as xml, its value is "minorAscii".</para>
///</summary>
[EnumString("minorAscii")]
MinorAscii,
///<summary>
///Minor High ANSI Theme Font.
///<para>When the item is serialized out as xml, its value is "minorHAnsi".</para>
///</summary>
[EnumString("minorHAnsi")]
MinorHighAnsi,
 
}
/// <summary>
/// Defines the RubyAlignValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RubyAlignValues
{  
	///<summary>
///Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Distribute All Characters.
///<para>When the item is serialized out as xml, its value is "distributeLetter".</para>
///</summary>
[EnumString("distributeLetter")]
DistributeLetter,
///<summary>
///Distribute all Characters w/ Additional Space On Either Side.
///<para>When the item is serialized out as xml, its value is "distributeSpace".</para>
///</summary>
[EnumString("distributeSpace")]
DistributeSpace,
///<summary>
///Left Aligned.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Right Aligned.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///Vertically Aligned to Right of Base Text.
///<para>When the item is serialized out as xml, its value is "rightVertical".</para>
///</summary>
[EnumString("rightVertical")]
RightVertical,
 
}
/// <summary>
/// Defines the LockingValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LockingValues
{  
	///<summary>
///SDT Cannot Be Deleted.
///<para>When the item is serialized out as xml, its value is "sdtLocked".</para>
///</summary>
[EnumString("sdtLocked")]
SdtLocked,
///<summary>
///Contents Cannot Be Edited At Runtime.
///<para>When the item is serialized out as xml, its value is "contentLocked".</para>
///</summary>
[EnumString("contentLocked")]
ContentLocked,
///<summary>
///No Locking.
///<para>When the item is serialized out as xml, its value is "unlocked".</para>
///</summary>
[EnumString("unlocked")]
Unlocked,
///<summary>
///Contents Cannot Be Edited At Runtime And SDT Cannot Be Deleted.
///<para>When the item is serialized out as xml, its value is "sdtContentLocked".</para>
///</summary>
[EnumString("sdtContentLocked")]
SdtContentLocked,
 
}
/// <summary>
/// Defines the DateFormatValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DateFormatValues
{  
	///<summary>
///Same As Display.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///XML Schema Date Format.
///<para>When the item is serialized out as xml, its value is "date".</para>
///</summary>
[EnumString("date")]
Date,
///<summary>
///XML Schema DateTime Format.
///<para>When the item is serialized out as xml, its value is "dateTime".</para>
///</summary>
[EnumString("dateTime")]
DateTime,
 
}
/// <summary>
/// Defines the TableWidthUnitValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableWidthUnitValues
{  
	///<summary>
///No Width.
///<para>When the item is serialized out as xml, its value is "nil".</para>
///</summary>
[EnumString("nil")]
Nil,
///<summary>
///Width in Fiftieths of a Percent.
///<para>When the item is serialized out as xml, its value is "pct".</para>
///</summary>
[EnumString("pct")]
Pct,
///<summary>
///Width in Twentieths of a Point.
///<para>When the item is serialized out as xml, its value is "dxa".</para>
///</summary>
[EnumString("dxa")]
Dxa,
///<summary>
///Automatically Determined Width.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
 
}
/// <summary>
/// Defines the TableWidthValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableWidthValues
{  
	///<summary>
///nil.
///<para>When the item is serialized out as xml, its value is "nil".</para>
///</summary>
[EnumString("nil")]
Nil,
///<summary>
///dxa.
///<para>When the item is serialized out as xml, its value is "dxa".</para>
///</summary>
[EnumString("dxa")]
Dxa,
 
}
/// <summary>
/// Defines the MergedCellValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MergedCellValues
{  
	///<summary>
///Continue Merged Region.
///<para>When the item is serialized out as xml, its value is "continue".</para>
///</summary>
[EnumString("continue")]
Continue,
///<summary>
///Start/Restart Merged Region.
///<para>When the item is serialized out as xml, its value is "restart".</para>
///</summary>
[EnumString("restart")]
Restart,
 
}
/// <summary>
/// Defines the TableLayoutValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableLayoutValues
{  
	///<summary>
///Fixed Width Table Layout.
///<para>When the item is serialized out as xml, its value is "fixed".</para>
///</summary>
[EnumString("fixed")]
Fixed,
///<summary>
///AutoFit Table Layout.
///<para>When the item is serialized out as xml, its value is "autofit".</para>
///</summary>
[EnumString("autofit")]
Autofit,
 
}
/// <summary>
/// Defines the TableOverlapValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableOverlapValues
{  
	///<summary>
///Floating Table Cannot Overlap.
///<para>When the item is serialized out as xml, its value is "never".</para>
///</summary>
[EnumString("never")]
Never,
///<summary>
///Floating Table Can Overlap.
///<para>When the item is serialized out as xml, its value is "overlap".</para>
///</summary>
[EnumString("overlap")]
Overlap,
 
}
/// <summary>
/// Defines the FootnotePositionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FootnotePositionValues
{  
	///<summary>
///Footnotes Positioned at Page Bottom.
///<para>When the item is serialized out as xml, its value is "pageBottom".</para>
///</summary>
[EnumString("pageBottom")]
PageBottom,
///<summary>
///Footnotes Positioned Beneath Text.
///<para>When the item is serialized out as xml, its value is "beneathText".</para>
///</summary>
[EnumString("beneathText")]
BeneathText,
///<summary>
///Footnotes Positioned At End of Section.
///<para>When the item is serialized out as xml, its value is "sectEnd".</para>
///</summary>
[EnumString("sectEnd")]
SectionEnd,
 
}
/// <summary>
/// Defines the EndnotePositionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum EndnotePositionValues
{  
	///<summary>
///Endnotes Positioned at End of Section.
///<para>When the item is serialized out as xml, its value is "sectEnd".</para>
///</summary>
[EnumString("sectEnd")]
SectionEnd,
///<summary>
///Endnotes Positioned at End of Document.
///<para>When the item is serialized out as xml, its value is "docEnd".</para>
///</summary>
[EnumString("docEnd")]
DocumentEnd,
 
}
/// <summary>
/// Defines the RestartNumberValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RestartNumberValues
{  
	///<summary>
///Continue Numbering From Previous Section.
///<para>When the item is serialized out as xml, its value is "continuous".</para>
///</summary>
[EnumString("continuous")]
Continuous,
///<summary>
///Restart Numbering For Each Section.
///<para>When the item is serialized out as xml, its value is "eachSect".</para>
///</summary>
[EnumString("eachSect")]
EachSection,
///<summary>
///Restart Numbering On Each Page.
///<para>When the item is serialized out as xml, its value is "eachPage".</para>
///</summary>
[EnumString("eachPage")]
EachPage,
 
}
/// <summary>
/// Defines the MailMergeSourceValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MailMergeSourceValues
{  
	///<summary>
///Database Data Source.
///<para>When the item is serialized out as xml, its value is "database".</para>
///</summary>
[EnumString("database")]
Database,
///<summary>
///Address Book Data Source.
///<para>When the item is serialized out as xml, its value is "addressBook".</para>
///</summary>
[EnumString("addressBook")]
AddressBook,
///<summary>
///Alternate Document Format Data Source.
///<para>When the item is serialized out as xml, its value is "document1".</para>
///</summary>
[EnumString("document1")]
Document1,
///<summary>
///Alternate Document Format Data Source Two.
///<para>When the item is serialized out as xml, its value is "document2".</para>
///</summary>
[EnumString("document2")]
Document2,
///<summary>
///Text File Data Source.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///E-Mail Program Data Source.
///<para>When the item is serialized out as xml, its value is "email".</para>
///</summary>
[EnumString("email")]
Email,
///<summary>
///Native Data Souce.
///<para>When the item is serialized out as xml, its value is "native".</para>
///</summary>
[EnumString("native")]
Native,
///<summary>
///Legacy Document Format Data Source.
///<para>When the item is serialized out as xml, its value is "legacy".</para>
///</summary>
[EnumString("legacy")]
Legacy,
///<summary>
///Aggregate Data Source.
///<para>When the item is serialized out as xml, its value is "master".</para>
///</summary>
[EnumString("master")]
Master,
 
}
/// <summary>
/// Defines the TargetScreenSizeValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TargetScreenSizeValues
{  
	///<summary>
///Optimize for 544x376.
///<para>When the item is serialized out as xml, its value is "544x376".</para>
///</summary>
[EnumString("544x376")]
Sz544x376,
///<summary>
///Optimize for 640x480.
///<para>When the item is serialized out as xml, its value is "640x480".</para>
///</summary>
[EnumString("640x480")]
Sz640x480,
///<summary>
///Optimize for 720x512.
///<para>When the item is serialized out as xml, its value is "720x512".</para>
///</summary>
[EnumString("720x512")]
Sz720x512,
///<summary>
///Optimize for 800x600.
///<para>When the item is serialized out as xml, its value is "800x600".</para>
///</summary>
[EnumString("800x600")]
Sz800x600,
///<summary>
///Optimize for 1024x768.
///<para>When the item is serialized out as xml, its value is "1024x768".</para>
///</summary>
[EnumString("1024x768")]
Sz1024x768,
///<summary>
///Optimize for 1152x882.
///<para>When the item is serialized out as xml, its value is "1152x882".</para>
///</summary>
[EnumString("1152x882")]
Sz1152x882,
///<summary>
///Optimize for 1152x900.
///<para>When the item is serialized out as xml, its value is "1152x900".</para>
///</summary>
[EnumString("1152x900")]
Sz1152x900,
///<summary>
///Optimize for 1280x1024.
///<para>When the item is serialized out as xml, its value is "1280x1024".</para>
///</summary>
[EnumString("1280x1024")]
Sz1280x1024,
///<summary>
///Optimize for 1600x1200.
///<para>When the item is serialized out as xml, its value is "1600x1200".</para>
///</summary>
[EnumString("1600x1200")]
Sz1600x1200,
///<summary>
///Optimize for 1800x1440.
///<para>When the item is serialized out as xml, its value is "1800x1440".</para>
///</summary>
[EnumString("1800x1440")]
Sz1800x1440,
///<summary>
///Optimize for 1920x1200.
///<para>When the item is serialized out as xml, its value is "1920x1200".</para>
///</summary>
[EnumString("1920x1200")]
Sz1920x1200,
 
}
/// <summary>
/// Defines the CharacterSpacingValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CharacterSpacingValues
{  
	///<summary>
///Do Not Compress Whitespace.
///<para>When the item is serialized out as xml, its value is "doNotCompress".</para>
///</summary>
[EnumString("doNotCompress")]
DoNotCompress,
///<summary>
///Compress Whitespace From Punctuation Characters.
///<para>When the item is serialized out as xml, its value is "compressPunctuation".</para>
///</summary>
[EnumString("compressPunctuation")]
CompressPunctuation,
///<summary>
///Compress Whitespace From Both Japanese Kana And Punctuation Characters.
///<para>When the item is serialized out as xml, its value is "compressPunctuationAndJapaneseKana".</para>
///</summary>
[EnumString("compressPunctuationAndJapaneseKana")]
CompressPunctuationAndJapaneseKana,
 
}
/// <summary>
/// Defines the ColorSchemeIndexValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ColorSchemeIndexValues
{  
	///<summary>
///Dark 1 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "dark1".</para>
///</summary>
[EnumString("dark1")]
Dark1,
///<summary>
///Light 1 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "light1".</para>
///</summary>
[EnumString("light1")]
Light1,
///<summary>
///Dark 2 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "dark2".</para>
///</summary>
[EnumString("dark2")]
Dark2,
///<summary>
///Light 2 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "light2".</para>
///</summary>
[EnumString("light2")]
Light2,
///<summary>
///Accent 1 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent1".</para>
///</summary>
[EnumString("accent1")]
Accent1,
///<summary>
///Accent 2 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent2".</para>
///</summary>
[EnumString("accent2")]
Accent2,
///<summary>
///Accent 3 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent3".</para>
///</summary>
[EnumString("accent3")]
Accent3,
///<summary>
///Accent4 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent4".</para>
///</summary>
[EnumString("accent4")]
Accent4,
///<summary>
///Accent5 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent5".</para>
///</summary>
[EnumString("accent5")]
Accent5,
///<summary>
///Accent 6 Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "accent6".</para>
///</summary>
[EnumString("accent6")]
Accent6,
///<summary>
///Hyperlink Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "hyperlink".</para>
///</summary>
[EnumString("hyperlink")]
Hyperlink,
///<summary>
///Followed Hyperlink Theme Color Reference.
///<para>When the item is serialized out as xml, its value is "followedHyperlink".</para>
///</summary>
[EnumString("followedHyperlink")]
FollowedHyperlink,
 
}
/// <summary>
/// Defines the FrameScrollbarVisibilityValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FrameScrollbarVisibilityValues
{  
	///<summary>
///Always Show Scrollbar.
///<para>When the item is serialized out as xml, its value is "on".</para>
///</summary>
[EnumString("on")]
On,
///<summary>
///Never Show Scrollbar.
///<para>When the item is serialized out as xml, its value is "off".</para>
///</summary>
[EnumString("off")]
Off,
///<summary>
///Automatically Show Scrollbar As Needed.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
 
}
/// <summary>
/// Defines the FrameLayoutValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FrameLayoutValues
{  
	///<summary>
///Stack Frames Vertically.
///<para>When the item is serialized out as xml, its value is "rows".</para>
///</summary>
[EnumString("rows")]
Rows,
///<summary>
///Stack Frames Horizontally.
///<para>When the item is serialized out as xml, its value is "cols".</para>
///</summary>
[EnumString("cols")]
Columns,
///<summary>
///Do Not Stack Frames.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the LevelSuffixValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LevelSuffixValues
{  
	///<summary>
///Tab Between Numbering and Text.
///<para>When the item is serialized out as xml, its value is "tab".</para>
///</summary>
[EnumString("tab")]
Tab,
///<summary>
///Space Between Numbering and Text.
///<para>When the item is serialized out as xml, its value is "space".</para>
///</summary>
[EnumString("space")]
Space,
///<summary>
///Nothing Between Numbering and Text.
///<para>When the item is serialized out as xml, its value is "nothing".</para>
///</summary>
[EnumString("nothing")]
Nothing,
 
}
/// <summary>
/// Defines the MultiLevelValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MultiLevelValues
{  
	///<summary>
///Single Level Numbering Definition.
///<para>When the item is serialized out as xml, its value is "singleLevel".</para>
///</summary>
[EnumString("singleLevel")]
SingleLevel,
///<summary>
///Multilevel Numbering Definition.
///<para>When the item is serialized out as xml, its value is "multilevel".</para>
///</summary>
[EnumString("multilevel")]
Multilevel,
///<summary>
///Hybrid Multilevel Numbering Definition.
///<para>When the item is serialized out as xml, its value is "hybridMultilevel".</para>
///</summary>
[EnumString("hybridMultilevel")]
HybridMultilevel,
 
}
/// <summary>
/// Defines the TableStyleOverrideValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableStyleOverrideValues
{  
	///<summary>
///Whole table formatting.
///<para>When the item is serialized out as xml, its value is "wholeTable".</para>
///</summary>
[EnumString("wholeTable")]
WholeTable,
///<summary>
///First Row Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "firstRow".</para>
///</summary>
[EnumString("firstRow")]
FirstRow,
///<summary>
///Last table row formatting.
///<para>When the item is serialized out as xml, its value is "lastRow".</para>
///</summary>
[EnumString("lastRow")]
LastRow,
///<summary>
///First Column Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "firstCol".</para>
///</summary>
[EnumString("firstCol")]
FirstColumn,
///<summary>
///Last table column formatting.
///<para>When the item is serialized out as xml, its value is "lastCol".</para>
///</summary>
[EnumString("lastCol")]
LastColumn,
///<summary>
///Banded Column Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "band1Vert".</para>
///</summary>
[EnumString("band1Vert")]
Band1Vertical,
///<summary>
///Even Column Stripe Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "band2Vert".</para>
///</summary>
[EnumString("band2Vert")]
Band2Vertical,
///<summary>
///Banded Row Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "band1Horz".</para>
///</summary>
[EnumString("band1Horz")]
Band1Horizontal,
///<summary>
///Even Row Stripe Conditional Formatting.
///<para>When the item is serialized out as xml, its value is "band2Horz".</para>
///</summary>
[EnumString("band2Horz")]
Band2Horizontal,
///<summary>
///Top right table cell formatting.
///<para>When the item is serialized out as xml, its value is "neCell".</para>
///</summary>
[EnumString("neCell")]
NorthEastCell,
///<summary>
///Top left table cell formatting.
///<para>When the item is serialized out as xml, its value is "nwCell".</para>
///</summary>
[EnumString("nwCell")]
NorthWestCell,
///<summary>
///Bottom right table cell formatting.
///<para>When the item is serialized out as xml, its value is "seCell".</para>
///</summary>
[EnumString("seCell")]
SouthEastCell,
///<summary>
///Bottom left table cell formatting.
///<para>When the item is serialized out as xml, its value is "swCell".</para>
///</summary>
[EnumString("swCell")]
SouthWestCell,
 
}
/// <summary>
/// Defines the StyleValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum StyleValues
{  
	///<summary>
///Paragraph Style.
///<para>When the item is serialized out as xml, its value is "paragraph".</para>
///</summary>
[EnumString("paragraph")]
Paragraph,
///<summary>
///Character Style.
///<para>When the item is serialized out as xml, its value is "character".</para>
///</summary>
[EnumString("character")]
Character,
///<summary>
///Table Style.
///<para>When the item is serialized out as xml, its value is "table".</para>
///</summary>
[EnumString("table")]
Table,
///<summary>
///Numbering Style.
///<para>When the item is serialized out as xml, its value is "numbering".</para>
///</summary>
[EnumString("numbering")]
Numbering,
 
}
/// <summary>
/// Defines the FontFamilyValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FontFamilyValues
{  
	///<summary>
///Novelty Font.
///<para>When the item is serialized out as xml, its value is "decorative".</para>
///</summary>
[EnumString("decorative")]
Decorative,
///<summary>
///Monospace Font.
///<para>When the item is serialized out as xml, its value is "modern".</para>
///</summary>
[EnumString("modern")]
Modern,
///<summary>
///Proportional Font With Serifs.
///<para>When the item is serialized out as xml, its value is "roman".</para>
///</summary>
[EnumString("roman")]
Roman,
///<summary>
///Script Font.
///<para>When the item is serialized out as xml, its value is "script".</para>
///</summary>
[EnumString("script")]
Script,
///<summary>
///Proportional Font Without Serifs.
///<para>When the item is serialized out as xml, its value is "swiss".</para>
///</summary>
[EnumString("swiss")]
Swiss,
///<summary>
///No Font Family.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
 
}
/// <summary>
/// Defines the FontPitchValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FontPitchValues
{  
	///<summary>
///Fixed Width.
///<para>When the item is serialized out as xml, its value is "fixed".</para>
///</summary>
[EnumString("fixed")]
Fixed,
///<summary>
///Proportional Width.
///<para>When the item is serialized out as xml, its value is "variable".</para>
///</summary>
[EnumString("variable")]
Variable,
///<summary>
///Default.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
 
}
/// <summary>
/// Defines the ThemeColorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ThemeColorValues
{  
	///<summary>
///Dark 1 Theme Color.
///<para>When the item is serialized out as xml, its value is "dark1".</para>
///</summary>
[EnumString("dark1")]
Dark1,
///<summary>
///Light 1 Theme Color.
///<para>When the item is serialized out as xml, its value is "light1".</para>
///</summary>
[EnumString("light1")]
Light1,
///<summary>
///Dark 2 Theme Color.
///<para>When the item is serialized out as xml, its value is "dark2".</para>
///</summary>
[EnumString("dark2")]
Dark2,
///<summary>
///Light 2 Theme Color.
///<para>When the item is serialized out as xml, its value is "light2".</para>
///</summary>
[EnumString("light2")]
Light2,
///<summary>
///Accent 1 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent1".</para>
///</summary>
[EnumString("accent1")]
Accent1,
///<summary>
///Accent 2 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent2".</para>
///</summary>
[EnumString("accent2")]
Accent2,
///<summary>
///Accent 3 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent3".</para>
///</summary>
[EnumString("accent3")]
Accent3,
///<summary>
///Accent 4 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent4".</para>
///</summary>
[EnumString("accent4")]
Accent4,
///<summary>
///Accent 5 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent5".</para>
///</summary>
[EnumString("accent5")]
Accent5,
///<summary>
///Accent 6 Theme Color.
///<para>When the item is serialized out as xml, its value is "accent6".</para>
///</summary>
[EnumString("accent6")]
Accent6,
///<summary>
///Hyperlink Theme Color.
///<para>When the item is serialized out as xml, its value is "hyperlink".</para>
///</summary>
[EnumString("hyperlink")]
Hyperlink,
///<summary>
///Followed Hyperlink Theme Color.
///<para>When the item is serialized out as xml, its value is "followedHyperlink".</para>
///</summary>
[EnumString("followedHyperlink")]
FollowedHyperlink,
///<summary>
///No Theme Color.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Background 1 Theme Color.
///<para>When the item is serialized out as xml, its value is "background1".</para>
///</summary>
[EnumString("background1")]
Background1,
///<summary>
///Text 1 Theme Color.
///<para>When the item is serialized out as xml, its value is "text1".</para>
///</summary>
[EnumString("text1")]
Text1,
///<summary>
///Background 2 Theme Color.
///<para>When the item is serialized out as xml, its value is "background2".</para>
///</summary>
[EnumString("background2")]
Background2,
///<summary>
///Text 2 Theme Color.
///<para>When the item is serialized out as xml, its value is "text2".</para>
///</summary>
[EnumString("text2")]
Text2,
 
}
/// <summary>
/// Defines the DocPartBehaviorValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocPartBehaviorValues
{  
	///<summary>
///Insert Content At Specified Location.
///<para>When the item is serialized out as xml, its value is "content".</para>
///</summary>
[EnumString("content")]
Content,
///<summary>
///Ensure Entry Is In New Paragraph.
///<para>When the item is serialized out as xml, its value is "p".</para>
///</summary>
[EnumString("p")]
Paragraph,
///<summary>
///Ensure Entry Is On New Page.
///<para>When the item is serialized out as xml, its value is "pg".</para>
///</summary>
[EnumString("pg")]
Page,
 
}
/// <summary>
/// Defines the DocPartValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocPartValues
{  
	///<summary>
///No Type.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Normal.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Automatically Replace Name With Content.
///<para>When the item is serialized out as xml, its value is "autoExp".</para>
///</summary>
[EnumString("autoExp")]
AutoExp,
///<summary>
///AutoText User Interface Entry.
///<para>When the item is serialized out as xml, its value is "toolbar".</para>
///</summary>
[EnumString("toolbar")]
Toolbar,
///<summary>
///AutoCorrect Entry.
///<para>When the item is serialized out as xml, its value is "speller".</para>
///</summary>
[EnumString("speller")]
Speller,
///<summary>
///Form Field Help Text.
///<para>When the item is serialized out as xml, its value is "formFld".</para>
///</summary>
[EnumString("formFld")]
FormField,
///<summary>
///Structured Document Tag Placeholder Text.
///<para>When the item is serialized out as xml, its value is "bbPlcHdr".</para>
///</summary>
[EnumString("bbPlcHdr")]
SdtPlaceholder,
 
}
/// <summary>
/// Defines the DocPartGalleryValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocPartGalleryValues
{  
	///<summary>
///Structured Document Tag Placeholder Text Gallery.
///<para>When the item is serialized out as xml, its value is "placeholder".</para>
///</summary>
[EnumString("placeholder")]
Placeholder,
///<summary>
///All Galleries.
///<para>When the item is serialized out as xml, its value is "any".</para>
///</summary>
[EnumString("any")]
Any,
///<summary>
///No Gallery Classification.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///Document Parts Gallery.
///<para>When the item is serialized out as xml, its value is "docParts".</para>
///</summary>
[EnumString("docParts")]
DocumentPart,
///<summary>
///Cover Page Gallery.
///<para>When the item is serialized out as xml, its value is "coverPg".</para>
///</summary>
[EnumString("coverPg")]
CoverPage,
///<summary>
///Equations Gallery.
///<para>When the item is serialized out as xml, its value is "eq".</para>
///</summary>
[EnumString("eq")]
Equation,
///<summary>
///Footers Gallery.
///<para>When the item is serialized out as xml, its value is "ftrs".</para>
///</summary>
[EnumString("ftrs")]
Footer,
///<summary>
///Headers Gallery.
///<para>When the item is serialized out as xml, its value is "hdrs".</para>
///</summary>
[EnumString("hdrs")]
Header,
///<summary>
///Page Numbers Gallery.
///<para>When the item is serialized out as xml, its value is "pgNum".</para>
///</summary>
[EnumString("pgNum")]
PageNumber,
///<summary>
///Table Gallery.
///<para>When the item is serialized out as xml, its value is "tbls".</para>
///</summary>
[EnumString("tbls")]
Table,
///<summary>
///Watermark Gallery.
///<para>When the item is serialized out as xml, its value is "watermarks".</para>
///</summary>
[EnumString("watermarks")]
WaterMark,
///<summary>
///AutoText Gallery.
///<para>When the item is serialized out as xml, its value is "autoTxt".</para>
///</summary>
[EnumString("autoTxt")]
AutoText,
///<summary>
///Text Box Gallery.
///<para>When the item is serialized out as xml, its value is "txtBox".</para>
///</summary>
[EnumString("txtBox")]
TextBox,
///<summary>
///Page Numbers At Top Gallery.
///<para>When the item is serialized out as xml, its value is "pgNumT".</para>
///</summary>
[EnumString("pgNumT")]
PageNumberTop,
///<summary>
///Page Numbers At Bottom Gallery.
///<para>When the item is serialized out as xml, its value is "pgNumB".</para>
///</summary>
[EnumString("pgNumB")]
PageNumberBottom,
///<summary>
///Page Numbers At Margins Gallery.
///<para>When the item is serialized out as xml, its value is "pgNumMargins".</para>
///</summary>
[EnumString("pgNumMargins")]
PageNumberMargins,
///<summary>
///Table of Contents Gallery.
///<para>When the item is serialized out as xml, its value is "tblOfContents".</para>
///</summary>
[EnumString("tblOfContents")]
TableOfContents,
///<summary>
///Bibliography Gallery.
///<para>When the item is serialized out as xml, its value is "bib".</para>
///</summary>
[EnumString("bib")]
Bibliography,
///<summary>
///Custom Quick Parts Gallery.
///<para>When the item is serialized out as xml, its value is "custQuickParts".</para>
///</summary>
[EnumString("custQuickParts")]
CustomQuickParts,
///<summary>
///Custom Cover Page Gallery.
///<para>When the item is serialized out as xml, its value is "custCoverPg".</para>
///</summary>
[EnumString("custCoverPg")]
CustomCoverPage,
///<summary>
///Custom Equation Gallery.
///<para>When the item is serialized out as xml, its value is "custEq".</para>
///</summary>
[EnumString("custEq")]
CustomEquation,
///<summary>
///Custom Footer Gallery.
///<para>When the item is serialized out as xml, its value is "custFtrs".</para>
///</summary>
[EnumString("custFtrs")]
CustomFooter,
///<summary>
///Custom Header Gallery.
///<para>When the item is serialized out as xml, its value is "custHdrs".</para>
///</summary>
[EnumString("custHdrs")]
CustomHeaders,
///<summary>
///Custom Page Number Gallery.
///<para>When the item is serialized out as xml, its value is "custPgNum".</para>
///</summary>
[EnumString("custPgNum")]
CustomPageNumber,
///<summary>
///Custom Table Gallery.
///<para>When the item is serialized out as xml, its value is "custTbls".</para>
///</summary>
[EnumString("custTbls")]
CustomTable,
///<summary>
///Custom Watermark Gallery.
///<para>When the item is serialized out as xml, its value is "custWatermarks".</para>
///</summary>
[EnumString("custWatermarks")]
CustomWatermark,
///<summary>
///Custom AutoText Gallery.
///<para>When the item is serialized out as xml, its value is "custAutoTxt".</para>
///</summary>
[EnumString("custAutoTxt")]
CustomAutoText,
///<summary>
///Custom Text Box Gallery.
///<para>When the item is serialized out as xml, its value is "custTxtBox".</para>
///</summary>
[EnumString("custTxtBox")]
CustomTextBox,
///<summary>
///Custom Page Number At Top Gallery.
///<para>When the item is serialized out as xml, its value is "custPgNumT".</para>
///</summary>
[EnumString("custPgNumT")]
CustomPageNumberTop,
///<summary>
///Custom Page Number At Bottom Gallery.
///<para>When the item is serialized out as xml, its value is "custPgNumB".</para>
///</summary>
[EnumString("custPgNumB")]
CustomPageNumberBottom,
///<summary>
///Custom Page Number At Margins Gallery.
///<para>When the item is serialized out as xml, its value is "custPgNumMargins".</para>
///</summary>
[EnumString("custPgNumMargins")]
CustomPageNumberMargin,
///<summary>
///Custom Table of Contents Gallery.
///<para>When the item is serialized out as xml, its value is "custTblOfContents".</para>
///</summary>
[EnumString("custTblOfContents")]
CustomTableOfContents,
///<summary>
///Custom Bibliography Gallery.
///<para>When the item is serialized out as xml, its value is "custBib".</para>
///</summary>
[EnumString("custBib")]
CustomBibliography,
///<summary>
///Custom 1 Gallery.
///<para>When the item is serialized out as xml, its value is "custom1".</para>
///</summary>
[EnumString("custom1")]
Custom1,
///<summary>
///Custom 2 Gallery.
///<para>When the item is serialized out as xml, its value is "custom2".</para>
///</summary>
[EnumString("custom2")]
Custom2,
///<summary>
///Custom 3 Gallery.
///<para>When the item is serialized out as xml, its value is "custom3".</para>
///</summary>
[EnumString("custom3")]
Custom3,
///<summary>
///Custom 4 Gallery.
///<para>When the item is serialized out as xml, its value is "custom4".</para>
///</summary>
[EnumString("custom4")]
Custom4,
///<summary>
///Custom 5 Gallery.
///<para>When the item is serialized out as xml, its value is "custom5".</para>
///</summary>
[EnumString("custom5")]
Custom5,
 
}
/// <summary>
/// Automatic Caption Positioning Values 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CaptionPositionValues
{  
	///<summary>
///Position Caption Above Object.
///<para>When the item is serialized out as xml, its value is "above".</para>
///</summary>
[EnumString("above")]
Above,
///<summary>
///Position Caption Below Object.
///<para>When the item is serialized out as xml, its value is "below".</para>
///</summary>
[EnumString("below")]
Below,
 
}
/// <summary>
/// Horizontal Alignment Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum LevelJustificationValues
{  
	///<summary>
///Align Left.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Align Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Align Right.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
 
}
/// <summary>
/// Defines the ShadingPatternValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ShadingPatternValues
{  
	///<summary>
///No Pattern.
///<para>When the item is serialized out as xml, its value is "nil".</para>
///</summary>
[EnumString("nil")]
Nil,
///<summary>
///No Pattern.
///<para>When the item is serialized out as xml, its value is "clear".</para>
///</summary>
[EnumString("clear")]
Clear,
///<summary>
///100% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "solid".</para>
///</summary>
[EnumString("solid")]
Solid,
///<summary>
///Horizontal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "horzStripe".</para>
///</summary>
[EnumString("horzStripe")]
HorizontalStripe,
///<summary>
///Vertical Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "vertStripe".</para>
///</summary>
[EnumString("vertStripe")]
VerticalStripe,
///<summary>
///Reverse Diagonal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "reverseDiagStripe".</para>
///</summary>
[EnumString("reverseDiagStripe")]
ReverseDiagonalStripe,
///<summary>
///Diagonal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "diagStripe".</para>
///</summary>
[EnumString("diagStripe")]
DiagonalStripe,
///<summary>
///Horizontal Cross Pattern.
///<para>When the item is serialized out as xml, its value is "horzCross".</para>
///</summary>
[EnumString("horzCross")]
HorizontalCross,
///<summary>
///Diagonal Cross Pattern.
///<para>When the item is serialized out as xml, its value is "diagCross".</para>
///</summary>
[EnumString("diagCross")]
DiagonalCross,
///<summary>
///Thin Horizontal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "thinHorzStripe".</para>
///</summary>
[EnumString("thinHorzStripe")]
ThinHorizontalStripe,
///<summary>
///Thin Vertical Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "thinVertStripe".</para>
///</summary>
[EnumString("thinVertStripe")]
ThinVerticalStripe,
///<summary>
///Thin Reverse Diagonal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "thinReverseDiagStripe".</para>
///</summary>
[EnumString("thinReverseDiagStripe")]
ThinReverseDiagonalStripe,
///<summary>
///Thin Diagonal Stripe Pattern.
///<para>When the item is serialized out as xml, its value is "thinDiagStripe".</para>
///</summary>
[EnumString("thinDiagStripe")]
ThinDiagonalStripe,
///<summary>
///Thin Horizontal Cross Pattern.
///<para>When the item is serialized out as xml, its value is "thinHorzCross".</para>
///</summary>
[EnumString("thinHorzCross")]
ThinHorizontalCross,
///<summary>
///Thin Diagonal Cross Pattern.
///<para>When the item is serialized out as xml, its value is "thinDiagCross".</para>
///</summary>
[EnumString("thinDiagCross")]
ThinDiagonalCross,
///<summary>
///5% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct5".</para>
///</summary>
[EnumString("pct5")]
Percent5,
///<summary>
///10% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct10".</para>
///</summary>
[EnumString("pct10")]
Percent10,
///<summary>
///12.5% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct12".</para>
///</summary>
[EnumString("pct12")]
Percent12,
///<summary>
///15% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct15".</para>
///</summary>
[EnumString("pct15")]
Percent15,
///<summary>
///20% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct20".</para>
///</summary>
[EnumString("pct20")]
Percent20,
///<summary>
///25% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct25".</para>
///</summary>
[EnumString("pct25")]
Percent25,
///<summary>
///30% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct30".</para>
///</summary>
[EnumString("pct30")]
Percent30,
///<summary>
///35% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct35".</para>
///</summary>
[EnumString("pct35")]
Percent35,
///<summary>
///37.5% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct37".</para>
///</summary>
[EnumString("pct37")]
Percent37,
///<summary>
///40% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct40".</para>
///</summary>
[EnumString("pct40")]
Percent40,
///<summary>
///45% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct45".</para>
///</summary>
[EnumString("pct45")]
Percent45,
///<summary>
///50% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct50".</para>
///</summary>
[EnumString("pct50")]
Percent50,
///<summary>
///55% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct55".</para>
///</summary>
[EnumString("pct55")]
Percent55,
///<summary>
///60% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct60".</para>
///</summary>
[EnumString("pct60")]
Percent60,
///<summary>
///62.5% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct62".</para>
///</summary>
[EnumString("pct62")]
Percent62,
///<summary>
///65% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct65".</para>
///</summary>
[EnumString("pct65")]
Percent65,
///<summary>
///70% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct70".</para>
///</summary>
[EnumString("pct70")]
Percent70,
///<summary>
///75% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct75".</para>
///</summary>
[EnumString("pct75")]
Percent75,
///<summary>
///80% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct80".</para>
///</summary>
[EnumString("pct80")]
Percent80,
///<summary>
///85% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct85".</para>
///</summary>
[EnumString("pct85")]
Percent85,
///<summary>
///87.5% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct87".</para>
///</summary>
[EnumString("pct87")]
Percent87,
///<summary>
///90% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct90".</para>
///</summary>
[EnumString("pct90")]
Percent90,
///<summary>
///95% Fill Pattern.
///<para>When the item is serialized out as xml, its value is "pct95".</para>
///</summary>
[EnumString("pct95")]
Percent95,
 
}
/// <summary>
/// Defines the StylePaneSortMethodsValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum StylePaneSortMethodsValues
{  
	///<summary>
///0000.
///<para>When the item is serialized out as xml, its value is "0000".</para>
///</summary>
[EnumString("0000")]
Zero,
///<summary>
///name.
///<para>When the item is serialized out as xml, its value is "name".</para>
///</summary>
[EnumString("name")]
Name,
///<summary>
///0001.
///<para>When the item is serialized out as xml, its value is "0001".</para>
///</summary>
[EnumString("0001")]
One,
///<summary>
///priority.
///<para>When the item is serialized out as xml, its value is "priority".</para>
///</summary>
[EnumString("priority")]
Priority,
///<summary>
///0002.
///<para>When the item is serialized out as xml, its value is "0002".</para>
///</summary>
[EnumString("0002")]
Two,
///<summary>
///font.
///<para>When the item is serialized out as xml, its value is "font".</para>
///</summary>
[EnumString("font")]
Font,
///<summary>
///0003.
///<para>When the item is serialized out as xml, its value is "0003".</para>
///</summary>
[EnumString("0003")]
Three,
///<summary>
///basedOn.
///<para>When the item is serialized out as xml, its value is "basedOn".</para>
///</summary>
[EnumString("basedOn")]
BasedOn,
///<summary>
///0004.
///<para>When the item is serialized out as xml, its value is "0004".</para>
///</summary>
[EnumString("0004")]
Four,
///<summary>
///type.
///<para>When the item is serialized out as xml, its value is "type".</para>
///</summary>
[EnumString("type")]
Type,
///<summary>
///0005.
///<para>When the item is serialized out as xml, its value is "0005".</para>
///</summary>
[EnumString("0005")]
Five,
///<summary>
///default.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
 
}
/// <summary>
/// Defines the DirectionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DirectionValues
{  
	///<summary>
///ltr.
///<para>When the item is serialized out as xml, its value is "ltr".</para>
///</summary>
[EnumString("ltr")]
Ltr,
///<summary>
///rtl.
///<para>When the item is serialized out as xml, its value is "rtl".</para>
///</summary>
[EnumString("rtl")]
Rtl,
 
}
/// <summary>
/// Defines the CalendarValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CalendarValues
{  
	///<summary>
///Gregorian.
///<para>When the item is serialized out as xml, its value is "gregorian".</para>
///</summary>
[EnumString("gregorian")]
Gregorian,
///<summary>
///Hijri.
///<para>When the item is serialized out as xml, its value is "hijri".</para>
///</summary>
[EnumString("hijri")]
Hijri,
///<summary>
///umalqura.
///<para>When the item is serialized out as xml, its value is "umalqura".</para>
///</summary>
[EnumString("umalqura")]
Umalqura,
///<summary>
///Hebrew.
///<para>When the item is serialized out as xml, its value is "hebrew".</para>
///</summary>
[EnumString("hebrew")]
Hebrew,
///<summary>
///Taiwan.
///<para>When the item is serialized out as xml, its value is "taiwan".</para>
///</summary>
[EnumString("taiwan")]
Taiwan,
///<summary>
///Japanese Emperor Era.
///<para>When the item is serialized out as xml, its value is "japan".</para>
///</summary>
[EnumString("japan")]
Japan,
///<summary>
///Thai.
///<para>When the item is serialized out as xml, its value is "thai".</para>
///</summary>
[EnumString("thai")]
Thai,
///<summary>
///Korean Tangun Era.
///<para>When the item is serialized out as xml, its value is "korea".</para>
///</summary>
[EnumString("korea")]
Korea,
///<summary>
///Saka Era.
///<para>When the item is serialized out as xml, its value is "saka".</para>
///</summary>
[EnumString("saka")]
Saka,
///<summary>
///Gregorian transliterated English.
///<para>When the item is serialized out as xml, its value is "gregorianXlitEnglish".</para>
///</summary>
[EnumString("gregorianXlitEnglish")]
GregorianTransliteratedEnglish,
///<summary>
///Gregorian transliterated French.
///<para>When the item is serialized out as xml, its value is "gregorianXlitFrench".</para>
///</summary>
[EnumString("gregorianXlitFrench")]
GregorianTransliteratedFrench,
///<summary>
///gregorianUs.
///<para>When the item is serialized out as xml, its value is "gregorianUs".</para>
///</summary>
[EnumString("gregorianUs")]
GregorianUs,
///<summary>
///gregorianMeFrench.
///<para>When the item is serialized out as xml, its value is "gregorianMeFrench".</para>
///</summary>
[EnumString("gregorianMeFrench")]
GregorianMeFrench,
///<summary>
///gregorianArabic.
///<para>When the item is serialized out as xml, its value is "gregorianArabic".</para>
///</summary>
[EnumString("gregorianArabic")]
GregorianArabic,
///<summary>
///none.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Defines the NumberFormatValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum NumberFormatValues
{  
	///<summary>
///Decimal Numbers.
///<para>When the item is serialized out as xml, its value is "decimal".</para>
///</summary>
[EnumString("decimal")]
Decimal,
///<summary>
///Uppercase Roman Numerals.
///<para>When the item is serialized out as xml, its value is "upperRoman".</para>
///</summary>
[EnumString("upperRoman")]
UpperRoman,
///<summary>
///Lowercase Roman Numerals.
///<para>When the item is serialized out as xml, its value is "lowerRoman".</para>
///</summary>
[EnumString("lowerRoman")]
LowerRoman,
///<summary>
///Uppercase Latin Alphabet.
///<para>When the item is serialized out as xml, its value is "upperLetter".</para>
///</summary>
[EnumString("upperLetter")]
UpperLetter,
///<summary>
///Lowercase Latin Alphabet.
///<para>When the item is serialized out as xml, its value is "lowerLetter".</para>
///</summary>
[EnumString("lowerLetter")]
LowerLetter,
///<summary>
///Ordinal.
///<para>When the item is serialized out as xml, its value is "ordinal".</para>
///</summary>
[EnumString("ordinal")]
Ordinal,
///<summary>
///Cardinal Text.
///<para>When the item is serialized out as xml, its value is "cardinalText".</para>
///</summary>
[EnumString("cardinalText")]
CardinalText,
///<summary>
///Ordinal Text.
///<para>When the item is serialized out as xml, its value is "ordinalText".</para>
///</summary>
[EnumString("ordinalText")]
OrdinalText,
///<summary>
///Hexadecimal Numbering.
///<para>When the item is serialized out as xml, its value is "hex".</para>
///</summary>
[EnumString("hex")]
Hex,
///<summary>
///Chicago Manual of Style.
///<para>When the item is serialized out as xml, its value is "chicago".</para>
///</summary>
[EnumString("chicago")]
Chicago,
///<summary>
///Ideographs.
///<para>When the item is serialized out as xml, its value is "ideographDigital".</para>
///</summary>
[EnumString("ideographDigital")]
IdeographDigital,
///<summary>
///Japanese Counting System.
///<para>When the item is serialized out as xml, its value is "japaneseCounting".</para>
///</summary>
[EnumString("japaneseCounting")]
JapaneseCounting,
///<summary>
///AIUEO Order Hiragana.
///<para>When the item is serialized out as xml, its value is "aiueo".</para>
///</summary>
[EnumString("aiueo")]
Aiueo,
///<summary>
///Iroha Ordered Katakana.
///<para>When the item is serialized out as xml, its value is "iroha".</para>
///</summary>
[EnumString("iroha")]
Iroha,
///<summary>
///Double Byte Arabic Numerals.
///<para>When the item is serialized out as xml, its value is "decimalFullWidth".</para>
///</summary>
[EnumString("decimalFullWidth")]
DecimalFullWidth,
///<summary>
///Single Byte Arabic Numerals.
///<para>When the item is serialized out as xml, its value is "decimalHalfWidth".</para>
///</summary>
[EnumString("decimalHalfWidth")]
DecimalHalfWidth,
///<summary>
///Japanese Legal Numbering.
///<para>When the item is serialized out as xml, its value is "japaneseLegal".</para>
///</summary>
[EnumString("japaneseLegal")]
JapaneseLegal,
///<summary>
///Japanese Digital Ten Thousand Counting System.
///<para>When the item is serialized out as xml, its value is "japaneseDigitalTenThousand".</para>
///</summary>
[EnumString("japaneseDigitalTenThousand")]
JapaneseDigitalTenThousand,
///<summary>
///Decimal Numbers Enclosed in a Circle.
///<para>When the item is serialized out as xml, its value is "decimalEnclosedCircle".</para>
///</summary>
[EnumString("decimalEnclosedCircle")]
DecimalEnclosedCircle,
///<summary>
///Double Byte Arabic Numerals Alternate.
///<para>When the item is serialized out as xml, its value is "decimalFullWidth2".</para>
///</summary>
[EnumString("decimalFullWidth2")]
DecimalFullWidth2,
///<summary>
///Full-Width AIUEO Order Hiragana.
///<para>When the item is serialized out as xml, its value is "aiueoFullWidth".</para>
///</summary>
[EnumString("aiueoFullWidth")]
AiueoFullWidth,
///<summary>
///Full-Width Iroha Ordered Katakana.
///<para>When the item is serialized out as xml, its value is "irohaFullWidth".</para>
///</summary>
[EnumString("irohaFullWidth")]
IrohaFullWidth,
///<summary>
///Initial Zero Arabic Numerals.
///<para>When the item is serialized out as xml, its value is "decimalZero".</para>
///</summary>
[EnumString("decimalZero")]
DecimalZero,
///<summary>
///Bullet.
///<para>When the item is serialized out as xml, its value is "bullet".</para>
///</summary>
[EnumString("bullet")]
Bullet,
///<summary>
///Korean Ganada Numbering.
///<para>When the item is serialized out as xml, its value is "ganada".</para>
///</summary>
[EnumString("ganada")]
Ganada,
///<summary>
///Korean Chosung Numbering.
///<para>When the item is serialized out as xml, its value is "chosung".</para>
///</summary>
[EnumString("chosung")]
Chosung,
///<summary>
///Decimal Numbers Followed by a Period.
///<para>When the item is serialized out as xml, its value is "decimalEnclosedFullstop".</para>
///</summary>
[EnumString("decimalEnclosedFullstop")]
DecimalEnclosedFullstop,
///<summary>
///Decimal Numbers Enclosed in Parenthesis.
///<para>When the item is serialized out as xml, its value is "decimalEnclosedParen".</para>
///</summary>
[EnumString("decimalEnclosedParen")]
DecimalEnclosedParen,
///<summary>
///Decimal Numbers Enclosed in a Circle.
///<para>When the item is serialized out as xml, its value is "decimalEnclosedCircleChinese".</para>
///</summary>
[EnumString("decimalEnclosedCircleChinese")]
DecimalEnclosedCircleChinese,
///<summary>
///Ideographs Enclosed in a Circle.
///<para>When the item is serialized out as xml, its value is "ideographEnclosedCircle".</para>
///</summary>
[EnumString("ideographEnclosedCircle")]
IdeographEnclosedCircle,
///<summary>
///Traditional Ideograph Format.
///<para>When the item is serialized out as xml, its value is "ideographTraditional".</para>
///</summary>
[EnumString("ideographTraditional")]
IdeographTraditional,
///<summary>
///Zodiac Ideograph Format.
///<para>When the item is serialized out as xml, its value is "ideographZodiac".</para>
///</summary>
[EnumString("ideographZodiac")]
IdeographZodiac,
///<summary>
///Traditional Zodiac Ideograph Format.
///<para>When the item is serialized out as xml, its value is "ideographZodiacTraditional".</para>
///</summary>
[EnumString("ideographZodiacTraditional")]
IdeographZodiacTraditional,
///<summary>
///Taiwanese Counting System.
///<para>When the item is serialized out as xml, its value is "taiwaneseCounting".</para>
///</summary>
[EnumString("taiwaneseCounting")]
TaiwaneseCounting,
///<summary>
///Traditional Legal Ideograph Format.
///<para>When the item is serialized out as xml, its value is "ideographLegalTraditional".</para>
///</summary>
[EnumString("ideographLegalTraditional")]
IdeographLegalTraditional,
///<summary>
///Taiwanese Counting Thousand System.
///<para>When the item is serialized out as xml, its value is "taiwaneseCountingThousand".</para>
///</summary>
[EnumString("taiwaneseCountingThousand")]
TaiwaneseCountingThousand,
///<summary>
///Taiwanese Digital Counting System.
///<para>When the item is serialized out as xml, its value is "taiwaneseDigital".</para>
///</summary>
[EnumString("taiwaneseDigital")]
TaiwaneseDigital,
///<summary>
///Chinese Counting System.
///<para>When the item is serialized out as xml, its value is "chineseCounting".</para>
///</summary>
[EnumString("chineseCounting")]
ChineseCounting,
///<summary>
///Chinese Legal Simplified Format.
///<para>When the item is serialized out as xml, its value is "chineseLegalSimplified".</para>
///</summary>
[EnumString("chineseLegalSimplified")]
ChineseLegalSimplified,
///<summary>
///Chinese Counting Thousand System.
///<para>When the item is serialized out as xml, its value is "chineseCountingThousand".</para>
///</summary>
[EnumString("chineseCountingThousand")]
ChineseCountingThousand,
///<summary>
///Korean Digital Counting System.
///<para>When the item is serialized out as xml, its value is "koreanDigital".</para>
///</summary>
[EnumString("koreanDigital")]
KoreanDigital,
///<summary>
///Korean Counting System.
///<para>When the item is serialized out as xml, its value is "koreanCounting".</para>
///</summary>
[EnumString("koreanCounting")]
KoreanCounting,
///<summary>
///Korean Legal Numbering.
///<para>When the item is serialized out as xml, its value is "koreanLegal".</para>
///</summary>
[EnumString("koreanLegal")]
KoreanLegal,
///<summary>
///Korean Digital Counting System Alternate.
///<para>When the item is serialized out as xml, its value is "koreanDigital2".</para>
///</summary>
[EnumString("koreanDigital2")]
KoreanDigital2,
///<summary>
///Vietnamese Numerals.
///<para>When the item is serialized out as xml, its value is "vietnameseCounting".</para>
///</summary>
[EnumString("vietnameseCounting")]
VietnameseCounting,
///<summary>
///Lowercase Russian Alphabet.
///<para>When the item is serialized out as xml, its value is "russianLower".</para>
///</summary>
[EnumString("russianLower")]
RussianLower,
///<summary>
///Uppercase Russian Alphabet.
///<para>When the item is serialized out as xml, its value is "russianUpper".</para>
///</summary>
[EnumString("russianUpper")]
RussianUpper,
///<summary>
///No Numbering.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Number With Dashes.
///<para>When the item is serialized out as xml, its value is "numberInDash".</para>
///</summary>
[EnumString("numberInDash")]
NumberInDash,
///<summary>
///Hebrew Numerals.
///<para>When the item is serialized out as xml, its value is "hebrew1".</para>
///</summary>
[EnumString("hebrew1")]
Hebrew1,
///<summary>
///Hebrew Alphabet.
///<para>When the item is serialized out as xml, its value is "hebrew2".</para>
///</summary>
[EnumString("hebrew2")]
Hebrew2,
///<summary>
///Arabic Alphabet.
///<para>When the item is serialized out as xml, its value is "arabicAlpha".</para>
///</summary>
[EnumString("arabicAlpha")]
ArabicAlpha,
///<summary>
///Arabic Abjad Numerals.
///<para>When the item is serialized out as xml, its value is "arabicAbjad".</para>
///</summary>
[EnumString("arabicAbjad")]
ArabicAbjad,
///<summary>
///Hindi Vowels.
///<para>When the item is serialized out as xml, its value is "hindiVowels".</para>
///</summary>
[EnumString("hindiVowels")]
HindiVowels,
///<summary>
///Hindi Consonants.
///<para>When the item is serialized out as xml, its value is "hindiConsonants".</para>
///</summary>
[EnumString("hindiConsonants")]
HindiConsonants,
///<summary>
///Hindi Numbers.
///<para>When the item is serialized out as xml, its value is "hindiNumbers".</para>
///</summary>
[EnumString("hindiNumbers")]
HindiNumbers,
///<summary>
///Hindi Counting System.
///<para>When the item is serialized out as xml, its value is "hindiCounting".</para>
///</summary>
[EnumString("hindiCounting")]
HindiCounting,
///<summary>
///Thai Letters.
///<para>When the item is serialized out as xml, its value is "thaiLetters".</para>
///</summary>
[EnumString("thaiLetters")]
ThaiLetters,
///<summary>
///Thai Numerals.
///<para>When the item is serialized out as xml, its value is "thaiNumbers".</para>
///</summary>
[EnumString("thaiNumbers")]
ThaiNumbers,
///<summary>
///Thai Counting System.
///<para>When the item is serialized out as xml, its value is "thaiCounting".</para>
///</summary>
[EnumString("thaiCounting")]
ThaiCounting,
///<summary>
///bahtText.
///<para>When the item is serialized out as xml, its value is "bahtText".</para>
///</summary>
[EnumString("bahtText")]
BahtText,
///<summary>
///dollarText.
///<para>When the item is serialized out as xml, its value is "dollarText".</para>
///</summary>
[EnumString("dollarText")]
DollarText,
///<summary>
///custom.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// Defines the TextDirectionValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextDirectionValues
{  
	///<summary>
///Left to Right, Top to Bottom.
///<para>When the item is serialized out as xml, its value is "lrTb".</para>
///</summary>
[EnumString("lrTb")]
LefToRightTopToBottom,
///<summary>
///tb.
///<para>When the item is serialized out as xml, its value is "tb".</para>
///</summary>
[EnumString("tb")]
LeftToRightTopToBottom2010,
///<summary>
///Top to Bottom, Right to Left.
///<para>When the item is serialized out as xml, its value is "tbRl".</para>
///</summary>
[EnumString("tbRl")]
TopToBottomRightToLeft,
///<summary>
///rl.
///<para>When the item is serialized out as xml, its value is "rl".</para>
///</summary>
[EnumString("rl")]
TopToBottomRightToLeft2010,
///<summary>
///Bottom to Top, Left to Right.
///<para>When the item is serialized out as xml, its value is "btLr".</para>
///</summary>
[EnumString("btLr")]
BottomToTopLeftToRight,
///<summary>
///lr.
///<para>When the item is serialized out as xml, its value is "lr".</para>
///</summary>
[EnumString("lr")]
BottomToTopLeftToRight2010,
///<summary>
///Left to Right, Top to Bottom Rotated.
///<para>When the item is serialized out as xml, its value is "lrTbV".</para>
///</summary>
[EnumString("lrTbV")]
LefttoRightTopToBottomRotated,
///<summary>
///tbV.
///<para>When the item is serialized out as xml, its value is "tbV".</para>
///</summary>
[EnumString("tbV")]
LeftToRightTopToBottomRotated2010,
///<summary>
///Top to Bottom, Right to Left Rotated.
///<para>When the item is serialized out as xml, its value is "tbRlV".</para>
///</summary>
[EnumString("tbRlV")]
TopToBottomRightToLeftRotated,
///<summary>
///rlV.
///<para>When the item is serialized out as xml, its value is "rlV".</para>
///</summary>
[EnumString("rlV")]
TopToBottomRightToLeftRotated2010,
///<summary>
///Top to Bottom, Left to Right Rotated.
///<para>When the item is serialized out as xml, its value is "tbLrV".</para>
///</summary>
[EnumString("tbLrV")]
TopToBottomLeftToRightRotated,
///<summary>
///lrV.
///<para>When the item is serialized out as xml, its value is "lrV".</para>
///</summary>
[EnumString("lrV")]
TopToBottomLeftToRightRotated2010,
 
}
/// <summary>
/// Defines the CryptAlgorithmValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CryptAlgorithmValues
{  
	///<summary>
///Any Type.
///<para>When the item is serialized out as xml, its value is "typeAny".</para>
///</summary>
[EnumString("typeAny")]
TypeAny,
///<summary>
///custom.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// Defines the CryptAlgorithmClassValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CryptAlgorithmClassValues
{  
	///<summary>
///Hashing.
///<para>When the item is serialized out as xml, its value is "hash".</para>
///</summary>
[EnumString("hash")]
Hash,
///<summary>
///custom.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// Defines the CryptProviderValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CryptProviderValues
{  
	///<summary>
///AES Provider.
///<para>When the item is serialized out as xml, its value is "rsaAES".</para>
///</summary>
[EnumString("rsaAES")]
RsaAdvancedEncryptionStandard,
///<summary>
///Any Provider.
///<para>When the item is serialized out as xml, its value is "rsaFull".</para>
///</summary>
[EnumString("rsaFull")]
RsaFull,
///<summary>
///custom.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// Defines the JustificationValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum JustificationValues
{  
	///<summary>
///Align Left.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///start.
///<para>When the item is serialized out as xml, its value is "start".</para>
///</summary>
[EnumString("start")]
Start,
///<summary>
///Align Center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Align Right.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///end.
///<para>When the item is serialized out as xml, its value is "end".</para>
///</summary>
[EnumString("end")]
End,
///<summary>
///Justified.
///<para>When the item is serialized out as xml, its value is "both".</para>
///</summary>
[EnumString("both")]
Both,
///<summary>
///Medium Kashida Length.
///<para>When the item is serialized out as xml, its value is "mediumKashida".</para>
///</summary>
[EnumString("mediumKashida")]
MediumKashida,
///<summary>
///Distribute All Characters Equally.
///<para>When the item is serialized out as xml, its value is "distribute".</para>
///</summary>
[EnumString("distribute")]
Distribute,
///<summary>
///Align to List Tab.
///<para>When the item is serialized out as xml, its value is "numTab".</para>
///</summary>
[EnumString("numTab")]
NumTab,
///<summary>
///Widest Kashida Length.
///<para>When the item is serialized out as xml, its value is "highKashida".</para>
///</summary>
[EnumString("highKashida")]
HighKashida,
///<summary>
///Low Kashida Length.
///<para>When the item is serialized out as xml, its value is "lowKashida".</para>
///</summary>
[EnumString("lowKashida")]
LowKashida,
///<summary>
///Thai Language Justification.
///<para>When the item is serialized out as xml, its value is "thaiDistribute".</para>
///</summary>
[EnumString("thaiDistribute")]
ThaiDistribute,
 
}
/// <summary>
/// Defines the TabStopValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TabStopValues
{  
	///<summary>
///No Tab Stop.
///<para>When the item is serialized out as xml, its value is "clear".</para>
///</summary>
[EnumString("clear")]
Clear,
///<summary>
///Left Tab.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///start.
///<para>When the item is serialized out as xml, its value is "start".</para>
///</summary>
[EnumString("start")]
Start,
///<summary>
///Centered Tab.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Right Tab.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///end.
///<para>When the item is serialized out as xml, its value is "end".</para>
///</summary>
[EnumString("end")]
End,
///<summary>
///Decimal Tab.
///<para>When the item is serialized out as xml, its value is "decimal".</para>
///</summary>
[EnumString("decimal")]
Decimal,
///<summary>
///Bar Tab.
///<para>When the item is serialized out as xml, its value is "bar".</para>
///</summary>
[EnumString("bar")]
Bar,
///<summary>
///List Tab.
///<para>When the item is serialized out as xml, its value is "num".</para>
///</summary>
[EnumString("num")]
Number,
 
}
/// <summary>
/// Defines the BorderValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BorderValues
{  
	///<summary>
///No Border.
///<para>When the item is serialized out as xml, its value is "nil".</para>
///</summary>
[EnumString("nil")]
Nil,
///<summary>
///No Border.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Single Line Border.
///<para>When the item is serialized out as xml, its value is "single".</para>
///</summary>
[EnumString("single")]
Single,
///<summary>
///Single Line Border.
///<para>When the item is serialized out as xml, its value is "thick".</para>
///</summary>
[EnumString("thick")]
Thick,
///<summary>
///Double Line Border.
///<para>When the item is serialized out as xml, its value is "double".</para>
///</summary>
[EnumString("double")]
Double,
///<summary>
///Dotted Line Border.
///<para>When the item is serialized out as xml, its value is "dotted".</para>
///</summary>
[EnumString("dotted")]
Dotted,
///<summary>
///Dashed Line Border.
///<para>When the item is serialized out as xml, its value is "dashed".</para>
///</summary>
[EnumString("dashed")]
Dashed,
///<summary>
///Dot Dash Line Border.
///<para>When the item is serialized out as xml, its value is "dotDash".</para>
///</summary>
[EnumString("dotDash")]
DotDash,
///<summary>
///Dot Dot Dash Line Border.
///<para>When the item is serialized out as xml, its value is "dotDotDash".</para>
///</summary>
[EnumString("dotDotDash")]
DotDotDash,
///<summary>
///Triple Line Border.
///<para>When the item is serialized out as xml, its value is "triple".</para>
///</summary>
[EnumString("triple")]
Triple,
///<summary>
///Thin, Thick Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickSmallGap".</para>
///</summary>
[EnumString("thinThickSmallGap")]
ThinThickSmallGap,
///<summary>
///Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thickThinSmallGap".</para>
///</summary>
[EnumString("thickThinSmallGap")]
ThickThinSmallGap,
///<summary>
///Thin, Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickThinSmallGap".</para>
///</summary>
[EnumString("thinThickThinSmallGap")]
ThinThickThinSmallGap,
///<summary>
///Thin, Thick Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickMediumGap".</para>
///</summary>
[EnumString("thinThickMediumGap")]
ThinThickMediumGap,
///<summary>
///Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thickThinMediumGap".</para>
///</summary>
[EnumString("thickThinMediumGap")]
ThickThinMediumGap,
///<summary>
///Thin, Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickThinMediumGap".</para>
///</summary>
[EnumString("thinThickThinMediumGap")]
ThinThickThinMediumGap,
///<summary>
///Thin, Thick Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickLargeGap".</para>
///</summary>
[EnumString("thinThickLargeGap")]
ThinThickLargeGap,
///<summary>
///Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thickThinLargeGap".</para>
///</summary>
[EnumString("thickThinLargeGap")]
ThickThinLargeGap,
///<summary>
///Thin, Thick, Thin Line Border.
///<para>When the item is serialized out as xml, its value is "thinThickThinLargeGap".</para>
///</summary>
[EnumString("thinThickThinLargeGap")]
ThinThickThinLargeGap,
///<summary>
///Wavy Line Border.
///<para>When the item is serialized out as xml, its value is "wave".</para>
///</summary>
[EnumString("wave")]
Wave,
///<summary>
///Double Wave Line Border.
///<para>When the item is serialized out as xml, its value is "doubleWave".</para>
///</summary>
[EnumString("doubleWave")]
DoubleWave,
///<summary>
///Dashed Line Border.
///<para>When the item is serialized out as xml, its value is "dashSmallGap".</para>
///</summary>
[EnumString("dashSmallGap")]
DashSmallGap,
///<summary>
///Dash Dot Strokes Line Border.
///<para>When the item is serialized out as xml, its value is "dashDotStroked".</para>
///</summary>
[EnumString("dashDotStroked")]
DashDotStroked,
///<summary>
///3D Embossed Line Border.
///<para>When the item is serialized out as xml, its value is "threeDEmboss".</para>
///</summary>
[EnumString("threeDEmboss")]
ThreeDEmboss,
///<summary>
///3D Engraved Line Border.
///<para>When the item is serialized out as xml, its value is "threeDEngrave".</para>
///</summary>
[EnumString("threeDEngrave")]
ThreeDEngrave,
///<summary>
///Outset Line Border.
///<para>When the item is serialized out as xml, its value is "outset".</para>
///</summary>
[EnumString("outset")]
Outset,
///<summary>
///Inset Line Border.
///<para>When the item is serialized out as xml, its value is "inset".</para>
///</summary>
[EnumString("inset")]
Inset,
///<summary>
///Apples Art Border.
///<para>When the item is serialized out as xml, its value is "apples".</para>
///</summary>
[EnumString("apples")]
Apples,
///<summary>
///Arched Scallops Art Border.
///<para>When the item is serialized out as xml, its value is "archedScallops".</para>
///</summary>
[EnumString("archedScallops")]
ArchedScallops,
///<summary>
///Baby Pacifier Art Border.
///<para>When the item is serialized out as xml, its value is "babyPacifier".</para>
///</summary>
[EnumString("babyPacifier")]
BabyPacifier,
///<summary>
///Baby Rattle Art Border.
///<para>When the item is serialized out as xml, its value is "babyRattle".</para>
///</summary>
[EnumString("babyRattle")]
BabyRattle,
///<summary>
///Three Color Balloons Art Border.
///<para>When the item is serialized out as xml, its value is "balloons3Colors".</para>
///</summary>
[EnumString("balloons3Colors")]
Balloons3Colors,
///<summary>
///Hot Air Balloons Art Border.
///<para>When the item is serialized out as xml, its value is "balloonsHotAir".</para>
///</summary>
[EnumString("balloonsHotAir")]
BalloonsHotAir,
///<summary>
///Black Dash Art Border.
///<para>When the item is serialized out as xml, its value is "basicBlackDashes".</para>
///</summary>
[EnumString("basicBlackDashes")]
BasicBlackDashes,
///<summary>
///Black Dot Art Border.
///<para>When the item is serialized out as xml, its value is "basicBlackDots".</para>
///</summary>
[EnumString("basicBlackDots")]
BasicBlackDots,
///<summary>
///Black Square Art Border.
///<para>When the item is serialized out as xml, its value is "basicBlackSquares".</para>
///</summary>
[EnumString("basicBlackSquares")]
BasicBlackSquares,
///<summary>
///Thin Line Art Border.
///<para>When the item is serialized out as xml, its value is "basicThinLines".</para>
///</summary>
[EnumString("basicThinLines")]
BasicThinLines,
///<summary>
///White Dash Art Border.
///<para>When the item is serialized out as xml, its value is "basicWhiteDashes".</para>
///</summary>
[EnumString("basicWhiteDashes")]
BasicWhiteDashes,
///<summary>
///White Dot Art Border.
///<para>When the item is serialized out as xml, its value is "basicWhiteDots".</para>
///</summary>
[EnumString("basicWhiteDots")]
BasicWhiteDots,
///<summary>
///White Square Art Border.
///<para>When the item is serialized out as xml, its value is "basicWhiteSquares".</para>
///</summary>
[EnumString("basicWhiteSquares")]
BasicWhiteSquares,
///<summary>
///Wide Inline Art Border.
///<para>When the item is serialized out as xml, its value is "basicWideInline".</para>
///</summary>
[EnumString("basicWideInline")]
BasicWideInline,
///<summary>
///Wide Midline Art Border.
///<para>When the item is serialized out as xml, its value is "basicWideMidline".</para>
///</summary>
[EnumString("basicWideMidline")]
BasicWideMidline,
///<summary>
///Wide Outline Art Border.
///<para>When the item is serialized out as xml, its value is "basicWideOutline".</para>
///</summary>
[EnumString("basicWideOutline")]
BasicWideOutline,
///<summary>
///Bats Art Border.
///<para>When the item is serialized out as xml, its value is "bats".</para>
///</summary>
[EnumString("bats")]
Bats,
///<summary>
///Birds Art Border.
///<para>When the item is serialized out as xml, its value is "birds".</para>
///</summary>
[EnumString("birds")]
Birds,
///<summary>
///Birds Flying Art Border.
///<para>When the item is serialized out as xml, its value is "birdsFlight".</para>
///</summary>
[EnumString("birdsFlight")]
BirdsFlight,
///<summary>
///Cabin Art Border.
///<para>When the item is serialized out as xml, its value is "cabins".</para>
///</summary>
[EnumString("cabins")]
Cabins,
///<summary>
///Cake Art Border.
///<para>When the item is serialized out as xml, its value is "cakeSlice".</para>
///</summary>
[EnumString("cakeSlice")]
CakeSlice,
///<summary>
///Candy Corn Art Border.
///<para>When the item is serialized out as xml, its value is "candyCorn".</para>
///</summary>
[EnumString("candyCorn")]
CandyCorn,
///<summary>
///Knot Work Art Border.
///<para>When the item is serialized out as xml, its value is "celticKnotwork".</para>
///</summary>
[EnumString("celticKnotwork")]
CelticKnotwork,
///<summary>
///Certificate Banner Art Border.
///<para>When the item is serialized out as xml, its value is "certificateBanner".</para>
///</summary>
[EnumString("certificateBanner")]
CertificateBanner,
///<summary>
///Chain Link Art Border.
///<para>When the item is serialized out as xml, its value is "chainLink".</para>
///</summary>
[EnumString("chainLink")]
ChainLink,
///<summary>
///Champagne Bottle Art Border.
///<para>When the item is serialized out as xml, its value is "champagneBottle".</para>
///</summary>
[EnumString("champagneBottle")]
ChampagneBottle,
///<summary>
///Black and White Bar Art Border.
///<para>When the item is serialized out as xml, its value is "checkedBarBlack".</para>
///</summary>
[EnumString("checkedBarBlack")]
CheckedBarBlack,
///<summary>
///Color Checked Bar Art Border.
///<para>When the item is serialized out as xml, its value is "checkedBarColor".</para>
///</summary>
[EnumString("checkedBarColor")]
CheckedBarColor,
///<summary>
///Checkerboard Art Border.
///<para>When the item is serialized out as xml, its value is "checkered".</para>
///</summary>
[EnumString("checkered")]
Checkered,
///<summary>
///Christmas Tree Art Border.
///<para>When the item is serialized out as xml, its value is "christmasTree".</para>
///</summary>
[EnumString("christmasTree")]
ChristmasTree,
///<summary>
///Circles And Lines Art Border.
///<para>When the item is serialized out as xml, its value is "circlesLines".</para>
///</summary>
[EnumString("circlesLines")]
CirclesLines,
///<summary>
///Circles and Rectangles Art Border.
///<para>When the item is serialized out as xml, its value is "circlesRectangles".</para>
///</summary>
[EnumString("circlesRectangles")]
CirclesRectangles,
///<summary>
///Wave Art Border.
///<para>When the item is serialized out as xml, its value is "classicalWave".</para>
///</summary>
[EnumString("classicalWave")]
ClassicalWave,
///<summary>
///Clocks Art Border.
///<para>When the item is serialized out as xml, its value is "clocks".</para>
///</summary>
[EnumString("clocks")]
Clocks,
///<summary>
///Compass Art Border.
///<para>When the item is serialized out as xml, its value is "compass".</para>
///</summary>
[EnumString("compass")]
Compass,
///<summary>
///Confetti Art Border.
///<para>When the item is serialized out as xml, its value is "confetti".</para>
///</summary>
[EnumString("confetti")]
Confetti,
///<summary>
///Confetti Art Border.
///<para>When the item is serialized out as xml, its value is "confettiGrays".</para>
///</summary>
[EnumString("confettiGrays")]
ConfettiGrays,
///<summary>
///Confetti Art Border.
///<para>When the item is serialized out as xml, its value is "confettiOutline".</para>
///</summary>
[EnumString("confettiOutline")]
ConfettiOutline,
///<summary>
///Confetti Streamers Art Border.
///<para>When the item is serialized out as xml, its value is "confettiStreamers".</para>
///</summary>
[EnumString("confettiStreamers")]
ConfettiStreamers,
///<summary>
///Confetti Art Border.
///<para>When the item is serialized out as xml, its value is "confettiWhite".</para>
///</summary>
[EnumString("confettiWhite")]
ConfettiWhite,
///<summary>
///Corner Triangle Art Border.
///<para>When the item is serialized out as xml, its value is "cornerTriangles".</para>
///</summary>
[EnumString("cornerTriangles")]
CornerTriangles,
///<summary>
///Dashed Line Art Border.
///<para>When the item is serialized out as xml, its value is "couponCutoutDashes".</para>
///</summary>
[EnumString("couponCutoutDashes")]
CouponCutoutDashes,
///<summary>
///Dotted Line Art Border.
///<para>When the item is serialized out as xml, its value is "couponCutoutDots".</para>
///</summary>
[EnumString("couponCutoutDots")]
CouponCutoutDots,
///<summary>
///Maze Art Border.
///<para>When the item is serialized out as xml, its value is "crazyMaze".</para>
///</summary>
[EnumString("crazyMaze")]
CrazyMaze,
///<summary>
///Butterfly Art Border.
///<para>When the item is serialized out as xml, its value is "creaturesButterfly".</para>
///</summary>
[EnumString("creaturesButterfly")]
CreaturesButterfly,
///<summary>
///Fish Art Border.
///<para>When the item is serialized out as xml, its value is "creaturesFish".</para>
///</summary>
[EnumString("creaturesFish")]
CreaturesFish,
///<summary>
///Insects Art Border.
///<para>When the item is serialized out as xml, its value is "creaturesInsects".</para>
///</summary>
[EnumString("creaturesInsects")]
CreaturesInsects,
///<summary>
///Ladybug Art Border.
///<para>When the item is serialized out as xml, its value is "creaturesLadyBug".</para>
///</summary>
[EnumString("creaturesLadyBug")]
CreaturesLadyBug,
///<summary>
///Cross-stitch Art Border.
///<para>When the item is serialized out as xml, its value is "crossStitch".</para>
///</summary>
[EnumString("crossStitch")]
CrossStitch,
///<summary>
///Cupid Art Border.
///<para>When the item is serialized out as xml, its value is "cup".</para>
///</summary>
[EnumString("cup")]
Cup,
///<summary>
///Archway Art Border.
///<para>When the item is serialized out as xml, its value is "decoArch".</para>
///</summary>
[EnumString("decoArch")]
DecoArch,
///<summary>
///Color Archway Art Border.
///<para>When the item is serialized out as xml, its value is "decoArchColor".</para>
///</summary>
[EnumString("decoArchColor")]
DecoArchColor,
///<summary>
///Blocks Art Border.
///<para>When the item is serialized out as xml, its value is "decoBlocks".</para>
///</summary>
[EnumString("decoBlocks")]
DecoBlocks,
///<summary>
///Gray Diamond Art Border.
///<para>When the item is serialized out as xml, its value is "diamondsGray".</para>
///</summary>
[EnumString("diamondsGray")]
DiamondsGray,
///<summary>
///Double D Art Border.
///<para>When the item is serialized out as xml, its value is "doubleD".</para>
///</summary>
[EnumString("doubleD")]
DoubleD,
///<summary>
///Diamond Art Border.
///<para>When the item is serialized out as xml, its value is "doubleDiamonds".</para>
///</summary>
[EnumString("doubleDiamonds")]
DoubleDiamonds,
///<summary>
///Earth Art Border.
///<para>When the item is serialized out as xml, its value is "earth1".</para>
///</summary>
[EnumString("earth1")]
Earth1,
///<summary>
///Earth Art Border.
///<para>When the item is serialized out as xml, its value is "earth2".</para>
///</summary>
[EnumString("earth2")]
Earth2,
///<summary>
///Shadowed Square Art Border.
///<para>When the item is serialized out as xml, its value is "eclipsingSquares1".</para>
///</summary>
[EnumString("eclipsingSquares1")]
EclipsingSquares1,
///<summary>
///Shadowed Square Art Border.
///<para>When the item is serialized out as xml, its value is "eclipsingSquares2".</para>
///</summary>
[EnumString("eclipsingSquares2")]
EclipsingSquares2,
///<summary>
///Painted Egg Art Border.
///<para>When the item is serialized out as xml, its value is "eggsBlack".</para>
///</summary>
[EnumString("eggsBlack")]
EggsBlack,
///<summary>
///Fans Art Border.
///<para>When the item is serialized out as xml, its value is "fans".</para>
///</summary>
[EnumString("fans")]
Fans,
///<summary>
///Film Reel Art Border.
///<para>When the item is serialized out as xml, its value is "film".</para>
///</summary>
[EnumString("film")]
Film,
///<summary>
///Firecracker Art Border.
///<para>When the item is serialized out as xml, its value is "firecrackers".</para>
///</summary>
[EnumString("firecrackers")]
Firecrackers,
///<summary>
///Flowers Art Border.
///<para>When the item is serialized out as xml, its value is "flowersBlockPrint".</para>
///</summary>
[EnumString("flowersBlockPrint")]
FlowersBlockPrint,
///<summary>
///Daisy Art Border.
///<para>When the item is serialized out as xml, its value is "flowersDaisies".</para>
///</summary>
[EnumString("flowersDaisies")]
FlowersDaisies,
///<summary>
///Flowers Art Border.
///<para>When the item is serialized out as xml, its value is "flowersModern1".</para>
///</summary>
[EnumString("flowersModern1")]
FlowersModern1,
///<summary>
///Flowers Art Border.
///<para>When the item is serialized out as xml, its value is "flowersModern2".</para>
///</summary>
[EnumString("flowersModern2")]
FlowersModern2,
///<summary>
///Pansy Art Border.
///<para>When the item is serialized out as xml, its value is "flowersPansy".</para>
///</summary>
[EnumString("flowersPansy")]
FlowersPansy,
///<summary>
///Red Rose Art Border.
///<para>When the item is serialized out as xml, its value is "flowersRedRose".</para>
///</summary>
[EnumString("flowersRedRose")]
FlowersRedRose,
///<summary>
///Roses Art Border.
///<para>When the item is serialized out as xml, its value is "flowersRoses".</para>
///</summary>
[EnumString("flowersRoses")]
FlowersRoses,
///<summary>
///Flowers in a Teacup Art Border.
///<para>When the item is serialized out as xml, its value is "flowersTeacup".</para>
///</summary>
[EnumString("flowersTeacup")]
FlowersTeacup,
///<summary>
///Small Flower Art Border.
///<para>When the item is serialized out as xml, its value is "flowersTiny".</para>
///</summary>
[EnumString("flowersTiny")]
FlowersTiny,
///<summary>
///Gems Art Border.
///<para>When the item is serialized out as xml, its value is "gems".</para>
///</summary>
[EnumString("gems")]
Gems,
///<summary>
///Gingerbread Man Art Border.
///<para>When the item is serialized out as xml, its value is "gingerbreadMan".</para>
///</summary>
[EnumString("gingerbreadMan")]
GingerbreadMan,
///<summary>
///Triangle Gradient Art Border.
///<para>When the item is serialized out as xml, its value is "gradient".</para>
///</summary>
[EnumString("gradient")]
Gradient,
///<summary>
///Handmade Art Border.
///<para>When the item is serialized out as xml, its value is "handmade1".</para>
///</summary>
[EnumString("handmade1")]
Handmade1,
///<summary>
///Handmade Art Border.
///<para>When the item is serialized out as xml, its value is "handmade2".</para>
///</summary>
[EnumString("handmade2")]
Handmade2,
///<summary>
///Heart-Shaped Balloon Art Border.
///<para>When the item is serialized out as xml, its value is "heartBalloon".</para>
///</summary>
[EnumString("heartBalloon")]
HeartBalloon,
///<summary>
///Gray Heart Art Border.
///<para>When the item is serialized out as xml, its value is "heartGray".</para>
///</summary>
[EnumString("heartGray")]
HeartGray,
///<summary>
///Hearts Art Border.
///<para>When the item is serialized out as xml, its value is "hearts".</para>
///</summary>
[EnumString("hearts")]
Hearts,
///<summary>
///Pattern Art Border.
///<para>When the item is serialized out as xml, its value is "heebieJeebies".</para>
///</summary>
[EnumString("heebieJeebies")]
HeebieJeebies,
///<summary>
///Holly Art Border.
///<para>When the item is serialized out as xml, its value is "holly".</para>
///</summary>
[EnumString("holly")]
Holly,
///<summary>
///House Art Border.
///<para>When the item is serialized out as xml, its value is "houseFunky".</para>
///</summary>
[EnumString("houseFunky")]
HouseFunky,
///<summary>
///Circular Art Border.
///<para>When the item is serialized out as xml, its value is "hypnotic".</para>
///</summary>
[EnumString("hypnotic")]
Hypnotic,
///<summary>
///Ice Cream Cone Art Border.
///<para>When the item is serialized out as xml, its value is "iceCreamCones".</para>
///</summary>
[EnumString("iceCreamCones")]
IceCreamCones,
///<summary>
///Light Bulb Art Border.
///<para>When the item is serialized out as xml, its value is "lightBulb".</para>
///</summary>
[EnumString("lightBulb")]
LightBulb,
///<summary>
///Lightning Art Border.
///<para>When the item is serialized out as xml, its value is "lightning1".</para>
///</summary>
[EnumString("lightning1")]
Lightning1,
///<summary>
///Lightning Art Border.
///<para>When the item is serialized out as xml, its value is "lightning2".</para>
///</summary>
[EnumString("lightning2")]
Lightning2,
///<summary>
///Map Pins Art Border.
///<para>When the item is serialized out as xml, its value is "mapPins".</para>
///</summary>
[EnumString("mapPins")]
MapPins,
///<summary>
///Maple Leaf Art Border.
///<para>When the item is serialized out as xml, its value is "mapleLeaf".</para>
///</summary>
[EnumString("mapleLeaf")]
MapleLeaf,
///<summary>
///Muffin Art Border.
///<para>When the item is serialized out as xml, its value is "mapleMuffins".</para>
///</summary>
[EnumString("mapleMuffins")]
MapleMuffins,
///<summary>
///Marquee Art Border.
///<para>When the item is serialized out as xml, its value is "marquee".</para>
///</summary>
[EnumString("marquee")]
Marquee,
///<summary>
///Marquee Art Border.
///<para>When the item is serialized out as xml, its value is "marqueeToothed".</para>
///</summary>
[EnumString("marqueeToothed")]
MarqueeToothed,
///<summary>
///Moon Art Border.
///<para>When the item is serialized out as xml, its value is "moons".</para>
///</summary>
[EnumString("moons")]
Moons,
///<summary>
///Mosaic Art Border.
///<para>When the item is serialized out as xml, its value is "mosaic".</para>
///</summary>
[EnumString("mosaic")]
Mosaic,
///<summary>
///Musical Note Art Border.
///<para>When the item is serialized out as xml, its value is "musicNotes".</para>
///</summary>
[EnumString("musicNotes")]
MusicNotes,
///<summary>
///Patterned Art Border.
///<para>When the item is serialized out as xml, its value is "northwest".</para>
///</summary>
[EnumString("northwest")]
Northwest,
///<summary>
///Oval Art Border.
///<para>When the item is serialized out as xml, its value is "ovals".</para>
///</summary>
[EnumString("ovals")]
Ovals,
///<summary>
///Package Art Border.
///<para>When the item is serialized out as xml, its value is "packages".</para>
///</summary>
[EnumString("packages")]
Packages,
///<summary>
///Black Palm Tree Art Border.
///<para>When the item is serialized out as xml, its value is "palmsBlack".</para>
///</summary>
[EnumString("palmsBlack")]
PalmsBlack,
///<summary>
///Color Palm Tree Art Border.
///<para>When the item is serialized out as xml, its value is "palmsColor".</para>
///</summary>
[EnumString("palmsColor")]
PalmsColor,
///<summary>
///Paper Clip Art Border.
///<para>When the item is serialized out as xml, its value is "paperClips".</para>
///</summary>
[EnumString("paperClips")]
PaperClips,
///<summary>
///Papyrus Art Border.
///<para>When the item is serialized out as xml, its value is "papyrus".</para>
///</summary>
[EnumString("papyrus")]
Papyrus,
///<summary>
///Party Favor Art Border.
///<para>When the item is serialized out as xml, its value is "partyFavor".</para>
///</summary>
[EnumString("partyFavor")]
PartyFavor,
///<summary>
///Party Glass Art Border.
///<para>When the item is serialized out as xml, its value is "partyGlass".</para>
///</summary>
[EnumString("partyGlass")]
PartyGlass,
///<summary>
///Pencils Art Border.
///<para>When the item is serialized out as xml, its value is "pencils".</para>
///</summary>
[EnumString("pencils")]
Pencils,
///<summary>
///Character Art Border.
///<para>When the item is serialized out as xml, its value is "people".</para>
///</summary>
[EnumString("people")]
People,
///<summary>
///Waving Character Border.
///<para>When the item is serialized out as xml, its value is "peopleWaving".</para>
///</summary>
[EnumString("peopleWaving")]
PeopleWaving,
///<summary>
///Character With Hat Art Border.
///<para>When the item is serialized out as xml, its value is "peopleHats".</para>
///</summary>
[EnumString("peopleHats")]
PeopleHats,
///<summary>
///Poinsettia Art Border.
///<para>When the item is serialized out as xml, its value is "poinsettias".</para>
///</summary>
[EnumString("poinsettias")]
Poinsettias,
///<summary>
///Postage Stamp Art Border.
///<para>When the item is serialized out as xml, its value is "postageStamp".</para>
///</summary>
[EnumString("postageStamp")]
PostageStamp,
///<summary>
///Pumpkin Art Border.
///<para>When the item is serialized out as xml, its value is "pumpkin1".</para>
///</summary>
[EnumString("pumpkin1")]
Pumpkin1,
///<summary>
///Push Pin Art Border.
///<para>When the item is serialized out as xml, its value is "pushPinNote2".</para>
///</summary>
[EnumString("pushPinNote2")]
PushPinNote2,
///<summary>
///Push Pin Art Border.
///<para>When the item is serialized out as xml, its value is "pushPinNote1".</para>
///</summary>
[EnumString("pushPinNote1")]
PushPinNote1,
///<summary>
///Pyramid Art Border.
///<para>When the item is serialized out as xml, its value is "pyramids".</para>
///</summary>
[EnumString("pyramids")]
Pyramids,
///<summary>
///Pyramid Art Border.
///<para>When the item is serialized out as xml, its value is "pyramidsAbove".</para>
///</summary>
[EnumString("pyramidsAbove")]
PyramidsAbove,
///<summary>
///Quadrants Art Border.
///<para>When the item is serialized out as xml, its value is "quadrants".</para>
///</summary>
[EnumString("quadrants")]
Quadrants,
///<summary>
///Rings Art Border.
///<para>When the item is serialized out as xml, its value is "rings".</para>
///</summary>
[EnumString("rings")]
Rings,
///<summary>
///Safari Art Border.
///<para>When the item is serialized out as xml, its value is "safari".</para>
///</summary>
[EnumString("safari")]
Safari,
///<summary>
///Saw tooth Art Border.
///<para>When the item is serialized out as xml, its value is "sawtooth".</para>
///</summary>
[EnumString("sawtooth")]
Sawtooth,
///<summary>
///Gray Saw tooth Art Border.
///<para>When the item is serialized out as xml, its value is "sawtoothGray".</para>
///</summary>
[EnumString("sawtoothGray")]
SawtoothGray,
///<summary>
///Scared Cat Art Border.
///<para>When the item is serialized out as xml, its value is "scaredCat".</para>
///</summary>
[EnumString("scaredCat")]
ScaredCat,
///<summary>
///Umbrella Art Border.
///<para>When the item is serialized out as xml, its value is "seattle".</para>
///</summary>
[EnumString("seattle")]
Seattle,
///<summary>
///Shadowed Squares Art Border.
///<para>When the item is serialized out as xml, its value is "shadowedSquares".</para>
///</summary>
[EnumString("shadowedSquares")]
ShadowedSquares,
///<summary>
///Shark Tooth Art Border.
///<para>When the item is serialized out as xml, its value is "sharksTeeth".</para>
///</summary>
[EnumString("sharksTeeth")]
SharksTeeth,
///<summary>
///Bird Tracks Art Border.
///<para>When the item is serialized out as xml, its value is "shorebirdTracks".</para>
///</summary>
[EnumString("shorebirdTracks")]
ShorebirdTracks,
///<summary>
///Rocket Art Border.
///<para>When the item is serialized out as xml, its value is "skyrocket".</para>
///</summary>
[EnumString("skyrocket")]
Skyrocket,
///<summary>
///Snowflake Art Border.
///<para>When the item is serialized out as xml, its value is "snowflakeFancy".</para>
///</summary>
[EnumString("snowflakeFancy")]
SnowflakeFancy,
///<summary>
///Snowflake Art Border.
///<para>When the item is serialized out as xml, its value is "snowflakes".</para>
///</summary>
[EnumString("snowflakes")]
Snowflakes,
///<summary>
///Sombrero Art Border.
///<para>When the item is serialized out as xml, its value is "sombrero".</para>
///</summary>
[EnumString("sombrero")]
Sombrero,
///<summary>
///Southwest-themed Art Border.
///<para>When the item is serialized out as xml, its value is "southwest".</para>
///</summary>
[EnumString("southwest")]
Southwest,
///<summary>
///Stars Art Border.
///<para>When the item is serialized out as xml, its value is "stars".</para>
///</summary>
[EnumString("stars")]
Stars,
///<summary>
///Stars On Top Art Border.
///<para>When the item is serialized out as xml, its value is "starsTop".</para>
///</summary>
[EnumString("starsTop")]
StarsTop,
///<summary>
///3-D Stars Art Border.
///<para>When the item is serialized out as xml, its value is "stars3d".</para>
///</summary>
[EnumString("stars3d")]
Stars3d,
///<summary>
///Stars Art Border.
///<para>When the item is serialized out as xml, its value is "starsBlack".</para>
///</summary>
[EnumString("starsBlack")]
StarsBlack,
///<summary>
///Stars With Shadows Art Border.
///<para>When the item is serialized out as xml, its value is "starsShadowed".</para>
///</summary>
[EnumString("starsShadowed")]
StarsShadowed,
///<summary>
///Sun Art Border.
///<para>When the item is serialized out as xml, its value is "sun".</para>
///</summary>
[EnumString("sun")]
Sun,
///<summary>
///Whirligig Art Border.
///<para>When the item is serialized out as xml, its value is "swirligig".</para>
///</summary>
[EnumString("swirligig")]
Swirligig,
///<summary>
///Torn Paper Art Border.
///<para>When the item is serialized out as xml, its value is "tornPaper".</para>
///</summary>
[EnumString("tornPaper")]
TornPaper,
///<summary>
///Black Torn Paper Art Border.
///<para>When the item is serialized out as xml, its value is "tornPaperBlack".</para>
///</summary>
[EnumString("tornPaperBlack")]
TornPaperBlack,
///<summary>
///Tree Art Border.
///<para>When the item is serialized out as xml, its value is "trees".</para>
///</summary>
[EnumString("trees")]
Trees,
///<summary>
///Triangle Art Border.
///<para>When the item is serialized out as xml, its value is "triangleParty".</para>
///</summary>
[EnumString("triangleParty")]
TriangleParty,
///<summary>
///Triangles Art Border.
///<para>When the item is serialized out as xml, its value is "triangles".</para>
///</summary>
[EnumString("triangles")]
Triangles,
///<summary>
///Tribal Art Border One.
///<para>When the item is serialized out as xml, its value is "tribal1".</para>
///</summary>
[EnumString("tribal1")]
Tribal1,
///<summary>
///Tribal Art Border Two.
///<para>When the item is serialized out as xml, its value is "tribal2".</para>
///</summary>
[EnumString("tribal2")]
Tribal2,
///<summary>
///Tribal Art Border Three.
///<para>When the item is serialized out as xml, its value is "tribal3".</para>
///</summary>
[EnumString("tribal3")]
Tribal3,
///<summary>
///Tribal Art Border Four.
///<para>When the item is serialized out as xml, its value is "tribal4".</para>
///</summary>
[EnumString("tribal4")]
Tribal4,
///<summary>
///Tribal Art Border Five.
///<para>When the item is serialized out as xml, its value is "tribal5".</para>
///</summary>
[EnumString("tribal5")]
Tribal5,
///<summary>
///Tribal Art Border Six.
///<para>When the item is serialized out as xml, its value is "tribal6".</para>
///</summary>
[EnumString("tribal6")]
Tribal6,
///<summary>
///triangle1.
///<para>When the item is serialized out as xml, its value is "triangle1".</para>
///</summary>
[EnumString("triangle1")]
Triangle1,
///<summary>
///triangle2.
///<para>When the item is serialized out as xml, its value is "triangle2".</para>
///</summary>
[EnumString("triangle2")]
Triangle2,
///<summary>
///triangleCircle1.
///<para>When the item is serialized out as xml, its value is "triangleCircle1".</para>
///</summary>
[EnumString("triangleCircle1")]
TriangleCircle1,
///<summary>
///triangleCircle2.
///<para>When the item is serialized out as xml, its value is "triangleCircle2".</para>
///</summary>
[EnumString("triangleCircle2")]
TriangleCircle2,
///<summary>
///shapes1.
///<para>When the item is serialized out as xml, its value is "shapes1".</para>
///</summary>
[EnumString("shapes1")]
Shapes1,
///<summary>
///shapes2.
///<para>When the item is serialized out as xml, its value is "shapes2".</para>
///</summary>
[EnumString("shapes2")]
Shapes2,
///<summary>
///Twisted Lines Art Border.
///<para>When the item is serialized out as xml, its value is "twistedLines1".</para>
///</summary>
[EnumString("twistedLines1")]
TwistedLines1,
///<summary>
///Twisted Lines Art Border.
///<para>When the item is serialized out as xml, its value is "twistedLines2".</para>
///</summary>
[EnumString("twistedLines2")]
TwistedLines2,
///<summary>
///Vine Art Border.
///<para>When the item is serialized out as xml, its value is "vine".</para>
///</summary>
[EnumString("vine")]
Vine,
///<summary>
///Wavy Line Art Border.
///<para>When the item is serialized out as xml, its value is "waveline".</para>
///</summary>
[EnumString("waveline")]
Waveline,
///<summary>
///Weaving Angles Art Border.
///<para>When the item is serialized out as xml, its value is "weavingAngles".</para>
///</summary>
[EnumString("weavingAngles")]
WeavingAngles,
///<summary>
///Weaving Braid Art Border.
///<para>When the item is serialized out as xml, its value is "weavingBraid".</para>
///</summary>
[EnumString("weavingBraid")]
WeavingBraid,
///<summary>
///Weaving Ribbon Art Border.
///<para>When the item is serialized out as xml, its value is "weavingRibbon".</para>
///</summary>
[EnumString("weavingRibbon")]
WeavingRibbon,
///<summary>
///Weaving Strips Art Border.
///<para>When the item is serialized out as xml, its value is "weavingStrips".</para>
///</summary>
[EnumString("weavingStrips")]
WeavingStrips,
///<summary>
///White Flowers Art Border.
///<para>When the item is serialized out as xml, its value is "whiteFlowers".</para>
///</summary>
[EnumString("whiteFlowers")]
WhiteFlowers,
///<summary>
///Woodwork Art Border.
///<para>When the item is serialized out as xml, its value is "woodwork".</para>
///</summary>
[EnumString("woodwork")]
Woodwork,
///<summary>
///Crisscross Art Border.
///<para>When the item is serialized out as xml, its value is "xIllusions".</para>
///</summary>
[EnumString("xIllusions")]
XIllusions,
///<summary>
///Triangle Art Border.
///<para>When the item is serialized out as xml, its value is "zanyTriangles".</para>
///</summary>
[EnumString("zanyTriangles")]
ZanyTriangles,
///<summary>
///Zigzag Art Border.
///<para>When the item is serialized out as xml, its value is "zigZag".</para>
///</summary>
[EnumString("zigZag")]
ZigZag,
///<summary>
///Zigzag stitch.
///<para>When the item is serialized out as xml, its value is "zigZagStitch".</para>
///</summary>
[EnumString("zigZagStitch")]
ZigZagStitch,
 
}
/// <summary>
/// Defines the DocumentConformance enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DocumentConformance
{  
	///<summary>
///transitional.
///<para>When the item is serialized out as xml, its value is "transitional".</para>
///</summary>
[EnumString("transitional")]
transitional,
///<summary>
///strict.
///<para>When the item is serialized out as xml, its value is "strict".</para>
///</summary>
[EnumString("strict")]
strict,
 
}
/// <summary>
/// Defines the StrictCharacterSet enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum StrictCharacterSet
{  
	///<summary>
///iso-8859-1.
///<para>When the item is serialized out as xml, its value is "iso-8859-1".</para>
///</summary>
[EnumString("iso-8859-1")]
chsAnsi,
///<summary>
///macintosh.
///<para>When the item is serialized out as xml, its value is "macintosh".</para>
///</summary>
[EnumString("macintosh")]
chsMacFfn,
///<summary>
///shift_jis.
///<para>When the item is serialized out as xml, its value is "shift_jis".</para>
///</summary>
[EnumString("shift_jis")]
chsShiftJIS,
///<summary>
///ks_c-5601-1987.
///<para>When the item is serialized out as xml, its value is "ks_c-5601-1987".</para>
///</summary>
[EnumString("ks_c-5601-1987")]
chsHangeul,
///<summary>
///KS_C-5601-1992.
///<para>When the item is serialized out as xml, its value is "KS_C-5601-1992".</para>
///</summary>
[EnumString("KS_C-5601-1992")]
chsJohab,
///<summary>
///GBK.
///<para>When the item is serialized out as xml, its value is "GBK".</para>
///</summary>
[EnumString("GBK")]
chsGB2312,
///<summary>
///Big5.
///<para>When the item is serialized out as xml, its value is "Big5".</para>
///</summary>
[EnumString("Big5")]
chsChinese5,
///<summary>
///windows-1253.
///<para>When the item is serialized out as xml, its value is "windows-1253".</para>
///</summary>
[EnumString("windows-1253")]
chsGreek,
///<summary>
///iso-8859-9.
///<para>When the item is serialized out as xml, its value is "iso-8859-9".</para>
///</summary>
[EnumString("iso-8859-9")]
chsTurkish,
///<summary>
///windows-1258.
///<para>When the item is serialized out as xml, its value is "windows-1258".</para>
///</summary>
[EnumString("windows-1258")]
chsVietnamese,
///<summary>
///windows-1255.
///<para>When the item is serialized out as xml, its value is "windows-1255".</para>
///</summary>
[EnumString("windows-1255")]
chsHebrew,
///<summary>
///windows-1256.
///<para>When the item is serialized out as xml, its value is "windows-1256".</para>
///</summary>
[EnumString("windows-1256")]
chsArabic,
///<summary>
///windows-1257.
///<para>When the item is serialized out as xml, its value is "windows-1257".</para>
///</summary>
[EnumString("windows-1257")]
chsBaltic,
///<summary>
///windows-1251.
///<para>When the item is serialized out as xml, its value is "windows-1251".</para>
///</summary>
[EnumString("windows-1251")]
chsRussian,
///<summary>
///windows-874.
///<para>When the item is serialized out as xml, its value is "windows-874".</para>
///</summary>
[EnumString("windows-874")]
chsThai,
///<summary>
///windows-1250.
///<para>When the item is serialized out as xml, its value is "windows-1250".</para>
///</summary>
[EnumString("windows-1250")]
chsEastEurope,
 
}
/// <summary>
/// Defines the ObjectDrawAspect enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ObjectDrawAspect
{  
	///<summary>
///content.
///<para>When the item is serialized out as xml, its value is "content".</para>
///</summary>
[EnumString("content")]
content,
///<summary>
///icon.
///<para>When the item is serialized out as xml, its value is "icon".</para>
///</summary>
[EnumString("icon")]
icon,
 
}
/// <summary>
/// Linked Object Update Modes 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ObjectUpdateMode
{  
	///<summary>
///always.
///<para>When the item is serialized out as xml, its value is "always".</para>
///</summary>
[EnumString("always")]
always,
///<summary>
///onCall.
///<para>When the item is serialized out as xml, its value is "onCall".</para>
///</summary>
[EnumString("onCall")]
onCall,
 
}
/// <summary>
/// Defines the CompatSettingNameValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CompatSettingNameValues
{  
	///<summary>
///compatibilityMode.
///<para>When the item is serialized out as xml, its value is "compatibilityMode".</para>
///</summary>
[EnumString("compatibilityMode")]
CompatibilityMode,
///<summary>
///overrideTableStyleFontSizeAndJustification.
///<para>When the item is serialized out as xml, its value is "overrideTableStyleFontSizeAndJustification".</para>
///</summary>
[EnumString("overrideTableStyleFontSizeAndJustification")]
OverrideTableStyleFontSizeAndJustification,
///<summary>
///enableOpenTypeFeatures.
///<para>When the item is serialized out as xml, its value is "enableOpenTypeFeatures".</para>
///</summary>
[EnumString("enableOpenTypeFeatures")]
EnableOpenTypeFeatures,
///<summary>
///doNotFlipMirrorIndents.
///<para>When the item is serialized out as xml, its value is "doNotFlipMirrorIndents".</para>
///</summary>
[EnumString("doNotFlipMirrorIndents")]
DoNotFlipMirrorIndents,
///<summary>
///differentiateMultirowTableHeaders.
///<para>When the item is serialized out as xml, its value is "differentiateMultirowTableHeaders".</para>
///</summary>
[EnumString("differentiateMultirowTableHeaders")]
DifferentiateMultirowTableHeaders,
 
}
}
 
 
